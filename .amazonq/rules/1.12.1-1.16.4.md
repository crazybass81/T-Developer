
## Task 1.12: DynamoDB 연결 설정

### SubTask 1.12.1: DynamoDB 클라이언트 설정 및 연결 풀
**담당자**: 백엔드 개발자  
**예상 소요시간**: 8시간

**목표**: 효율적인 DynamoDB 클라이언트 설정 및 연결 관리

**구현 내용**:
```typescript
// backend/src/data/dynamodb/client.ts
import { 
  DynamoDBClient, 
  DynamoDBClientConfig,
  RetryStrategy 
} from '@aws-sdk/client-dynamodb';
import { 
  DynamoDBDocumentClient,
  TranslateConfig 
} from '@aws-sdk/lib-dynamodb';
import { NodeHttpHandler } from '@aws-sdk/node-http-handler';
import { Agent } from 'https';

export interface DynamoDBConnectionConfig {
  region: string;
  endpoint?: string;
  maxRetries?: number;
  maxSockets?: number;
  keepAlive?: boolean;
  connectionTimeout?: number;
  requestTimeout?: number;
}

export class DynamoDBConnectionManager {
  private clients: Map<string, DynamoDBDocumentClient>;
  private metrics: ConnectionMetrics;
  
  constructor(
    private config: DynamoDBConnectionConfig
  ) {
    this.clients = new Map();
    this.metrics = new ConnectionMetrics();
    
    this.initializePrimaryClient();
  }
  
  private initializePrimaryClient(): void {
    // HTTPS Agent 설정 (연결 재사용)
    const agent = new Agent({
      maxSockets: this.config.maxSockets || 50,
      keepAlive: this.config.keepAlive ?? true,
      keepAliveMsecs: 1000,
      rejectUnauthorized: true
    });
    
    // 사용자 정의 재시도 전략
    const retryStrategy: RetryStrategy = {
      mode: 'adaptive',
      maxAttempts: this.config.maxRetries || 3,
      retryDecider: (error: any) => {
        // 재시도 가능한 에러 판단
        if (error.name === 'ProvisionedThroughputExceededException' ||
            error.name === 'ThrottlingException' ||
            error.name === 'ServiceUnavailable' ||
            error.statusCode === 503) {
          return true;
        }
        return false;
      },
      delayDecider: (delayBase: number, attempts: number) => {
        // 지수 백오프 with jitter
        const delay = Math.min(
          delayBase * Math.pow(2, attempts) + Math.random() * 1000,
          20000 // 최대 20초
        );
        return delay;
      }
    };
    
    // DynamoDB 클라이언트 설정
    const clientConfig: DynamoDBClientConfig = {
      region: this.config.region,
      endpoint: this.config.endpoint,
      maxAttempts: this.config.maxRetries || 3,
      requestHandler: new NodeHttpHandler({
        httpsAgent: agent,
        connectionTimeout: this.config.connectionTimeout || 3000,
        requestTimeout: this.config.requestTimeout || 5000
      }),
      retryStrategy
    };
    
    // 기본 클라이언트 생성
    const baseClient = new DynamoDBClient(clientConfig);
    
    // Document 클라이언트 설정
    const translateConfig: TranslateConfig = {
      marshallOptions: {
        convertEmptyValues: false,
        removeUndefinedValues: true,
        convertClassInstanceToMap: true
      },
      unmarshallOptions: {
        wrapNumbers: false
      }
    };
    
    const docClient = DynamoDBDocumentClient.from(
      baseClient,
      translateConfig
    );
    
    // 클라이언트 인터셉터 추가
    this.addClientInterceptors(docClient);
    
    this.clients.set('primary', docClient);
  }
  
  private addClientInterceptors(client: DynamoDBDocumentClient): void {
    // 요청 인터셉터
    client.middlewareStack.add(
      (next) => async (args) => {
        const start = Date.now();
        
        try {
          // 요청 로깅
          this.logRequest(args);
          
          // 메트릭 수집
          this.metrics.incrementRequests();
          
          const result = await next(args);
          
          // 성공 메트릭
          this.metrics.recordLatency(Date.now() - start);
          this.metrics.incrementSuccess();
          
          return result;
          
        } catch (error) {
          // 에러 메트릭
          this.metrics.incrementErrors(error.name);
          
          // 에러 로깅
          this.logError(error, args);
          
          throw error;
        }
      },
      {
        step: 'finalizeRequest',
        name: 'metricsMiddleware',
        tags: ['METRICS']
      }
    );
  }
  
  // 읽기 전용 복제본 클라이언트
  async getReadReplicaClient(): Promise<DynamoDBDocumentClient> {
    if (!this.clients.has('read-replica')) {
      const replicaConfig = {
        ...this.config,
        region: this.config.readReplicaRegion || this.config.region
      };
      
      const replicaClient = this.createClient(replicaConfig);
      this.clients.set('read-replica', replicaClient);
    }
    
    return this.clients.get('read-replica')!;
  }
  
  // 트랜잭션 전용 클라이언트
  getTransactionClient(): DynamoDBDocumentClient {
    if (!this.clients.has('transaction')) {
      const txConfig = {
        ...this.config,
        maxRetries: 5, // 트랜잭션은 더 많은 재시도
        requestTimeout: 10000 // 더 긴 타임아웃
      };
      
      const txClient = this.createClient(txConfig);
      this.clients.set('transaction', txClient);
    }
    
    return this.clients.get('transaction')!;
  }
  
  // 연결 상태 모니터링
  async healthCheck(): Promise<HealthCheckResult> {
    const results: HealthCheckResult = {
      status: 'healthy',
      clients: {},
      metrics: this.metrics.getSummary()
    };
    
    for (const [name, client] of this.clients) {
      try {
        // 간단한 DescribeTable 호출로 연결 확인
        const start = Date.now();
        await client.send(new DescribeTableCommand({
          TableName: 'HealthCheck'
        }));
        
        results.clients[name] = {
          status: 'healthy',
          latency: Date.now() - start
        };
      } catch (error) {
        results.clients[name] = {
          status: 'unhealthy',
          error: error.message
        };
        results.status = 'degraded';
      }
    }
    
    return results;
  }
  
  // 연결 풀 통계
  getConnectionStats(): ConnectionStats {
    return {
      activeConnections: this.clients.size,
      totalRequests: this.metrics.totalRequests,
      successRate: this.metrics.getSuccessRate(),
      averageLatency: this.metrics.getAverageLatency(),
      errorsByType: this.metrics.getErrorBreakdown()
    };
  }
}

// 연결 메트릭 수집
class ConnectionMetrics {
  private requests = 0;
  private successes = 0;
  private errors = new Map<string, number>();
  private latencies: number[] = [];
  private windowStart = Date.now();
  
  incrementRequests(): void {
    this.requests++;
  }
  
  incrementSuccess(): void {
    this.successes++;
  }
  
  incrementErrors(errorType: string): void {
    this.errors.set(errorType, (this.errors.get(errorType) || 0) + 1);
  }
  
  recordLatency(ms: number): void {
    this.latencies.push(ms);
    
    // 슬라이딩 윈도우 (최근 1000개만 유지)
    if (this.latencies.length > 1000) {
      this.latencies.shift();
    }
  }
  
  getSummary(): MetricsSummary {
    const now = Date.now();
    const duration = (now - this.windowStart) / 1000; // 초
    
    return {
      requestsPerSecond: this.requests / duration,
      successRate: this.requests > 0 ? this.successes / this.requests : 1,
      averageLatency: this.getAverageLatency(),
      p95Latency: this.getPercentileLatency(95),
      p99Latency: this.getPercentileLatency(99),
      errorRate: this.requests > 0 
        ? (this.requests - this.successes) / this.requests 
        : 0,
      uptime: duration
    };
  }
  
  private getPercentileLatency(percentile: number): number {
    if (this.latencies.length === 0) return 0;
    
    const sorted = [...this.latencies].sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[index];
  }
}
```

### SubTask 1.12.2: 단일 테이블 설계 패턴 구현
**담당자**: 데이터베이스 전문가  
**예상 소요시간**: 12시간

**목표**: DynamoDB 단일 테이블 설계 패턴을 활용한 효율적인 데이터 모델 구현

**구현 내용**:
```typescript
// backend/src/data/dynamodb/single-table-design.ts
export interface TableDesign {
  tableName: string;
  partitionKey: string;
  sortKey: string;
  gsiDefinitions: GSIDefinition[];
  lsiDefinitions: LSIDefinition[];
}

export class SingleTableDesign {
  private readonly TABLE_NAME = 'T-Developer-Main';
  
  // 엔티티 타입 정의
  private readonly EntityTypes = {
    USER: 'USER',
    PROJECT: 'PROJECT',
    AGENT: 'AGENT',
    SESSION: 'SESSION',
    EXECUTION: 'EXECUTION',
    COMPONENT: 'COMPONENT',
    TEMPLATE: 'TEMPLATE',
    METRICS: 'METRICS'
  } as const;
  
  // 키 생성 전략
  generateKeys(entityType: string, entityId: string): KeySchema {
    switch (entityType) {
      case this.EntityTypes.USER:
        return {
          PK: `USER#${entityId}`,
          SK: `METADATA#${entityId}`
        };
        
      case this.EntityTypes.PROJECT:
        return {
          PK: `PROJECT#${entityId}`,
          SK: `METADATA#${entityId}`
        };
        
      case this.EntityTypes.AGENT:
        return {
          PK: `AGENT#${entityId}`,
          SK: `CONFIG#${entityId}`
        };
        
      case this.EntityTypes.SESSION:
        return {
          PK: `SESSION#${entityId}`,
          SK: `DETAILS#${new Date().toISOString()}`
        };
        
      default:
        throw new Error(`Unknown entity type: ${entityType}`);
    }
  }
  
  // 관계 모델링
  generateRelationshipKeys(
    parentType: string,
    parentId: string,
    childType: string,
    childId: string
  ): KeySchema {
    return {
      PK: `${parentType}#${parentId}`,
      SK: `${childType}#${childId}`
    };
  }
  
  // GSI 키 생성
  generateGSIKeys(indexName: string, entity: any): GSIKeySchema {
    switch (indexName) {
      case 'GSI1': // 사용자별 조회
        return {
          GSI1PK: `USER#${entity.userId}`,
          GSI1SK: `${entity.entityType}#${entity.createdAt}`
        };
        
      case 'GSI2': // 프로젝트별 조회
        return {
          GSI2PK: `PROJECT#${entity.projectId}`,
          GSI2SK: `${entity.entityType}#${entity.updatedAt}`
        };
        
      case 'GSI3': // 상태별 조회
        return {
          GSI3PK: `STATUS#${entity.status}`,
          GSI3SK: `${entity.entityType}#${entity.id}`
        };
        
      default:
        return {};
    }
  }
  
  // 접근 패턴 구현
  async implementAccessPatterns(): Promise<AccessPatternImplementation[]> {
    return [
      // 1. 사용자의 모든 프로젝트 조회
      {
        name: 'GetProjectsByUser',
        index: 'GSI1',
        keyCondition: 'GSI1PK = :userId AND begins_with(GSI1SK, :prefix)',
        implementation: async (userId: string) => {
          return await this.query({
            IndexName: 'GSI1',
            KeyConditionExpression: 'GSI1PK = :pk AND begins_with(GSI1SK, :sk)',
            ExpressionAttributeValues: {
              ':pk': `USER#${userId}`,
              ':sk': 'PROJECT#'
            }
          });
        }
      },
      
      // 2. 프로젝트의 모든 에이전트 실행 조회
      {
        name: 'GetExecutionsByProject',
        index: 'GSI2',
        keyCondition: 'GSI2PK = :projectId AND begins_with(GSI2SK, :prefix)',
        implementation: async (projectId: string, dateRange?: DateRange) => {
          let keyCondition = 'GSI2PK = :pk';
          const values: any = { ':pk': `PROJECT#${projectId}` };
          
          if (dateRange) {
            keyCondition += ' AND GSI2SK BETWEEN :start AND :end';
            values[':start'] = `EXECUTION#${dateRange.start}`;
            values[':end'] = `EXECUTION#${dateRange.end}`;
          } else {
            keyCondition += ' AND begins_with(GSI2SK, :sk)';
            values[':sk'] = 'EXECUTION#';
          }
          
          return await this.query({
            IndexName: 'GSI2',
            KeyConditionExpression: keyCondition,
            ExpressionAttributeValues: values,
            ScanIndexForward: false // 최신순
          });
        }
      },
      
      // 3. 계층적 데이터 조회 (프로젝트 > 컴포넌트 > 서브컴포넌트)
      {
        name: 'GetProjectHierarchy',
        index: 'Primary',
        keyCondition: 'PK = :projectId',
        implementation: async (projectId: string) => {
          const items = await this.query({
            KeyConditionExpression: 'PK = :pk',
            ExpressionAttributeValues: {
              ':pk': `PROJECT#${projectId}`
            }
          });
          
          // 계층 구조로 재구성
          return this.buildHierarchy(items);
        }
      }
    ];
  }
  
  // 트랜잭션 패턴
  async createProjectWithComponents(
    project: Project,
    components: Component[]
  ): Promise<void> {
    const transactItems: TransactWriteItem[] = [];
    
    // 프로젝트 메타데이터
    transactItems.push({
      Put: {
        TableName: this.TABLE_NAME,
        Item: {
          ...this.generateKeys(this.EntityTypes.PROJECT, project.id),
          ...this.generateGSIKeys('GSI1', project),
          ...this.generateGSIKeys('GSI2', project),
          entityType: this.EntityTypes.PROJECT,
          ...project,
          createdAt: new Date().toISOString()
        }
      }
    });
    
    // 컴포넌트들
    for (const component of components) {
      // 컴포넌트 메타데이터
      transactItems.push({
        Put: {
          TableName: this.TABLE_NAME,
          Item: {
            PK: `PROJECT#${project.id}`,
            SK: `COMPONENT#${component.id}`,
            ...this.generateGSIKeys('GSI2', { 
              ...component, 
              projectId: project.id 
            }),
            entityType: this.EntityTypes.COMPONENT,
            ...component
          }
        }
      });
      
      // 컴포넌트 관계
      transactItems.push({
        Put: {
          TableName: this.TABLE_NAME,
          Item: {
            PK: `COMPONENT#${component.id}`,
            SK: `METADATA#${component.id}`,
            entityType: this.EntityTypes.COMPONENT,
            projectId: project.id,
            ...component
          }
        }
      });
    }
    
    // 원자적 실행
    await this.docClient.send(new TransactWriteCommand({
      TransactItems: transactItems
    }));
  }
  
  // 효율적인 배치 조회
  async batchGetRelatedEntities(
    entityId: string,
    entityType: string,
    relationTypes: string[]
  ): Promise<Map<string, any[]>> {
    const results = new Map<string, any[]>();
    
    // 병렬 쿼리 실행
    const queries = relationTypes.map(relationType => 
      this.query({
        KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk)',
        ExpressionAttributeValues: {
          ':pk': `${entityType}#${entityId}`,
          ':sk': `${relationType}#`
        }
      })
    );
    
    const queryResults = await Promise.all(queries);
    
    // 결과 매핑
    relationTypes.forEach((relationType, index) => {
      results.set(relationType, queryResults[index]);
    });
    
    return results;
  }
  
  // 스파스 인덱스 활용
  async createSparseIndex(
    attributeName: string,
    entities: any[]
  ): Promise<void> {
    const updates = entities
      .filter(entity => entity[attributeName] !== undefined)
      .map(entity => ({
        Update: {
          TableName: this.TABLE_NAME,
          Key: this.generateKeys(entity.entityType, entity.id),
          UpdateExpression: 'SET #attr = :value, GSI4PK = :gsi4pk, GSI4SK = :gsi4sk',
          ExpressionAttributeNames: {
            '#attr': attributeName
          },
          ExpressionAttributeValues: {
            ':value': entity[attributeName],
            ':gsi4pk': `${attributeName.toUpperCase()}#${entity[attributeName]}`,
            ':gsi4sk': `${entity.entityType}#${entity.id}`
          }
        }
      }));
    
    // 배치 업데이트
    for (let i = 0; i < updates.length; i += 25) {
      const batch = updates.slice(i, i + 25);
      await this.docClient.send(new TransactWriteCommand({
        TransactItems: batch
      }));
    }
  }
}

// 쿼리 빌더
export class DynamoQueryBuilder {
  private params: any = {
    TableName: '',
    KeyConditionExpression: '',
    ExpressionAttributeValues: {},
    ExpressionAttributeNames: {}
  };
  
  table(name: string): this {
    this.params.TableName = name;
    return this;
  }
  
  index(name: string): this {
    this.params.IndexName = name;
    return this;
  }
  
  where(attribute: string, operator: string, value: any): this {
    const placeholder = `:${attribute.toLowerCase()}`;
    
    switch (operator) {
      case '=':
        this.params.KeyConditionExpression = `${attribute} = ${placeholder}`;
        break;
      case 'begins_with':
        this.params.KeyConditionExpression = `begins_with(${attribute}, ${placeholder})`;
        break;
      case 'between':
        const [start, end] = value;
        this.params.KeyConditionExpression = `${attribute} BETWEEN :start AND :end`;
        this.params.ExpressionAttributeValues[':start'] = start;
        this.params.ExpressionAttributeValues[':end'] = end;
        return this;
    }
    
    this.params.ExpressionAttributeValues[placeholder] = value;
    return this;
  }
  
  filter(expression: string, values: Record<string, any>): this {
    this.params.FilterExpression = expression;
    Object.assign(this.params.ExpressionAttributeValues, values);
    return this;
  }
  
  limit(count: number): this {
    this.params.Limit = count;
    return this;
  }
  
  orderBy(ascending: boolean = true): this {
    this.params.ScanIndexForward = ascending;
    return this;
  }
  
  build(): QueryCommandInput {
    return this.params;
  }
}
```

### SubTask 1.12.3: 쿼리 최적화 및 인덱싱 전략
**담당자**: 데이터베이스 전문가  
**예상 소요시간**: 10시간

**목표**: DynamoDB 쿼리 성능 최적화 및 효율적인 인덱싱 전략 구현

**구현 내용**:
```typescript
// backend/src/data/dynamodb/query-optimizer.ts
export class DynamoDBQueryOptimizer {
  private queryCache: LRUCache<string, CachedQuery>;
  private hotPartitionDetector: HotPartitionDetector;
  
  constructor(
    private tableDesign: SingleTableDesign,
    private metrics: MetricsCollector
  ) {
    this.queryCache = new LRUCache({ 
      max: 1000,
      ttl: 1000 * 60 * 5 // 5분
    });
    this.hotPartitionDetector = new HotPartitionDetector();
  }
  
  // 쿼리 최적화
  async optimizeQuery(
    originalQuery: QueryCommandInput
  ): Promise<OptimizedQuery> {
    const queryHash = this.hashQuery(originalQuery);
    
    // 캐시 확인
    const cached = this.queryCache.get(queryHash);
    if (cached && cached.isValid()) {
      return cached.optimizedQuery;
    }
    
    // 쿼리 분석
    const analysis = await this.analyzeQuery(originalQuery);
    
    // 최적화 전략 적용
    const optimized = await this.applyOptimizations(
      originalQuery,
      analysis
    );
    
    // 캐시 저장
    this.queryCache.set(queryHash, {
      originalQuery,
      optimizedQuery: optimized,
      analysis,
      timestamp: Date.now()
    });
    
    return optimized;
  }
  
  private async analyzeQuery(
    query: QueryCommandInput
  ): Promise<QueryAnalysis> {
    const analysis: QueryAnalysis = {
      estimatedItemCount: 0,
      estimatedRCU: 0,
      indexEfficiency: 0,
      partitionKeyDistribution: 'unknown',
      suggestions: []
    };
    
    // 1. 예상 아이템 수 추정
    const stats = await this.getTableStatistics(query.TableName);
    analysis.estimatedItemCount = this.estimateItemCount(query, stats);
    
    // 2. RCU 계산
    analysis.estimatedRCU = this.calculateRCU(
      analysis.estimatedItemCount,
      this.getAverageItemSize(query.TableName)
    );
    
    // 3. 인덱스 효율성 평가
    if (query.IndexName) {
      analysis.indexEfficiency = await this.evaluateIndexEfficiency(
        query.TableName,
        query.IndexName,
        query.KeyConditionExpression
      );
    }
    
    // 4. 파티션 키 분포 분석
    analysis.partitionKeyDistribution = 
      await this.analyzePartitionKeyDistribution(query);
    
    // 5. 최적화 제안 생성
    analysis.suggestions = this.generateOptimizationSuggestions(analysis);
    
    return analysis;
  }
  
  private async applyOptimizations(
    query: QueryCommandInput,
    analysis: QueryAnalysis
  ): Promise<OptimizedQuery> {
    let optimized = { ...query };
    
    // 1. 프로젝션 최적화
    if (!optimized.ProjectionExpression) {
      optimized = this.addOptimalProjection(optimized, analysis);
    }
    
    // 2. 페이지네이션 최적화
    if (analysis.estimatedItemCount > 100) {
      optimized = this.optimizePagination(optimized);
    }
    
    // 3. 병렬 쿼리 전략
    if (analysis.estimatedRCU > 1000) {
      return this.createParallelQueryStrategy(optimized, analysis);
    }
    
    // 4. 핫 파티션 회피
    if (analysis.partitionKeyDistribution === 'hot') {
      optimized = await this.applyHotPartitionMitigation(optimized);
    }
    
    return {
      query: optimized,
      strategy: 'single',
      estimatedCost: analysis.estimatedRCU
    };
  }
  
  // 병렬 쿼리 전략
  private createParallelQueryStrategy(
    query: QueryCommandInput,
    analysis: QueryAnalysis
  ): ParallelQueryStrategy {
    const segments = this.calculateOptimalSegments(analysis.estimatedRCU);
    
    return {
      query,
      strategy: 'parallel',
      segments,
      queries: Array.from({ length: segments }, (_, i) => ({
        ...query,
        Segment: i,
        TotalSegments: segments
      })),
      estimatedCost: analysis.estimatedRCU,
      execute: async () => {
        const results = await Promise.all(
          this.queries.map(q => 
            this.docClient.send(new QueryCommand(q))
          )
        );
        
        // 결과 병합
        return {
          Items: results.flatMap(r => r.Items || []),
          Count: results.reduce((sum, r) => sum + (r.Count || 0), 0),
          ScannedCount: results.reduce((sum, r) => sum + (r.ScannedCount || 0), 0)
        };
      }
    };
  }
  
  // 적응형 쿼리 실행
  async executeAdaptiveQuery(
    query: QueryCommandInput,
    options?: AdaptiveQueryOptions
  ): Promise<QueryResult> {
    const startTime = Date.now();
    let result: QueryResult;
    
    try {
      // 쿼리 최적화
      const optimized = await this.optimizeQuery(query);
      
      // 실행
      if (optimized.strategy === 'parallel') {
        result = await optimized.execute();
      } else {
        result = await this.docClient.send(
          new QueryCommand(optimized.query)
        );
      }
      
      // 성능 메트릭 수집
      this.collectQueryMetrics({
        query,
        optimized,
        result,
        duration: Date.now() - startTime
      });
      
      // 학습 및 적응
      await this.learnFromExecution(query, result, optimized);
      
      return result;
      
    } catch (error) {
      // 에러 처리 및 폴백 전략
      if (error.name === 'ProvisionedThroughputExceededException') {
        return await this.handleThrottling(query, options);
      }
      throw error;
    }
  }
  
  // 인덱스 추천 시스템
  async recommendIndexes(
    accessPatterns: AccessPattern[]
  ): Promise<IndexRecommendation[]> {
    const recommendations: IndexRecommendation[] = [];
    
    // 현재 인덱스 사용 패턴 분석
    const currentUsage = await this.analyzeCurrentIndexUsage();
    
    // 각 접근 패턴 분석
    for (const pattern of accessPatterns) {
      const coverage = this.calculateIndexCoverage(pattern, currentUsage);
      
      if (coverage < 0.8) { // 80% 미만 커버리지
        const recommendation = this.generateIndexRecommendation(
          pattern,
          currentUsage
        );
        
        if (recommendation) {
          recommendations.push(recommendation);
        }
      }
    }
    
    // 중복 제거 및 우선순위 정렬
    return this.prioritizeRecommendations(recommendations);
  }
  
  // 쿼리 비용 예측
  async estimateQueryCost(
    query: QueryCommandInput,
    expectedFrequency: number
  ): Promise<QueryCostEstimate> {
    const analysis = await this.analyzeQuery(query);
    
    const hourlyCost = analysis.estimatedRCU * expectedFrequency;
    const monthlyCost = hourlyCost * 24 * 30;
    
    return {
      rcuPerQuery: analysis.estimatedRCU,
      expectedQueriesPerHour: expectedFrequency,
      hourlyRCU: hourlyCost,
      monthlyRCU: monthlyCost,
      estimatedMonthlyCost: this.calculateDynamoDBCost(monthlyCost),
      optimizationPotential: this.calculateOptimizationPotential(analysis),
      recommendations: analysis.suggestions
    };
  }
}

// 핫 파티션 감지기
class HotPartitionDetector {
  private partitionMetrics: Map<string, PartitionMetrics>;
  
  constructor() {
    this.partitionMetrics = new Map();
  }
  
  async detectHotPartitions(
    tableName: string,
    timeWindow: number = 300000 // 5분
  ): Promise<HotPartition[]> {
    const metrics = await this.collectPartitionMetrics(tableName);
    const threshold = this.calculateDynamicThreshold(metrics);
    
    const hotPartitions: HotPartition[] = [];
    
    for (const [partitionKey, metric] of metrics) {
      if (metric.requestRate > threshold) {
        hotPartitions.push({
          partitionKey,
          requestRate: metric.requestRate,
          throttleRate: metric.throttleRate,
          suggestions: this.generateMitigationSuggestions(metric)
        });
      }
    }
    
    return hotPartitions;
  }
  
  private generateMitigationSuggestions(
    metric: PartitionMetrics
  ): string[] {
    const suggestions: string[] = [];
    
    if (metric.requestRate > 3000) {
      suggestions.push('Consider sharding this partition key');
    }
    
    if (metric.throttleRate > 0.05) {
      suggestions.push('Implement exponential backoff');
      suggestions.push('Consider using DynamoDB auto-scaling');
    }
    
    if (metric.burstiness > 0.8) {
      suggestions.push('Implement request smoothing');
      suggestions.push('Use SQS to buffer requests');
    }
    
    return suggestions;
  }
}
```

### SubTask 1.12.4: 데이터 일관성 및 트랜잭션 관리
**담당자**: 백엔드 개발자  
**예상 소요시간**: 10시간

**목표**: DynamoDB에서 데이터 일관성을 보장하고 복잡한 트랜잭션을 관리하는 시스템 구현

**구현 내용**:
```typescript
// backend/src/data/dynamodb/transaction-manager.ts
export class DynamoDBTransactionManager {
  private pendingTransactions: Map<string, PendingTransaction>;
  private transactionLog: TransactionLog;
  
  constructor(
    private docClient: DynamoDBDocumentClient,
    private tableName: string
  ) {
    this.pendingTransactions = new Map();
    this.transactionLog = new TransactionLog(docClient);
  }
  
  // 분산 트랜잭션 구현 (Saga 패턴)
  async executeSaga<T>(
    sagaDefinition: SagaDefinition<T>
  ): Promise<SagaResult<T>> {
    const sagaId = crypto.randomUUID();
    const saga: Saga<T> = {
      id: sagaId,
      status: 'pending',
      steps: sagaDefinition.steps,
      compensations: [],
      startedAt: new Date(),
      context: sagaDefinition.initialContext || {} as T
    };
    
    // 트랜잭션 로그 시작
    await this.transactionLog.logStart(saga);
    
    try {
      // 각 스텝 실행
      for (let i = 0; i < saga.steps.length; i++) {
        const step = saga.steps[i];
        
        try {
          // 스텝 실행
          const result = await this.executeStep(step, saga.context);
          
          // 컨텍스트 업데이트
          saga.context = { ...saga.context, ...result };
          
          // 보상 트랜잭션 기록
          if (step.compensation) {
            saga.compensations.push({
              stepIndex: i,
              compensation: step.compensation,
              context: { ...saga.context }
            });
          }
          
          // 진행 상황 로깅
          await this.transactionLog.logProgress(sagaId, i, 'completed');
          
        } catch (error) {
          // 스텝 실패 시 롤백
          await this.rollbackSaga(saga, i, error);
          throw error;
        }
      }
      
      // 성공 완료
      saga.status = 'completed';
      await this.transactionLog.logComplete(saga);
      
      return {
        success: true,
        sagaId,
        result: saga.context
      };
      
    } catch (error) {
      saga.status = 'failed';
      await this.transactionLog.logFailure(saga, error);
      
      return {
        success: false,
        sagaId,
        error: error.message
      };
    }
  }
  
  private async rollbackSaga<T>(
    saga: Saga<T>,
    failedStepIndex: number,
    error: Error
  ): Promise<void> {
    console.log(`Rolling back saga ${saga.id} from step ${failedStepIndex}`);
    
    // 역순으로 보상 트랜잭션 실행
    for (let i = saga.compensations.length - 1; i >= 0; i--) {
      const compensation = saga.compensations[i];
      
      try {
        await this.executeCompensation(
          compensation.compensation,
          compensation.context
        );
        
        await this.transactionLog.logCompensation(
          saga.id,
          compensation.stepIndex,
          'completed'
        );
      } catch (compensationError) {
        // 보상 실패는 로깅하고 계속 진행
        await this.transactionLog.logCompensation(
          saga.id,
          compensation.stepIndex,
          'failed',
          compensationError
        );
      }
    }
  }
  
  // 조건부 트랜잭션
  async conditionalTransaction(
    operations: ConditionalOperation[]
  ): Promise<TransactionResult> {
    const transactItems: TransactWriteItem[] = [];
    
    for (const op of operations) {
      const item = this.buildTransactItem(op);
      transactItems.push(item);
    }
    
    try {
      await this.docClient.send(new TransactWriteCommand({
        TransactItems: transactItems,
        ClientRequestToken: crypto.randomUUID()
      }));
      
      return { success: true };
      
    } catch (error) {
      if (error.name === 'TransactionCanceledException') {
        // 어떤 조건이 실패했는지 분석
        const failures = this.analyzeTransactionFailure(
          error.CancellationReasons
        );
        
        return {
          success: false,
          failures,
          error: 'Transaction cancelled due to condition failures'
        };
      }
      throw error;
    }
  }
  
  // 낙관적 동시성 제어
  async optimisticUpdate<T>(
    key: DynamoDBKey,
    updateFn: (current: T) => T,
    options?: OptimisticOptions
  ): Promise<T> {
    const maxRetries = options?.maxRetries || 3;
    let attempts = 0;
    
    while (attempts < maxRetries) {
      try {
        // 현재 값 조회
        const current = await this.getItem(key);
        if (!current) {
          throw new Error('Item not found');
        }
        
        // 버전 확인
        const currentVersion = current.version || 0;
        
        // 업데이트 적용
        const updated = updateFn(current as T);
        
        // 조건부 업데이트
        await this.docClient.send(new UpdateCommand({
          TableName: this.tableName,
          Key: key,
          UpdateExpression: 'SET #data = :data, #version = :newVersion',
          ConditionExpression: '#version = :currentVersion',
          ExpressionAttributeNames: {
            '#data': 'data',
            '#version': 'version'
          },
          ExpressionAttributeValues: {
            ':data': updated,
            ':newVersion': currentVersion + 1,
            ':currentVersion': currentVersion
          }
        }));
        
        return updated;
        
      } catch (error) {
        if (error.name === 'ConditionalCheckFailedException') {
          attempts++;
          
          if (attempts >= maxRetries) {
            throw new Error('Optimistic lock failed after max retries');
          }
          
          // 지수 백오프
          await this.delay(Math.pow(2, attempts) * 100);
          continue;
        }
        throw error;
      }
    }
  }
  
  // 이벤트 소싱 패턴
  async appendEvent(
    aggregateId: string,
    event: DomainEvent
  ): Promise<void> {
    const eventItem = {
      PK: `AGGREGATE#${aggregateId}`,
      SK: `EVENT#${event.timestamp}#${event.id}`,
      aggregateId,
      eventId: event.id,
      eventType: event.type,
      eventData: event.data,
      timestamp: event.timestamp,
      version: event.version,
      metadata: event.metadata
    };
    
    // 이벤트 저장
    await this.docClient.send(new PutCommand({
      TableName: this.tableName,
      Item: eventItem,
      ConditionExpression: 'attribute_not_exists(SK)'
    }));
    
    // 스냅샷 체크
    await this.checkAndCreateSnapshot(aggregateId);
  }
  
  // 일관성 검증
  async validateConsistency(
    entityId: string,
    rules: ConsistencyRule[]
  ): Promise<ConsistencyValidation> {
    const validation: ConsistencyValidation = {
      entityId,
      timestamp: new Date(),
      valid: true,
      violations: []
    };
    
    for (const rule of rules) {
      try {
        const result = await this.executeConsistencyRule(entityId, rule);
        
        if (!result.valid) {
          validation.valid = false;
          validation.violations.push({
            rule: rule.name,
            message: result.message,
            severity: rule.severity,
            data: result.data
          });
        }
      } catch (error) {
        validation.valid = false;
        validation.violations.push({
          rule: rule.name,
          message: `Rule execution failed: ${error.message}`,
          severity: 'error'
        });
      }
    }
    
    // 검증 결과 로깅
    await this.logConsistencyCheck(validation);
    
    return validation;
  }
  
  // 분산 잠금
  async acquireDistributedLock(
    resourceId: string,
    ttl: number = 30000
  ): Promise<DistributedLock> {
    const lockId = crypto.randomUUID();
    const expiresAt = Date.now() + ttl;
    
    try {
      await this.docClient.send(new PutCommand({
        TableName: this.tableName,
        Item: {
          PK: `LOCK#${resourceId}`,
          SK: 'ACTIVE',
          lockId,
          owner: process.env.INSTANCE_ID || 'unknown',
          acquiredAt: Date.now(),
          expiresAt,
          ttl: Math.floor(expiresAt / 1000)
        },
        ConditionExpression: 'attribute_not_exists(PK) OR expiresAt < :now',
        ExpressionAttributeValues: {
          ':now': Date.now()
        }
      }));
      
      return {
        lockId,
        resourceId,
        acquired: true,
        expiresAt,
        release: async () => {
          await this.releaseLock(resourceId, lockId);
        },
        extend: async (additionalTtl: number) => {
          await this.extendLock(resourceId, lockId, additionalTtl);
        }
      };
      
    } catch (error) {
      if (error.name === 'ConditionalCheckFailedException') {
        return {
          lockId: null,
          resourceId,
          acquired: false,
          error: 'Resource is already locked'
        };
      }
      throw error;
    }
  }
}

// 트랜잭션 로그
class TransactionLog {
  constructor(private docClient: DynamoDBDocumentClient) {}
  
  async logStart<T>(saga: Saga<T>): Promise<void> {
    await this.docClient.send(new PutCommand({
      TableName: 'TransactionLogs',
      Item: {
        PK: `SAGA#${saga.id}`,
        SK: `LOG#${new Date().toISOString()}`,
        type: 'start',
        sagaId: saga.id,
        steps: saga.steps.map(s => s.name),
        timestamp: new Date().toISOString()
      }
    }));
  }
  
  async queryTransactionHistory(
    sagaId: string
  ): Promise<TransactionHistory> {
    const result = await this.docClient.send(new QueryCommand({
      TableName: 'TransactionLogs',
      KeyConditionExpression: 'PK = :pk',
      ExpressionAttributeValues: {
        ':pk': `SAGA#${sagaId}`
      },
      ScanIndexForward: true
    }));
    
    return {
      sagaId,
      events: result.Items || [],
      duration: this.calculateDuration(result.Items),
      status: this.determineStatus(result.Items)
    };
  }
}
```

## Task 1.13: 캐싱 시스템 구축

### SubTask 1.13.1: Redis 클러스터 설정
**담당자**: 인프라 엔지니어  
**예상 소요시간**: 8시간

**목표**: 고가용성 Redis 클러스터 구성 및 연결 설정

**구현 내용**:
```typescript
// backend/src/cache/redis/cluster-manager.ts
import Redis, { Cluster, ClusterOptions } from 'ioredis';
import { EventEmitter } from 'events';

export interface RedisClusterConfig {
  nodes: RedisNode[];
  options: ClusterOptions;
  healthCheckInterval: number;
  connectionPoolSize: number;
}

export interface RedisNode {
  host: string;
  port: number;
  role?: 'master' | 'slave';
}

export class RedisClusterManager extends EventEmitter {
  private cluster: Cluster;
  private healthChecker: NodeJS.Timer;
  private connectionPool: Map<string, Redis>;
  
  constructor(private config: RedisClusterConfig) {
    super();
    this.connectionPool = new Map();
    this.initializeCluster();
  }
  
  private initializeCluster(): void {
    const clusterOptions: ClusterOptions = {
      ...this.config.options,
      clusterRetryStrategy: (times) => {
        if (times > 3) {
          this.emit('error', new Error('Redis cluster connection failed'));
          return null;
        }
        return Math.min(times * 100, 3000);
      },
      enableReadyCheck: true,
      enableOfflineQueue: true,
      maxRetriesPerRequest: 3,
      
      // 연결 풀 설정
      connectionPoolSize: this.config.connectionPoolSize,
      slotsRefreshTimeout: 2000,
      
      // 성능 최적화
      lazyConnect: false,
      readOnly: true, // 읽기 쿼리를 슬레이브로 라우팅
      
      // 모니터링
      sentinelRetryStrategy: (times) => Math.min(times * 50, 500)
    };
    
    // 클러스터 생성
    this.cluster = new Cluster(
      this.config.nodes.map(node => ({
        host: node.host,
        port: node.port
      })),
      clusterOptions
    );
    
    this.setupEventHandlers();
    this.startHealthMonitoring();
  }
  
  private setupEventHandlers(): void {
    this.cluster.on('connect', () => {
      console.log('Redis cluster connected');
      this.emit('connected');
    });
    
    this.cluster.on('ready', () => {
      console.log('Redis cluster ready');
      this.emit('ready');
    });
    
    this.cluster.on('error', (error) => {
      console.error('Redis cluster error:', error);
      this.emit('error', error);
    });
    
    this.cluster.on('node error', (error, node) => {
      console.error(`Redis node error on ${node}:`, error);
      this.emit('nodeError', { error, node });
    });
    
    this.cluster.on('+node', (node) => {
      console.log(`New Redis node added: ${node}`);
      this.emit('nodeAdded', node);
    });
    
    this.cluster.on('-node', (node) => {
      console.log(`Redis node removed: ${node}`);
      this.emit('nodeRemoved', node);
    });
  }
  
  // 헬스 체크 모니터링
  private startHealthMonitoring(): void {
    this.healthChecker = setInterval(async () => {
      try {
        const health = await this.performHealthCheck();
        this.emit('healthCheck', health);
        
        if (!health.healthy) {
          await this.handleUnhealthyCluster(health);
        }
      } catch (error) {
        console.error('Health check failed:', error);
      }
    }, this.config.healthCheckInterval);
  }
  
  private async performHealthCheck(): Promise<ClusterHealth> {
    const nodes = this.cluster.nodes('all');
    const health: ClusterHealth = {
      healthy: true,
      totalNodes: nodes.length,
      healthyNodes: 0,
      unhealthyNodes: 0,
      nodeStatuses: []
    };
    
    // 각 노드 상태 확인
    for (const node of nodes) {
      try {
        const start = Date.now();
        await node.ping();
        const latency = Date.now() - start;
        
        const info = await node.info();
        const role = this.parseRole(info);
        const memory = this.parseMemoryUsage(info);
        
        health.nodeStatuses.push({
          address: `${node.options.host}:${node.options.port}`,
          status: 'healthy',
          role,
          latency,
          memoryUsage: memory,
          connectedClients: this.parseConnectedClients(info)
        });
        
        health.healthyNodes++;
        
      } catch (error) {
        health.nodeStatuses.push({
          address: `${node.options.host}:${node.options.port}`,
          status: 'unhealthy',
          error: error.message
        });
        
        health.unhealthyNodes++;
        health.healthy = false;
      }
    }
    
    return health;
  }
  
  // 파티션 기반 캐싱
  async getPartitionedCache(
    partition: string
  ): Promise<PartitionedCache> {
    const poolKey = `partition:${partition}`;
    
    if (!this.connectionPool.has(poolKey)) {
      const connection = this.cluster.duplicate();
      this.connectionPool.set(poolKey, connection);
    }
    
    return new PartitionedCache(
      this.connectionPool.get(poolKey)!,
      partition
    );
  }
  
  // 캐시 워밍
  async warmCache(
    keys: string[],
    loader: (keys: string[]) => Promise<Map<string, any>>
  ): Promise<WarmingResult> {
    const result: WarmingResult = {
      totalKeys: keys.length,
      warmedKeys: 0,
      failedKeys: 0,
      duration: 0
    };
    
    const start = Date.now();
    const batchSize = 100;
    
    // 배치 처리
    for (let i = 0; i < keys.length; i += batchSize) {
      const batch = keys.slice(i, i + batchSize);
      
      try {
        // 데이터 로드
        const data = await loader(batch);
        
        // Redis 파이프라인으로 저장
        const pipeline = this.cluster.pipeline();
        
        for (const [key, value] of data) {
          pipeline.setex(
            key,
            3600, // 1시간 TTL
            JSON.stringify(value)
          );
          result.warmedKeys++;
        }
        
        await pipeline.exec();
        
      } catch (error) {
        console.error('Cache warming batch failed:', error);
        result.failedKeys += batch.length;
      }
    }
    
    result.duration = Date.now() - start;
    return result;
  }
  
  // 지능형 캐시 무효화
  async intelligentInvalidation(
    pattern: string,
    strategy: InvalidationStrategy
  ): Promise<void> {
    switch (strategy) {
      case 'immediate':
        await this.immediateInvalidation(pattern);
        break;
        
      case 'lazy':
        await this.lazyInvalidation(pattern);
        break;
        
      case 'scheduled':
        await this.scheduleInvalidation(pattern);
        break;
        
      case 'cascade':
        await this.cascadeInvalidation(pattern);
        break;
    }
  }
  
  // 분산 캐시 동기화
  async syncAcrossNodes(
    key: string,
    value: any,
    options?: SyncOptions
  ): Promise<void> {
    const nodes = this.cluster.nodes('master');
    const promises: Promise<any>[] = [];
    
    for (const node of nodes) {
      const promise = node.setex(
        key,
        options?.ttl || 3600,
        JSON.stringify(value)
      );
      promises.push(promise);
    }
    
    // 일관성 레벨에 따른 처리
    if (options?.consistency === 'strong') {
      await Promise.all(promises);
    } else if (options?.consistency === 'eventual') {
      // 비동기 처리
      Promise.all(promises).catch(error => {
        console.error('Cache sync failed:', error);
      });
    }
  }
}

// 파티션된 캐시 구현
class PartitionedCache {
  constructor(
    private redis: Redis,
    private partition: string
  ) {}
  
  private getKey(key: string): string {
    return `${this.partition}:${key}`;
  }
  
  async get<T>(key: string): Promise<T | null> {
    const value = await this.redis.get(this.getKey(key));
    return value ? JSON.parse(value) : null;
  }
  
  async set<T>(
    key: string,
    value: T,
    ttl?: number
  ): Promise<void> {
    const serialized = JSON.stringify(value);
    
    if (ttl) {
      await this.redis.setex(this.getKey(key), ttl, serialized);
    } else {
      await this.redis.set(this.getKey(key), serialized);
    }
  }
  
  async mget<T>(keys: string[]): Promise<Map<string, T>> {
    const fullKeys = keys.map(k => this.getKey(k));
    const values = await this.redis.mget(...fullKeys);
    
    const result = new Map<string, T>();
    keys.forEach((key, index) => {
      if (values[index]) {
        result.set(key, JSON.parse(values[index]!));
      }
    });
    
    return result;
  }
  
  async delete(pattern: string): Promise<number> {
    const keys = await this.redis.keys(this.getKey(pattern));
    if (keys.length === 0) return 0;
    
    return await this.redis.del(...keys);
  }
}
```


### SubTask 1.13.2: 캐싱 전략 및 패턴 구현
**담당자**: 백엔드 개발자  
**예상 소요시간**: 10시간

**목표**: 효율적인 캐싱 전략과 다양한 캐싱 패턴 구현

**구현 내용**:
```typescript
// backend/src/cache/strategies/caching-strategies.ts
export interface CacheStrategy {
  get<T>(key: string, fetcher?: () => Promise<T>): Promise<T | null>;
  set<T>(key: string, value: T, options?: CacheOptions): Promise<void>;
  invalidate(key: string | string[]): Promise<void>;
  refresh<T>(key: string, fetcher: () => Promise<T>): Promise<T>;
}

// Cache-Aside (Lazy Loading) 패턴
export class CacheAsideStrategy implements CacheStrategy {
  constructor(
    private cache: RedisCache,
    private config: CacheConfig
  ) {}
  
  async get<T>(
    key: string, 
    fetcher?: () => Promise<T>
  ): Promise<T | null> {
    // 1. 캐시에서 조회
    const cached = await this.cache.get<T>(key);
    if (cached !== null) {
      this.metrics.recordHit(key);
      return cached;
    }
    
    this.metrics.recordMiss(key);
    
    // 2. fetcher가 있으면 데이터 로드 후 캐싱
    if (fetcher) {
      const data = await fetcher();
      await this.set(key, data);
      return data;
    }
    
    return null;
  }
  
  async set<T>(
    key: string, 
    value: T, 
    options?: CacheOptions
  ): Promise<void> {
    const ttl = options?.ttl || this.config.defaultTTL;
    const compressed = await this.compress(value);
    
    await this.cache.set(key, compressed, {
      ttl,
      tags: options?.tags
    });
  }
}

// Write-Through 패턴
export class WriteThroughStrategy implements CacheStrategy {
  constructor(
    private cache: RedisCache,
    private dataStore: DataStore
  ) {}
  
  async set<T>(
    key: string,
    value: T,
    options?: CacheOptions
  ): Promise<void> {
    // 1. 데이터 스토어에 먼저 저장
    await this.dataStore.save(key, value);
    
    // 2. 캐시에 저장
    await this.cache.set(key, value, options);
    
    // 3. 관련 캐시 무효화
    await this.invalidateRelated(key, value);
  }
  
  private async invalidateRelated(
    key: string,
    value: any
  ): Promise<void> {
    const relations = this.analyzeRelations(key, value);
    
    for (const pattern of relations) {
      await this.cache.invalidatePattern(pattern);
    }
  }
}

// Write-Behind (Write-Back) 패턴
export class WriteBehindStrategy implements CacheStrategy {
  private writeQueue: WriteQueue;
  private batchProcessor: NodeJS.Timer;
  
  constructor(
    private cache: RedisCache,
    private dataStore: DataStore,
    private config: WriteBehindConfig
  ) {
    this.writeQueue = new WriteQueue();
    this.startBatchProcessor();
  }
  
  async set<T>(
    key: string,
    value: T,
    options?: CacheOptions
  ): Promise<void> {
    // 1. 즉시 캐시에 저장
    await this.cache.set(key, value, options);
    
    // 2. 쓰기 큐에 추가
    this.writeQueue.enqueue({
      key,
      value,
      timestamp: Date.now(),
      attempts: 0
    });
  }
  
  private startBatchProcessor(): void {
    this.batchProcessor = setInterval(async () => {
      const batch = this.writeQueue.dequeueBatch(
        this.config.batchSize
      );
      
      if (batch.length > 0) {
        await this.processBatch(batch);
      }
    }, this.config.flushInterval);
  }
  
  private async processBatch(
    batch: WriteQueueItem[]
  ): Promise<void> {
    try {
      // 배치 쓰기
      await this.dataStore.batchSave(
        batch.map(item => ({
          key: item.key,
          value: item.value
        }))
      );
      
      // 성공 메트릭
      this.metrics.recordBatchSuccess(batch.length);
      
    } catch (error) {
      // 실패한 항목 재시도 큐에 추가
      for (const item of batch) {
        item.attempts++;
        
        if (item.attempts < this.config.maxRetries) {
          this.writeQueue.enqueueRetry(item);
        } else {
          // 데드레터 큐로 이동
          await this.moveToDeadLetter(item);
        }
      }
      
      this.metrics.recordBatchFailure(batch.length);
    }
  }
}

// 계층적 캐싱 전략
export class TieredCachingStrategy implements CacheStrategy {
  private tiers: CacheTier[];
  
  constructor(tiers: CacheTier[]) {
    this.tiers = tiers.sort((a, b) => a.priority - b.priority);
  }
  
  async get<T>(
    key: string,
    fetcher?: () => Promise<T>
  ): Promise<T | null> {
    // 각 계층에서 순차적으로 조회
    for (let i = 0; i < this.tiers.length; i++) {
      const tier = this.tiers[i];
      const value = await tier.cache.get<T>(key);
      
      if (value !== null) {
        // 상위 계층에 프로모션
        await this.promoteToUpperTiers(key, value, i);
        return value;
      }
    }
    
    // 모든 계층에서 miss인 경우
    if (fetcher) {
      const value = await fetcher();
      await this.populateAllTiers(key, value);
      return value;
    }
    
    return null;
  }
  
  private async promoteToUpperTiers<T>(
    key: string,
    value: T,
    foundTierIndex: number
  ): Promise<void> {
    // 발견된 계층보다 상위 계층에 데이터 복사
    const promotions = [];
    
    for (let i = 0; i < foundTierIndex; i++) {
      const tier = this.tiers[i];
      promotions.push(
        tier.cache.set(key, value, {
          ttl: tier.ttl
        })
      );
    }
    
    await Promise.all(promotions);
  }
}

// 적응형 캐싱 전략
export class AdaptiveCachingStrategy implements CacheStrategy {
  private accessPatterns: AccessPatternAnalyzer;
  private strategies: Map<string, CacheStrategy>;
  
  constructor(
    private cache: RedisCache,
    private config: AdaptiveConfig
  ) {
    this.accessPatterns = new AccessPatternAnalyzer();
    this.strategies = new Map();
    this.initializeStrategies();
  }
  
  async get<T>(
    key: string,
    fetcher?: () => Promise<T>
  ): Promise<T | null> {
    // 접근 패턴 분석
    const pattern = await this.accessPatterns.analyze(key);
    
    // 최적 전략 선택
    const strategy = this.selectOptimalStrategy(pattern);
    
    // 전략 실행
    return strategy.get(key, fetcher);
  }
  
  private selectOptimalStrategy(
    pattern: AccessPattern
  ): CacheStrategy {
    // 읽기가 많은 패턴
    if (pattern.readWriteRatio > 10) {
      return this.strategies.get('cache-aside')!;
    }
    
    // 쓰기가 많은 패턴
    if (pattern.writeFrequency > 100) {
      return this.strategies.get('write-behind')!;
    }
    
    // 일관성이 중요한 패턴
    if (pattern.consistencyRequirement === 'strong') {
      return this.strategies.get('write-through')!;
    }
    
    // 기본 전략
    return this.strategies.get('cache-aside')!;
  }
  
  // TTL 자동 조정
  async optimizeTTL(key: string): Promise<number> {
    const stats = await this.accessPatterns.getKeyStats(key);
    
    // 접근 빈도에 따른 TTL 계산
    const accessFrequency = stats.accessCount / stats.timeWindow;
    const updateFrequency = stats.updateCount / stats.timeWindow;
    
    if (accessFrequency > 100 && updateFrequency < 1) {
      // 자주 읽히고 거의 업데이트되지 않음
      return 3600 * 24; // 24시간
    } else if (accessFrequency > 10 && updateFrequency < 10) {
      // 보통 빈도
      return 3600; // 1시간
    } else {
      // 자주 변경됨
      return 300; // 5분
    }
  }
}

// 캐시 워밍 전략
export class CacheWarmingStrategy {
  private scheduler: CronJob;
  
  constructor(
    private cache: RedisCache,
    private dataSource: DataSource
  ) {}
  
  // 예측 기반 워밍
  async predictiveWarming(): Promise<void> {
    const predictions = await this.predictNextPeriodKeys();
    
    for (const prediction of predictions) {
      if (prediction.probability > 0.7) {
        const data = await this.dataSource.load(prediction.key);
        await this.cache.set(prediction.key, data, {
          ttl: prediction.expectedDuration
        });
      }
    }
  }
  
  // 스케줄 기반 워밍
  scheduleWarming(
    pattern: string,
    schedule: string,
    loader: () => Promise<Map<string, any>>
  ): void {
    this.scheduler = new CronJob(schedule, async () => {
      try {
        const data = await loader();
        
        const pipeline = this.cache.pipeline();
        for (const [key, value] of data) {
          pipeline.setex(key, 3600, JSON.stringify(value));
        }
        
        await pipeline.exec();
        
        console.log(`Warmed ${data.size} keys for pattern: ${pattern}`);
      } catch (error) {
        console.error('Cache warming failed:', error);
      }
    });
    
    this.scheduler.start();
  }
}

// 캐시 일관성 관리
export class CacheConsistencyManager {
  private invalidationQueue: InvalidationQueue;
  
  constructor(
    private cache: RedisCache,
    private pubsub: RedisPubSub
  ) {
    this.invalidationQueue = new InvalidationQueue();
    this.setupInvalidationHandlers();
  }
  
  // 이벤트 기반 무효화
  private setupInvalidationHandlers(): void {
    this.pubsub.subscribe('data:updated', async (event) => {
      await this.handleDataUpdate(event);
    });
    
    this.pubsub.subscribe('data:deleted', async (event) => {
      await this.handleDataDeletion(event);
    });
  }
  
  private async handleDataUpdate(
    event: DataUpdateEvent
  ): Promise<void> {
    // 직접 관련 키 무효화
    await this.cache.delete(event.primaryKey);
    
    // 종속 키 무효화
    const dependencies = await this.findDependencies(event.primaryKey);
    await this.cache.deleteMany(dependencies);
    
    // 태그 기반 무효화
    if (event.tags) {
      for (const tag of event.tags) {
        await this.cache.invalidateByTag(tag);
      }
    }
  }
  
  // 분산 환경에서의 일관성
  async ensureConsistency(
    operation: ConsistencyOperation
  ): Promise<void> {
    const lock = await this.acquireLock(operation.key);
    
    try {
      // 1. 모든 노드에서 캐시 무효화
      await this.broadcastInvalidation(operation.key);
      
      // 2. 데이터 업데이트
      await operation.execute();
      
      // 3. 캐시 재구축 (선택적)
      if (operation.rebuild) {
        const data = await operation.rebuild();
        await this.cache.set(operation.key, data);
      }
    } finally {
      await lock.release();
    }
  }
}
```

### SubTask 1.13.3: 캐시 모니터링 및 분석
**담당자**: 데이터 엔지니어  
**예상 소요시간**: 8시간

**목표**: 캐시 성능 모니터링 및 분석 도구 구현

**구현 내용**:
```typescript
// backend/src/cache/monitoring/cache-monitor.ts
export class CacheMonitor {
  private metrics: CacheMetrics;
  private analyzer: CacheAnalyzer;
  private alertManager: AlertManager;
  
  constructor(
    private cache: RedisCache,
    private config: MonitorConfig
  ) {
    this.metrics = new CacheMetrics();
    this.analyzer = new CacheAnalyzer();
    this.alertManager = new AlertManager();
    
    this.startMonitoring();
  }
  
  private startMonitoring(): void {
    // 실시간 메트릭 수집
    setInterval(() => this.collectMetrics(), 
      this.config.metricsInterval
    );
    
    // 분석 실행
    setInterval(() => this.runAnalysis(), 
      this.config.analysisInterval
    );
  }
  
  private async collectMetrics(): Promise<void> {
    const stats = await this.cache.info();
    
    // 히트율 계산
    const hitRate = this.calculateHitRate(stats);
    this.metrics.gauge('cache.hit_rate', hitRate);
    
    // 메모리 사용량
    const memoryUsage = this.parseMemoryUsage(stats);
    this.metrics.gauge('cache.memory_used_bytes', memoryUsage.used);
    this.metrics.gauge('cache.memory_rss_bytes', memoryUsage.rss);
    
    // 연결 수
    this.metrics.gauge('cache.connected_clients', 
      stats.connected_clients
    );
    
    // 명령어 처리율
    this.metrics.counter('cache.commands_processed', 
      stats.total_commands_processed
    );
    
    // 키 통계
    const keyStats = await this.collectKeyStatistics();
    this.metrics.gauge('cache.total_keys', keyStats.totalKeys);
    this.metrics.gauge('cache.expired_keys', keyStats.expiredKeys);
    this.metrics.gauge('cache.evicted_keys', keyStats.evictedKeys);
  }
  
  private async runAnalysis(): Promise<void> {
    const analysis = await this.analyzer.analyze({
      hitRate: await this.getAverageHitRate(),
      memoryUsage: await this.getMemoryTrend(),
      keyDistribution: await this.analyzeKeyDistribution(),
      performanceMetrics: await this.getPerformanceMetrics()
    });
    
    // 이상 감지
    if (analysis.anomalies.length > 0) {
      await this.handleAnomalies(analysis.anomalies);
    }
    
    // 최적화 제안
    if (analysis.suggestions.length > 0) {
      await this.applySuggestions(analysis.suggestions);
    }
  }
  
  // 캐시 히트율 분석
  async analyzeHitRate(
    timeRange: TimeRange
  ): Promise<HitRateAnalysis> {
    const metrics = await this.metrics.query({
      metric: 'cache.hit_rate',
      start: timeRange.start,
      end: timeRange.end,
      step: '1m'
    });
    
    return {
      average: this.calculateAverage(metrics),
      min: Math.min(...metrics.map(m => m.value)),
      max: Math.max(...metrics.map(m => m.value)),
      trend: this.calculateTrend(metrics),
      volatility: this.calculateVolatility(metrics),
      recommendations: this.generateHitRateRecommendations(metrics)
    };
  }
  
  // 메모리 사용 패턴 분석
  async analyzeMemoryPattern(): Promise<MemoryAnalysis> {
    const memoryData = await this.collectMemoryData();
    
    return {
      currentUsage: memoryData.current,
      peakUsage: memoryData.peak,
      averageObjectSize: memoryData.totalMemory / memoryData.totalKeys,
      fragmentationRatio: memoryData.rss / memoryData.used,
      evictionRisk: this.calculateEvictionRisk(memoryData),
      recommendations: this.generateMemoryRecommendations(memoryData)
    };
  }
  
  // 키 수명 분석
  async analyzeKeyLifecycle(): Promise<KeyLifecycleAnalysis> {
    const sample = await this.sampleKeys(1000);
    const lifecycles: KeyLifecycle[] = [];
    
    for (const key of sample) {
      const ttl = await this.cache.ttl(key);
      const idleTime = await this.cache.idletime(key);
      const accessCount = await this.getKeyAccessCount(key);
      
      lifecycles.push({
        key,
        ttl,
        idleTime,
        accessCount,
        efficiency: this.calculateKeyEfficiency(
          ttl, 
          idleTime, 
          accessCount
        )
      });
    }
    
    return {
      averageTTL: this.average(lifecycles.map(l => l.ttl)),
      averageIdleTime: this.average(lifecycles.map(l => l.idleTime)),
      inefficientKeys: lifecycles.filter(l => l.efficiency < 0.3),
      recommendations: this.generateLifecycleRecommendations(lifecycles)
    };
  }
  
  // 실시간 대시보드 데이터
  async getDashboardData(): Promise<CacheDashboard> {
    const [
      currentStats,
      hitRateTrend,
      memoryTrend,
      topKeys,
      slowCommands
    ] = await Promise.all([
      this.getCurrentStats(),
      this.getHitRateTrend('-1h'),
      this.getMemoryTrend('-1h'),
      this.getTopKeys(10),
      this.getSlowCommands(10)
    ]);
    
    return {
      overview: {
        hitRate: currentStats.hitRate,
        memoryUsage: currentStats.memoryUsage,
        totalKeys: currentStats.totalKeys,
        connectedClients: currentStats.connectedClients,
        opsPerSecond: currentStats.opsPerSecond
      },
      charts: {
        hitRateTrend,
        memoryTrend,
        commandDistribution: await this.getCommandDistribution()
      },
      insights: {
        topKeys,
        slowCommands,
        anomalies: await this.getRecentAnomalies(),
        recommendations: await this.getCurrentRecommendations()
      }
    };
  }
  
  // 캐시 성능 보고서 생성
  async generatePerformanceReport(
    period: ReportPeriod
  ): Promise<PerformanceReport> {
    const report: PerformanceReport = {
      period,
      summary: await this.generateSummary(period),
      metrics: {
        availability: await this.calculateAvailability(period),
        performance: await this.analyzePerformance(period),
        efficiency: await this.analyzeEfficiency(period),
        cost: await this.estimateCost(period)
      },
      incidents: await this.getIncidents(period),
      optimizations: await this.getAppliedOptimizations(period),
      recommendations: await this.generateRecommendations(period)
    };
    
    return report;
  }
}

// 캐시 이상 감지
export class CacheAnomalyDetector {
  private baseline: BaselineMetrics;
  private detector: AnomalyDetector;
  
  constructor(private config: AnomalyConfig) {
    this.baseline = new BaselineMetrics();
    this.detector = new AnomalyDetector(config);
  }
  
  async detectAnomalies(
    metrics: CacheMetrics
  ): Promise<Anomaly[]> {
    const anomalies: Anomaly[] = [];
    
    // 히트율 이상
    if (this.isAnomalous(metrics.hitRate, this.baseline.hitRate)) {
      anomalies.push({
        type: 'hit_rate',
        severity: this.calculateSeverity(
          metrics.hitRate, 
          this.baseline.hitRate
        ),
        value: metrics.hitRate,
        baseline: this.baseline.hitRate,
        timestamp: new Date()
      });
    }
    
    // 메모리 스파이크
    if (metrics.memoryUsage > this.baseline.memoryUsage * 1.5) {
      anomalies.push({
        type: 'memory_spike',
        severity: 'high',
        value: metrics.memoryUsage,
        baseline: this.baseline.memoryUsage,
        timestamp: new Date()
      });
    }
    
    // 응답 시간 저하
    if (metrics.avgResponseTime > this.baseline.avgResponseTime * 2) {
      anomalies.push({
        type: 'slow_response',
        severity: 'medium',
        value: metrics.avgResponseTime,
        baseline: this.baseline.avgResponseTime,
        timestamp: new Date()
      });
    }
    
    return anomalies;
  }
  
  // ML 기반 이상 감지
  async mlAnomalyDetection(
    timeseries: TimeseriesData
  ): Promise<MLAnomaly[]> {
    // Isolation Forest 알고리즘 사용
    const anomalies = await this.detector.detectWithIsolationForest(
      timeseries,
      {
        contamination: 0.1,
        nEstimators: 100
      }
    );
    
    return anomalies.map(a => ({
      ...a,
      confidence: a.anomalyScore,
      suggestion: this.generateSuggestion(a)
    }));
  }
}
```

### SubTask 1.13.4: 분산 캐싱 및 샤딩
**담당자**: 시니어 백엔드 개발자  
**예상 소요시간**: 12시간

**목표**: 대규모 분산 환경에서의 캐싱 및 샤딩 전략 구현

**구현 내용**:
```typescript
// backend/src/cache/distributed/sharding-manager.ts
export class CacheShardingManager {
  private shards: Map<string, CacheShard>;
  private consistentHash: ConsistentHash;
  private rebalancer: ShardRebalancer;
  
  constructor(
    private config: ShardingConfig,
    private clusterManager: RedisClusterManager
  ) {
    this.shards = new Map();
    this.consistentHash = new ConsistentHash(config.virtualNodes);
    this.rebalancer = new ShardRebalancer();
    
    this.initializeShards();
  }
  
  private async initializeShards(): Promise<void> {
    for (const shardConfig of this.config.shards) {
      const shard = new CacheShard({
        id: shardConfig.id,
        nodes: shardConfig.nodes,
        weight: shardConfig.weight,
        replicationFactor: shardConfig.replicationFactor
      });
      
      await shard.initialize();
      this.shards.set(shard.id, shard);
      
      // Consistent hashing에 샤드 추가
      this.consistentHash.addNode(shard.id, shard.weight);
    }
  }
  
  // 키를 샤드에 매핑
  getShard(key: string): CacheShard {
    const shardId = this.consistentHash.getNode(key);
    const shard = this.shards.get(shardId);
    
    if (!shard) {
      throw new Error(`Shard not found for key: ${key}`);
    }
    
    return shard;
  }
  
  // 분산 get 연산
  async get<T>(key: string): Promise<T | null> {
    const shard = this.getShard(key);
    
    try {
      return await shard.get<T>(key);
    } catch (error) {
      // 장애 조치: 다른 샤드에서 시도
      if (this.config.enableFailover) {
        return await this.getWithFailover<T>(key, shard.id);
      }
      throw error;
    }
  }
  
  // 분산 set 연산
  async set<T>(
    key: string, 
    value: T, 
    options?: DistributedCacheOptions
  ): Promise<void> {
    const shard = this.getShard(key);
    
    // 복제 설정
    if (options?.replication) {
      await this.setWithReplication(key, value, options);
    } else {
      await shard.set(key, value, options);
    }
  }
  
  // 복제를 통한 고가용성
  private async setWithReplication<T>(
    key: string,
    value: T,
    options: DistributedCacheOptions
  ): Promise<void> {
    const primaryShard = this.getShard(key);
    const replicaShards = this.getReplicaShards(
      primaryShard.id,
      options.replication!
    );
    
    // 병렬로 모든 샤드에 저장
    const promises = [
      primaryShard.set(key, value, options),
      ...replicaShards.map(shard => 
        shard.set(key, value, { ...options, isReplica: true })
      )
    ];
    
    const results = await Promise.allSettled(promises);
    
    // 최소 성공 개수 확인
    const successCount = results.filter(r => 
      r.status === 'fulfilled'
    ).length;
    
    if (successCount < options.minReplicas!) {
      throw new Error(
        `Insufficient replicas: ${successCount}/${options.minReplicas}`
      );
    }
  }
  
  // 샤드 리밸런싱
  async rebalanceShards(
    strategy: RebalanceStrategy = 'gradual'
  ): Promise<RebalanceResult> {
    const plan = await this.rebalancer.createPlan(
      this.shards,
      this.consistentHash
    );
    
    switch (strategy) {
      case 'immediate':
        return await this.immediateRebalance(plan);
        
      case 'gradual':
        return await this.gradualRebalance(plan);
        
      case 'scheduled':
        return await this.scheduleRebalance(plan);
    }
  }
  
  private async gradualRebalance(
    plan: RebalancePlan
  ): Promise<RebalanceResult> {
    const result: RebalanceResult = {
      movedKeys: 0,
      duration: 0,
      errors: []
    };
    
    const start = Date.now();
    
    for (const migration of plan.migrations) {
      try {
        // 키 마이그레이션
        const keys = await this.scanKeys(
          migration.sourceShard,
          migration.keyPattern
        );
        
        for (const batch of this.batchKeys(keys, 100)) {
          await this.migrateKeyBatch(
            batch,
            migration.sourceShard,
            migration.targetShard
          );
          
          result.movedKeys += batch.length;
          
          // 속도 제한
          await this.delay(this.config.rebalanceDelay);
        }
        
      } catch (error) {
        result.errors.push({
          migration,
          error: error.message
        });
      }
    }
    
    result.duration = Date.now() - start;
    return result;
  }
  
  // 지능형 샤딩 전략
  async optimizeSharding(): Promise<ShardingOptimization> {
    const metrics = await this.collectShardMetrics();
    const analysis = this.analyzeShardDistribution(metrics);
    
    const optimization: ShardingOptimization = {
      currentDistribution: analysis.distribution,
      recommendations: [],
      estimatedImprovement: 0
    };
    
    // 핫스팟 감지
    const hotspots = analysis.shards.filter(s => 
      s.load > analysis.averageLoad * 1.5
    );
    
    for (const hotspot of hotspots) {
      optimization.recommendations.push({
        type: 'split_shard',
        shard: hotspot.id,
        reason: 'High load detected',
        expectedImprovement: 0.3
      });
    }
    
    // 언더유틸라이즈드 샤드
    const underutilized = analysis.shards.filter(s => 
      s.load < analysis.averageLoad * 0.5
    );
    
    if (underutilized.length >= 2) {
      optimization.recommendations.push({
        type: 'merge_shards',
        shards: underutilized.map(s => s.id),
        reason: 'Low utilization',
        expectedImprovement: 0.2
      });
    }
    
    return optimization;
  }
}

// 샤드 구현
class CacheShard {
  private primary: Redis;
  private replicas: Redis[];
  private healthChecker: HealthChecker;
  
  constructor(private config: ShardConfig) {
    this.replicas = [];
    this.healthChecker = new HealthChecker();
  }
  
  async initialize(): Promise<void> {
    // 주 노드 연결
    this.primary = await this.connectToNode(
      this.config.nodes[0]
    );
    
    // 복제 노드 연결
    for (let i = 1; i < this.config.nodes.length; i++) {
      const replica = await this.connectToNode(
        this.config.nodes[i]
      );
      this.replicas.push(replica);
    }
    
    // 헬스 체크 시작
    this.startHealthCheck();
  }
  
  async get<T>(key: string): Promise<T | null> {
    // 읽기는 복제본에서도 가능 (부하 분산)
    const node = this.selectReadNode();
    
    try {
      const value = await node.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      // 장애 조치
      return await this.getWithFailover(key);
    }
  }
  
  private selectReadNode(): Redis {
    // 라운드 로빈 또는 최소 연결 수 기반 선택
    if (this.config.readPreference === 'primary') {
      return this.primary;
    }
    
    // 건강한 노드 중에서 선택
    const healthyNodes = [
      this.primary,
      ...this.replicas
    ].filter(node => this.healthChecker.isHealthy(node));
    
    return this.loadBalancer.select(healthyNodes);
  }
  
  // 지리적 분산 캐싱
  async geoDistributedSet(
    key: string,
    value: any,
    geoOptions: GeoDistributionOptions
  ): Promise<void> {
    const regions = geoOptions.regions || ['primary'];
    const promises: Promise<void>[] = [];
    
    for (const region of regions) {
      const regionalShard = this.getRegionalShard(region);
      
      promises.push(
        regionalShard.set(key, value, {
          ttl: geoOptions.ttl,
          tags: [...(geoOptions.tags || []), `region:${region}`]
        })
      );
    }
    
    // 쿼럼 기반 성공 확인
    const results = await Promise.allSettled(promises);
    const successCount = results.filter(r => 
      r.status === 'fulfilled'
    ).length;
    
    const requiredQuorum = Math.ceil(regions.length * 0.51);
    
    if (successCount < requiredQuorum) {
      throw new Error(
        `Geo-distributed write failed: ${successCount}/${requiredQuorum}`
      );
    }
  }
}

// Consistent Hashing 구현
class ConsistentHash {
  private ring: Map<number, string>;
  private sortedKeys: number[];
  
  constructor(
    private virtualNodes: number = 150
  ) {
    this.ring = new Map();
    this.sortedKeys = [];
  }
  
  addNode(nodeId: string, weight: number = 1): void {
    const nodeCount = this.virtualNodes * weight;
    
    for (let i = 0; i < nodeCount; i++) {
      const virtualNodeId = `${nodeId}:${i}`;
      const hash = this.hashFunction(virtualNodeId);
      
      this.ring.set(hash, nodeId);
    }
    
    this.sortedKeys = Array.from(this.ring.keys()).sort((a, b) => a - b);
  }
  
  removeNode(nodeId: string): void {
    const keysToRemove: number[] = [];
    
    for (const [hash, node] of this.ring) {
      if (node === nodeId) {
        keysToRemove.push(hash);
      }
    }
    
    keysToRemove.forEach(key => this.ring.delete(key));
    this.sortedKeys = Array.from(this.ring.keys()).sort((a, b) => a - b);
  }
  
  getNode(key: string): string {
    if (this.ring.size === 0) {
      throw new Error('No nodes available');
    }
    
    const hash = this.hashFunction(key);
    
    // 이진 검색으로 가장 가까운 노드 찾기
    let left = 0;
    let right = this.sortedKeys.length - 1;
    
    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (this.sortedKeys[mid] < hash) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }
    
    // 순환 구조이므로 끝에 도달하면 처음으로
    const selectedKey = left === this.sortedKeys.length 
      ? this.sortedKeys[0] 
      : this.sortedKeys[left];
      
    return this.ring.get(selectedKey)!;
  }
  
  private hashFunction(key: string): number {
    // MurmurHash3 구현
    return murmur.v3(key);
  }
}
```

## Task 1.14: 메시징 큐 시스템

### SubTask 1.14.1: SQS/EventBridge 통합
**담당자**: 백엔드 개발자  
**예상 소요시간**: 10시간

**목표**: AWS SQS와 EventBridge를 활용한 비동기 메시징 시스템 구현

**구현 내용**:
```typescript
// backend/src/messaging/aws/messaging-service.ts
import { 
  SQSClient, 
  SendMessageCommand,
  ReceiveMessageCommand,
  DeleteMessageCommand 
} from '@aws-sdk/client-sqs';
import { 
  EventBridgeClient,
  PutEventsCommand 
} from '@aws-sdk/client-eventbridge';

export interface MessagingConfig {
  sqs: SQSConfig;
  eventBridge: EventBridgeConfig;
  dlq: DeadLetterQueueConfig;
}

export class AWSMessagingService {
  private sqsClient: SQSClient;
  private eventBridgeClient: EventBridgeClient;
  private queues: Map<string, QueueConfig>;
  private consumers: Map<string, QueueConsumer>;
  
  constructor(private config: MessagingConfig) {
    this.sqsClient = new SQSClient({
      region: config.sqs.region,
      maxAttempts: 3
    });
    
    this.eventBridgeClient = new EventBridgeClient({
      region: config.eventBridge.region
    });
    
    this.queues = new Map();
    this.consumers = new Map();
    
    this.initializeQueues();
  }
  
  private async initializeQueues(): Promise<void> {
    // 에이전트 실행 큐
    await this.createQueue('agent-execution', {
      visibilityTimeout: 300, // 5분
      messageRetentionPeriod: 86400, // 24시간
      fifo: true,
      contentBasedDeduplication: true,
      dlq: {
        maxReceiveCount: 3
      }
    });
    
    // 프로젝트 빌드 큐
    await this.createQueue('project-build', {
      visibilityTimeout: 600, // 10분
      messageRetentionPeriod: 172800, // 48시간
      fifo: false,
      dlq: {
        maxReceiveCount: 2
      }
    });
    
    // 알림 큐
    await this.createQueue('notifications', {
      visibilityTimeout: 30,
      messageRetentionPeriod: 3600, // 1시간
      fifo: false
    });
  }
  
  // 메시지 전송
  async sendMessage<T>(
    queueName: string,
    message: T,
    options?: SendMessageOptions
  ): Promise<string> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue not found: ${queueName}`);
    }
    
    const messageBody = JSON.stringify({
      data: message,
      timestamp: new Date().toISOString(),
      correlationId: options?.correlationId || crypto.randomUUID(),
      metadata: options?.metadata
    });
    
    const command = new SendMessageCommand({
      QueueUrl: queue.url,
      MessageBody: messageBody,
      MessageGroupId: options?.messageGroupId,
      MessageDeduplicationId: options?.deduplicationId || 
        this.generateDeduplicationId(messageBody),
      MessageAttributes: this.buildMessageAttributes(options),
      DelaySeconds: options?.delaySeconds
    });
    
    const response = await this.sqsClient.send(command);
    
    // 메트릭 수집
    this.metrics.incrementMessagesSent(queueName);
    
    return response.MessageId!;
  }
  
  // 배치 메시지 전송
  async sendBatchMessages<T>(
    queueName: string,
    messages: T[],
    options?: BatchSendOptions
  ): Promise<BatchSendResult> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue not found: ${queueName}`);
    }
    
    const results: BatchSendResult = {
      successful: [],
      failed: []
    };
    
    // 10개씩 배치 처리 (SQS 제한)
    for (let i = 0; i < messages.length; i += 10) {
      const batch = messages.slice(i, i + 10);
      const entries = batch.map((message, index) => ({
        Id: `${i + index}`,
        MessageBody: JSON.stringify({
          data: message,
          timestamp: new Date().toISOString(),
          batchId: options?.batchId
        }),
        MessageGroupId: options?.messageGroupId,
        MessageDeduplicationId: this.generateDeduplicationId(
          JSON.stringify(message)
        )
      }));
      
      const response = await this.sqsClient.send(
        new SendMessageBatchCommand({
          QueueUrl: queue.url,
          Entries: entries
        })
      );
      
      results.successful.push(
        ...response.Successful.map(s => s.Id)
      );
      
      if (response.Failed) {
        results.failed.push(...response.Failed);
      }
    }
    
    return results;
  }
  
  // 메시지 소비자 등록
  registerConsumer<T>(
    queueName: string,
    handler: MessageHandler<T>,
    options?: ConsumerOptions
  ): void {
    const consumer = new QueueConsumer({
      queueName,
      sqsClient: this.sqsClient,
      handler,
      options: {
        batchSize: options?.batchSize || 10,
        visibilityTimeout: options?.visibilityTimeout || 30,
        waitTimeSeconds: options?.waitTimeSeconds || 20,
        maxRetries: options?.maxRetries || 3
      }
    });
    
    consumer.start();
    this.consumers.set(queueName, consumer);
  }
  
  // EventBridge 이벤트 발행
  async publishEvent(
    event: DomainEvent,
    options?: EventOptions
  ): Promise<void> {
    const eventDetail = {
      version: '1.0',
      id: event.id || crypto.randomUUID(),
      source: `t-developer.${event.source}`,
      type: event.type,
      timestamp: event.timestamp || new Date().toISOString(),
      data: event.data,
      metadata: {
        correlationId: event.correlationId,
        causationId: event.causationId,
        userId: event.userId,
        ...event.metadata
      }
    };
    
    const command = new PutEventsCommand({
      Entries: [{
        EventBusName: this.config.eventBridge.busName,
        Source: eventDetail.source,
        DetailType: event.type,
        Detail: JSON.stringify(eventDetail),
        Time: new Date(eventDetail.timestamp),
        Resources: options?.resources
      }]
    });
    
    await this.eventBridgeClient.send(command);
    
    // 이벤트 로깅
    await this.eventLogger.log(eventDetail);
  }
  
  // 이벤트 규칙 생성
  async createEventRule(
    rule: EventRule
  ): Promise<void> {
    const putRuleCommand = new PutRuleCommand({
      Name: rule.name,
      Description: rule.description,
      EventPattern: JSON.stringify({
        source: rule.sources,
        'detail-type': rule.detailTypes,
        detail: rule.detailFilter
      }),
      State: 'ENABLED',
      EventBusName: this.config.eventBridge.busName
    });
    
    await this.eventBridgeClient.send(putRuleCommand);
    
    // 타겟 추가
    if (rule.targets) {
      await this.addRuleTargets(rule.name, rule.targets);
    }
  }
  
  // Dead Letter Queue 처리
  async processDeadLetters(
    queueName: string,
    processor: DeadLetterProcessor
  ): Promise<ProcessingResult> {
    const dlqName = `${queueName}-dlq`;
    const messages = await this.receiveMessages(dlqName, {
      maxMessages: 10,
      waitTimeSeconds: 5
    });
    
    const results: ProcessingResult = {
      processed: 0,
      requeued: 0,
      discarded: 0,
      failed: 0
    };
    
    for (const message of messages) {
      try {
        const action = await processor.process(message);
        
        switch (action) {
          case 'requeue':
            await this.sendMessage(queueName, message.body);
            await this.deleteMessage(dlqName, message.receiptHandle);
            results.requeued++;
            break;
            
          case 'discard':
            await this.deleteMessage(dlqName, message.receiptHandle);
            results.discarded++;
            break;
            
          case 'retry':
            // 메시지를 DLQ에 남겨둠
            results.failed++;
            break;
        }
        
        results.processed++;
        
      } catch (error) {
        console.error('DLQ processing error:', error);
        results.failed++;
      }
    }
    
    return results;
  }
}

// 큐 소비자 구현
class QueueConsumer {
  private isRunning: boolean = false;
  private processingCount: number = 0;
  
  constructor(
    private config: ConsumerConfig
  ) {}
  
  async start(): Promise<void> {
    this.isRunning = true;
    this.consumeMessages();
  }
  
  async stop(): Promise<void> {
    this.isRunning = false;
    
    // 처리 중인 메시지 완료 대기
    while (this.processingCount > 0) {
      await this.delay(100);
    }
  }
  
  private async consumeMessages(): Promise<void> {
    while (this.isRunning) {
      try {
        const messages = await this.receiveMessages();
        
        if (messages.length > 0) {
          await this.processMessages(messages);
        }
      } catch (error) {
        console.error('Consumer error:', error);
        await this.delay(5000); // 에러 시 5초 대기
      }
    }
  }
  
  private async processMessages(
    messages: Message[]
  ): Promise<void> {
    const promises = messages.map(message => 
      this.processMessage(message)
    );
    
    await Promise.allSettled(promises);
  }
  
  private async processMessage(
    message: Message
  ): Promise<void> {
    this.processingCount++;
    
    try {
      const body = JSON.parse(message.Body);
      
      // 핸들러 실행
      await this.config.handler(body.data, {
        messageId: message.MessageId,
        receiptHandle: message.ReceiptHandle,
        attributes: message.MessageAttributes,
        metadata: body.metadata
      });
      
      // 성공 시 메시지 삭제
      await this.deleteMessage(message.ReceiptHandle);
      
    } catch (error) {
      // 에러 처리
      await this.handleProcessingError(message, error);
    } finally {
      this.processingCount--;
    }
  }
  
  private async handleProcessingError(
    message: Message,
    error: Error
  ): Promise<void> {
    const retryCount = parseInt(
      message.Attributes?.ApproximateReceiveCount || '0'
    );
    
    if (retryCount < this.config.options.maxRetries) {
      // 재시도를 위해 메시지를 큐에 남김
      console.log(
        `Message ${message.MessageId} will be retried. ` +
        `Attempt ${retryCount + 1}/${this.config.options.maxRetries}`
      );
    } else {
      // 최대 재시도 횟수 초과 - DLQ로 이동
      console.error(
        `Message ${message.MessageId} exceeded max retries. ` +
        `Moving to DLQ.`
      );
    }
    
    // 에러 메트릭 수집
    this.metrics.incrementProcessingErrors(
      this.config.queueName,
      error.name
    );
  }
}
```

### SubTask 1.14.2: Pub/Sub 패턴 구현
**담당자**: 백엔드 개발자  
**예상 소요시간**: 8시간

**목표**: 이벤트 기반 Pub/Sub 패턴을 활용한 실시간 통신 구현

**구현 내용**:
```typescript
// backend/src/messaging/pubsub/pubsub-service.ts
import { 
  SNSClient, 
  CreateTopicCommand,
  PublishCommand,
  SubscribeCommand 
} from '@aws-sdk/client-sns';
import { Redis } from 'ioredis';
import { EventEmitter } from 'events';

export interface PubSubConfig {
  provider: 'sns' | 'redis' | 'eventbridge';
  sns?: SNSConfig;
  redis?: RedisConfig;
}

export class PubSubService {
  private publishers: Map<string, Publisher> = new Map();
  private subscribers: Map<string, Subscriber[]> = new Map();
  private localEmitter: EventEmitter = new EventEmitter();
  
  constructor(private config: PubSubConfig) {
    this.initialize();
  }
  
  private async initialize(): Promise<void> {
    switch (this.config.provider) {
      case 'sns':
        await this.initializeSNS();
        break;
      case 'redis':
        await this.initializeRedis();
        break;
      case 'eventbridge':
        await this.initializeEventBridge();
        break;
    }
  }
  
  // 토픽 생성
  async createTopic(topicName: string): Promise<string> {
    const topic = await this.getOrCreateTopic(topicName);
    
    // 로컬 이벤트 에미터에도 등록
    this.localEmitter.setMaxListeners(
      this.localEmitter.getMaxListeners() + 10
    );
    
    return topic.arn || topic.id;
  }
  
  // 메시지 발행
  async publish<T>(
    topicName: string,
    message: T,
    attributes?: Record<string, any>
  ): Promise<void> {
    const topic = await this.getOrCreateTopic(topicName);
    
    const payload: PublishPayload = {
      id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      topic: topicName,
      data: message,
      attributes,
      version: '1.0'
    };
    
    // 프로바이더별 발행
    await this.publishToProvider(topic, payload);
    
    // 로컬 구독자에게도 전달
    this.localEmitter.emit(topicName, payload);
    
    // 메트릭 수집
    this.metrics.incrementPublished(topicName);
  }
  
  // 구독 등록
  async subscribe<T>(
    topicName: string,
    handler: MessageHandler<T>,
    options?: SubscribeOptions
  ): Promise<Subscription> {
    const subscription = new Subscription({
      id: crypto.randomUUID(),
      topic: topicName,
      handler,
      options: {
        maxRetries: options?.maxRetries || 3,
        deadLetterTopic: options?.deadLetterTopic,
        filter: options?.filter
      }
    });
    
    // 구독자 등록
    if (!this.subscribers.has(topicName)) {
      this.subscribers.set(topicName, []);
    }
    this.subscribers.get(topicName)!.push(subscription);
    
    // 프로바이더별 구독 설정
    await this.subscribeToProvider(topicName, subscription);
    
    // 로컬 이벤트 리스너 등록
    this.localEmitter.on(topicName, async (payload) => {
      await this.handleMessage(subscription, payload);
    });
    
    return subscription;
  }
  
  // 메시지 필터링
  private async applyMessageFilter(
    message: any,
    filter?: MessageFilter
  ): Promise<boolean> {
    if (!filter) return true;
    
    // 속성 기반 필터링
    if (filter.attributes) {
      for (const [key, value] of Object.entries(filter.attributes)) {
        if (message.attributes?.[key] !== value) {
          return false;
        }
      }
    }
    
    // 콘텐츠 기반 필터링
    if (filter.contentFilter) {
      return await filter.contentFilter(message.data);
    }
    
    return true;
  }
  
  // Redis Pub/Sub 구현
  private async initializeRedis(): Promise<void> {
    const publisher = new Redis(this.config.redis);
    const subscriber = new Redis(this.config.redis);
    
    subscriber.on('message', async (channel, message) => {
      try {
        const payload = JSON.parse(message);
        await this.distributeToSubscribers(channel, payload);
      } catch (error) {
        console.error('Redis message parsing error:', error);
      }
    });
    
    this.redisPublisher = publisher;
    this.redisSubscriber = subscriber;
  }
}

// 메시지 핸들러 래퍼
class MessageHandlerWrapper {
  constructor(
    private handler: MessageHandler<any>,
    private options: HandlerOptions
  ) {}
  
  async handle(message: any): Promise<void> {
    let retries = 0;
    const maxRetries = this.options.maxRetries || 3;
    
    while (retries <= maxRetries) {
      try {
        await this.handler(message);
        return;
      } catch (error) {
        retries++;
        
        if (retries > maxRetries) {
          await this.sendToDeadLetter(message, error);
          throw error;
        }
        
        // 지수 백오프
        await this.delay(Math.pow(2, retries) * 1000);
      }
    }
  }
  
  private async sendToDeadLetter(
    message: any,
    error: any
  ): Promise<void> {
    if (this.options.deadLetterTopic) {
      await this.publishToDeadLetter({
        originalMessage: message,
        error: error.message,
        timestamp: new Date().toISOString(),
        retries: this.options.maxRetries
      });
    }
  }
}
```

### SubTask 1.14.3: 메시지 라우팅 및 필터링
**담당자**: 백엔드 개발자  
**예상 소요시간**: 6시간

**목표**: 복잡한 메시지 라우팅 규칙과 필터링 시스템 구현

**구현 내용**:
```typescript
// backend/src/messaging/routing/message-router.ts
export interface RoutingRule {
  id: string;
  name: string;
  source: string | string[];
  destination: string | string[];
  filter?: MessageFilter;
  transform?: MessageTransformer;
  priority: number;
  enabled: boolean;
}

export class MessageRouter {
  private rules: Map<string, RoutingRule> = new Map();
  private ruleEngine: RuleEngine;
  
  constructor() {
    this.ruleEngine = new RuleEngine();
    this.loadRoutingRules();
  }
  
  // 라우팅 규칙 추가
  async addRule(rule: RoutingRule): Promise<void> {
    // 규칙 유효성 검증
    await this.validateRule(rule);
    
    // 규칙 저장
    this.rules.set(rule.id, rule);
    
    // 규칙 엔진에 등록
    await this.ruleEngine.registerRule({
      id: rule.id,
      condition: this.buildCondition(rule),
      action: this.buildAction(rule),
      priority: rule.priority
    });
  }
  
  // 메시지 라우팅
  async routeMessage(
    message: Message,
    context: RoutingContext
  ): Promise<RoutingResult> {
    const startTime = Date.now();
    const results: RoutingDecision[] = [];
    
    try {
      // 1. 적용 가능한 규칙 찾기
      const applicableRules = await this.findApplicableRules(
        message,
        context
      );
      
      // 2. 우선순위에 따라 정렬
      const sortedRules = applicableRules.sort(
        (a, b) => b.priority - a.priority
      );
      
      // 3. 규칙 적용
      for (const rule of sortedRules) {
        const decision = await this.applyRule(rule, message, context);
        results.push(decision);
        
        // 체인 중단 조건 확인
        if (decision.stopProcessing) {
          break;
        }
      }
      
      // 4. 라우팅 실행
      await this.executeRouting(results, message);
      
      return {
        success: true,
        decisions: results,
        processingTime: Date.now() - startTime
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message,
        decisions: results,
        processingTime: Date.now() - startTime
      };
    }
  }
  
  // 컨텐츠 기반 라우팅
  private async applyContentBasedRouting(
    message: Message,
    rule: RoutingRule
  ): Promise<string[]> {
    const destinations: string[] = [];
    
    // JSON Path 기반 필터링
    if (rule.filter?.jsonPath) {
      const matches = JSONPath.query(
        message.data,
        rule.filter.jsonPath
      );
      
      if (matches.length > 0) {
        destinations.push(...this.resolveDestinations(rule.destination));
      }
    }
    
    // 정규식 기반 필터링
    if (rule.filter?.regex) {
      const content = JSON.stringify(message.data);
      const regex = new RegExp(rule.filter.regex, 'g');
      
      if (regex.test(content)) {
        destinations.push(...this.resolveDestinations(rule.destination));
      }
    }
    
    // 커스텀 함수 기반 필터링
    if (rule.filter?.customFunction) {
      const shouldRoute = await rule.filter.customFunction(message);
      
      if (shouldRoute) {
        destinations.push(...this.resolveDestinations(rule.destination));
      }
    }
    
    return destinations;
  }
  
  // 메시지 변환
  private async transformMessage(
    message: Message,
    transformer: MessageTransformer
  ): Promise<Message> {
    if (transformer.type === 'template') {
      return this.applyTemplate(message, transformer.template);
    }
    
    if (transformer.type === 'function') {
      return await transformer.function(message);
    }
    
    if (transformer.type === 'mapping') {
      return this.applyMapping(message, transformer.mapping);
    }
    
    return message;
  }
}

// 라우팅 엔진
class RuleEngine {
  private rules: CompiledRule[] = [];
  
  async registerRule(rule: EngineRule): Promise<void> {
    const compiled = await this.compileRule(rule);
    this.rules.push(compiled);
    
    // 규칙 최적화
    this.optimizeRules();
  }
  
  async evaluate(
    message: Message,
    context: RoutingContext
  ): Promise<EvaluationResult[]> {
    const results: EvaluationResult[] = [];
    
    for (const rule of this.rules) {
      const result = await this.evaluateRule(rule, message, context);
      
      if (result.matched) {
        results.push(result);
      }
    }
    
    return results;
  }
  
  private async compileRule(rule: EngineRule): Promise<CompiledRule> {
    // 규칙을 실행 가능한 형태로 컴파일
    const conditionFn = this.compileCondition(rule.condition);
    const actionFn = this.compileAction(rule.action);
    
    return {
      id: rule.id,
      evaluate: conditionFn,
      execute: actionFn,
      priority: rule.priority,
      metadata: rule.metadata
    };
  }
}
```

### SubTask 1.14.4: 메시지 보장성 및 트랜잭션
**담당자**: 시니어 백엔드 개발자  
**예상 소요시간**: 10시간

**목표**: 메시지 전달 보장성과 분산 트랜잭션 지원

**구현 내용**:
```typescript
// backend/src/messaging/reliability/message-guarantees.ts
export class ReliableMessaging {
  private messageStore: MessageStore;
  private transactionManager: TransactionManager;
  private acknowledgmentTracker: AcknowledgmentTracker;
  
  constructor() {
    this.messageStore = new MessageStore();
    this.transactionManager = new TransactionManager();
    this.acknowledgmentTracker = new AcknowledgmentTracker();
  }
  
  // At-least-once 전달 보장
  async sendWithGuarantee(
    message: Message,
    options: GuaranteeOptions
  ): Promise<SendResult> {
    const messageId = crypto.randomUUID();
    const transaction = await this.transactionManager.begin();
    
    try {
      // 1. 메시지 저장 (아웃박스 패턴)
      await this.messageStore.save({
        id: messageId,
        message,
        status: 'pending',
        attempts: 0,
        maxAttempts: options.maxAttempts || 3,
        timestamp: new Date()
      });
      
      // 2. 비즈니스 로직 실행
      if (options.businessLogic) {
        await options.businessLogic(transaction);
      }
      
      // 3. 트랜잭션 커밋
      await transaction.commit();
      
      // 4. 메시지 발송 시도
      const sendResult = await this.attemptSend(messageId);
      
      return {
        messageId,
        status: sendResult.success ? 'sent' : 'queued',
        timestamp: new Date()
      };
      
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
  
  // Exactly-once 전달 보장 (멱등성)
  async sendExactlyOnce(
    message: Message,
    idempotencyKey: string
  ): Promise<SendResult> {
    // 중복 확인
    const existing = await this.messageStore.findByIdempotencyKey(
      idempotencyKey
    );
    
    if (existing) {
      return {
        messageId: existing.id,
        status: 'duplicate',
        timestamp: existing.timestamp
      };
    }
    
    // 새 메시지 처리
    return await this.sendWithGuarantee(message, {
      idempotencyKey,
      maxAttempts: 5,
      businessLogic: async (tx) => {
        await this.messageStore.saveIdempotencyKey(
          idempotencyKey,
          message.id,
          tx
        );
      }
    });
  }
  
  // 아웃박스 프로세서
  async processOutbox(): Promise<void> {
    const pendingMessages = await this.messageStore.getPending({
      limit: 100,
      maxAge: 3600000 // 1시간
    });
    
    for (const record of pendingMessages) {
      try {
        const result = await this.attemptSend(record.id);
        
        if (result.success) {
          await this.messageStore.markSent(record.id);
        } else if (record.attempts >= record.maxAttempts) {
          await this.messageStore.markFailed(record.id);
          await this.handleFailedMessage(record);
        } else {
          await this.messageStore.incrementAttempts(record.id);
        }
        
      } catch (error) {
        console.error(`Outbox processing error for ${record.id}:`, error);
      }
    }
  }
  
  // 분산 트랜잭션 (Saga 패턴)
  async executeSaga<T>(
    saga: SagaDefinition<T>
  ): Promise<SagaResult<T>> {
    const sagaId = crypto.randomUUID();
    const executedSteps: ExecutedStep[] = [];
    
    try {
      // 전진 단계 실행
      for (const step of saga.steps) {
        const stepResult = await this.executeStep(step, saga.context);
        
        executedSteps.push({
          stepId: step.id,
          result: stepResult,
          timestamp: new Date()
        });
        
        // 상태 저장
        await this.saveSagaState(sagaId, executedSteps);
        
        // 보상 트랜잭션 등록
        if (step.compensate) {
          await this.registerCompensation(sagaId, step);
        }
      }
      
      return {
        success: true,
        sagaId,
        result: saga.onComplete(executedSteps)
      };
      
    } catch (error) {
      // 보상 트랜잭션 실행
      await this.compensateSaga(sagaId, executedSteps);
      
      return {
        success: false,
        sagaId,
        error: error.message,
        compensated: true
      };
    }
  }
  
  // 메시지 순서 보장
  async sendOrdered(
    messages: Message[],
    partitionKey: string
  ): Promise<void> {
    const queue = await this.getOrderedQueue(partitionKey);
    
    for (const message of messages) {
      await queue.enqueue({
        ...message,
        sequenceNumber: await this.getNextSequence(partitionKey),
        partitionKey
      });
    }
  }
}

// 트랜잭션 로그
class TransactionLog {
  async append(entry: LogEntry): Promise<void> {
    await this.storage.append({
      ...entry,
      timestamp: new Date(),
      checksum: this.calculateChecksum(entry)
    });
  }
  
  async replay(fromSequence: number): Promise<LogEntry[]> {
    const entries = await this.storage.readFrom(fromSequence);
    
    // 체크섬 검증
    for (const entry of entries) {
      if (!this.verifyChecksum(entry)) {
        throw new Error(`Corrupted log entry: ${entry.sequence}`);
      }
    }
    
    return entries;
  }
}
```
## Task 1.15: 로깅 및 모니터링

### SubTask 1.15.1: 구조화된 로깅 시스템
**담당자**: 백엔드 개발자  
**예상 소요시간**: 8시간

**목표**: CloudWatch와 통합된 구조화된 로깅 시스템 구현

**구현 내용**:
```typescript
// backend/src/logging/structured-logger.ts
import winston from 'winston';
import { CloudWatchLogs } from '@aws-sdk/client-cloudwatch-logs';
import { performance } from 'perf_hooks';

export interface LogContext {
  userId?: string;
  projectId?: string;
  agentId?: string;
  correlationId?: string;
  sessionId?: string;
  traceId?: string;
  spanId?: string;
}

export class StructuredLogger {
  private logger: winston.Logger;
  private cloudwatch: CloudWatchLogs;
  private context: LogContext = {};
  private performanceMarks: Map<string, number> = new Map();
  
  constructor(private config: LoggerConfig) {
    this.cloudwatch = new CloudWatchLogs({
      region: config.aws.region
    });
    
    this.logger = winston.createLogger({
      level: config.logLevel || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json(),
        winston.format.printf(info => {
          return JSON.stringify({
            ...this.enrichLog(info),
            ...this.context
          });
        })
      ),
      transports: this.createTransports()
    });
  }
  
  // 로그 강화
  private enrichLog(info: any): any {
    return {
      timestamp: new Date().toISOString(),
      level: info.level,
      message: info.message,
      service: this.config.serviceName,
      environment: process.env.NODE_ENV,
      version: process.env.APP_VERSION,
      hostname: process.env.HOSTNAME,
      pid: process.pid,
      ...this.extractMetadata(info)
    };
  }
  
  // 컨텍스트 설정
  setContext(context: Partial<LogContext>): void {
    this.context = { ...this.context, ...context };
  }
  
  // 에이전트 실행 로깅
  logAgentExecution(
    agentId: string,
    event: AgentExecutionEvent
  ): void {
    this.logger.info('Agent execution', {
      agentId,
      event: event.type,
      duration: event.duration,
      status: event.status,
      input: this.sanitizeInput(event.input),
      output: this.sanitizeOutput(event.output),
      metadata: {
        modelUsed: event.modelUsed,
        tokensUsed: event.tokensUsed,
        cost: event.cost
      }
    });
  }
  
  // 성능 측정
  startTimer(label: string): void {
    this.performanceMarks.set(label, performance.now());
  }
  
  endTimer(label: string, metadata?: any): void {
    const startTime = this.performanceMarks.get(label);
    if (!startTime) return;
    
    const duration = performance.now() - startTime;
    this.performanceMarks.delete(label);
    
    this.logger.info('Performance measurement', {
      label,
      duration,
      unit: 'ms',
      ...metadata
    });
  }
  
  // 에러 로깅
  logError(error: Error, context?: any): void {
    this.logger.error('Error occurred', {
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack,
        ...this.extractErrorMetadata(error)
      },
      context
    });
  }
  
  // CloudWatch Logs 통합
  private createCloudWatchTransport(): winston.transport {
    return new CloudWatchTransport({
      logGroupName: `/aws/t-developer/${this.config.environment}`,
      logStreamName: `${this.config.serviceName}-${new Date().toISOString().split('T')[0]}`,
      cloudwatch: this.cloudwatch,
      messageFormatter: (info) => JSON.stringify(info),
      retentionInDays: 30
    });
  }
  
  // 로그 집계 및 분석
  async queryLogs(
    query: LogQuery
  ): Promise<LogQueryResult> {
    const params = {
      logGroupName: `/aws/t-developer/${this.config.environment}`,
      startTime: query.startTime.getTime(),
      endTime: query.endTime.getTime(),
      queryString: this.buildInsightsQuery(query),
      limit: query.limit || 1000
    };
    
    const result = await this.cloudwatch.startQuery(params);
    
    // 쿼리 완료 대기
    return await this.waitForQueryCompletion(result.queryId!);
  }
  
  // CloudWatch Insights 쿼리 빌더
  private buildInsightsQuery(query: LogQuery): string {
    const conditions: string[] = [];
    
    if (query.level) {
      conditions.push(`level = "${query.level}"`);
    }
    
    if (query.agentId) {
      conditions.push(`agentId = "${query.agentId}"`);
    }
    
    if (query.searchText) {
      conditions.push(`message like /${query.searchText}/`);
    }
    
    const whereClause = conditions.length > 0 
      ? `| filter ${conditions.join(' and ')}` 
      : '';
    
    return `
      fields @timestamp, level, message, agentId, duration
      | sort @timestamp desc
      ${whereClause}
      | limit ${query.limit || 1000}
    `;
  }
}

// 로그 전송 버퍼
class LogBuffer {
  private buffer: LogEntry[] = [];
  private timer?: NodeJS.Timeout;
  
  constructor(
    private maxSize: number = 100,
    private flushInterval: number = 5000
  ) {
    this.startFlushTimer();
  }
  
  add(entry: LogEntry): void {
    this.buffer.push(entry);
    
    if (this.buffer.length >= this.maxSize) {
      this.flush();
    }
  }
  
  private async flush(): Promise<void> {
    if (this.buffer.length === 0) return;
    
    const entries = [...this.buffer];
    this.buffer = [];
    
    try {
      await this.sendToCloudWatch(entries);
    } catch (error) {
      // 실패한 로그는 다시 버퍼에 추가
      this.buffer.unshift(...entries);
    }
  }
}
```

### SubTask 1.15.2: 메트릭 수집 시스템
**담당자**: DevOps 엔지니어  
**예상 소요시간**: 10시간

**목표**: CloudWatch Metrics와 Prometheus 통합 메트릭 시스템

**구현 내용**:
```typescript
// backend/src/monitoring/metrics-collector.ts
import { CloudWatch } from '@aws-sdk/client-cloudwatch';
import { Counter, Gauge, Histogram, Registry } from 'prom-client';
import { EventEmitter } from 'events';

export class MetricsCollector {
  private cloudwatch: CloudWatch;
  private registry: Registry;
  private customMetrics: Map<string, any> = new Map();
  private aggregator: MetricAggregator;
  
  constructor(private config: MetricsConfig) {
    this.cloudwatch = new CloudWatch({ region: config.aws.region });
    this.registry = new Registry();
    this.aggregator = new MetricAggregator();
    
    this.initializeDefaultMetrics();
  }
  
  private initializeDefaultMetrics(): void {
    // 에이전트 메트릭
    this.createMetric('agent_executions_total', 'counter', {
      help: 'Total number of agent executions',
      labelNames: ['agent_type', 'status']
    });
    
    this.createMetric('agent_execution_duration', 'histogram', {
      help: 'Agent execution duration in seconds',
      labelNames: ['agent_type'],
      buckets: [0.1, 0.5, 1, 2, 5, 10, 30, 60]
    });
    
    this.createMetric('active_agents', 'gauge', {
      help: 'Number of active agents',
      labelNames: ['agent_type']
    });
    
    // 시스템 메트릭
    this.createMetric('api_requests_total', 'counter', {
      help: 'Total API requests',
      labelNames: ['method', 'endpoint', 'status_code']
    });
    
    this.createMetric('database_connections', 'gauge', {
      help: 'Active database connections'
    });
    
    // 비즈니스 메트릭
    this.createMetric('projects_created_total', 'counter', {
      help: 'Total projects created',
      labelNames: ['project_type']
    });
  }
  
  // 메트릭 기록
  async recordMetric(
    name: string,
    value: number,
    labels?: Record<string, string>,
    unit?: MetricUnit
  ): Promise<void> {
    // Prometheus 메트릭 업데이트
    const metric = this.customMetrics.get(name);
    if (metric) {
      if (metric instanceof Counter) {
        metric.inc(labels, value);
      } else if (metric instanceof Gauge) {
        metric.set(labels, value);
      } else if (metric instanceof Histogram) {
        metric.observe(labels, value);
      }
    }
    
    // CloudWatch 메트릭 전송
    await this.sendToCloudWatch({
      MetricName: name,
      Value: value,
      Unit: unit || 'None',
      Dimensions: this.convertLabelsToDimensions(labels),
      Timestamp: new Date()
    });
  }
  
  // 에이전트 실행 메트릭
  async recordAgentExecution(
    agentType: string,
    duration: number,
    status: 'success' | 'failure',
    metadata?: AgentExecutionMetadata
  ): Promise<void> {
    // 실행 횟수
    await this.recordMetric(
      'agent_executions_total',
      1,
      { agent_type: agentType, status }
    );
    
    // 실행 시간
    await this.recordMetric(
      'agent_execution_duration',
      duration,
      { agent_type: agentType },
      'Seconds'
    );
    
    // 토큰 사용량
    if (metadata?.tokensUsed) {
      await this.recordMetric(
        'llm_tokens_used',
        metadata.tokensUsed,
        { 
          agent_type: agentType,
          model: metadata.model 
        }
      );
    }
    
    // 비용
    if (metadata?.cost) {
      await this.recordMetric(
        'agent_execution_cost',
        metadata.cost,
        { agent_type: agentType },
        'USD'
      );
    }
  }
  
  // 실시간 대시보드 데이터
  async getDashboardMetrics(): Promise<DashboardData> {
    const metrics = await this.aggregator.aggregate([
      'agent_executions_total',
      'agent_execution_duration',
      'active_agents',
      'api_requests_total',
      'error_rate'
    ]);
    
    return {
      timestamp: new Date(),
      summary: {
        totalExecutions: metrics.agent_executions_total,
        averageDuration: metrics.agent_execution_duration_avg,
        activeAgents: metrics.active_agents,
        errorRate: metrics.error_rate
      },
      timeSeries: await this.getTimeSeriesData(),
      topAgents: await this.getTopAgentsByUsage(),
      alerts: await this.getActiveAlerts()
    };
  }
  
  // CloudWatch 알람 설정
  async createAlarm(
    name: string,
    config: AlarmConfig
  ): Promise<void> {
    await this.cloudwatch.putMetricAlarm({
      AlarmName: `t-developer-${name}`,
      ComparisonOperator: config.comparisonOperator,
      EvaluationPeriods: config.evaluationPeriods,
      MetricName: config.metricName,
      Namespace: 'T-Developer',
      Period: config.period,
      Statistic: config.statistic,
      Threshold: config.threshold,
      ActionsEnabled: true,
      AlarmActions: config.alarmActions,
      AlarmDescription: config.description,
      Dimensions: config.dimensions
    });
  }
}

// 메트릭 집계
class MetricAggregator {
  private cache: Map<string, AggregatedMetric> = new Map();
  
  async aggregate(
    metricNames: string[]
  ): Promise<Record<string, any>> {
    const results: Record<string, any> = {};
    
    for (const name of metricNames) {
      const cached = this.cache.get(name);
      
      if (cached && this.isCacheValid(cached)) {
        results[name] = cached.value;
      } else {
        const value = await this.computeMetric(name);
        this.cache.set(name, {
          value,
          timestamp: Date.now()
        });
        results[name] = value;
      }
    }
    
    return results;
  }
  
  private async computeMetric(name: string): Promise<any> {
    // 메트릭별 계산 로직
    switch (name) {
      case 'error_rate':
        return await this.calculateErrorRate();
      case 'agent_execution_duration_avg':
        return await this.calculateAverageExecutionTime();
      default:
        return await this.getLatestValue(name);
    }
  }
}
```

### SubTask 1.15.3: 분산 추적 시스템
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**목표**: AWS X-Ray 기반 분산 추적 시스템 구현

**구현 내용**:
```typescript
// backend/src/monitoring/distributed-tracing.ts
import AWSXRay from 'aws-xray-sdk-core';
import { Subsegment, Segment } from 'aws-xray-sdk-core';
import { AsyncLocalStorage } from 'async_hooks';

export class DistributedTracing {
  private asyncLocalStorage: AsyncLocalStorage<TraceContext>;
  private samplingRules: SamplingRule[];
  
  constructor(private config: TracingConfig) {
    this.asyncLocalStorage = new AsyncLocalStorage();
    this.samplingRules = config.samplingRules || this.getDefaultRules();
    
    // X-Ray 설정
    AWSXRay.config([
      AWSXRay.plugins.ECSPlugin,
      AWSXRay.plugins.EC2Plugin
    ]);
    
    if (config.captureHTTPS) {
      AWSXRay.captureHTTPsGlobal(require('http'));
      AWSXRay.captureHTTPsGlobal(require('https'));
    }
    
    if (config.captureAWS) {
      AWSXRay.captureAWS(require('aws-sdk'));
    }
  }
  
  // 트레이스 시작
  startTrace(
    name: string,
    metadata?: any
  ): TraceContext {
    const segment = new AWSXRay.Segment(name);
    
    // 샘플링 결정
    const shouldSample = this.shouldSample(name, metadata);
    segment.trace_id = shouldSample ? 
      AWSXRay.utils.generateTraceID() : 
      AWSXRay.utils.generateNotTraceID();
    
    // 메타데이터 추가
    if (metadata) {
      segment.addMetadata('request', metadata);
    }
    
    const context: TraceContext = {
      segment,
      traceId: segment.trace_id,
      startTime: Date.now()
    };
    
    this.asyncLocalStorage.enterWith(context);
    
    return context;
  }
  
  // 에이전트 실행 추적
  async traceAgentExecution<T>(
    agentId: string,
    agentType: string,
    operation: () => Promise<T>
  ): Promise<T> {
    const context = this.getCurrentContext();
    if (!context) {
      return await operation();
    }
    
    const subsegment = context.segment.addNewSubsegment(
      `agent-${agentType}`
    );
    
    subsegment.addAnnotation('agent_id', agentId);
    subsegment.addAnnotation('agent_type', agentType);
    
    try {
      const startTime = Date.now();
      const result = await operation();
      
      subsegment.addMetadata('execution', {
        duration: Date.now() - startTime,
        success: true
      });
      
      subsegment.close();
      return result;
      
    } catch (error) {
      subsegment.addError(error);
      subsegment.close(error);
      throw error;
    }
  }
  
  // LLM 호출 추적
  async traceLLMCall<T>(
    model: string,
    provider: string,
    operation: () => Promise<T>
  ): Promise<T> {
    const subsegment = this.createSubsegment('llm-call');
    
    subsegment.addAnnotation('model', model);
    subsegment.addAnnotation('provider', provider);
    
    const startTime = Date.now();
    
    try {
      const result = await operation();
      
      // LLM 특화 메트릭
      subsegment.addMetadata('llm', {
        model,
        provider,
        duration: Date.now() - startTime,
        tokens: (result as any).usage?.total_tokens,
        cost: this.calculateCost(model, (result as any).usage)
      });
      
      subsegment.close();
      return result;
      
    } catch (error) {
      subsegment.addError(error);
      subsegment.close(error);
      throw error;
    }
  }
  
  // 커스텀 스팬 생성
  createSpan(name: string, attributes?: SpanAttributes): Span {
    const context = this.getCurrentContext();
    if (!context) {
      throw new Error('No active trace context');
    }
    
    const span = new Span(name, context.segment);
    
    if (attributes) {
      Object.entries(attributes).forEach(([key, value]) => {
        span.setAttribute(key, value);
      });
    }
    
    return span;
  }
  
  // 분산 시스템 간 전파
  injectTraceHeaders(headers: Record<string, string>): void {
    const context = this.getCurrentContext();
    if (!context) return;
    
    headers['X-Amzn-Trace-Id'] = context.segment.trace_id;
    headers['X-Trace-Parent'] = this.generateTraceParent(context);
  }
  
  extractTraceHeaders(
    headers: Record<string, string>
  ): TraceContext | null {
    const traceId = headers['X-Amzn-Trace-Id'] || 
                   headers['x-amzn-trace-id'];
    
    if (!traceId) return null;
    
    const segment = AWSXRay.utils.processTraceData(traceId);
    
    return {
      segment,
      traceId,
      startTime: Date.now()
    };
  }
  
  // 트레이스 분석
  async analyzeTrace(traceId: string): Promise<TraceAnalysis> {
    const xray = new AWS.XRay();
    
    const traceResult = await xray.getTraceSummaries({
      TraceIds: [traceId],
      TimeRangeType: 'TraceId'
    }).promise();
    
    if (!traceResult.TraceSummaries?.length) {
      throw new Error('Trace not found');
    }
    
    const segments = await xray.getTraceGraph({
      TraceId: traceId
    }).promise();
    
    return this.analyzeTraceGraph(segments.Services || []);
  }
  
  // 성능 이상 감지
  private analyzeTraceGraph(services: any[]): TraceAnalysis {
    const analysis: TraceAnalysis = {
      totalDuration: 0,
      criticalPath: [],
      bottlenecks: [],
      errors: []
    };
    
    // 크리티컬 패스 분석
    const criticalPath = this.findCriticalPath(services);
    analysis.criticalPath = criticalPath;
    
    // 병목 지점 찾기
    services.forEach(service => {
      if (service.ResponseTimeHistogram) {
        const p95 = this.calculatePercentile(
          service.ResponseTimeHistogram,
          0.95
        );
        
        if (p95 > this.config.bottleneckThreshold) {
          analysis.bottlenecks.push({
            service: service.Name,
            p95Duration: p95,
            callCount: service.ResponseTimeHistogram.TotalCount
          });
        }
      }
    });
    
    return analysis;
  }
}

// 트레이스 컨텍스트 관리
export class TraceContextManager {
  private static instance: TraceContextManager;
  private storage: AsyncLocalStorage<TraceContext>;
  
  private constructor() {
    this.storage = new AsyncLocalStorage();
  }
  
  static getInstance(): TraceContextManager {
    if (!this.instance) {
      this.instance = new TraceContextManager();
    }
    return this.instance;
  }
  
  run<T>(context: TraceContext, fn: () => T): T {
    return this.storage.run(context, fn);
  }
  
  getContext(): TraceContext | undefined {
    return this.storage.getStore();
  }
}
```

### SubTask 1.15.4: 통합 모니터링 대시보드
**담당자**: 풀스택 개발자  
**예상 소요시간**: 10시간

**목표**: 실시간 모니터링 대시보드 구현

**구현 내용**:
```typescript
// backend/src/monitoring/dashboard/monitoring-dashboard.ts
export class MonitoringDashboard {
  private metricsCollector: MetricsCollector;
  private logQuerier: LogQuerier;
  private traceAnalyzer: TraceAnalyzer;
  private alertManager: AlertManager;
  
  constructor() {
    this.metricsCollector = new MetricsCollector();
    this.logQuerier = new LogQuerier();
    this.traceAnalyzer = new TraceAnalyzer();
    this.alertManager = new AlertManager();
  }
  
  // 대시보드 데이터 집계
  async getDashboardData(
    timeRange: TimeRange
  ): Promise<DashboardData> {
    const [metrics, logs, traces, alerts] = await Promise.all([
      this.getMetricsSummary(timeRange),
      this.getLogsSummary(timeRange),
      this.getTracesSummary(timeRange),
      this.getActiveAlerts()
    ]);
    
    return {
      overview: this.generateOverview(metrics),
      agentPerformance: await this.getAgentPerformance(timeRange),
      systemHealth: await this.getSystemHealth(),
      recentErrors: logs.errors.slice(0, 10),
      activeAlerts: alerts,
      traces: traces.recentTraces,
      costAnalysis: await this.getCostAnalysis(timeRange)
    };
  }
  
  // 에이전트 성능 분석
  async getAgentPerformance(
    timeRange: TimeRange
  ): Promise<AgentPerformanceData> {
    const agentMetrics = await this.metricsCollector.query({
      namespace: 'T-Developer/Agents',
      metricName: 'ExecutionTime',
      dimensions: [{ Name: 'AgentType', Value: '*' }],
      statistics: ['Average', 'Maximum', 'SampleCount'],
      period: 300, // 5분
      startTime: timeRange.start,
      endTime: timeRange.end
    });
    
    const agentErrors = await this.logQuerier.query({
      query: 'level="error" AND agentId exists',
      timeRange,
      aggregation: {
        field: 'agentId',
        type: 'count'
      }
    });
    
    return {
      executionStats: this.processAgentMetrics(agentMetrics),
      errorRates: this.calculateErrorRates(agentErrors),
      topPerformers: this.identifyTopPerformers(agentMetrics),
      recommendations: this.generatePerformanceRecommendations(
        agentMetrics,
        agentErrors
      )
    };
  }
  
  // 실시간 알림 스트림
  async *streamAlerts(): AsyncGenerator<Alert> {
    const eventSource = new EventSource('/api/monitoring/alerts/stream');
    
    for await (const event of eventSource) {
      const alert = JSON.parse(event.data);
      
      // 알림 우선순위 평가
      alert.priority = this.evaluateAlertPriority(alert);
      
      // 상관관계 분석
      alert.correlatedEvents = await this.findCorrelatedEvents(alert);
      
      yield alert;
    }
  }
  
  // 비용 분석
  async getCostAnalysis(
    timeRange: TimeRange
  ): Promise<CostAnalysis> {
    const usage = await this.metricsCollector.query({
      namespace: 'T-Developer/Usage',
      metricNames: [
        'LLMTokensUsed',
        'AgentExecutions',
        'StorageUsed',
        'DataTransfer'
      ],
      timeRange
    });
    
    const costs = {
      llm: this.calculateLLMCost(usage.LLMTokensUsed),
      compute: this.calculateComputeCost(usage.AgentExecutions),
      storage: this.calculateStorageCost(usage.StorageUsed),
      network: this.calculateNetworkCost(usage.DataTransfer)
    };
    
    return {
      total: Object.values(costs).reduce((a, b) => a + b, 0),
      breakdown: costs,
      trend: await this.getCostTrend(timeRange),
      projections: this.projectMonthlyCost(costs, timeRange),
      optimizationSuggestions: this.generateCostOptimizations(usage)
    };
  }
  
  // 시스템 상태 체크
  async getSystemHealth(): Promise<SystemHealth> {
    const checks = await Promise.all([
      this.checkAPIHealth(),
      this.checkDatabaseHealth(),
      this.checkCacheHealth(),
      this.checkQueueHealth(),
      this.checkAgentHealth()
    ]);
    
    const overallHealth = checks.every(c => c.status === 'healthy') 
      ? 'healthy' 
      : checks.some(c => c.status === 'critical') 
        ? 'critical' 
        : 'degraded';
    
    return {
      status: overallHealth,
      components: checks,
      lastChecked: new Date(),
      uptime: process.uptime(),
      incidents: await this.getRecentIncidents()
    };
  }
}

// 실시간 메트릭 스트리밍
export class MetricsStreamer {
  private websocketServer: WebSocketServer;
  private subscribers: Map<string, Set<WebSocket>> = new Map();
  
  async streamMetrics(
    metricName: string,
    interval: number = 1000
  ): void {
    setInterval(async () => {
      const value = await this.getMetricValue(metricName);
      const data = {
        metric: metricName,
        value,
        timestamp: Date.now()
      };
      
      this.broadcast(metricName, data);
    }, interval);
  }
  
  private broadcast(channel: string, data: any): void {
    const subscribers = this.subscribers.get(channel);
    if (!subscribers) return;
    
    const message = JSON.stringify(data);
    
    subscribers.forEach(ws => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(message);
      }
    });
  }
}
```

## Task 1.16: 에러 처리 프레임워크

### SubTask 1.16.1: 중앙화된 에러 처리 시스템
**담당자**: 시니어 백엔드 개발자  
**예상 소요시간**: 10시간

**목표**: 체계적인 에러 처리 및 복구 시스템 구현

**구현 내용**:
```typescript
// backend/src/errors/error-handler.ts
export abstract class BaseError extends Error {
  public readonly id: string;
  public readonly timestamp: Date;
  public readonly isOperational: boolean;
  public readonly statusCode: number;
  public readonly context?: any;
  
  constructor(
    message: string,
    statusCode: number,
    isOperational: boolean = true,
    context?: any
  ) {
    super(message);
    this.id = crypto.randomUUID();
    this.timestamp = new Date();
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.context = context;
    
    Error.captureStackTrace(this, this.constructor);
  }
  
  toJSON(): ErrorResponse {
    return {
      id: this.id,
      name: this.name,
      message: this.message,
      statusCode: this.statusCode,
      timestamp: this.timestamp,
      context: this.sanitizeContext()
    };
  }
  
  private sanitizeContext(): any {
    // 민감한 정보 제거
    if (!this.context) return undefined;
    
    const sanitized = { ...this.context };
    const sensitiveKeys = ['password', 'token', 'apiKey', 'secret'];
    
    sensitiveKeys.forEach(key => {
      if (key in sanitized) {
        sanitized[key] = '[REDACTED]';
      }
    });
    
    return sanitized;
  }
}

// 에러 타입별 클래스
export class ValidationError extends BaseError {
  constructor(message: string, field?: string, value?: any) {
    super(message, 400, true, { field, value });
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends BaseError {
  constructor(message: string = 'Authentication failed') {
    super(message, 401, true);
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends BaseError {
  constructor(resource: string, action: string) {
    super(
      `Not authorized to ${action} ${resource}`,
      403,
      true,
      { resource, action }
    );
    this.name = 'AuthorizationError';
  }
}

export class NotFoundError extends BaseError {
  constructor(resource: string, identifier?: string) {
    super(
      `${resource} not found${identifier ? `: ${identifier}` : ''}`,
      404,
      true,
      { resource, identifier }
    );
    this.name = 'NotFoundError';
  }
}

export class ConflictError extends BaseError {
  constructor(message: string, conflictingResource?: any) {
    super(message, 409, true, { conflictingResource });
    this.name = 'ConflictError';
  }
}

export class RateLimitError extends BaseError {
  constructor(limit: number, window: string, retryAfter?: number) {
    super(
      `Rate limit exceeded: ${limit} requests per ${window}`,
      429,
      true,
      { limit, window, retryAfter }
    );
    this.name = 'RateLimitError';
  }
}

export class ExternalServiceError extends BaseError {
  constructor(service: string, originalError?: any) {
    super(
      `External service error: ${service}`,
      502,
      true,
      { service, originalError: originalError?.message }
    );
    this.name = 'ExternalServiceError';
  }
}

// 중앙 에러 핸들러
export class ErrorHandler {
  private errorLogger: ErrorLogger;
  private alertManager: AlertManager;
  private errorRecovery: ErrorRecovery;
  
  constructor() {
    this.errorLogger = new ErrorLogger();
    this.alertManager = new AlertManager();
    this.errorRecovery = new ErrorRecovery();
  }
  
  async handle(error: Error, context?: ErrorContext): Promise<void> {
    // 에러 분류
    const errorType = this.classifyError(error);
    
    // 로깅
    await this.errorLogger.log(error, {
      ...context,
      type: errorType,
      severity: this.determineSeverity(error)
    });
    
    // 운영 에러 vs 프로그래밍 에러
    if (error instanceof BaseError && error.isOperational) {
      await this.handleOperationalError(error, context);
    } else {
      await this.handleProgrammerError(error, context);
    }
    
    // 복구 시도
    if (this.errorRecovery.canRecover(error)) {
      await this.errorRecovery.attempt(error, context);
    }
  }
  
  private async handleOperationalError(
    error: BaseError,
    context?: ErrorContext
  ): Promise<void> {
    // 메트릭 기록
    await this.recordErrorMetric(error);
    
    // 필요시 알림
    if (this.shouldAlert(error)) {
      await this.alertManager.send({
        level: 'warning',
        title: `Operational Error: ${error.name}`,
        message: error.message,
        context
      });
    }
  }
  
  private async handleProgrammerError(
    error: Error,
    context?: ErrorContext
  ): Promise<void> {
    // 심각한 에러로 처리
    await this.errorLogger.logCritical(error, context);
    
    // 즉시 알림
    await this.alertManager.sendCritical({
      title: 'Programmer Error Detected',
      error,
      context,
      recommendation: 'Immediate investigation required'
    });
    
    // 서비스 상태 확인
    if (this.shouldShutdown(error)) {
      await this.gracefulShutdown();
    }
  }
  
  // 에러 집계 및 분석
  async analyzeErrors(
    timeRange: TimeRange
  ): Promise<ErrorAnalysis> {
    const errors = await this.errorLogger.query(timeRange);
    
    return {
      total: errors.length,
      byType: this.groupByType(errors),
      byService: this.groupByService(errors),
      trends: this.analyzeTrends(errors),
      patterns: await this.detectPatterns(errors),
      recommendations: this.generateRecommendations(errors)
    };
  }
}

// 에러 복구 전략
export class ErrorRecovery {
  private strategies: Map<string, RecoveryStrategy> = new Map();
  
  constructor() {
    this.registerDefaultStrategies();
  }
  
  private registerDefaultStrategies(): void {
    // 재시도 전략
    this.strategies.set('retry', new RetryStrategy({
      maxAttempts: 3,
      backoffMultiplier: 2,
      maxBackoffTime: 30000
    }));
    
    // 폴백 전략
    this.strategies.set('fallback', new FallbackStrategy());
    
    // 서킷 브레이커
    this.strategies.set('circuit-breaker', new CircuitBreakerStrategy({
      threshold: 5,
      timeout: 60000,
      resetTimeout: 120000
    }));
  }
  
  async attempt(
    error: Error,
    context?: ErrorContext
  ): Promise<RecoveryResult> {
    const strategy = this.selectStrategy(error);
    
    if (!strategy) {
      return { recovered: false, reason: 'No recovery strategy available' };
    }
    
    try {
      const result = await strategy.recover(error, context);
      
      if (result.recovered) {
        await this.logRecovery(error, strategy, result);
      }
      
      return result;
      
    } catch (recoveryError) {
      return {
        recovered: false,
        reason: 'Recovery failed',
        error: recoveryError
      };
    }
  }
}
```

### SubTask 1.16.2: 에러 복구 메커니즘
**담당자**: 백엔드 개발자  
**예상 소요시간**: 8시간

**목표**: 자동화된 에러 복구 및 재시도 메커니즘 구현

**구현 내용**:
```typescript
// backend/src/errors/recovery-strategies.ts
export abstract class RecoveryStrategy {
  abstract canRecover(error: Error): boolean;
  abstract recover(
    error: Error,
    context?: any
  ): Promise<RecoveryResult>;
}

// 재시도 전략
export class RetryStrategy extends RecoveryStrategy {
  private attemptCounts: Map<string, number> = new Map();
  
  constructor(private config: RetryConfig) {
    super();
  }
  
  canRecover(error: Error): boolean {
    // 재시도 가능한 에러 판단
    const retryableErrors = [
      'ETIMEDOUT',
      'ECONNRESET',
      'ENOTFOUND',
      'ECONNREFUSED',
      'EAI_AGAIN'
    ];
    
    if (error instanceof ExternalServiceError) {
      return true;
    }
    
    if (error instanceof RateLimitError) {
      return true;
    }
    
    return retryableErrors.some(code => 
      error.message.includes(code)
    );
  }
  
  async recover(
    error: Error,
    context?: any
  ): Promise<RecoveryResult> {
    const key = this.getRetryKey(error, context);
    const attempts = this.attemptCounts.get(key) || 0;
    
    if (attempts >= this.config.maxAttempts) {
      return {
        recovered: false,
        reason: 'Max retry attempts exceeded'
      };
    }
    
    // 백오프 계산
    const delay = this.calculateBackoff(attempts);
    
    // 재시도 전 대기
    await this.delay(delay);
    
    try {
      // 원래 작업 재실행
      const result = await context.operation();
      
      // 성공시 카운터 초기화
      this.attemptCounts.delete(key);
      
      return {
        recovered: true,
        result,
        attempts: attempts + 1
      };
      
    } catch (retryError) {
      // 재시도 실패
      this.attemptCounts.set(key, attempts + 1);
      
      // 계속 재시도할지 결정
      if (attempts + 1 < this.config.maxAttempts) {
        return await this.recover(retryError, context);
      }
      
      return {
        recovered: false,
        reason: 'Retry failed',
        error: retryError
      };
    }
  }
  
  private calculateBackoff(attempt: number): number {
    const exponentialDelay = Math.pow(
      this.config.backoffMultiplier,
      attempt
    ) * 1000;
    
    const jitteredDelay = exponentialDelay * (0.5 + Math.random() * 0.5);
    
    return Math.min(jitteredDelay, this.config.maxBackoffTime);
  }
}

// 서킷 브레이커 패턴
export class CircuitBreaker {
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  private failures: number = 0;
  private lastFailureTime?: Date;
  private successCount: number = 0;
  
  constructor(private config: CircuitBreakerConfig) {}
  
  async execute<T>(
    operation: () => Promise<T>
  ): Promise<T> {
    // 서킷 상태 확인
    if (this.state === 'open') {
      if (this.shouldAttemptReset()) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open');
      }
    }
    
    try {
      const result = await operation();
      
      // 성공 처리
      this.onSuccess();
      
      return result;
      
    } catch (error) {
      // 실패 처리
      this.onFailure();
      
      throw error;
    }
  }
  
  private onSuccess(): void {
    this.failures = 0;
    
    if (this.state === 'half-open') {
      this.successCount++;
      
      if (this.successCount >= this.config.successThreshold) {
        this.state = 'closed';
        this.successCount = 0;
      }
    }
  }
  
  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = new Date();
    
    if (this.state === 'half-open') {
      this.state = 'open';
      this.successCount = 0;
    } else if (this.failures >= this.config.threshold) {
      this.state = 'open';
    }
  }
  
  private shouldAttemptReset(): boolean {
    if (!this.lastFailureTime) return false;
    
    const timeSinceLastFailure = 
      Date.now() - this.lastFailureTime.getTime();
    
    return timeSinceLastFailure >= this.config.resetTimeout;
  }
}

// 폴백 전략
export class FallbackStrategy extends RecoveryStrategy {
  private fallbackHandlers: Map<string, FallbackHandler> = new Map();
  
  registerFallback(
    errorType: string,
    handler: FallbackHandler
  ): void {
    this.fallbackHandlers.set(errorType, handler);
  }
  
  canRecover(error: Error): boolean {
    return this.fallbackHandlers.has(error.constructor.name) ||
           this.fallbackHandlers.has('default');
  }
  
  async recover(
    error: Error,
    context?: any
  ): Promise<RecoveryResult> {
    const handler = this.fallbackHandlers.get(error.constructor.name) ||
                   this.fallbackHandlers.get('default');
    
    if (!handler) {
      return {
        recovered: false,
        reason: 'No fallback handler available'
      };
    }
    
    try {
      const fallbackResult = await handler(error, context);
      
      return {
        recovered: true,
        result: fallbackResult,
        fallback: true
      };
      
    } catch (fallbackError) {
      return {
        recovered: false,
        reason: 'Fallback failed',
        error: fallbackError
      };
    }
  }
}

// 에러 복구 조정자
export class RecoveryOrchestrator {
  private strategies: RecoveryStrategy[] = [];
  private circuitBreakers: Map<string, CircuitBreaker> = new Map();
  
  async orchestrateRecovery(
    error: Error,
    context: RecoveryContext
  ): Promise<RecoveryResult> {
    // 서킷 브레이커 확인
    const breaker = this.getCircuitBreaker(context.service);
    
    try {
      return await breaker.execute(async () => {
        // 적용 가능한 전략 찾기
        for (const strategy of this.strategies) {
          if (strategy.canRecover(error)) {
            const result = await strategy.recover(error, context);
            
            if (result.recovered) {
              return result;
            }
          }
        }
        
        throw error;
      });
      
    } catch (error) {
      // 모든 복구 시도 실패
      return {
        recovered: false,
        reason: 'All recovery strategies failed',
        error
      };
    }
  }
  
  private getCircuitBreaker(service: string): CircuitBreaker {
    if (!this.circuitBreakers.has(service)) {
      this.circuitBreakers.set(service, new CircuitBreaker({
        threshold: 5,
        resetTimeout: 60000,
        successThreshold: 3
      }));
    }
    
    return this.circuitBreakers.get(service)!;
  }
}
```

### SubTask 1.16.3: 에러 로깅 및 분석
**담당자**: 데이터 엔지니어  
**예상 소요시간**: 8시간

**목표**: 상세한 에러 로깅 및 패턴 분석 시스템

**구현 내용**:
```typescript
// backend/src/errors/error-analytics.ts
export class ErrorAnalytics {
  private errorStore: ErrorStore;
  private patternDetector: PatternDetector;
  private anomalyDetector: AnomalyDetector;
  
  constructor() {
    this.errorStore = new ErrorStore();
    this.patternDetector = new PatternDetector();
    this.anomalyDetector = new AnomalyDetector();
  }
  
  // 에러 패턴 분석
  async analyzePatterns(
    timeRange: TimeRange
  ): Promise<ErrorPatternAnalysis> {
    const errors = await this.errorStore.query({
      startTime: timeRange.start,
      endTime: timeRange.end,
      includeStackTrace: true
    });
    
    // 스택 트레이스 클러스터링
    const stackClusters = await this.clusterByStackTrace(errors);
    
    // 시계열 패턴 분석
    const temporalPatterns = await this.analyzeTemporalPatterns(errors);
    
    // 상관관계 분석
    const correlations = await this.findCorrelations(errors);
    
    return {
      clusters: stackClusters,
      temporalPatterns,
      correlations,
      insights: this.generateInsights(stackClusters, temporalPatterns)
    };
  }
  
  // 스택 트레이스 클러스터링
  private async clusterByStackTrace(
    errors: ErrorRecord[]
  ): Promise<StackCluster[]> {
    const clusters: Map<string, StackCluster> = new Map();
    
    for (const error of errors) {
      const signature = this.generateStackSignature(error.stackTrace);
      
      if (!clusters.has(signature)) {
        clusters.set(signature, {
          signature,
          count: 0,
          errors: [],
          firstSeen: error.timestamp,
          lastSeen: error.timestamp,
          affectedServices: new Set()
        });
      }
      
      const cluster = clusters.get(signature)!;
      cluster.count++;
      cluster.errors.push(error);
      cluster.lastSeen = error.timestamp;
      cluster.affectedServices.add(error.service);
    }
    
    // 중요도 계산
    return Array.from(clusters.values())
      .map(cluster => ({
        ...cluster,
        severity: this.calculateClusterSeverity(cluster),
        trend: this.calculateTrend(cluster.errors)
      }))
      .sort((a, b) => b.severity - a.severity);
  }
  
  // 에러 예측 모델
  async predictErrors(
    horizon: number
  ): Promise<ErrorPrediction[]> {
    const historicalData = await this.errorStore.getHistoricalData({
      days: 30
    });
    
    // 시계열 분석
    const timeSeries = this.createTimeSeries(historicalData);
    
    // ARIMA 모델 적용
    const model = new ARIMAModel(timeSeries);
    await model.fit();
    
    // 예측
    const predictions = model.predict(horizon);
    
    return predictions.map((value, index) => ({
      timestamp: new Date(Date.now() + index * 3600000),
      predictedCount: Math.round(value),
      confidence: model.getConfidenceInterval(index),
      factors: this.identifyRiskFactors(historicalData)
    }));
  }
  
  // 에러 영향도 분석
  async analyzeImpact(
    error: ErrorRecord
  ): Promise<ErrorImpact> {
    // 영향받는 사용자 수
    const affectedUsers = await this.countAffectedUsers(error);
    
    // 영향받는 서비스
    const affectedServices = await this.traceAffectedServices(error);
    
    // 비즈니스 영향도
    const businessImpact = await this.calculateBusinessImpact(error);
    
    // 복구 시간 예측
    const estimatedRecoveryTime = await this.estimateRecoveryTime(error);
    
    return {
      users: affectedUsers,
      services: affectedServices,
      businessImpact,
      estimatedRecoveryTime,
      severity: this.calculateSeverity(
        affectedUsers,
        affectedServices,
        businessImpact
      ),
      recommendations: this.generateRecommendations(error)
    };
  }
  
  // 실시간 이상 감지
  async detectAnomalies(
    metrics: ErrorMetrics
  ): Promise<Anomaly[]> {
    const anomalies: Anomaly[] = [];
    
    // 에러율 스파이크 감지
    if (metrics.errorRate > this.anomalyDetector.getThreshold('errorRate')) {
      anomalies.push({
        type: 'error_rate_spike',
        severity: 'high',
        value: metrics.errorRate,
        threshold: this.anomalyDetector.getThreshold('errorRate'),
        timestamp: new Date()
      });
    }
    
    // 새로운 에러 타입 감지
    const newErrorTypes = await this.detectNewErrorTypes(metrics);
    if (newErrorTypes.length > 0) {
      anomalies.push({
        type: 'new_error_types',
        severity: 'medium',
        value: newErrorTypes,
        timestamp: new Date()
      });
    }
    
    // 에러 패턴 변화 감지
    const patternChanges = await this.detectPatternChanges(metrics);
    if (patternChanges.significant) {
      anomalies.push({
        type: 'pattern_change',
        severity: 'medium',
        value: patternChanges,
        timestamp: new Date()
      });
    }
    
    return anomalies;
  }
}

// 에러 리포트 생성
export class ErrorReporter {
  async generateReport(
    timeRange: TimeRange,
    options: ReportOptions
  ): Promise<ErrorReport> {
    const analytics = new ErrorAnalytics();
    
    const [patterns, predictions, topErrors] = await Promise.all([
      analytics.analyzePatterns(timeRange),
      analytics.predictErrors(24), // 24시간 예측
      this.getTopErrors(timeRange)
    ]);
    
    return {
      summary: {
        totalErrors: topErrors.reduce((sum, e) => sum + e.count, 0),
        errorRate: this.calculateErrorRate(topErrors),
        mttr: await this.calculateMTTR(timeRange),
        trends: patterns.temporalPatterns
      },
      topErrors: topErrors.map(error => ({
        ...error,
        impact: await analytics.analyzeImpact(error),
        resolution: await this.getResolutionStatus(error)
      })),
      patterns: patterns.clusters,
      predictions,
      recommendations: this.generateRecommendations(patterns, predictions),
      generatedAt: new Date()
    };
  }
}
```

### SubTask 1.16.4: 에러 알림 시스템
**담당자**: DevOps 엔지니어  
**예상 소요시간**: 6시간

**목표**: 지능적인 에러 알림 및 에스컬레이션 시스템

**구현 내용**:
```typescript
// backend/src/errors/error-alerting.ts
export class ErrorAlertingSystem {
  private channels: Map<string, AlertChannel> = new Map();
  private rules: AlertRule[] = [];
  private suppressionRules: SuppressionRule[] = [];
  private escalationPolicy: EscalationPolicy;
  
  constructor() {
    this.initializeChannels();
    this.loadAlertRules();
    this.escalationPolicy = new EscalationPolicy();
  }
  
  private initializeChannels(): void {
    // Slack 채널
    this.channels.set('slack', new SlackAlertChannel({
      webhookUrl: process.env.SLACK_WEBHOOK_URL,
      defaultChannel: '#alerts'
    }));
    
    // Email 채널
    this.channels.set('email', new EmailAlertChannel({
      smtp: {
        host: process.env.SMTP_HOST,
        port: 587,
        secure: false
      }
    }));
    
    // PagerDuty 채널
    this.channels.set('pagerduty', new PagerDutyAlertChannel({
      apiKey: process.env.PAGERDUTY_API_KEY,
      serviceId: process.env.PAGERDUTY_SERVICE_ID
    }));
    
    // SMS 채널
    this.channels.set('sms', new SMSAlertChannel({
      twilioAccountSid: process.env.TWILIO_ACCOUNT_SID,
      twilioAuthToken: process.env.TWILIO_AUTH_TOKEN
    }));
  }
  
  // 에러 알림 처리
  async handleError(error: ErrorRecord): Promise<void> {
    // 억제 규칙 확인
    if (this.shouldSuppress(error)) {
      await this.logSuppression(error);
      return;
    }
    
    // 적용 가능한 규칙 찾기
    const matchingRules = this.findMatchingRules(error);
    
    // 알림 그룹화
    const groupKey = this.generateGroupKey(error);
    const shouldGroup = await this.shouldGroupAlert(groupKey, error);
    
    if (shouldGroup) {
      await this.updateAlertGroup(groupKey, error);
    } else {
      // 새 알림 생성
      const alert = await this.createAlert(error, matchingRules);
      
      // 채널별 전송
      await this.sendAlert(alert);
      
      // 에스컬레이션 스케줄링
      if (alert.severity >= 'high') {
        await this.scheduleEscalation(alert);
      }
    }
  }
  
  // 지능적인 알림 규칙
  private findMatchingRules(error: ErrorRecord): AlertRule[] {
    return this.rules.filter(rule => {
      // 에러 타입 매칭
      if (rule.errorTypes && !rule.errorTypes.includes(error.type)) {
        return false;
      }
      
      // 서비스 매칭
      if (rule.services && !rule.services.includes(error.service)) {
        return false;
      }
      
      // 심각도 매칭
      if (rule.minSeverity && error.severity < rule.minSeverity) {
        return false;
      }
      
      // 커스텀 조건
      if (rule.customCondition) {
        return rule.customCondition(error);
      }
      
      return true;
    });
  }
  
  // 알림 그룹화
  private async shouldGroupAlert(
    groupKey: string,
    error: ErrorRecord
  ): Promise<boolean> {
    const existingGroup = await this.getAlertGroup(groupKey);
    
    if (!existingGroup) return false;
    
    // 시간 윈도우 확인
    const timeSinceFirst = Date.now() - existingGroup.firstAlert.getTime();
    if (timeSinceFirst > 3600000) return false; // 1시간
    
    // 그룹 크기 제한
    if (existingGroup.count >= 100) return false;
    
    return true;
  }
  
  // 에스컬레이션 처리
  async scheduleEscalation(alert: Alert): Promise<void> {
    const escalationSteps = this.escalationPolicy.getSteps(alert.severity);
    
    for (const [index, step] of escalationSteps.entries()) {
      setTimeout(async () => {
        // 알림이 해결되었는지 확인
        if (await this.isResolved(alert.id)) {
          return;
        }
        
        // 에스컬레이션 실행
        await this.escalate(alert, step);
        
      }, step.delayMinutes * 60 * 1000);
    }
  }
  
  private async escalate(
    alert: Alert,
    step: EscalationStep
  ): Promise<void> {
    // 담당자 찾기
    const responders = await this.getResponders(step.level);
    
    // 에스컬레이션 알림 전송
    const escalationAlert = {
      ...alert,
      escalationLevel: step.level,
      responders,
      message: `[ESCALATED] ${alert.message}`
    };
    
    // 고급 채널로 전송
    for (const channel of step.channels) {
      await this.channels.get(channel)?.send(escalationAlert);
    }
    
    // 에스컬레이션 기록
    await this.logEscalation(alert, step);
  }
  
  // 알림 억제 규칙
  private shouldSuppress(error: ErrorRecord): boolean {
    for (const rule of this.suppressionRules) {
      // 시간 기반 억제
      if (rule.schedule && !this.isInSchedule(rule.schedule)) {
        continue;
      }
      
      // 조건 기반 억제
      if (rule.condition(error)) {
        return true;
      }
    }
    
    return false;
  }
  
  // 알림 템플릿
  private formatAlert(
    error: ErrorRecord,
    template: AlertTemplate
  ): FormattedAlert {
    const context = {
      error,
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV,
      service: error.service,
      dashboard: `${process.env.DASHBOARD_URL}/errors/${error.id}`
    };
    
    return {
      title: this.renderTemplate(template.title, context),
      message: this.renderTemplate(template.message, context),
      fields: template.fields?.map(field => ({
        name: field.name,
        value: this.renderTemplate(field.value, context),
        inline: field.inline
      })),
      actions: template.actions,
      priority: error.severity
    };
  }
}

// 알림 채널 구현
export abstract class AlertChannel {
  abstract send(alert: Alert): Promise<void>;
  abstract test(): Promise<boolean>;
}

export class SlackAlertChannel extends AlertChannel {
  constructor(private config: SlackConfig) {
    super();
  }
  
  async send(alert: Alert): Promise<void> {
    const message = {
      text: alert.title,
      attachments: [{
        color: this.getSeverityColor(alert.severity),
        fields: alert.fields,
        ts: Math.floor(Date.now() / 1000)
      }],
      blocks: this.createBlocks(alert)
    };
    
    await axios.post(this.config.webhookUrl, message);
  }
  
  private createBlocks(alert: Alert): any[] {
    return [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: alert.title
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: alert.message
        }
      },
      {
        type: 'actions',
        elements: alert.actions?.map(action => ({
          type: 'button',
          text: {
            type: 'plain_text',
            text: action.label
          },
          url: action.url,
          style: action.style
        }))
      }
    ];
  }
}
```
