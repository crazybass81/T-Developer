# T-Developer 완전 구현을 위한 3단계 세분화 작업 문서

## 📌 전체 구조 개요

```
총 10개 Phase
├── Phase 0: 사전 준비 및 환경 설정 (15 Tasks)
├── Phase 1: 코어 인프라 구축 (20 Tasks)
├── Phase 2: 데이터 레이어 구현 (15 Tasks)
├── Phase 3: 에이전트 프레임워크 구축 (20 Tasks)
├── Phase 4: 9개 핵심 에이전트 구현 (90 Tasks)
├── Phase 5: 오케스트레이션 시스템 (15 Tasks)
├── Phase 6: API 레이어 구현 (25 Tasks)
├── Phase 7: 프론트엔드 구현 (30 Tasks)
├── Phase 8: 통합 및 테스트 (20 Tasks)
└── Phase 9: 배포 및 운영 (15 Tasks)

총 예상 작업: 265 Tasks × 평균 4 SubTasks = 약 1,060개 작업 단위
```

---

# 📋 Phase 0: 사전 준비 및 환경 설정

## Task 0.1: 개발 환경 초기 설정

### SubTask 0.1.1: 필수 도구 설치 확인
**목표**: 개발에 필요한 모든 도구가 설치되어 있는지 확인

**구현 내용**:
```bash
#!/bin/bash
# check-requirements.sh

echo "🔍 개발 환경 체크 시작..."

# Node.js 버전 확인
NODE_VERSION=$(node -v)
if [[ ! "$NODE_VERSION" =~ ^v18\.|^v20\. ]]; then
    echo "❌ Node.js 18+ 필요 (현재: $NODE_VERSION)"
    exit 1
fi

# Python 버전 확인
PYTHON_VERSION=$(python3 --version)
if [[ ! "$PYTHON_VERSION" =~ 3\.(9|10|11) ]]; then
    echo "❌ Python 3.9+ 필요 (현재: $PYTHON_VERSION)"
    exit 1
fi

# AWS CLI 확인
if ! command -v aws &> /dev/null; then
    echo "❌ AWS CLI가 설치되지 않음"
    exit 1
fi

# Docker 확인
if ! command -v docker &> /dev/null; then
    echo "❌ Docker가 설치되지 않음"
    exit 1
fi

echo "✅ 모든 필수 도구가 설치되어 있습니다!"
```

**🔧 사용자 작업**:
- Node.js 18+ 설치
- Python 3.9+ 설치
- AWS CLI v2 설치
- Docker Desktop 설치
- Git 설치

### SubTask 0.1.2: AWS 계정 및 권한 설정
**목표**: AWS 서비스 사용을 위한 계정 설정

**구현 내용**:
```python
# scripts/setup-aws-profile.py
import boto3
import json
import os

def create_iam_policy():
    """T-Developer에 필요한 IAM 정책 생성"""
    policy_document = {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Action": [
                    "bedrock:*",
                    "lambda:*",
                    "dynamodb:*",
                    "s3:*",
                    "cloudwatch:*",
                    "logs:*",
                    "iam:PassRole"
                ],
                "Resource": "*"
            }
        ]
    }
    
    return json.dumps(policy_document)

def setup_aws_profile():
    """AWS 프로필 설정 확인"""
    try:
        sts = boto3.client('sts')
        identity = sts.get_caller_identity()
        print(f"✅ AWS 계정 확인: {identity['Account']}")
        print(f"✅ 사용자 ARN: {identity['Arn']}")
    except Exception as e:
        print(f"❌ AWS 자격 증명 오류: {e}")
        return False
    
    return True

if __name__ == "__main__":
    if setup_aws_profile():
        print("\n📋 필요한 IAM 정책:")
        print(create_iam_policy())
```

**🔧 사용자 작업**:


### SubTask 0.1.3: 프로젝트 저장소 초기화
**목표**: Git 저장소 및 기본 구조 생성

**구현 내용**:
```bash
#!/bin/bash
# init-repository.sh

# 프로젝트 루트 생성
mkdir -p T-DeveloperMVP
cd T-DeveloperMVP

# Git 초기화
git init

# 기본 .gitignore 생성
cat > .gitignore << EOF
# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/
*.lcov
.nyc_output

# Production
build/
dist/
*.log

# Environment
.env
.env.local
.env.*.local

# AWS
.aws/
*.pem

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Python
__pycache__/
*.py[cod]
*$py.class
.Python
venv/
ENV/

# Terraform
*.tfstate
*.tfstate.*
.terraform/
EOF

# 기본 README 생성
cat > README.md << EOF
# T-Developer

AI-powered multi-agent development platform.

## 🚀 Getting Started

### Prerequisites
- Node.js 18+
- Python 3.9+
- AWS Account
- Docker

### Installation
\`\`\`bash
# Clone repository
git clone https://github.com/your-org/t-developer.git

# Install dependencies
npm install
\`\`\`

## 📚 Documentation
- [Architecture](./docs/architecture.md)
- [API Reference](./docs/api.md)
- [Agent Guide](./docs/agents.md)
EOF

git add .
git commit -m "Initial commit: Project setup"

echo "✅ 저장소 초기화 완료!"
```

**🔧 사용자 작업**:
- GitHub/GitLab 저장소 생성
- 원격 저장소 연결
- 초기 커밋 푸시

### SubTask 0.1.4: 환경 변수 템플릿 생성
**목표**: 필요한 모든 환경 변수 템플릿 파일 생성

**구현 내용**:
```typescript
// scripts/create-env-template.ts
import fs from 'fs';
import path from 'path';

const envTemplate = `# T-Developer Environment Configuration

# Node Environment
NODE_ENV=development
PORT=3000
LOG_LEVEL=debug

# AWS Configuration
AWS_ACCESS_KEY_ID=your-access-key-here
AWS_SECRET_ACCESS_KEY=your-secret-key-here
AWS_REGION=us-east-1
AWS_BEDROCK_REGION=us-east-1

# AI Model API Keys
OPENAI_API_KEY=sk-proj-xxxxxxxxxxxxx
ANTHROPIC_API_KEY=sk-ant-xxxxxxxxxxxxx

# Bedrock AgentCore Configuration
BEDROCK_AGENTCORE_RUNTIME_ID=runtime-xxx
BEDROCK_AGENTCORE_GATEWAY_URL=https://xxx.agentcore.amazonaws.com

# Agent Squad Configuration
AGENT_SQUAD_STORAGE=dynamodb
AGENT_SQUAD_TIMEOUT=300

# Database Configuration
DYNAMODB_ENDPOINT=http://localhost:8000
DYNAMODB_REGION=us-east-1

# S3 Configuration
S3_ARTIFACTS_BUCKET=t-developer-artifacts
S3_REGION=us-east-1

# Redis Configuration (for caching)
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# GitHub Integration
GITHUB_TOKEN=ghp_xxxxxxxxxxxxx
GITHUB_OWNER=your-org
GITHUB_REPO=t-developer

# Monitoring
AGNO_MONITORING_URL=https://agno.com
ENABLE_MONITORING=true

# Security
JWT_SECRET=your-super-secret-jwt-key
ENCRYPTION_KEY=your-32-character-encryption-key

# External Services
NPM_REGISTRY_URL=https://registry.npmjs.org
PYPI_INDEX_URL=https://pypi.org/simple
MAVEN_CENTRAL_URL=https://repo.maven.apache.org/maven2

# Feature Flags
ENABLE_CACHE=true
ENABLE_TELEMETRY=true
MAX_CONCURRENT_AGENTS=50
`;

const envExamplePath = path.join(process.cwd(), '.env.example');
fs.writeFileSync(envExamplePath, envTemplate);

console.log('✅ .env.example 파일 생성 완료!');
console.log('📋 다음 단계:');
console.log('1. .env.example을 .env로 복사');
console.log('2. 실제 값으로 환경 변수 업데이트');
```

**🔧 사용자 작업**:
- `.env.example`을 `.env`로 복사
- 모든 환경 변수 값 입력
- AWS 자격 증명 설정
- API 키 획득 및 설정

### SubTask 0.1.5: 개발 도구 설정 파일 생성
**목표**: VS Code, ESLint, Prettier 등 개발 도구 설정

**구현 내용**:
```json
// .vscode/settings.json
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "typescript.tsdk": "node_modules/typescript/lib",
  "files.exclude": {
    "**/.git": true,
    "**/.DS_Store": true,
    "**/node_modules": true,
    "**/dist": true,
    "**/build": true
  },
  "search.exclude": {
    "**/node_modules": true,
    "**/dist": true,
    "**/coverage": true
  }
}
```

```javascript
// .eslintrc.js
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint', 'import'],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    'import/order': ['error', {
      'groups': ['builtin', 'external', 'internal', 'parent', 'sibling', 'index'],
      'newlines-between': 'always'
    }]
  },
};
```

```json
// .prettierrc
{
  "singleQuote": true,
  "trailingComma": "all",
  "printWidth": 100,
  "tabWidth": 2,
  "semi": true,
  "bracketSpacing": true,
  "arrowParens": "always",
  "endOfLine": "lf"
}
```

---

## Task 0.2: AWS 리소스 초기 설정

### SubTask 0.2.1: DynamoDB 로컬 설정
**목표**: 개발용 DynamoDB Local 설정

**구현 내용**:
```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  dynamodb-local:
    image: amazon/dynamodb-local:latest
    container_name: t-developer-dynamodb
    ports:
      - "8000:8000"
    command: "-jar DynamoDBLocal.jar -sharedDb -inMemory"
    volumes:
      - "./docker/dynamodb:/home/dynamodblocal/data"
    working_dir: /home/dynamodblocal

  dynamodb-admin:
    image: aaronshaf/dynamodb-admin
    container_name: t-developer-dynamodb-admin
    ports:
      - "8001:8001"
    environment:
      DYNAMO_ENDPOINT: "http://dynamodb-local:8000"
      AWS_REGION: "us-east-1"
      AWS_ACCESS_KEY_ID: "local"
      AWS_SECRET_ACCESS_KEY: "local"
    depends_on:
      - dynamodb-local

  redis:
    image: redis:7-alpine
    container_name: t-developer-redis
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - "./docker/redis:/data"
```

```typescript
// scripts/setup-local-db.ts
import { DynamoDBClient, CreateTableCommand } from '@aws-sdk/client-dynamodb';

const client = new DynamoDBClient({
  endpoint: 'http://localhost:8000',
  region: 'us-east-1',
  credentials: {
    accessKeyId: 'local',
    secretAccessKey: 'local'
  }
});

async function createTables() {
  // Projects 테이블
  const projectsTable = new CreateTableCommand({
    TableName: 'T-Developer-Projects',
    KeySchema: [
      { AttributeName: 'id', KeyType: 'HASH' },
    ],
    AttributeDefinitions: [
      { AttributeName: 'id', AttributeType: 'S' },
      { AttributeName: 'userId', AttributeType: 'S' },
      { AttributeName: 'createdAt', AttributeType: 'S' },
    ],
    GlobalSecondaryIndexes: [
      {
        IndexName: 'UserIdIndex',
        KeySchema: [
          { AttributeName: 'userId', KeyType: 'HASH' },
          { AttributeName: 'createdAt', KeyType: 'RANGE' },
        ],
        Projection: { ProjectionType: 'ALL' },
        ProvisionedThroughput: {
          ReadCapacityUnits: 5,
          WriteCapacityUnits: 5,
        },
      },
    ],
    BillingMode: 'PAY_PER_REQUEST',
  });

  try {
    await client.send(projectsTable);
    console.log('✅ Projects 테이블 생성 완료');
  } catch (error) {
    console.error('❌ Projects 테이블 생성 실패:', error);
  }
}

createTables();
```

**🔧 사용자 작업**:
- Docker Desktop 실행
- `docker-compose -f docker-compose.dev.yml up -d` 실행
- DynamoDB Admin UI 접속 확인 (http://localhost:8001)

### SubTask 0.2.2: S3 버킷 생성 스크립트
**목표**: 필요한 S3 버킷 생성 자동화

**구현 내용**:
```python
# scripts/create-s3-buckets.py
import boto3
import json
from botocore.exceptions import ClientError

def create_bucket_if_not_exists(s3_client, bucket_name, region):
    """S3 버킷이 없으면 생성"""
    try:
        s3_client.head_bucket(Bucket=bucket_name)
        print(f"✅ 버킷이 이미 존재함: {bucket_name}")
    except ClientError as e:
        error_code = e.response['Error']['Code']
        if error_code == '404':
            try:
                if region == 'us-east-1':
                    s3_client.create_bucket(Bucket=bucket_name)
                else:
                    s3_client.create_bucket(
                        Bucket=bucket_name,
                        CreateBucketConfiguration={'LocationConstraint': region}
                    )
                print(f"✅ 버킷 생성 완료: {bucket_name}")
                
                # 버킷 정책 설정
                set_bucket_policy(s3_client, bucket_name)
                
            except ClientError as e:
                print(f"❌ 버킷 생성 실패: {e}")
        else:
            print(f"❌ 버킷 확인 실패: {e}")

def set_bucket_policy(s3_client, bucket_name):
    """버킷 정책 설정"""
    bucket_policy = {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Sid": "AllowCloudFrontAccess",
                "Effect": "Allow",
                "Principal": {
                    "Service": "cloudfront.amazonaws.com"
                },
                "Action": "s3:GetObject",
                "Resource": f"arn:aws:s3:::{bucket_name}/*"
            }
        ]
    }
    
    s3_client.put_bucket_policy(
        Bucket=bucket_name,
        Policy=json.dumps(bucket_policy)
    )

def main():
    region = 'us-east-1'
    s3_client = boto3.client('s3', region_name=region)
    
    buckets = [
        't-developer-artifacts',
        't-developer-components',
        't-developer-templates',
        't-developer-backups'
    ]
    
    for bucket in buckets:
        create_bucket_if_not_exists(s3_client, bucket, region)

if __name__ == "__main__":
    main()
```

**🔧 사용자 작업**:
- AWS 콘솔에서 S3 서비스 접근 확인
- 스크립트 실행: `python scripts/create-s3-buckets.py`
- 버킷 생성 확인

### SubTask 0.2.3: Bedrock 모델 액세스 요청
**목표**: AWS Bedrock 모델 사용 권한 획득

**구현 내용**:
```typescript
// scripts/request-bedrock-access.ts
import { BedrockClient, ListFoundationModelsCommand } from '@aws-sdk/client-bedrock';

async function checkBedrockAccess() {
  const client = new BedrockClient({ region: 'us-east-1' });
  
  try {
    const command = new ListFoundationModelsCommand({});
    const response = await client.send(command);
    
    console.log('✅ Bedrock 액세스 확인됨');
    console.log('사용 가능한 모델:');
    
    response.modelSummaries?.forEach(model => {
      console.log(`- ${model.modelId}: ${model.modelName}`);
    });
    
  } catch (error) {
    console.error('❌ Bedrock 액세스 오류:', error);
    console.log('\n📋 Bedrock 모델 액세스 요청 방법:');
    console.log('1. AWS Console > Bedrock 서비스로 이동');
    console.log('2. Model access 메뉴 클릭');
    console.log('3. 다음 모델들에 대해 액세스 요청:');
    console.log('   - Anthropic Claude 3 Sonnet');
    console.log('   - Anthropic Claude 3 Opus');
    console.log('   - Amazon Nova Pro');
    console.log('   - Amazon Nova Lite');
  }
}

checkBedrockAccess();
```

**🔧 사용자 작업**:
- AWS Console에서 Bedrock 서비스 접속
- Model access 메뉴에서 필요한 모델 액세스 요청
- 승인 대기 (보통 즉시 승인)
- 스크립트로 액세스 확인

### SubTask 0.2.4: Lambda 레이어 준비
**목표**: 공통 의존성을 위한 Lambda 레이어 생성

**구현 내용**:
```bash
#!/bin/bash
# scripts/create-lambda-layers.sh

# Node.js 레이어 생성
mkdir -p layers/nodejs-common/nodejs
cd layers/nodejs-common/nodejs

# package.json 생성
cat > package.json << EOF
{
  "name": "t-developer-common-layer",
  "version": "1.0.0",
  "dependencies": {
    "aws-sdk": "^3.0.0",
    "axios": "^1.6.0",
    "lodash": "^4.17.21",
    "uuid": "^9.0.0",
    "joi": "^17.11.0"
  }
}
EOF

npm install --production

cd ..
zip -r nodejs-common-layer.zip nodejs/

# Python 레이어 생성
mkdir -p ../python-common/python
cd ../python-common

cat > requirements.txt << EOF
boto3>=1.26.0
requests>=2.31.0
pandas>=2.0.0
numpy>=1.24.0
EOF

pip install -r requirements.txt -t python/
zip -r python-common-layer.zip python/

echo "✅ Lambda 레이어 생성 완료!"
```

**🔧 사용자 작업**:
- 생성된 ZIP 파일을 AWS Lambda 콘솔에서 레이어로 업로드
- 레이어 ARN 기록

### SubTask 0.2.5: CloudWatch 대시보드 템플릿
**목표**: 모니터링을 위한 CloudWatch 대시보드 설정

**구현 내용**:
```json
// cloudwatch/dashboard-template.json
{
  "widgets": [
    {
      "type": "metric",
      "properties": {
        "metrics": [
          ["T-Developer", "AgentExecutionTime", {"stat": "Average"}],
          [".", ".", {"stat": "Maximum"}],
          [".", "AgentSuccessRate", {"stat": "Average"}]
        ],
        "period": 300,
        "stat": "Average",
        "region": "us-east-1",
        "title": "Agent Performance"
      }
    },
    {
      "type": "metric",
      "properties": {
        "metrics": [
          ["AWS/Lambda", "Invocations", {"stat": "Sum"}],
          [".", "Errors", {"stat": "Sum"}],
          [".", "Duration", {"stat": "Average"}]
        ],
        "period": 300,
        "stat": "Average",
        "region": "us-east-1",
        "title": "Lambda Functions"
      }
    },
    {
      "type": "log",
      "properties": {
        "query": "SOURCE '/aws/lambda/t-developer'\n| fields @timestamp, @message\n| filter @message like /ERROR/\n| sort @timestamp desc\n| limit 20",
        "region": "us-east-1",
        "title": "Recent Errors"
      }
    }
  ]
}
```

**🔧 사용자 작업**:
- CloudWatch 콘솔에서 대시보드 생성
- 템플릿 JSON 임포트
- 알람 설정

---

## Task 0.3: 프로젝트 의존성 설치

### SubTask 0.3.1: 백엔드 의존성 설치
**목표**: Node.js 백엔드 의존성 설치 및 설정

**구현 내용**:
```json
// backend/package.json
{
  "name": "t-developer-backend",
  "version": "1.0.0",
  "description": "T-Developer Backend Services",
  "scripts": {
    "dev": "nodemon",
    "build": "tsc",
    "start": "node dist/main.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/**/*.ts",
    "format": "prettier --write src/**/*.ts"
  },
  "dependencies": {
    "@aws-sdk/client-bedrock": "^3.0.0",
    "@aws-sdk/client-bedrock-runtime": "^3.0.0",
    "@aws-sdk/client-dynamodb": "^3.0.0",
    "@aws-sdk/client-lambda": "^3.0.0",
    "@aws-sdk/client-s3": "^3.0.0",
    "@aws-sdk/lib-dynamodb": "^3.0.0",
    "agno": "latest",
    "agent-squad": "latest",
    "express": "^4.18.0",
    "fastapi": "^0.1.0",
    "joi": "^17.11.0",
    "winston": "^3.11.0",
    "bull": "^4.11.0",
    "ioredis": "^5.3.0",
    "jsonwebtoken": "^9.0.0",
    "bcrypt": "^5.1.0",
    "axios": "^1.6.0",
    "lodash": "^4.17.21",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.0",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.0",
    "prettier": "^3.0.0",
    "ts-jest": "^29.1.0",
    "ts-node": "^10.9.0",
    "typescript": "^5.0.0"
  }
}
```

```bash
#!/bin/bash
# scripts/install-backend-deps.sh

cd backend
npm install

# Agno 프레임워크 설치 확인
if ! npm list agno > /dev/null 2>&1; then
    echo "⚠️  Agno 설치 확인 필요"
    npm install agno@latest
fi

# Agent Squad 설치 확인
if ! npm list agent-squad > /dev/null 2>&1; then
    echo "⚠️  Agent Squad 설치 확인 필요"
    npm install agent-squad@latest
fi

echo "✅ 백엔드 의존성 설치 완료!"
```

**🔧 사용자 작업**:
- `cd backend && npm install` 실행
- 설치 오류 발생 시 해결

### SubTask 0.3.2: Python 의존성 설치
**목표**: Python 스크립트 및 도구를 위한 의존성 설치

**구현 내용**:
```txt
# requirements.txt
boto3>=1.26.0
botocore>=1.29.0
python-dotenv>=1.0.0
requests>=2.31.0
pydantic>=2.0.0
fastapi>=0.100.0
uvicorn>=0.23.0
pytest>=7.4.0
black>=23.0.0
flake8>=6.0.0
mypy>=1.5.0
```

```python
# scripts/setup-python-env.py
import subprocess
import sys
import venv
import os

def create_virtual_env():
    """Python 가상 환경 생성"""
    venv_path = os.path.join(os.getcwd(), 'venv')
    
    if not os.path.exists(venv_path):
        print("🔧 Python 가상 환경 생성 중...")
        venv.create(venv_path, with_pip=True)
        print("✅ 가상 환경 생성 완료")
    else:
        print("✅ 가상 환경이 이미 존재합니다")
    
    # 활성화 명령 출력
    if sys.platform == "win32":
        activate_cmd = f"{venv_path}\\Scripts\\activate"
    else:
        activate_cmd = f"source {venv_path}/bin/activate"
    
    print(f"\n📋 가상 환경 활성화 명령:")
    print(f"   {activate_cmd}")
    
    return venv_path

def install_dependencies():
    """의존성 설치"""
    subprocess.run([sys.executable, "-m", "pip", "install", "--upgrade", "pip"])
    subprocess.run([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"])

if __name__ == "__main__":
    create_virtual_env()
    # 주의: 가상 환경 활성화 후 수동으로 설치 필요
```

**🔧 사용자 작업**:
- Python 가상 환경 생성: `python -m venv venv`
- 가상 환경 활성화
- `pip install -r requirements.txt` 실행

### SubTask 0.3.3: 프론트엔드 의존성 준비
**목표**: React 기반 프론트엔드 초기 설정

**구현 내용**:
```json
// frontend/package.json
{
  "name": "t-developer-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "@mui/material": "^5.14.0",
    "@emotion/react": "^11.11.0",
    "@emotion/styled": "^11.11.0",
    "axios": "^1.6.0",
    "socket.io-client": "^4.7.0",
    "@tanstack/react-query": "^5.0.0",
    "zustand": "^4.4.0",
    "react-hook-form": "^7.48.0",
    "recharts": "^2.10.0",
    "monaco-editor": "^0.44.0",
    "@monaco-editor/react": "^4.6.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.2.0",
    "vite": "^5.0.0",
    "typescript": "^5.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.0.0",
    "eslint-plugin-react": "^7.33.0",
    "eslint-plugin-react-hooks": "^4.6.0"
  },
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext ts,tsx",
    "type-check": "tsc --noEmit"
  }
}
```

```typescript
// frontend/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
      '/ws': {
        target: 'ws://localhost:8000',
        ws: true,
      },
    },
  },
});
```

**🔧 사용자 작업**:
- 프론트엔드 디렉토리 생성 (아직 구현하지 않음)
- 나중에 Phase 7에서 실제 설치 진행

### SubTask 0.3.4: 개발 도구 전역 설치
**목표**: 필요한 전역 개발 도구 설치

**구현 내용**:
```bash
#!/bin/bash
# scripts/install-global-tools.sh

echo "🔧 전역 개발 도구 설치 중..."

# TypeScript
npm install -g typescript

# AWS CDK
npm install -g aws-cdk

# Serverless Framework
npm install -g serverless

# PM2 (프로세스 관리)
npm install -g pm2

# Lerna (모노레포 관리)
npm install -g lerna

echo "✅ 전역 도구 설치 완료!"

# 설치 확인
echo "\n📋 설치된 도구 버전:"
echo "TypeScript: $(tsc --version)"
echo "AWS CDK: $(cdk --version)"
echo "Serverless: $(serverless --version)"
echo "PM2: $(pm2 --version)"
echo "Lerna: $(lerna --version)"
```

**🔧 사용자 작업**:
- 스크립트 실행 권한 부여: `chmod +x scripts/install-global-tools.sh`
- 스크립트 실행: `./scripts/install-global-tools.sh`

### SubTask 0.3.5: 로컬 개발 서버 설정
**목표**: 개발용 로컬 서버 환경 구성

**구현 내용**:
```typescript
// scripts/dev-server.ts
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';

const app = express();
const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: {
    origin: "http://localhost:3000",
    methods: ["GET", "POST"]
  }
});

// 미들웨어
app.use(cors());
app.use(express.json());

// 헬스 체크
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    services: {
      api: 'running',
      websocket: 'running',
      database: 'pending'
    }
  });
});

// WebSocket 연결
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
  
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});

const PORT = process.env.PORT || 8000;
httpServer.listen(PORT, () => {
  console.log(`✅ 개발 서버 실행 중: http://localhost:${PORT}`);
  console.log(`📡 WebSocket 서버 실행 중: ws://localhost:${PORT}`);
});
```

```json
// nodemon.json
{
  "watch": ["src", "scripts"],
  "ext": "ts,js,json",
  "ignore": ["src/**/*.spec.ts", "node_modules"],
  "exec": "ts-node",
  "env": {
    "NODE_ENV": "development"
  }
}
```

**🔧 사용자 작업**:
- 개발 서버 실행: `npm run dev`
- 헬스 체크 확인: http://localhost:8000/health

---

### SubTask 0.3.6: 모니터링 도구 설정
**목표**: 개발 환경 모니터링 도구 설정

**구현 내용**:
```typescript
// backend/src/utils/monitoring.ts
import { StatsD } from 'node-statsd';
import winston from 'winston';
import { CloudWatchTransport } from 'winston-cloudwatch';

// StatsD 클라이언트 (로컬 개발용)
export const metrics = new StatsD({
  host: process.env.STATSD_HOST || 'localhost',
  port: parseInt(process.env.STATSD_PORT || '8125'),
  prefix: 't-developer.',
  mock: process.env.NODE_ENV === 'test'
});

// Winston 로거 설정
export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    winston.format.json()
  ),
  defaultMeta: { service: 't-developer' },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log' 
    })
  ]
});

// CloudWatch 전송 (프로덕션)
if (process.env.NODE_ENV === 'production') {
  logger.add(new CloudWatchTransport({
    logGroupName: '/aws/t-developer',
    logStreamName: `${process.env.NODE_ENV}-${new Date().toISOString().split('T')[0]}`,
    awsRegion: process.env.AWS_REGION
  }));
}
```

```yaml
# docker-compose.monitoring.yml
version: '3.8'

services:
  grafana:
    image: grafana/grafana:latest
    container_name: t-developer-grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - ./docker/grafana:/var/lib/grafana

  prometheus:
    image: prom/prometheus:latest
    container_name: t-developer-prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./docker/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - ./docker/prometheus/data:/prometheus

  statsd:
    image: graphiteapp/graphite-statsd
    container_name: t-developer-statsd
    ports:
      - "8125:8125/udp"
      - "8126:8126"
      - "2003:2003"
```

**🔧 사용자 작업**:
- `docker-compose -f docker-compose.monitoring.yml up -d` 실행
- Grafana 접속: http://localhost:3001 (admin/admin)
- Prometheus 접속: http://localhost:9090

---

## Task 0.4: 보안 및 인증 기초 설정

### SubTask 0.4.1: 환경 변수 암호화 설정
**목표**: 민감한 정보 보호를 위한 암호화 설정

**구현 내용**:
```typescript
// backend/src/utils/crypto.ts
import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';

export class EnvCrypto {
  private algorithm = 'aes-256-gcm';
  private keyPath = path.join(process.cwd(), '.env.key');
  
  async generateKey(): Promise<string> {
    const key = crypto.randomBytes(32).toString('hex');
    await fs.writeFile(this.keyPath, key, { mode: 0o600 });
    console.log('✅ 암호화 키가 생성되었습니다: .env.key');
    console.log('⚠️  이 파일을 안전하게 보관하고 절대 커밋하지 마세요!');
    return key;
  }
  
  async encrypt(text: string): Promise<string> {
    const key = await this.getKey();
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, Buffer.from(key, 'hex'), iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
  }
  
  async decrypt(encryptedText: string): Promise<string> {
    const key = await this.getKey();
    const parts = encryptedText.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const authTag = Buffer.from(parts[1], 'hex');
    const encrypted = parts[2];
    
    const decipher = crypto.createDecipheriv(this.algorithm, Buffer.from(key, 'hex'), iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
  
  private async getKey(): Promise<string> {
    try {
      return await fs.readFile(this.keyPath, 'utf8');
    } catch (error) {
      throw new Error('암호화 키를 찾을 수 없습니다. generateKey()를 먼저 실행하세요.');
    }
  }
}

// 환경 변수 암호화 스크립트
export async function encryptEnvFile(): Promise<void> {
  const crypto = new EnvCrypto();
  const envPath = path.join(process.cwd(), '.env');
  const encryptedPath = path.join(process.cwd(), '.env.encrypted');
  
  const envContent = await fs.readFile(envPath, 'utf8');
  const lines = envContent.split('\n');
  
  const encryptedLines = await Promise.all(lines.map(async (line) => {
    if (line.includes('=') && !line.startsWith('#')) {
      const [key, value] = line.split('=', 2);
      if (key.includes('SECRET') || key.includes('KEY') || key.includes('PASSWORD')) {
        const encrypted = await crypto.encrypt(value);
        return `${key}=ENC:${encrypted}`;
      }
    }
    return line;
  }));
  
  await fs.writeFile(encryptedPath, encryptedLines.join('\n'));
  console.log('✅ 환경 변수가 암호화되었습니다: .env.encrypted');
}
```

**🔧 사용자 작업**:
- 암호화 키 생성: `ts-node scripts/generate-crypto-key.ts`
- `.env.key`를 안전한 곳에 보관
- `.gitignore`에 `.env.key` 추가 확인

### SubTask 0.4.2: JWT 토큰 관리 설정
**목표**: API 인증을 위한 JWT 설정

**구현 내용**:
```typescript
// backend/src/utils/auth.ts
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import { promisify } from 'util';

export interface TokenPayload {
  userId: string;
  email: string;
  role: 'user' | 'admin';
}

export class AuthManager {
  private readonly accessTokenSecret: string;
  private readonly refreshTokenSecret: string;
  private readonly accessTokenExpiry = '15m';
  private readonly refreshTokenExpiry = '7d';
  
  constructor() {
    this.accessTokenSecret = process.env.JWT_ACCESS_SECRET || 'dev-access-secret';
    this.refreshTokenSecret = process.env.JWT_REFRESH_SECRET || 'dev-refresh-secret';
    
    if (process.env.NODE_ENV === 'production' && this.accessTokenSecret === 'dev-access-secret') {
      throw new Error('JWT secrets must be set in production');
    }
  }
  
  async generateTokens(payload: TokenPayload): Promise<{
    accessToken: string;
    refreshToken: string;
  }> {
    const accessToken = jwt.sign(payload, this.accessTokenSecret, {
      expiresIn: this.accessTokenExpiry,
      issuer: 't-developer',
      audience: 'api'
    });
    
    const refreshToken = jwt.sign(
      { userId: payload.userId }, 
      this.refreshTokenSecret, 
      {
        expiresIn: this.refreshTokenExpiry,
        issuer: 't-developer',
        audience: 'refresh'
      }
    );
    
    return { accessToken, refreshToken };
  }
  
  async verifyAccessToken(token: string): Promise<TokenPayload> {
    try {
      return jwt.verify(token, this.accessTokenSecret, {
        issuer: 't-developer',
        audience: 'api'
      }) as TokenPayload;
    } catch (error) {
      throw new Error('Invalid access token');
    }
  }
  
  async verifyRefreshToken(token: string): Promise<{ userId: string }> {
    try {
      return jwt.verify(token, this.refreshTokenSecret, {
        issuer: 't-developer',
        audience: 'refresh'
      }) as { userId: string };
    } catch (error) {
      throw new Error('Invalid refresh token');
    }
  }
  
  async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, 12);
  }
  
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }
}
```

### SubTask 0.4.3: API Rate Limiting 설정
**목표**: API 남용 방지를 위한 Rate Limiting

**구현 내용**:
```typescript
// backend/src/middleware/rate-limiter.ts
import { Request, Response, NextFunction } from 'express';
import Redis from 'ioredis';

export interface RateLimitOptions {
  windowMs: number;
  max: number;
  message?: string;
  keyGenerator?: (req: Request) => string;
}

export class RateLimiter {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD
    });
  }
  
  middleware(options: RateLimitOptions) {
    const {
      windowMs = 60 * 1000, // 1분
      max = 100,
      message = 'Too many requests',
      keyGenerator = (req) => req.ip
    } = options;
    
    return async (req: Request, res: Response, next: NextFunction) => {
      const key = `rate-limit:${keyGenerator(req)}`;
      const now = Date.now();
      const window = now - windowMs;
      
      try {
        // 시간 window 기반 카운팅
        await this.redis.zremrangebyscore(key, '-inf', window);
        const count = await this.redis.zcard(key);
        
        if (count >= max) {
          return res.status(429).json({
            error: message,
            retryAfter: Math.ceil(windowMs / 1000)
          });
        }
        
        // 요청 기록
        await this.redis.zadd(key, now, `${now}-${Math.random()}`);
        await this.redis.expire(key, Math.ceil(windowMs / 1000));
        
        // 헤더 설정
        res.setHeader('X-RateLimit-Limit', max);
        res.setHeader('X-RateLimit-Remaining', Math.max(0, max - count - 1));
        res.setHeader('X-RateLimit-Reset', new Date(now + windowMs).toISOString());
        
        next();
      } catch (error) {
        console.error('Rate limiter error:', error);
        // Rate limiter 오류 시 요청 통과
        next();
      }
    };
  }
  
  // API별 다른 제한 설정
  apiLimits() {
    return {
      general: this.middleware({ windowMs: 60000, max: 100 }),
      auth: this.middleware({ windowMs: 300000, max: 5 }), // 5분에 5회
      create: this.middleware({ windowMs: 3600000, max: 10 }), // 1시간에 10회
      ai: this.middleware({ windowMs: 60000, max: 20 }) // 1분에 20회
    };
  }
}
```

### SubTask 0.4.4: CORS 및 보안 헤더 설정
**목표**: 웹 보안을 위한 헤더 설정

**구현 내용**:
```typescript
// backend/src/middleware/security.ts
import helmet from 'helmet';
import cors from 'cors';
import { Request, Response, NextFunction } from 'express';

export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "wss:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
});

export const corsOptions = cors({
  origin: (origin, callback) => {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [
      'http://localhost:3000',
      'http://localhost:8000'
    ];
    
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID'],
  exposedHeaders: ['X-Request-ID', 'X-RateLimit-Limit', 'X-RateLimit-Remaining']
});

// Request ID 미들웨어
export const requestId = (req: Request, res: Response, next: NextFunction) => {
  const id = req.headers['x-request-id'] || `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  req.id = id as string;
  res.setHeader('X-Request-ID', id);
  next();
};

// Security 감사 로깅
export const securityAudit = (req: Request, res: Response, next: NextFunction) => {
  const startTime = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    const audit = {
      timestamp: new Date().toISOString(),
      requestId: req.id,
      method: req.method,
      path: req.path,
      ip: req.ip,
      userAgent: req.headers['user-agent'],
      statusCode: res.statusCode,
      duration
    };
    
    if (res.statusCode >= 400) {
      console.warn('Security audit:', audit);
    }
  });
  
  next();
};
```

### SubTask 0.4.5: Secrets Manager 통합
**목표**: AWS Secrets Manager를 통한 시크릿 관리

**구현 내용**:
```typescript
// backend/src/config/secrets-manager.ts
import { 
  SecretsManagerClient, 
  GetSecretValueCommand,
  CreateSecretCommand,
  UpdateSecretCommand 
} from '@aws-sdk/client-secrets-manager';

export class SecretsManager {
  private client: SecretsManagerClient;
  private cache: Map<string, { value: any; expiry: number }> = new Map();
  private cacheTTL = 300000; // 5분
  
  constructor() {
    this.client = new SecretsManagerClient({
      region: process.env.AWS_REGION || 'us-east-1'
    });
  }
  
  async getSecret(secretName: string): Promise<any> {
    // 캐시 확인
    const cached = this.cache.get(secretName);
    if (cached && cached.expiry > Date.now()) {
      return cached.value;
    }
    
    try {
      const command = new GetSecretValueCommand({ SecretId: secretName });
      const response = await this.client.send(command);
      
      let secretValue: any;
      if (response.SecretString) {
        secretValue = JSON.parse(response.SecretString);
      } else if (response.SecretBinary) {
        const buff = Buffer.from(response.SecretBinary);
        secretValue = buff.toString('utf-8');
      }
      
      // 캐시에 저장
      this.cache.set(secretName, {
        value: secretValue,
        expiry: Date.now() + this.cacheTTL
      });
      
      return secretValue;
    } catch (error) {
      console.error(`Failed to retrieve secret ${secretName}:`, error);
      throw error;
    }
  }
  
  async createOrUpdateSecret(secretName: string, secretValue: any): Promise<void> {
    const secretString = typeof secretValue === 'string' 
      ? secretValue 
      : JSON.stringify(secretValue);
    
    try {
      // 먼저 업데이트 시도
      const updateCommand = new UpdateSecretCommand({
        SecretId: secretName,
        SecretString: secretString
      });
      await this.client.send(updateCommand);
      console.log(`✅ Secret updated: ${secretName}`);
    } catch (error: any) {
      if (error.name === 'ResourceNotFoundException') {
        // 없으면 생성
        const createCommand = new CreateSecretCommand({
          Name: secretName,
          SecretString: secretString,
          Description: `T-Developer secret: ${secretName}`
        });
        await this.client.send(createCommand);
        console.log(`✅ Secret created: ${secretName}`);
      } else {
        throw error;
      }
    }
    
    // 캐시 무효화
    this.cache.delete(secretName);
  }
  
  // 환경별 시크릿 로드
  async loadEnvironmentSecrets(): Promise<void> {
    const environment = process.env.NODE_ENV || 'development';
    const secretName = `t-developer/${environment}/config`;
    
    try {
      const secrets = await this.getSecret(secretName);
      
      // 환경 변수로 설정
      Object.entries(secrets).forEach(([key, value]) => {
        if (!process.env[key]) {
          process.env[key] = value as string;
        }
      });
      
      console.log(`✅ Loaded secrets for ${environment} environment`);
    } catch (error) {
      console.warn(`⚠️  No secrets found for ${environment}, using local .env`);
    }
  }
}

// 초기화 스크립트
export async function initializeSecrets(): Promise<void> {
  const manager = new SecretsManager();
  
  if (process.env.NODE_ENV === 'production') {
    await manager.loadEnvironmentSecrets();
  }
}
```

**🔧 사용자 작업**:
- AWS Secrets Manager에서 시크릿 생성
- 개발/스테이징/프로덕션 환경별 시크릿 설정
- IAM 권한에 Secrets Manager 읽기 권한 추가

---

## Task 0.5: 테스트 환경 구축

### SubTask 0.5.1: 단위 테스트 헬퍼 생성
**목표**: 테스트 작성을 위한 유틸리티 함수

**구현 내용**:
```typescript
// backend/tests/helpers/test-utils.ts
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
import { mockClient } from 'aws-sdk-client-mock';
import { jest } from '@jest/globals';

// DynamoDB Mock
export const dynamoDBMock = mockClient(DynamoDBDocumentClient);

// 테스트 데이터 생성기
export class TestDataGenerator {
  static project(overrides?: Partial<any>) {
    return {
      id: `proj_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      userId: 'user_test_123',
      name: 'Test Project',
      description: 'A test project description',
      status: 'analyzing',
      createdAt: new Date().toISOString(),
      ...overrides
    };
  }
  
  static agentExecution(overrides?: Partial<any>) {
    return {
      id: `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      projectId: 'proj_test_123',
      agentName: 'TestAgent',
      agentType: 'test',
      status: 'completed',
      startedAt: new Date().toISOString(),
      completedAt: new Date().toISOString(),
      ...overrides
    };
  }
  
  static user(overrides?: Partial<any>) {
    return {
      id: `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      email: 'test@example.com',
      role: 'user',
      createdAt: new Date().toISOString(),
      ...overrides
    };
  }
}

// 비동기 테스트 헬퍼
export async function waitFor(
  condition: () => boolean | Promise<boolean>,
  timeout = 5000,
  interval = 100
): Promise<void> {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    if (await condition()) {
      return;
    }
    await new Promise(resolve => setTimeout(resolve, interval));
  }
  
  throw new Error('Timeout waiting for condition');
}

// Mock 타이머 헬퍼
export class MockTimer {
  private timers: NodeJS.Timer[] = [];
  
  setTimeout(fn: Function, delay: number): NodeJS.Timer {
    const timer = setTimeout(fn, delay);
    this.timers.push(timer);
    return timer;
  }
  
  clearAll(): void {
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers = [];
  }
}

// 환경 변수 모킹
export function mockEnvironment(vars: Record<string, string>): () => void {
  const original = { ...process.env };
  
  Object.entries(vars).forEach(([key, value]) => {
    process.env[key] = value;
  });
  
  return () => {
    process.env = original;
  };
}
```

### SubTask 0.5.2: 통합 테스트 설정
**목표**: API 통합 테스트 환경 구축

**구현 내용**:
```typescript
// backend/tests/helpers/test-server.ts
import express, { Express } from 'express';
import { Server } from 'http';
import { AddressInfo } from 'net';

export class TestServer {
  private app: Express;
  private server?: Server;
  
  constructor() {
    this.app = express();
    this.setupMiddleware();
  }
  
  private setupMiddleware(): void {
    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: true }));
  }
  
  async start(): Promise<number> {
    return new Promise((resolve) => {
      this.server = this.app.listen(0, () => {
        const port = (this.server!.address() as AddressInfo).port;
        resolve(port);
      });
    });
  }
  
  async stop(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (this.server) {
        this.server.close((err) => {
          if (err) reject(err);
          else resolve();
        });
      } else {
        resolve();
      }
    });
  }
  
  getApp(): Express {
    return this.app;
  }
  
  getUrl(port: number): string {
    return `http://localhost:${port}`;
  }
}

// API 테스트 클라이언트
export class TestClient {
  constructor(private baseURL: string) {}
  
  async get(path: string, headers?: Record<string, string>) {
    const response = await fetch(`${this.baseURL}${path}`, {
      method: 'GET',
      headers
    });
    return {
      status: response.status,
      body: await response.json()
    };
  }
  
  async post(path: string, data?: any, headers?: Record<string, string>) {
    const response = await fetch(`${this.baseURL}${path}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...headers
      },
      body: JSON.stringify(data)
    });
    return {
      status: response.status,
      body: await response.json()
    };
  }
}
```

### SubTask 0.5.3: E2E 테스트 환경
**목표**: End-to-End 테스트를 위한 환경 구성

**구현 내용**:
```typescript
// backend/tests/e2e/setup.ts
import { spawn, ChildProcess } from 'child_process';
import { DynamoDBClient, CreateTableCommand } from '@aws-sdk/client-dynamodb';

export class E2ETestEnvironment {
  private processes: ChildProcess[] = [];
  private dynamoClient: DynamoDBClient;
  
  constructor() {
    this.dynamoClient = new DynamoDBClient({
      endpoint: 'http://localhost:8000',
      region: 'us-east-1',
      credentials: {
        accessKeyId: 'test',
        secretAccessKey: 'test'
      }
    });
  }
  
  async setup(): Promise<void> {
    console.log('🔧 Setting up E2E test environment...');
    
    // 1. DynamoDB Local 시작
    await this.startDynamoDBLocal();
    
    // 2. Redis 시작
    await this.startRedis();
    
    // 3. 테스트 테이블 생성
    await this.createTestTables();
    
    // 4. 애플리케이션 서버 시작
    await this.startAppServer();
    
    console.log('✅ E2E test environment ready!');
  }
  
  async teardown(): Promise<void> {
    console.log('🧹 Cleaning up E2E test environment...');
    
    // 모든 프로세스 종료
    this.processes.forEach(process => {
      process.kill('SIGTERM');
    });
    
    // 프로세스 종료 대기
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    console.log('✅ E2E test environment cleaned up!');
  }
  
  private async startDynamoDBLocal(): Promise<void> {
    const dynamodb = spawn('docker', [
      'run',
      '--rm',
      '-p', '8000:8000',
      'amazon/dynamodb-local',
      '-jar', 'DynamoDBLocal.jar',
      '-inMemory'
    ]);
    
    this.processes.push(dynamodb);
    
    // DynamoDB 시작 대기
    await this.waitForPort(8000, 10000);
  }
  
  private async startRedis(): Promise<void> {
    const redis = spawn('docker', [
      'run',
      '--rm',
      '-p', '6379:6379',
      'redis:7-alpine'
    ]);
    
    this.processes.push(redis);
    
    // Redis 시작 대기
    await this.waitForPort(6379, 10000);
  }
  
  private async createTestTables(): Promise<void> {
    const tables = [
      {
        TableName: 'test-projects',
        KeySchema: [{ AttributeName: 'id', KeyType: 'HASH' }],
        AttributeDefinitions: [{ AttributeName: 'id', AttributeType: 'S' }],
        BillingMode: 'PAY_PER_REQUEST'
      }
    ];
    
    for (const table of tables) {
      try {
        await this.dynamoClient.send(new CreateTableCommand(table));
      } catch (error: any) {
        if (error.name !== 'ResourceInUseException') {
          throw error;
        }
      }
    }
  }
  
  private async startAppServer(): Promise<void> {
    const app = spawn('npm', ['run', 'start:test'], {
      env: {
        ...process.env,
        NODE_ENV: 'test',
        PORT: '8080'
      }
    });
    
    this.processes.push(app);
    
    // 앱 서버 시작 대기
    await this.waitForPort(8080, 30000);
  }
  
  private async waitForPort(port: number, timeout: number): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      try {
        const response = await fetch(`http://localhost:${port}`);
        if (response.ok || response.status === 404) {
          return;
        }
      } catch (error) {
        // 연결 실패, 재시도
      }
      
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    throw new Error(`Port ${port} did not become available within ${timeout}ms`);
  }
}
```

### SubTask 0.5.4: 테스트 데이터 시더
**목표**: 테스트용 초기 데이터 생성

**구현 내용**:
```typescript
// backend/tests/fixtures/seed-data.ts
import { DynamoDBDocumentClient, PutCommand, BatchWriteCommand } from '@aws-sdk/lib-dynamodb';
import { faker } from '@faker-js/faker';

export class TestDataSeeder {
  constructor(private docClient: DynamoDBDocumentClient) {}
  
  async seedAll(): Promise<void> {
    await Promise.all([
      this.seedUsers(),
      this.seedProjects(),
      this.seedComponents()
    ]);
  }
  
  async seedUsers(count: number = 10): Promise<void> {
    const users = Array.from({ length: count }, () => ({
      id: `user_${faker.string.uuid()}`,
      email: faker.internet.email(),
      name: faker.person.fullName(),
      role: faker.helpers.arrayElement(['user', 'admin']),
      apiKey: `sk_test_${faker.string.alphanumeric(32)}`,
      createdAt: faker.date.past().toISOString()
    }));
    
    for (const user of users) {
      await this.docClient.send(new PutCommand({
        TableName: 'test-users',
        Item: user
      }));
    }
    
    console.log(`✅ Seeded ${count} test users`);
  }
  
  async seedProjects(count: number = 20): Promise<void> {
    const projects = Array.from({ length: count }, () => ({
      id: `proj_${faker.string.uuid()}`,
      userId: `user_${faker.string.uuid()}`,
      name: faker.commerce.productName(),
      description: faker.lorem.paragraph(),
      projectType: faker.helpers.arrayElement(['web', 'api', 'mobile']),
      status: faker.helpers.arrayElement(['analyzing', 'building', 'completed']),
      uiFramework: faker.helpers.arrayElement(['react', 'vue', 'angular']),
      createdAt: faker.date.past().toISOString()
    }));
    
    // 배치 쓰기 (25개씩)
    const chunks = this.chunkArray(projects, 25);
    
    for (const chunk of chunks) {
      await this.docClient.send(new BatchWriteCommand({
        RequestItems: {
          'test-projects': chunk.map(item => ({
            PutRequest: { Item: item }
          }))
        }
      }));
    }
    
    console.log(`✅ Seeded ${count} test projects`);
  }
  
  async seedComponents(count: number = 50): Promise<void> {
    const components = Array.from({ length: count }, () => ({
      id: `comp_${faker.string.uuid()}`,
      name: faker.hacker.noun(),
      version: faker.system.semver(),
      language: faker.helpers.arrayElement(['javascript', 'typescript', 'python']),
      framework: faker.helpers.arrayElement(['react', 'express', 'fastapi']),
      description: faker.lorem.sentence(),
      downloads: faker.number.int({ min: 0, max: 1000000 }),
      stars: faker.number.int({ min: 0, max: 50000 }),
      lastUpdated: faker.date.recent().toISOString()
    }));
    
    const chunks = this.chunkArray(components, 25);
    
    for (const chunk of chunks) {
      await this.docClient.send(new BatchWriteCommand({
        RequestItems: {
          'test-components': chunk.map(item => ({
            PutRequest: { Item: item }
          }))
        }
      }));
    }
    
    console.log(`✅ Seeded ${count} test components`);
  }
  
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}
```

### SubTask 0.5.5: 테스트 실행 스크립트
**목표**: 다양한 테스트 시나리오 실행 스크립트

**구현 내용**:
```json
// backend/package.json (scripts 섹션 추가)
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:unit": "jest --testPathPattern=unit",
    "test:integration": "jest --testPathPattern=integration",
    "test:e2e": "jest --testPathPattern=e2e --runInBand",
    "test:e2e:setup": "ts-node tests/e2e/setup.ts",
    "test:seed": "ts-node tests/fixtures/seed-data.ts",
    "test:all": "npm run test:unit && npm run test:integration && npm run test:e2e"
  }
}
```

```bash
#!/bin/bash
# scripts/run-tests.sh

#!/bin/bash
set -e

echo "🧪 T-Developer 테스트 실행"
echo "=========================="

# 환경 변수 설정
export NODE_ENV=test
export AWS_REGION=us-east-1
export DYNAMODB_ENDPOINT=http://localhost:8000

# 테스트 타입 선택
if [ "$1" == "unit" ]; then
    echo "🔬 단위 테스트 실행..."
    npm run test:unit
elif [ "$1" == "integration" ]; then
    echo "🔗 통합 테스트 실행..."
    npm run test:integration
elif [ "$1" == "e2e" ]; then
    echo "🌐 E2E 테스트 실행..."
    npm run test:e2e:setup
    npm run test:e2e
elif [ "$1" == "all" ]; then
    echo "📊 전체 테스트 실행..."
    npm run test:all
else
    echo "사용법: ./run-tests.sh [unit|integration|e2e|all]"
    exit 1
fi

echo "✅ 테스트 완료!"
```

**🔧 사용자 작업**:
- 테스트 스크립트 실행 권한: `chmod +x scripts/run-tests.sh`
- 단위 테스트 실행: `./scripts/run-tests.sh unit`
- 전체 테스트 실행: `./scripts/run-tests.sh all`

---

### SubTask 0.5.6: 테스트 보고서 생성 설정
**목표**: 테스트 결과를 시각적으로 보여주는 리포트 설정

**구현 내용**:
```typescript
// backend/jest-html-reporter.config.js
module.exports = {
  pageTitle: 'T-Developer Test Report',
  outputPath: 'test-reports/index.html',
  includeFailureMsg: true,
  includeConsoleLog: true,
  dateFormat: 'yyyy-mm-dd HH:MM:ss',
  theme: 'darkTheme',
  logo: './assets/logo.png',
  customCss: './test-reports/custom.css',
  executionTimeWarningThreshold: 5000,
  
  // 커스텀 정보 추가
  customInfos: [
    {label: 'Environment', value: process.env.NODE_ENV || 'test'},
    {label: 'Node Version', value: process.version},
    {label: 'Test Runner', value: 'Jest'}
  ]
};
```

```typescript
// backend/src/utils/test-reporter.ts
import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';

export class CustomTestReporter {
  private results: any[] = [];
  
  onRunStart() {
    this.results = [];
    console.log('🧪 테스트 실행 시작...');
  }
  
  onTestResult(test: any, testResult: any) {
    this.results.push({
      testPath: test.path,
      duration: testResult.perfStats.runtime,
      passed: testResult.numFailingTests === 0,
      coverage: testResult.coverage
    });
  }
  
  onRunComplete(contexts: any, results: any) {
    const report = {
      startTime: results.startTime,
      endTime: Date.now(),
      duration: Date.now() - results.startTime,
      numTotalTests: results.numTotalTests,
      numPassedTests: results.numPassedTests,
      numFailedTests: results.numFailedTests,
      numPendingTests: results.numPendingTests,
      testResults: this.results,
      coverage: results.coverageMap
    };
    
    // 리포트 디렉토리 생성
    const reportDir = join(process.cwd(), 'test-reports');
    mkdirSync(reportDir, { recursive: true });
    
    // JSON 리포트 저장
    writeFileSync(
      join(reportDir, 'test-results.json'),
      JSON.stringify(report, null, 2)
    );
    
    // 간단한 요약 출력
    console.log('\n📊 테스트 결과 요약:');
    console.log(`✅ 성공: ${results.numPassedTests}`);
    console.log(`❌ 실패: ${results.numFailedTests}`);
    console.log(`⏭️  스킵: ${results.numPendingTests}`);
    console.log(`⏱️  시간: ${(report.duration / 1000).toFixed(2)}초`);
  }
}
```

---

## Task 0.6: 로컬 개발 인프라 구성

### SubTask 0.6.1: Docker Compose 전체 설정
**목표**: 완전한 로컬 개발 환경을 위한 Docker 구성

**구현 내용**:
```yaml
# docker-compose.yml
version: '3.8'

services:
  # DynamoDB Local
  dynamodb:
    image: amazon/dynamodb-local:latest
    container_name: t-developer-dynamodb
    ports:
      - "8000:8000"
    command: "-jar DynamoDBLocal.jar -sharedDb -inMemory"
    networks:
      - t-developer-network

  # Redis
  redis:
    image: redis:7-alpine
    container_name: t-developer-redis
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD:-devpassword}
    volumes:
      - redis-data:/data
    networks:
      - t-developer-network

  # LocalStack (AWS 서비스 모킹)
  localstack:
    image: localstack/localstack:latest
    container_name: t-developer-localstack
    ports:
      - "4566:4566"
      - "4571:4571"
    environment:
      - SERVICES=s3,lambda,secretsmanager,cloudwatch
      - DEBUG=1
      - LAMBDA_EXECUTOR=docker
      - DOCKER_HOST=unix:///var/run/docker.sock
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock"
      - localstack-data:/tmp/localstack
    networks:
      - t-developer-network

  # Postgres (선택적 - DynamoDB 대신 사용 가능)
  postgres:
    image: postgres:15-alpine
    container_name: t-developer-postgres
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: t_developer
      POSTGRES_USER: ${DB_USER:-developer}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-devpassword}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - t-developer-network

  # Elasticsearch (컴포넌트 검색용)
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: t-developer-elasticsearch
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data
    networks:
      - t-developer-network

  # Kibana (Elasticsearch UI)
  kibana:
    image: docker.elastic.co/kibana/kibana:8.11.0
    container_name: t-developer-kibana
    ports:
      - "5601:5601"
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    depends_on:
      - elasticsearch
    networks:
      - t-developer-network

  # Jaeger (분산 추적)
  jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: t-developer-jaeger
    ports:
      - "16686:16686"
      - "14268:14268"
    environment:
      - COLLECTOR_ZIPKIN_HOST_PORT=:9411
    networks:
      - t-developer-network

volumes:
  redis-data:
  localstack-data:
  postgres-data:
  elasticsearch-data:

networks:
  t-developer-network:
    driver: bridge
```

**🔧 사용자 작업**:
- Docker Desktop 메모리 할당 확인 (최소 4GB)
- `docker-compose up -d` 실행
- 모든 서비스 health check 확인

### SubTask 0.6.2: LocalStack AWS 서비스 초기화
**목표**: LocalStack에서 필요한 AWS 서비스 설정

**구현 내용**:
```python
# scripts/setup-localstack.py
import boto3
import json
import time
from botocore.config import Config

# LocalStack 설정
config = Config(
    region_name='us-east-1',
    retries={'max_attempts': 10, 'mode': 'standard'}
)

# LocalStack 엔드포인트
LOCALSTACK_URL = 'http://localhost:4566'

def create_s3_buckets():
    """S3 버킷 생성"""
    s3 = boto3.client('s3', endpoint_url=LOCALSTACK_URL, config=config)
    
    buckets = [
        't-developer-artifacts',
        't-developer-components',
        't-developer-templates',
        't-developer-test-data'
    ]
    
    for bucket in buckets:
        try:
            s3.create_bucket(Bucket=bucket)
            print(f"✅ S3 버킷 생성: {bucket}")
            
            # 버킷 정책 설정
            bucket_policy = {
                "Version": "2012-10-17",
                "Statement": [{
                    "Effect": "Allow",
                    "Principal": "*",
                    "Action": "s3:GetObject",
                    "Resource": f"arn:aws:s3:::{bucket}/*"
                }]
            }
            s3.put_bucket_policy(
                Bucket=bucket,
                Policy=json.dumps(bucket_policy)
            )
        except Exception as e:
            print(f"⚠️  버킷 생성 실패 {bucket}: {e}")

def create_lambda_functions():
    """Lambda 함수 스텁 생성"""
    lambda_client = boto3.client('lambda', endpoint_url=LOCALSTACK_URL, config=config)
    
    functions = [
        {
            'FunctionName': 't-developer-nl-processor',
            'Runtime': 'nodejs18.x',
            'Role': 'arn:aws:iam::123456789012:role/lambda-role',
            'Handler': 'index.handler',
            'Code': {'ZipFile': b'exports.handler = async (event) => { return { statusCode: 200, body: "OK" }; };'},
            'Timeout': 300,
            'MemorySize': 512
        }
    ]
    
    for func in functions:
        try:
            lambda_client.create_function(**func)
            print(f"✅ Lambda 함수 생성: {func['FunctionName']}")
        except Exception as e:
            print(f"⚠️  Lambda 생성 실패: {e}")

def create_secrets():
    """Secrets Manager 시크릿 생성"""
    sm = boto3.client('secretsmanager', endpoint_url=LOCALSTACK_URL, config=config)
    
    secrets = {
        't-developer/dev/api-keys': {
            'OPENAI_API_KEY': 'sk-test-xxx',
            'ANTHROPIC_API_KEY': 'sk-ant-test-xxx'
        },
        't-developer/dev/database': {
            'DB_HOST': 'localhost',
            'DB_PORT': '5432',
            'DB_NAME': 't_developer',
            'DB_USER': 'developer',
            'DB_PASSWORD': 'devpassword'
        }
    }
    
    for secret_name, secret_value in secrets.items():
        try:
            sm.create_secret(
                Name=secret_name,
                SecretString=json.dumps(secret_value)
            )
            print(f"✅ Secret 생성: {secret_name}")
        except Exception as e:
            print(f"⚠️  Secret 생성 실패: {e}")

def setup_cloudwatch():
    """CloudWatch 로그 그룹 생성"""
    logs = boto3.client('logs', endpoint_url=LOCALSTACK_URL, config=config)
    
    log_groups = [
        '/aws/lambda/t-developer-agents',
        '/aws/ecs/t-developer-api',
        '/t-developer/application'
    ]
    
    for log_group in log_groups:
        try:
            logs.create_log_group(logGroupName=log_group)
            print(f"✅ 로그 그룹 생성: {log_group}")
        except Exception as e:
            print(f"⚠️  로그 그룹 생성 실패: {e}")

def main():
    print("🚀 LocalStack 초기화 시작...")
    
    # LocalStack이 준비될 때까지 대기
    time.sleep(5)
    
    create_s3_buckets()
    create_lambda_functions()
    create_secrets()
    setup_cloudwatch()
    
    print("\n✅ LocalStack 초기화 완료!")
    print("📋 사용 가능한 서비스:")
    print("- S3: http://localhost:4566")
    print("- Lambda: http://localhost:4566")
    print("- Secrets Manager: http://localhost:4566")
    print("- CloudWatch: http://localhost:4566")

if __name__ == "__main__":
    main()
```

### SubTask 0.6.3: 개발용 SSL 인증서 생성
**목표**: HTTPS 로컬 개발을 위한 자체 서명 인증서

**구현 내용**:
```bash
#!/bin/bash
# scripts/generate-ssl-certs.sh

CERT_DIR="./certs"
DOMAIN="localhost"

# 인증서 디렉토리 생성
mkdir -p $CERT_DIR

# Root CA 생성
openssl genrsa -out $CERT_DIR/rootCA.key 2048
openssl req -x509 -new -nodes -key $CERT_DIR/rootCA.key -sha256 -days 365 \
    -out $CERT_DIR/rootCA.crt \
    -subj "/C=US/ST=State/L=City/O=T-Developer/CN=T-Developer Root CA"

# 서버 키 생성
openssl genrsa -out $CERT_DIR/server.key 2048

# 인증서 요청 생성
openssl req -new -key $CERT_DIR/server.key -out $CERT_DIR/server.csr \
    -subj "/C=US/ST=State/L=City/O=T-Developer/CN=$DOMAIN"

# SAN 설정 파일 생성
cat > $CERT_DIR/server.conf <<EOF
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req

[req_distinguished_name]

[v3_req]
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = *.localhost
IP.1 = 127.0.0.1
IP.2 = ::1
EOF

# 서버 인증서 생성
openssl x509 -req -in $CERT_DIR/server.csr -CA $CERT_DIR/rootCA.crt \
    -CAkey $CERT_DIR/rootCA.key -CAcreateserial \
    -out $CERT_DIR/server.crt -days 365 -sha256 \
    -extfile $CERT_DIR/server.conf -extensions v3_req

# PEM 형식으로 변환
cat $CERT_DIR/server.crt $CERT_DIR/server.key > $CERT_DIR/server.pem

echo "✅ SSL 인증서 생성 완료!"
echo "📁 인증서 위치: $CERT_DIR/"
echo "🔐 Root CA를 시스템에 신뢰할 인증서로 추가하세요:"
echo "   - macOS: sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $CERT_DIR/rootCA.crt"
echo "   - Ubuntu: sudo cp $CERT_DIR/rootCA.crt /usr/local/share/ca-certificates/ && sudo update-ca-certificates"
```

```typescript
// backend/src/config/https-server.ts
import https from 'https';
import fs from 'fs';
import path from 'path';
import express from 'express';

export function createHttpsServer(app: express.Application) {
  const certPath = path.join(process.cwd(), 'certs');
  
  const options = {
    key: fs.readFileSync(path.join(certPath, 'server.key')),
    cert: fs.readFileSync(path.join(certPath, 'server.crt'))
  };
  
  return https.createServer(options, app);
}

// 개발 환경에서 HTTPS 사용
if (process.env.NODE_ENV === 'development' && process.env.USE_HTTPS === 'true') {
  const httpsServer = createHttpsServer(app);
  httpsServer.listen(443, () => {
    console.log('🔒 HTTPS Server running on https://localhost');
  });
}
```

### SubTask 0.6.4: 로컬 CDN 시뮬레이션
**목표**: 정적 파일 서빙을 위한 로컬 CDN 환경

**구현 내용**:
```typescript
// backend/src/services/local-cdn.ts
import express from 'express';
import path from 'path';
import { createHash } from 'crypto';
import { promises as fs } from 'fs';

export class LocalCDN {
  private app: express.Application;
  private cache: Map<string, Buffer> = new Map();
  
  constructor() {
    this.app = express();
    this.setupRoutes();
  }
  
  private setupRoutes() {
    // 정적 파일 서빙
    this.app.use('/static', express.static(path.join(process.cwd(), 'public'), {
      maxAge: '1y',
      etag: true,
      lastModified: true,
      setHeaders: (res, filepath) => {
        // 파일 타입별 캐시 설정
        if (filepath.endsWith('.js') || filepath.endsWith('.css')) {
          res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
        } else if (filepath.endsWith('.html')) {
          res.setHeader('Cache-Control', 'no-cache');
        }
        
        // CORS 헤더
        res.setHeader('Access-Control-Allow-Origin', '*');
      }
    }));
    
    // 이미지 최적화
    this.app.get('/images/:size/:filename', async (req, res) => {
      const { size, filename } = req.params;
      const cacheKey = `${size}-${filename}`;
      
      // 캐시 확인
      if (this.cache.has(cacheKey)) {
        res.setHeader('X-Cache', 'HIT');
        return res.send(this.cache.get(cacheKey));
      }
      
      // 이미지 리사이징 (sharp 라이브러리 사용)
      try {
        const originalPath = path.join(process.cwd(), 'public/images', filename);
        const [width, height] = size.split('x').map(Number);
        
        // 실제 구현에서는 sharp를 사용하여 리사이징
        // const resized = await sharp(originalPath).resize(width, height).toBuffer();
        
        res.setHeader('X-Cache', 'MISS');
        res.sendFile(originalPath); // 임시로 원본 전송
      } catch (error) {
        res.status(404).send('Image not found');
      }
    });
    
    // 파일 버전 관리
    this.app.get('/versioned/*', async (req, res) => {
      const filepath = req.params[0];
      const fullPath = path.join(process.cwd(), 'public', filepath);
      
      try {
        const content = await fs.readFile(fullPath);
        const hash = createHash('md5').update(content).digest('hex').substr(0, 8);
        
        res.setHeader('ETag', `"${hash}"`);
        res.setHeader('Cache-Control', 'public, max-age=31536000');
        
        res.send(content);
      } catch (error) {
        res.status(404).send('File not found');
      }
    });
  }
  
  start(port: number = 3002) {
    this.app.listen(port, () => {
      console.log(`🌐 Local CDN running on http://localhost:${port}`);
    });
  }
}
```

```nginx
# nginx/nginx.conf (로컬 CDN용)
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    # 캐싱 설정
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=cdn_cache:10m max_size=1g inactive=60m;
    
    # Gzip 압축
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss;
    
    server {
        listen 80;
        server_name cdn.localhost;
        
        location / {
            proxy_pass http://localhost:3002;
            proxy_cache cdn_cache;
            proxy_cache_valid 200 302 1d;
            proxy_cache_valid 404 1m;
            
            add_header X-Cache-Status $upstream_cache_status;
            add_header Cache-Control "public, max-age=31536000";
        }
        
        location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}
```

### SubTask 0.6.5: 개발 데이터 생성기
**목표**: 현실적인 테스트 데이터 자동 생성

**구현 내용**:
```typescript
// backend/src/utils/data-generator.ts
import { faker } from '@faker-js/faker';
import { DynamoDBDocumentClient, PutCommand } from '@aws-sdk/lib-dynamodb';

export class DevelopmentDataGenerator {
  constructor(private docClient: DynamoDBDocumentClient) {}
  
  async generateProjects(count: number = 50): Promise<void> {
    const projects = [];
    
    for (let i = 0; i < count; i++) {
      const project = {
        id: `proj_${faker.string.uuid()}`,
        userId: `user_${faker.string.uuid()}`,
        name: this.generateProjectName(),
        description: this.generateProjectDescription(),
        projectType: faker.helpers.arrayElement(['web', 'api', 'mobile', 'desktop', 'cli']),
        status: this.generateWeightedStatus(),
        createdAt: faker.date.past({ years: 1 }).toISOString(),
        updatedAt: faker.date.recent({ days: 30 }).toISOString(),
        
        // 기술 스택
        techStack: {
          frontend: faker.helpers.arrayElement(['react', 'vue', 'angular', 'svelte', null]),
          backend: faker.helpers.arrayElement(['node', 'python', 'java', 'go', null]),
          database: faker.helpers.arrayElement(['postgres', 'mysql', 'mongodb', 'dynamodb']),
          cloud: faker.helpers.arrayElement(['aws', 'gcp', 'azure', 'vercel'])
        },
        
        // 에이전트 실행 기록
        agentExecutions: this.generateAgentExecutions(),
        
        // 성능 메트릭
        metrics: {
          buildTime: faker.number.int({ min: 30, max: 600 }),
          totalCost: faker.number.float({ min: 0.01, max: 10.00, precision: 0.01 }),
          componentsUsed: faker.number.int({ min: 5, max: 50 }),
          linesOfCode: faker.number.int({ min: 1000, max: 50000 })
        }
      };
      
      projects.push(project);
    }
    
    // 배치로 저장
    for (const project of projects) {
      await this.docClient.send(new PutCommand({
        TableName: 'T-Developer-Projects',
        Item: project
      }));
    }
    
    console.log(`✅ ${count}개의 프로젝트 데이터 생성 완료`);
  }
  
  private generateProjectName(): string {
    const templates = [
      () => `${faker.commerce.productAdjective()} ${faker.hacker.noun()} Platform`,
      () => `${faker.company.buzzNoun()} Management System`,
      () => `${faker.hacker.adjective()} ${faker.hacker.noun()} API`,
      () => `${faker.commerce.product()} Tracker`,
      () => `${faker.company.buzzAdjective()} Analytics Dashboard`
    ];
    
    return faker.helpers.arrayElement(templates)();
  }
  
  private generateProjectDescription(): string {
    const intros = [
      'A modern web application that',
      'An innovative platform designed to',
      'A comprehensive solution for',
      'A cutting-edge system that'
    ];
    
    const actions = [
      'streamlines business processes',
      'enhances user engagement',
      'automates workflow management',
      'provides real-time analytics',
      'optimizes resource allocation'
    ];
    
    const benefits = [
      'increasing productivity by up to 40%',
      'reducing operational costs',
      'improving customer satisfaction',
      'enabling data-driven decisions',
      'facilitating team collaboration'
    ];
    
    return `${faker.helpers.arrayElement(intros)} ${faker.helpers.arrayElement(actions)}, ${faker.helpers.arrayElement(benefits)}.`;
  }
  
  private generateWeightedStatus(): string {
    // 가중치를 둔 상태 생성 (더 현실적인 분포)
    const weights = {
      'completed': 0.6,
      'building': 0.2,
      'testing': 0.1,
      'analyzing': 0.05,
      'error': 0.05
    };
    
    const random = Math.random();
    let cumulative = 0;
    
    for (const [status, weight] of Object.entries(weights)) {
      cumulative += weight;
      if (random < cumulative) {
        return status;
      }
    }
    
    return 'completed';
  }
  
  private generateAgentExecutions(): any[] {
    const agents = [
      'nl-input', 'ui-selection', 'parsing', 'component-decision',
      'matching-rate', 'search', 'generation', 'assembly', 'download'
    ];
    
    return agents.map((agent, index) => ({
      agentName: agent,
      executionTime: faker.number.int({ min: 100, max: 5000 }),
      status: index < 7 ? 'completed' : faker.helpers.arrayElement(['completed', 'running', 'pending']),
      tokensUsed: faker.number.int({ min: 100, max: 10000 })
    }));
  }
  
  async generateComponents(count: number = 200): Promise<void> {
    const components = [];
    
    const componentTypes = {
      'authentication': ['login-form', 'oauth-provider', 'jwt-handler', 'session-manager'],
      'database': ['orm-wrapper', 'query-builder', 'migration-tool', 'connection-pool'],
      'ui': ['data-table', 'chart-library', 'form-builder', 'modal-system'],
      'api': ['rest-client', 'graphql-resolver', 'rate-limiter', 'api-gateway'],
      'utility': ['logger', 'validator', 'error-handler', 'config-manager']
    };
    
    for (let i = 0; i < count; i++) {
      const category = faker.helpers.objectKey(componentTypes);
      const componentName = faker.helpers.arrayElement(componentTypes[category]);
      
      const component = {
        id: `comp_${faker.string.uuid()}`,
        name: `${faker.company.buzzAdjective()}-${componentName}`,
        category,
        version: faker.system.semver(),
        language: faker.helpers.arrayElement(['javascript', 'typescript', 'python', 'java']),
        framework: faker.helpers.arrayElement(['react', 'vue', 'express', 'fastapi', 'spring']),
        
        // 품질 메트릭
        qualityScore: faker.number.float({ min: 3.0, max: 5.0, precision: 0.1 }),
        downloads: faker.number.int({ min: 100, max: 1000000 }),
        stars: faker.number.int({ min: 10, max: 50000 }),
        issues: faker.number.int({ min: 0, max: 100 }),
        
        // 메타데이터
        author: faker.person.fullName(),
        license: faker.helpers.arrayElement(['MIT', 'Apache-2.0', 'GPL-3.0', 'BSD-3-Clause']),
        lastUpdated: faker.date.recent({ days: 90 }).toISOString(),
        description: faker.lorem.sentence(),
        keywords: faker.lorem.words(5).split(' '),
        
        // 의존성
        dependencies: this.generateDependencies(),
        
        // 사용 통계
        usageStats: {
          projects: faker.number.int({ min: 1, max: 1000 }),
          successRate: faker.number.float({ min: 85, max: 100, precision: 0.1 }),
          avgIntegrationTime: faker.number.int({ min: 5, max: 60 })
        }
      };
      
      components.push(component);
    }
    
    // Elasticsearch에 인덱싱 (실제 구현 시)
    for (const component of components) {
      await this.docClient.send(new PutCommand({
        TableName: 'T-Developer-Components',
        Item: component
      }));
    }
    
    console.log(`✅ ${count}개의 컴포넌트 데이터 생성 완료`);
  }
  
  private generateDependencies(): Record<string, string> {
    const deps: Record<string, string> = {};
    const count = faker.number.int({ min: 0, max: 10 });
    
    const commonDeps = [
      'lodash', 'axios', 'express', 'react', 'vue',
      'moment', 'uuid', 'bcrypt', 'jsonwebtoken', 'dotenv'
    ];
    
    for (let i = 0; i < count; i++) {
      const dep = faker.helpers.arrayElement(commonDeps);
      deps[dep] = `^${faker.system.semver()}`;
    }
    
    return deps;
  }
}

// 실행 스크립트
export async function seedDevelopmentData() {
  const generator = new DevelopmentDataGenerator(docClient);
  
  console.log('🌱 개발 데이터 생성 시작...');
  
  await Promise.all([
    generator.generateProjects(100),
    generator.generateComponents(500)
  ]);
  
  console.log('✅ 모든 개발 데이터 생성 완료!');
}
```

**🔧 사용자 작업**:
- `npm install @faker-js/faker` 실행
- SSL 인증서 생성: `./scripts/generate-ssl-certs.sh`
- LocalStack 초기화: `python scripts/setup-localstack.py`
- 개발 데이터 생성: `npm run seed:dev`

---

## Task 0.7: CI/CD 파이프라인 기초 설정

### SubTask 0.7.1: GitHub Actions 워크플로우 설정
**목표**: 자동화된 테스트 및 빌드 파이프라인

**구현 내용**:
```yaml
# .github/workflows/ci.yml
name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  NODE_VERSION: '18.x'
  PYTHON_VERSION: '3.10'
  AWS_REGION: 'us-east-1'

jobs:
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: |
          cd backend
          npm ci
          
      - name: Run ESLint
        run: |
          cd backend
          npm run lint
          
      - name: Run Prettier check
        run: |
          cd backend
          npm run format:check

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: lint
    
    services:
      dynamodb:
        image: amazon/dynamodb-local
        ports:
          - 8000:8000
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: |
          cd backend
          npm ci
          
      - name: Run unit tests
        run: |
          cd backend
          npm run test:unit
          
      - name: Run integration tests
        run: |
          cd backend
          npm run test:integration
        env:
          DYNAMODB_ENDPOINT: http://localhost:8000
          REDIS_HOST: localhost
          
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          directory: ./backend/coverage
          flags: backend
          
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: lint
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
          
      - name: Run npm audit
        run: |
          cd backend
          npm audit --audit-level=high
          
      - name: Run OWASP dependency check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 't-developer'
          path: '.'
          format: 'HTML'
          
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: |
          cd backend
          npm ci
          
      - name: Build TypeScript
        run: |
          cd backend
          npm run build
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts
          path: backend/dist/
          retention-days: 7
```

### SubTask 0.7.2: 자동 버전 관리 설정
**목표**: Semantic Versioning 자동화

**구현 내용**:
```json
// .releaserc.json
{
  "branches": ["main"],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    "@semantic-release/npm",
    "@semantic-release/github",
    [
      "@semantic-release/git",
      {
        "assets": ["package.json", "package-lock.json", "CHANGELOG.md"],
        "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
      }
    ]
  ]
}
```

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    branches: [ main ]

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18.x'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: npx semantic-release
```

### SubTask 0.7.3: Docker 이미지 빌드 파이프라인
**목표**: 자동화된 Docker 이미지 빌드 및 푸시

**구현 내용**:
```yaml
# .github/workflows/docker.yml
name: Docker Build and Push

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
            
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
```

```dockerfile
# backend/Dockerfile
# Build stage
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY . .

# Build application
RUN npm run build

# Runtime stage
FROM node:18-alpine

# Install dumb-init for proper signal handling
RUN apk add --no-cache dumb-init

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

WORKDIR /app

# Copy node_modules and built application
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/package.json ./

# Switch to non-root user
USER nodejs

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js || exit 1

# Start application with dumb-init
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/main.js"]
```
---

프로젝트 지식을 확인해본 결과, 작업 단계별 구현 계획 문서가 0.7.3까지 작성되어 있고, Task 0.7: CI/CD 파이프라인 기초 설정의 SubTask 0.7.3: Docker 이미지 빌드 파이프라인까지 완료된 것을 확인했습니다.

네, 0.7.3까지 작성된 것을 확인했습니다. 이어서 SubTask 0.7.4부터 작성하겠습니다.

### SubTask 0.7.4: 테스트 자동화 파이프라인 설정
**목표**: PR 및 머지 시 자동 테스트 실행 설정

**구현 내용**:
```yaml
# .github/workflows/test-automation.yml
name: Automated Testing Pipeline

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [main, develop]

jobs:
  test-matrix:
    name: Test Suite - ${{ matrix.test-suite }}
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        test-suite: [unit, integration, e2e]
        node-version: [18.x, 20.x]
        include:
          - test-suite: unit
            timeout: 10
          - test-suite: integration
            timeout: 20
          - test-suite: e2e
            timeout: 30
    
    services:
      dynamodb:
        image: amazon/dynamodb-local
        ports:
          - 8000:8000
        options: >-
          --health-cmd "curl http://localhost:8000"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
      
      - name: Install dependencies
        run: |
          cd backend
          npm ci
      
      - name: Setup test environment
        run: |
          cd backend
          npm run test:setup:${{ matrix.test-suite }}
        env:
          DYNAMODB_ENDPOINT: http://localhost:8000
          REDIS_HOST: localhost
      
      - name: Run ${{ matrix.test-suite }} tests
        run: |
          cd backend
          npm run test:${{ matrix.test-suite }} -- --coverage
        timeout-minutes: ${{ matrix.timeout }}
        env:
          NODE_ENV: test
          CI: true
      
      - name: Upload coverage reports
        if: matrix.node-version == '18.x'
        uses: actions/upload-artifact@v3
        with:
          name: coverage-${{ matrix.test-suite }}
          path: backend/coverage/
      
      - name: Comment test results on PR
        if: github.event_name == 'pull_request' && matrix.node-version == '18.x'
        uses: actions/github-script@v7
        with:
          script: |
            const testResults = require('./backend/test-results.json');
            const comment = `## Test Results - ${{ matrix.test-suite }}
            
            ✅ Passed: ${testResults.numPassedTests}
            ❌ Failed: ${testResults.numFailedTests}
            ⏭️ Skipped: ${testResults.numPendingTests}
            ⏱️ Duration: ${(testResults.duration / 1000).toFixed(2)}s
            
            Coverage: ${testResults.coverage}%`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

### SubTask 0.7.5: 의존성 업데이트 자동화
**목표**: 보안 취약점 및 의존성 업데이트 자동화

**구현 내용**:
```yaml
# .github/workflows/dependency-update.yml
name: Dependency Update Automation

on:
  schedule:
    - cron: '0 9 * * 1' # 매주 월요일 오전 9시
  workflow_dispatch:

jobs:
  update-dependencies:
    name: Update Dependencies
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18.x'
      
      - name: Update npm dependencies
        run: |
          cd backend
          npx npm-check-updates -u --target minor
          npm install
          npm audit fix
      
      - name: Run tests after update
        run: |
          cd backend
          npm test
        continue-on-error: true
      
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: 'chore: update dependencies'
          title: '🔄 Weekly Dependency Update'
          body: |
            ## Automated Dependency Update
            
            This PR contains the following updates:
            - Minor version updates for all dependencies
            - Security patches applied via `npm audit fix`
            
            ### Checklist
            - [ ] All tests pass
            - [ ] No breaking changes identified
            - [ ] Security vulnerabilities resolved
          branch: deps/weekly-update
          delete-branch: true
```

```yaml
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/backend"
    schedule:
      interval: "daily"
    open-pull-requests-limit: 5
    groups:
      aws-sdk:
        patterns:
          - "@aws-sdk/*"
      development:
        patterns:
          - "@types/*"
          - "eslint*"
          - "prettier*"
          - "jest*"
    
  - package-ecosystem: "docker"
    directory: "/"
    schedule:
      interval: "weekly"
    
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
```

**🔧 사용자 작업**:
- GitHub 저장소 Settings에서 Dependabot 활성화
- Dependabot 보안 알림 설정
- 자동 머지 규칙 설정 (선택사항)

---

## Task 0.8: 문서화 시스템 구축

### SubTask 0.8.1: API 문서 자동 생성 설정
**목표**: OpenAPI/Swagger 기반 API 문서 자동화

**구현 내용**:
```typescript
// backend/src/config/swagger.ts
import swaggerJsdoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';
import { Express } from 'express';

const swaggerOptions: swaggerJsdoc.Options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'T-Developer API',
      version: '1.0.0',
      description: 'AI-powered multi-agent development platform API',
      contact: {
        name: 'T-Developer Team',
        email: 'support@t-developer.com'
      },
      license: {
        name: 'MIT',
        url: 'https://opensource.org/licenses/MIT'
      }
    },
    servers: [
      {
        url: 'http://localhost:8000/api/v1',
        description: 'Development server'
      },
      {
        url: 'https://api.t-developer.com/v1',
        description: 'Production server'
      }
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT'
        },
        apiKey: {
          type: 'apiKey',
          in: 'header',
          name: 'X-API-Key'
        }
      }
    }
  },
  apis: [
    './src/routes/*.ts',
    './src/models/*.ts',
    './src/controllers/*.ts'
  ]
};

export function setupSwagger(app: Express): void {
  const swaggerSpec = swaggerJsdoc(swaggerOptions);
  
  // Swagger UI
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {
    explorer: true,
    customCss: '.swagger-ui .topbar { display: none }',
    customSiteTitle: 'T-Developer API Documentation'
  }));
  
  // JSON spec endpoint
  app.get('/api-docs.json', (req, res) => {
    res.setHeader('Content-Type', 'application/json');
    res.send(swaggerSpec);
  });
}

// API 엔드포인트 문서화 예시
/**
 * @swagger
 * /projects:
 *   post:
 *     summary: Create a new project
 *     tags: [Projects]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - description
 *             properties:
 *               name:
 *                 type: string
 *                 description: Project name
 *               description:
 *                 type: string
 *                 description: Natural language project description
 *               projectType:
 *                 type: string
 *                 enum: [web, api, mobile, desktop, cli]
 *               targetPlatforms:
 *                 type: array
 *                 items:
 *                   type: string
 *     responses:
 *       201:
 *         description: Project created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Project'
 *       400:
 *         description: Invalid request
 *       401:
 *         description: Unauthorized
 */
```

### SubTask 0.8.2: 코드 문서화 표준 설정
**목표**: JSDoc/TSDoc 표준 및 자동 생성 설정

**구현 내용**:
```typescript
// backend/typedoc.json
{
  "entryPoints": ["./src"],
  "entryPointStrategy": "expand",
  "out": "./docs/api",
  "exclude": [
    "**/*.test.ts",
    "**/*.spec.ts",
    "**/node_modules/**"
  ],
  "theme": "default",
  "name": "T-Developer API Reference",
  "includeVersion": true,
  "excludePrivate": true,
  "excludeProtected": false,
  "excludeInternal": true,
  "readme": "./README.md",
  "plugin": ["typedoc-plugin-markdown"],
  "githubPages": false,
  "validation": {
    "notExported": true,
    "invalidLink": true,
    "notDocumented": false
  }
}
```

```typescript
// backend/src/standards/documentation.ts
/**
 * T-Developer 문서화 표준 예시
 * 
 * @module DocumentationStandards
 */

/**
 * 프로젝트 생성 서비스
 * 
 * @class ProjectService
 * @description 자연어 설명을 기반으로 프로젝트를 생성하고 관리하는 서비스
 * 
 * @example
 * ```typescript
 * const projectService = new ProjectService();
 * const project = await projectService.createProject({
 *   name: "My E-commerce Platform",
 *   description: "Create a modern e-commerce platform with React and Node.js"
 * });
 * ```
 */
export class ProjectService {
  /**
   * 새로운 프로젝트 생성
   * 
   * @param {CreateProjectDto} dto - 프로젝트 생성 정보
   * @param {string} dto.name - 프로젝트 이름
   * @param {string} dto.description - 자연어 프로젝트 설명
   * @param {string} [dto.projectType] - 프로젝트 타입 (web, api, mobile 등)
   * @param {string[]} [dto.targetPlatforms] - 대상 플랫폼 목록
   * 
   * @returns {Promise<Project>} 생성된 프로젝트 정보
   * 
   * @throws {ValidationError} 입력 데이터가 유효하지 않은 경우
   * @throws {QuotaExceededError} 프로젝트 생성 한도 초과
   * 
   * @since 1.0.0
   * @author T-Developer Team
   */
  async createProject(dto: CreateProjectDto): Promise<Project> {
    // 구현...
  }
  
  /**
   * 프로젝트 상태 업데이트
   * 
   * @param {string} projectId - 프로젝트 ID
   * @param {ProjectStatus} status - 새로운 상태
   * @param {Object} [metadata] - 추가 메타데이터
   * 
   * @returns {Promise<void>}
   * 
   * @fires ProjectStatusChanged - 상태 변경 시 이벤트 발생
   * 
   * @internal
   */
  private async updateProjectStatus(
    projectId: string, 
    status: ProjectStatus,
    metadata?: Record<string, any>
  ): Promise<void> {
    // 구현...
  }
}
```

### SubTask 0.8.3: README 템플릿 생성
**목표**: 프로젝트 및 컴포넌트별 README 템플릿

**구현 내용**:
```markdown
<!-- templates/README-project.md -->
# {{PROJECT_NAME}}

![T-Developer](https://img.shields.io/badge/Generated%20by-T--Developer-blue)
![Version](https://img.shields.io/badge/version-{{VERSION}}-green)
![License](https://img.shields.io/badge/license-{{LICENSE}}-yellow)

## 📋 프로젝트 개요

{{PROJECT_DESCRIPTION}}

### 🎯 주요 기능
{{#FEATURES}}
- {{.}}
{{/FEATURES}}

## 🚀 빠른 시작

### 필수 요구사항
- Node.js {{NODE_VERSION}}+
- {{#REQUIREMENTS}}{{.}}, {{/REQUIREMENTS}}

### 설치
```bash
# 저장소 클론
git clone {{REPOSITORY_URL}}
cd {{PROJECT_NAME}}

# 의존성 설치
npm install

# 환경 변수 설정
cp .env.example .env
# .env 파일을 편집하여 필요한 값 설정
```

### 실행
```bash
# 개발 모드
npm run dev

# 프로덕션 빌드
npm run build

# 프로덕션 실행
npm start
```

## 🏗️ 프로젝트 구조

```
{{PROJECT_NAME}}/
├── src/
│   ├── controllers/    # API 컨트롤러
│   ├── services/       # 비즈니스 로직
│   ├── models/         # 데이터 모델
│   ├── routes/         # API 라우트
│   └── utils/          # 유틸리티 함수
├── tests/              # 테스트 파일
├── docs/               # 문서
└── scripts/            # 스크립트
```

## 📚 API 문서

API 문서는 다음 주소에서 확인할 수 있습니다:
- 개발: http://localhost:{{PORT}}/api-docs
- 프로덕션: {{PRODUCTION_URL}}/api-docs

## 🧪 테스트

```bash
# 단위 테스트
npm run test:unit

# 통합 테스트
npm run test:integration

# 전체 테스트
npm test
```

## 🔧 환경 변수

| 변수명 | 설명 | 기본값 |
|--------|------|--------|
{{#ENV_VARS}}
| {{NAME}} | {{DESCRIPTION}} | {{DEFAULT}} |
{{/ENV_VARS}}

## 🤝 기여하기

기여를 환영합니다! [CONTRIBUTING.md](./CONTRIBUTING.md)를 참고해주세요.

## 📄 라이선스

이 프로젝트는 {{LICENSE}} 라이선스 하에 배포됩니다.

---

Generated with ❤️ by [T-Developer](https://github.com/t-developer)
```

```typescript
// backend/src/utils/readme-generator.ts
import Handlebars from 'handlebars';
import fs from 'fs/promises';
import path from 'path';

export class ReadmeGenerator {
  private template: HandlebarsTemplateDelegate;
  
  constructor(templatePath: string) {
    this.loadTemplate(templatePath);
  }
  
  private async loadTemplate(templatePath: string): Promise<void> {
    const templateContent = await fs.readFile(templatePath, 'utf-8');
    this.template = Handlebars.compile(templateContent);
  }
  
  async generate(project: Project): Promise<string> {
    const context = {
      PROJECT_NAME: project.name,
      VERSION: '1.0.0',
      LICENSE: 'MIT',
      PROJECT_DESCRIPTION: project.description,
      FEATURES: this.extractFeatures(project),
      NODE_VERSION: '18',
      REQUIREMENTS: this.extractRequirements(project),
      REPOSITORY_URL: `https://github.com/${project.userId}/${project.name}`,
      PORT: 3000,
      PRODUCTION_URL: `https://api.${project.name}.com`,
      ENV_VARS: this.extractEnvVars(project)
    };
    
    return this.template(context);
  }
  
  private extractFeatures(project: Project): string[] {
    // 프로젝트에서 주요 기능 추출
    return [
      '사용자 인증 및 권한 관리',
      'RESTful API',
      '실시간 데이터 업데이트',
      '확장 가능한 아키텍처'
    ];
  }
  
  private extractRequirements(project: Project): string[] {
    const reqs = ['npm 8+'];
    
    if (project.techStack?.database) {
      reqs.push(project.techStack.database);
    }
    
    if (project.techStack?.cloud === 'aws') {
      reqs.push('AWS CLI');
    }
    
    return reqs;
  }
  
  private extractEnvVars(project: Project): any[] {
    return [
      { NAME: 'NODE_ENV', DESCRIPTION: '실행 환경', DEFAULT: 'development' },
      { NAME: 'PORT', DESCRIPTION: '서버 포트', DEFAULT: '3000' },
      { NAME: 'DATABASE_URL', DESCRIPTION: '데이터베이스 연결 URL', DEFAULT: 'N/A' }
    ];
  }
}
```

### SubTask 0.8.4: 개발자 가이드 문서 구조
**목표**: 개발자를 위한 종합 가이드 문서 구조 생성

**구현 내용**:
```markdown
<!-- docs/developer-guide/index.md -->
# T-Developer 개발자 가이드

## 📚 목차

### 1. [시작하기](./getting-started.md)
- 시스템 요구사항
- 설치 및 설정
- 첫 프로젝트 생성

### 2. [아키텍처 개요](./architecture.md)
- 시스템 아키텍처
- 멀티 에이전트 시스템
- 기술 스택

### 3. [에이전트 개발](./agents/)
- [에이전트 프레임워크](./agents/framework.md)
- [에이전트 타입](./agents/types.md)
- [커스텀 에이전트 개발](./agents/custom.md)

### 4. [API 레퍼런스](./api/)
- [인증](./api/authentication.md)
- [프로젝트 관리](./api/projects.md)
- [에이전트 제어](./api/agents.md)
- [웹소켓 이벤트](./api/websocket.md)

### 5. [통합 가이드](./integrations/)
- [AWS 서비스](./integrations/aws.md)
- [GitHub 연동](./integrations/github.md)
- [CI/CD 파이프라인](./integrations/cicd.md)

### 6. [베스트 프랙티스](./best-practices/)
- [보안](./best-practices/security.md)
- [성능 최적화](./best-practices/performance.md)
- [에러 처리](./best-practices/error-handling.md)

### 7. [문제 해결](./troubleshooting/)
- [일반적인 문제](./troubleshooting/common-issues.md)
- [디버깅 가이드](./troubleshooting/debugging.md)
- [FAQ](./troubleshooting/faq.md)
```

```typescript
// scripts/generate-docs.ts
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';

const execAsync = promisify(exec);

async function generateDocumentation() {
  console.log('📚 문서 생성 시작...');
  
  try {
    // TypeDoc으로 API 문서 생성
    console.log('1️⃣ API 레퍼런스 생성 중...');
    await execAsync('npx typedoc');
    
    // Swagger 스펙 생성
    console.log('2️⃣ OpenAPI 스펙 생성 중...');
    await execAsync('npm run generate:swagger');
    
    // Markdown 문서 컴파일
    console.log('3️⃣ 마크다운 문서 처리 중...');
    await execAsync('npx @diplodoc/cli --input ./docs --output ./dist/docs');
    
    // 문서 인덱스 생성
    console.log('4️⃣ 문서 인덱스 생성 중...');
    await generateDocsIndex();
    
    console.log('✅ 문서 생성 완료!');
    console.log('📁 출력 위치: ./dist/docs');
    
  } catch (error) {
    console.error('❌ 문서 생성 실패:', error);
    process.exit(1);
  }
}

async function generateDocsIndex() {
  // 문서 인덱스 및 검색 기능을 위한 메타데이터 생성
  const docsMetadata = {
    version: process.env.npm_package_version,
    generated: new Date().toISOString(),
    sections: [
      { path: '/getting-started', title: '시작하기', weight: 1 },
      { path: '/architecture', title: '아키텍처', weight: 2 },
      { path: '/api', title: 'API 레퍼런스', weight: 3 }
    ]
  };
  
  await fs.writeFile(
    path.join('dist/docs/metadata.json'),
    JSON.stringify(docsMetadata, null, 2)
  );
}

if (require.main === module) {
  generateDocumentation();
}
```

### SubTask 0.8.5: 변경 로그 자동화
**목표**: 커밋 메시지 기반 CHANGELOG 자동 생성

**구현 내용**:
```json
// .commitlintrc.json
{
  "extends": ["@commitlint/config-conventional"],
  "rules": {
    "type-enum": [
      2,
      "always",
      [
        "feat",
        "fix",
        "docs",
        "style",
        "refactor",
        "perf",
        "test",
        "chore",
        "revert",
        "build",
        "ci"
      ]
    ],
    "subject-case": [2, "always", "sentence-case"],
    "header-max-length": [2, "always", 100]
  }
}
```

```javascript
// .changelog.config.js
module.exports = {
  "types": [
    { "type": "feat", "section": "✨ Features", "hidden": false },
    { "type": "fix", "section": "🐛 Bug Fixes", "hidden": false },
    { "type": "perf", "section": "⚡ Performance", "hidden": false },
    { "type": "docs", "section": "📚 Documentation", "hidden": false },
    { "type": "style", "section": "💎 Styles", "hidden": true },
    { "type": "refactor", "section": "♻️ Refactoring", "hidden": false },
    { "type": "test", "section": "✅ Tests", "hidden": true },
    { "type": "chore", "section": "🔧 Chores", "hidden": true },
    { "type": "build", "section": "📦 Build", "hidden": true },
    { "type": "ci", "section": "👷 CI", "hidden": true }
  ],
  "releaseCommitMessageFormat": "chore(release): 🚀 v{{currentTag}}",
  "commitUrlFormat": "{{host}}/{{owner}}/{{repository}}/commit/{{hash}}",
  "compareUrlFormat": "{{host}}/{{owner}}/{{repository}}/compare/{{previousTag}}...{{currentTag}}",
  "issueUrlFormat": "{{host}}/{{owner}}/{{repository}}/issues/{{id}}",
  "userUrlFormat": "{{host}}/{{user}}",
  "issuePrefixes": ["#", "GH-"]
};
```

```yaml
# .github/workflows/changelog.yml
name: Generate Changelog

on:
  push:
    tags:
      - 'v*'

jobs:
  changelog:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Generate Changelog
        uses: orhun/git-cliff-action@v2
        with:
          config: .cliff.toml
          args: --verbose
        env:
          OUTPUT: CHANGELOG.md
      
      - name: Commit Changelog
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "docs: update CHANGELOG.md for ${{ github.ref_name }}"
          git push
```

**🔧 사용자 작업**:
- commitlint 설치: `npm install --save-dev @commitlint/cli @commitlint/config-conventional`
- husky 설정으로 커밋 메시지 검증
- 첫 릴리스 태그 생성 시 CHANGELOG 자동 생성 확인

---

## Task 0.9: 모니터링 및 로깅 시스템 구축

### SubTask 0.9.1: 구조화된 로깅 시스템 구현
**목표**: Winston 기반 구조화된 로깅 시스템

**구현 내용**:
```typescript
// backend/src/config/logger.ts
import winston from 'winston';
import { WinstonTransport as AxiomTransport } from '@axiomhq/winston';
import DailyRotateFile from 'winston-daily-rotate-file';

// 커스텀 로그 레벨
const customLevels = {
  levels: {
    fatal: 0,
    error: 1,
    warn: 2,
    info: 3,
    debug: 4,
    trace: 5
  },
  colors: {
    fatal: 'red bold',
    error: 'red',
    warn: 'yellow',
    info: 'green',
    debug: 'blue',
    trace: 'gray'
  }
};

// 로그 포맷
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
  winston.format.errors({ stack: true }),
  winston.format.metadata({ fillExcept: ['message', 'level', 'timestamp', 'label'] }),
  winston.format.json()
);

// 개발 환경용 포맷
const devFormat = winston.format.combine(
  winston.format.colorize({ all: true }),
  winston.format.printf(({ timestamp, level, message, metadata }) => {
    const meta = Object.keys(metadata).length ? JSON.stringify(metadata, null, 2) : '';
    return `${timestamp} [${level}]: ${message} ${meta}`;
  })
);

class Logger {
  private logger: winston.Logger;
  
  constructor(service: string) {
    this.logger = winston.createLogger({
      levels: customLevels.levels,
      defaultMeta: { service },
      transports: this.createTransports()
    });
    
    winston.addColors(customLevels.colors);
  }
  
  private createTransports(): winston.transport[] {
    const transports: winston.transport[] = [];
    
    // 콘솔 출력
    if (process.env.NODE_ENV !== 'test') {
      transports.push(new winston.transports.Console({
        level: process.env.LOG_LEVEL || 'debug',
        format: process.env.NODE_ENV === 'production' ? logFormat : devFormat
      }));
    }
    
    // 파일 로테이션
    if (process.env.NODE_ENV === 'production') {
      // 에러 로그
      transports.push(new DailyRotateFile({
        level: 'error',
        filename: 'logs/error-%DATE%.log',
        datePattern: 'YYYY-MM-DD',
        maxSize: '20m',
        maxFiles: '14d',
        format: logFormat
      }));
      
      // 전체 로그
      transports.push(new DailyRotateFile({
        filename: 'logs/combined-%DATE%.log',
        datePattern: 'YYYY-MM-DD',
        maxSize: '20m',
        maxFiles: '7d',
        format: logFormat
      }));
    }
    
    // Axiom (클라우드 로깅)
    if (process.env.AXIOM_TOKEN) {
      transports.push(new AxiomTransport({
        dataset: process.env.AXIOM_DATASET || 't-developer',
        token: process.env.AXIOM_TOKEN
      }));
    }
    
    return transports;
  }
  
  // 로깅 메서드들
  fatal(message: string, meta?: any): void {
    this.logger.log('fatal', message, meta);
  }
  
  error(message: string, error?: Error | any, meta?: any): void {
    this.logger.error(message, { error: error?.stack || error, ...meta });
  }
  
  warn(message: string, meta?: any): void {
    this.logger.warn(message, meta);
  }
  
  info(message: string, meta?: any): void {
    this.logger.info(message, meta);
  }
  
  debug(message: string, meta?: any): void {
    this.logger.debug(message, meta);
  }
  
  trace(message: string, meta?: any): void {
    this.logger.log('trace', message, meta);
  }
  
  // 성능 측정 헬퍼
  startTimer(): () => void {
    const start = Date.now();
    return () => {
      const duration = Date.now() - start;
      return { duration };
    };
  }
  
  // 에이전트 실행 로깅
  logAgentExecution(agentName: string, projectId: string, result: 'success' | 'failure', meta?: any): void {
    this.info(`Agent execution: ${agentName}`, {
      agentName,
      projectId,
      result,
      ...meta
    });
  }
}

// 싱글톤 인스턴스
export const logger = new Logger('t-developer-backend');

// 요청별 로거 생성
export function createRequestLogger(requestId: string): Logger {
  const requestLogger = new Logger('t-developer-request');
  requestLogger['logger'].defaultMeta = { ...requestLogger['logger'].defaultMeta, requestId };
  return requestLogger;
}
```
---

### SubTask 0.9.2: 메트릭 수집 시스템 구현
**목표**: Prometheus 형식의 메트릭 수집 및 노출

**구현 내용**:
```typescript
// backend/src/config/metrics.ts
import promClient from 'prom-client';
import { Request, Response, NextFunction } from 'express';

// Prometheus 레지스트리
const register = new promClient.Registry();

// 기본 메트릭 수집
promClient.collectDefaultMetrics({ 
  register,
  prefix: 't_developer_'
});

// 커스텀 메트릭 정의
export const metrics = {
  // HTTP 요청 관련
  httpRequestDuration: new promClient.Histogram({
    name: 't_developer_http_request_duration_seconds',
    help: 'Duration of HTTP requests in seconds',
    labelNames: ['method', 'route', 'status_code'],
    buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
  }),
  
  httpRequestTotal: new promClient.Counter({
    name: 't_developer_http_requests_total',
    help: 'Total number of HTTP requests',
    labelNames: ['method', 'route', 'status_code']
  }),
  
  // 에이전트 실행 관련
  agentExecutionDuration: new promClient.Histogram({
    name: 't_developer_agent_execution_duration_seconds',
    help: 'Duration of agent executions in seconds',
    labelNames: ['agent_name', 'status'],
    buckets: [1, 5, 10, 30, 60, 120, 300, 600]
  }),
  
  agentExecutionTotal: new promClient.Counter({
    name: 't_developer_agent_executions_total',
    help: 'Total number of agent executions',
    labelNames: ['agent_name', 'status']
  }),
  
  agentTokenUsage: new promClient.Counter({
    name: 't_developer_agent_token_usage_total',
    help: 'Total tokens used by agents',
    labelNames: ['agent_name', 'model']
  }),
  
  // 프로젝트 관련
  projectCreationDuration: new promClient.Histogram({
    name: 't_developer_project_creation_duration_seconds',
    help: 'Duration of project creation in seconds',
    labelNames: ['project_type', 'status'],
    buckets: [10, 30, 60, 120, 300, 600, 1200]
  }),
  
  activeProjects: new promClient.Gauge({
    name: 't_developer_active_projects',
    help: 'Number of currently active projects',
    labelNames: ['status']
  }),
  
  // 시스템 리소스
  cacheHitRate: new promClient.Gauge({
    name: 't_developer_cache_hit_rate',
    help: 'Cache hit rate percentage',
    labelNames: ['cache_type']
  }),
  
  queueSize: new promClient.Gauge({
    name: 't_developer_queue_size',
    help: 'Current size of job queues',
    labelNames: ['queue_name']
  }),
  
  // 비즈니스 메트릭
  componentUsage: new promClient.Counter({
    name: 't_developer_component_usage_total',
    help: 'Total usage of components',
    labelNames: ['component_name', 'version', 'language']
  }),
  
  apiKeyUsage: new promClient.Counter({
    name: 't_developer_api_key_usage_total',
    help: 'API key usage by user',
    labelNames: ['user_id', 'endpoint']
  })
};

// 모든 메트릭을 레지스트리에 등록
Object.values(metrics).forEach(metric => register.registerMetric(metric));

// Express 미들웨어
export function metricsMiddleware() {
  return (req: Request, res: Response, next: NextFunction) => {
    const start = Date.now();
    
    res.on('finish', () => {
      const duration = (Date.now() - start) / 1000;
      const route = req.route?.path || req.path;
      const labels = {
        method: req.method,
        route,
        status_code: res.statusCode.toString()
      };
      
      metrics.httpRequestDuration.observe(labels, duration);
      metrics.httpRequestTotal.inc(labels);
    });
    
    next();
  };
}

// 메트릭 엔드포인트
export function metricsEndpoint() {
  return async (req: Request, res: Response) => {
    res.set('Content-Type', register.contentType);
    const metrics = await register.metrics();
    res.end(metrics);
  };
}

// 메트릭 헬퍼 클래스
export class MetricsHelper {
  // 에이전트 실행 메트릭 기록
  static recordAgentExecution(
    agentName: string, 
    duration: number, 
    status: 'success' | 'failure',
    tokensUsed?: number,
    model?: string
  ): void {
    metrics.agentExecutionDuration.observe({ agent_name: agentName, status }, duration);
    metrics.agentExecutionTotal.inc({ agent_name: agentName, status });
    
    if (tokensUsed && model) {
      metrics.agentTokenUsage.inc({ agent_name: agentName, model }, tokensUsed);
    }
  }
  
  // 프로젝트 생성 메트릭 기록
  static recordProjectCreation(
    projectType: string,
    duration: number,
    status: 'success' | 'failure'
  ): void {
    metrics.projectCreationDuration.observe({ project_type: projectType, status }, duration);
  }
  
  // 캐시 히트율 업데이트
  static updateCacheHitRate(cacheType: string, hitRate: number): void {
    metrics.cacheHitRate.set({ cache_type: cacheType }, hitRate);
  }
  
  // 큐 크기 업데이트
  static updateQueueSize(queueName: string, size: number): void {
    metrics.queueSize.set({ queue_name: queueName }, size);
  }
  
  // 활성 프로젝트 수 업데이트
  static updateActiveProjects(counts: Record<string, number>): void {
    Object.entries(counts).forEach(([status, count]) => {
      metrics.activeProjects.set({ status }, count);
    });
  }
}
```

### SubTask 0.9.3: 분산 추적 시스템 설정
**목표**: OpenTelemetry를 이용한 분산 추적

**구현 내용**:
```typescript
// backend/src/config/tracing.ts
import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { JaegerExporter } from '@opentelemetry/exporter-jaeger';
import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { HttpInstrumentation } from '@opentelemetry/instrumentation-http';
import { ExpressInstrumentation } from '@opentelemetry/instrumentation-express';
import { AwsInstrumentation } from '@opentelemetry/instrumentation-aws-sdk';
import { RedisInstrumentation } from '@opentelemetry/instrumentation-redis';
import { trace, context, SpanStatusCode } from '@opentelemetry/api';

// 트레이서 프로바이더 생성
const provider = new NodeTracerProvider({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 't-developer',
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.npm_package_version || '1.0.0',
    [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV || 'development'
  })
});

// Jaeger 익스포터 설정
const jaegerExporter = new JaegerExporter({
  endpoint: process.env.JAEGER_ENDPOINT || 'http://localhost:14268/api/traces',
  serviceName: 't-developer'
});

// 배치 프로세서 추가
provider.addSpanProcessor(new BatchSpanProcessor(jaegerExporter));

// 프로바이더 등록
provider.register();

// 자동 계측 설정
registerInstrumentations({
  instrumentations: [
    new HttpInstrumentation({
      requestHook: (span, request) => {
        span.setAttributes({
          'http.request.body': JSON.stringify(request.body),
          'http.request.headers': JSON.stringify(request.headers)
        });
      }
    }),
    new ExpressInstrumentation(),
    new AwsInstrumentation({
      suppressInternalInstrumentation: true
    }),
    new RedisInstrumentation()
  ]
});

// 트레이서 인스턴스
export const tracer = trace.getTracer('t-developer', '1.0.0');

// 커스텀 스팬 생성 헬퍼
export class TracingHelper {
  // 에이전트 실행 추적
  static async traceAgentExecution<T>(
    agentName: string,
    projectId: string,
    operation: () => Promise<T>
  ): Promise<T> {
    return tracer.startActiveSpan(`agent.${agentName}.execute`, async (span) => {
      span.setAttributes({
        'agent.name': agentName,
        'project.id': projectId,
        'agent.start_time': new Date().toISOString()
      });
      
      try {
        const result = await operation();
        span.setStatus({ code: SpanStatusCode.OK });
        span.setAttributes({
          'agent.success': true,
          'agent.end_time': new Date().toISOString()
        });
        return result;
      } catch (error) {
        span.recordException(error as Error);
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error instanceof Error ? error.message : 'Unknown error'
        });
        throw error;
      } finally {
        span.end();
      }
    });
  }
  
  // 외부 API 호출 추적
  static async traceExternalCall<T>(
    serviceName: string,
    endpoint: string,
    operation: () => Promise<T>
  ): Promise<T> {
    return tracer.startActiveSpan(`external.${serviceName}`, async (span) => {
      span.setAttributes({
        'external.service': serviceName,
        'external.endpoint': endpoint,
        'external.timestamp': new Date().toISOString()
      });
      
      try {
        const result = await operation();
        span.setStatus({ code: SpanStatusCode.OK });
        return result;
      } catch (error) {
        span.recordException(error as Error);
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error instanceof Error ? error.message : 'Unknown error'
        });
        throw error;
      } finally {
        span.end();
      }
    });
  }
  
  // 데이터베이스 작업 추적
  static async traceDatabaseOperation<T>(
    operation: string,
    table: string,
    query: () => Promise<T>
  ): Promise<T> {
    return tracer.startActiveSpan(`db.${operation}`, async (span) => {
      span.setAttributes({
        'db.operation': operation,
        'db.table': table,
        'db.system': 'dynamodb'
      });
      
      const startTime = Date.now();
      
      try {
        const result = await query();
        const duration = Date.now() - startTime;
        
        span.setAttributes({
          'db.duration_ms': duration,
          'db.success': true
        });
        span.setStatus({ code: SpanStatusCode.OK });
        
        return result;
      } catch (error) {
        span.recordException(error as Error);
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error instanceof Error ? error.message : 'Unknown error'
        });
        throw error;
      } finally {
        span.end();
      }
    });
  }
  
  // 배치 작업 추적
  static createBatchSpan(operationName: string, batchSize: number) {
    const span = tracer.startSpan(`batch.${operationName}`);
    span.setAttributes({
      'batch.size': batchSize,
      'batch.start_time': new Date().toISOString()
    });
    
    return {
      recordItem: (index: number, success: boolean) => {
        span.addEvent(`item_processed`, {
          'item.index': index,
          'item.success': success
        });
      },
      end: (successCount: number) => {
        span.setAttributes({
          'batch.success_count': successCount,
          'batch.failure_count': batchSize - successCount,
          'batch.end_time': new Date().toISOString()
        });
        span.end();
      }
    };
  }
}

// 컨텍스트 전파 미들웨어
export function tracingMiddleware() {
  return (req: Request, res: Response, next: NextFunction) => {
    const span = tracer.startSpan(`http ${req.method} ${req.path}`);
    
    context.with(trace.setSpan(context.active(), span), () => {
      // 요청 ID를 스팬에 추가
      span.setAttributes({
        'http.request_id': req.id,
        'http.user_agent': req.headers['user-agent'] || 'unknown'
      });
      
      // 응답 완료 시 스팬 종료
      res.on('finish', () => {
        span.setAttributes({
          'http.status_code': res.statusCode,
          'http.response_size': res.get('content-length') || 0
        });
        span.setStatus({
          code: res.statusCode >= 400 ? SpanStatusCode.ERROR : SpanStatusCode.OK
        });
        span.end();
      });
      
      next();
    });
  };
}
```

### SubTask 0.9.4: 애플리케이션 성능 모니터링 (APM)
**목표**: 실시간 성능 모니터링 및 알림 시스템

**구현 내용**:
```typescript
// backend/src/monitoring/apm.ts
import { EventEmitter } from 'events';
import os from 'os';
import v8 from 'v8';

interface PerformanceMetrics {
  cpu: {
    usage: number;
    loadAverage: number[];
  };
  memory: {
    heapUsed: number;
    heapTotal: number;
    external: number;
    rss: number;
  };
  eventLoop: {
    delay: number;
    utilization: number;
  };
  gc: {
    count: number;
    duration: number;
    type: string;
  }[];
}

export class APMService extends EventEmitter {
  private metrics: PerformanceMetrics;
  private thresholds = {
    cpu: { warning: 70, critical: 90 },
    memory: { warning: 80, critical: 95 },
    eventLoopDelay: { warning: 100, critical: 500 }
  };
  private monitoringInterval: NodeJS.Timer | null = null;
  
  constructor() {
    super();
    this.initializeMetrics();
  }
  
  private initializeMetrics(): void {
    this.metrics = {
      cpu: { usage: 0, loadAverage: [0, 0, 0] },
      memory: { heapUsed: 0, heapTotal: 0, external: 0, rss: 0 },
      eventLoop: { delay: 0, utilization: 0 },
      gc: []
    };
  }
  
  start(intervalMs: number = 5000): void {
    if (this.monitoringInterval) {
      return;
    }
    
    // GC 모니터링 활성화
    if (global.gc) {
      const performanceObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          if (entry.entryType === 'gc') {
            this.metrics.gc.push({
              count: 1,
              duration: entry.duration,
              type: entry.detail?.kind || 'unknown'
            });
          }
        });
      });
      performanceObserver.observe({ entryTypes: ['gc'] });
    }
    
    // 주기적 메트릭 수집
    this.monitoringInterval = setInterval(() => {
      this.collectMetrics();
      this.checkThresholds();
      this.emit('metrics', this.metrics);
    }, intervalMs);
    
    // Event Loop 지연 측정
    this.measureEventLoopDelay();
  }
  
  stop(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }
  }
  
  private collectMetrics(): void {
    // CPU 메트릭
    const cpus = os.cpus();
    const cpuUsage = cpus.reduce((acc, cpu) => {
      const total = Object.values(cpu.times).reduce((a, b) => a + b, 0);
      const idle = cpu.times.idle;
      return acc + ((total - idle) / total) * 100;
    }, 0) / cpus.length;
    
    this.metrics.cpu = {
      usage: Math.round(cpuUsage),
      loadAverage: os.loadavg()
    };
    
    // 메모리 메트릭
    const memUsage = process.memoryUsage();
    this.metrics.memory = {
      heapUsed: memUsage.heapUsed,
      heapTotal: memUsage.heapTotal,
      external: memUsage.external,
      rss: memUsage.rss
    };
    
    // V8 힙 통계
    const heapStats = v8.getHeapStatistics();
    const heapUsedPercent = (heapStats.used_heap_size / heapStats.heap_size_limit) * 100;
    
    // 메모리 사용률 계산
    if (heapUsedPercent > this.thresholds.memory.critical) {
      this.emit('alert', {
        level: 'critical',
        type: 'memory',
        message: `Memory usage critical: ${heapUsedPercent.toFixed(2)}%`,
        value: heapUsedPercent
      });
    }
  }
  
  private measureEventLoopDelay(): void {
    let lastCheck = process.hrtime.bigint();
    
    setImmediate(() => {
      const delay = Number(process.hrtime.bigint() - lastCheck) / 1e6; // Convert to ms
      this.metrics.eventLoop.delay = delay;
      
      if (delay > this.thresholds.eventLoopDelay.critical) {
        this.emit('alert', {
          level: 'critical',
          type: 'eventLoop',
          message: `Event loop delay critical: ${delay.toFixed(2)}ms`,
          value: delay
        });
      }
      
      // 재귀적으로 계속 측정
      if (this.monitoringInterval) {
        this.measureEventLoopDelay();
      }
    });
  }
  
  private checkThresholds(): void {
    // CPU 임계값 확인
    if (this.metrics.cpu.usage > this.thresholds.cpu.critical) {
      this.emit('alert', {
        level: 'critical',
        type: 'cpu',
        message: `CPU usage critical: ${this.metrics.cpu.usage}%`,
        value: this.metrics.cpu.usage
      });
    } else if (this.metrics.cpu.usage > this.thresholds.cpu.warning) {
      this.emit('alert', {
        level: 'warning',
        type: 'cpu',
        message: `CPU usage warning: ${this.metrics.cpu.usage}%`,
        value: this.metrics.cpu.usage
      });
    }
  }
  
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }
  
  getHealthStatus(): { healthy: boolean; issues: string[] } {
    const issues: string[] = [];
    
    if (this.metrics.cpu.usage > this.thresholds.cpu.warning) {
      issues.push(`High CPU usage: ${this.metrics.cpu.usage}%`);
    }
    
    const heapUsedPercent = (this.metrics.memory.heapUsed / this.metrics.memory.heapTotal) * 100;
    if (heapUsedPercent > this.thresholds.memory.warning) {
      issues.push(`High memory usage: ${heapUsedPercent.toFixed(2)}%`);
    }
    
    if (this.metrics.eventLoop.delay > this.thresholds.eventLoopDelay.warning) {
      issues.push(`High event loop delay: ${this.metrics.eventLoop.delay.toFixed(2)}ms`);
    }
    
    return {
      healthy: issues.length === 0,
      issues
    };
  }
}

// APM 서비스 인스턴스
export const apmService = new APMService();

// Express 엔드포인트
export function apmEndpoints(app: Express): void {
  // 실시간 메트릭
  app.get('/api/monitoring/metrics', (req, res) => {
    res.json(apmService.getMetrics());
  });
  
  // 헬스 체크
  app.get('/api/monitoring/health', (req, res) => {
    const health = apmService.getHealthStatus();
    res.status(health.healthy ? 200 : 503).json(health);
  });
  
  // 메트릭 스트리밍 (SSE)
  app.get('/api/monitoring/stream', (req, res) => {
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    });
    
    const sendMetrics = (metrics: PerformanceMetrics) => {
      res.write(`data: ${JSON.stringify(metrics)}\n\n`);
    };
    
    apmService.on('metrics', sendMetrics);
    
    req.on('close', () => {
      apmService.removeListener('metrics', sendMetrics);
    });
  });
}
```

### SubTask 0.9.5: 알림 및 에스컬레이션 시스템
**목표**: 다양한 채널을 통한 알림 시스템 구축

**구현 내용**:
```typescript
// backend/src/monitoring/alerting.ts
import nodemailer from 'nodemailer';
import { WebClient } from '@slack/web-api';
import twilio from 'twilio';
import { logger } from '../config/logger';

interface Alert {
  id: string;
  level: 'info' | 'warning' | 'critical' | 'emergency';
  type: string;
  title: string;
  message: string;
  metadata?: Record<string, any>;
  timestamp: Date;
}

interface AlertChannel {
  send(alert: Alert): Promise<void>;
}

// 이메일 알림 채널
class EmailAlertChannel implements AlertChannel {
  private transporter: nodemailer.Transporter;
  
  constructor() {
    this.transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: parseInt(process.env.SMTP_PORT || '587'),
      secure: process.env.SMTP_SECURE === 'true',
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
      }
    });
  }
  
  async send(alert: Alert): Promise<void> {
    const levelColors = {
      info: '#0066cc',
      warning: '#ff9900',
      critical: '#ff0000',
      emergency: '#660000'
    };
    
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px;">
        <div style="background-color: ${levelColors[alert.level]}; color: white; padding: 20px;">
          <h2 style="margin: 0;">T-Developer Alert: ${alert.title}</h2>
        </div>
        <div style="padding: 20px; background-color: #f5f5f5;">
          <p><strong>Level:</strong> ${alert.level.toUpperCase()}</p>
          <p><strong>Type:</strong> ${alert.type}</p>
          <p><strong>Time:</strong> ${alert.timestamp.toISOString()}</p>
          <p><strong>Message:</strong></p>
          <p style="background-color: white; padding: 15px; border-left: 4px solid ${levelColors[alert.level]};">
            ${alert.message}
          </p>
          ${alert.metadata ? `
            <p><strong>Additional Details:</strong></p>
            <pre style="background-color: white; padding: 15px; overflow-x: auto;">
${JSON.stringify(alert.metadata, null, 2)}
            </pre>
          ` : ''}
        </div>
      </div>
    `;
    
    await this.transporter.sendMail({
      from: process.env.ALERT_FROM_EMAIL,
      to: process.env.ALERT_TO_EMAILS?.split(','),
      subject: `[${alert.level.toUpperCase()}] T-Developer: ${alert.title}`,
      html
    });
  }
}

// Slack 알림 채널
class SlackAlertChannel implements AlertChannel {
  private client: WebClient;
  private channel: string;
  
  constructor() {
    this.client = new WebClient(process.env.SLACK_BOT_TOKEN);
    this.channel = process.env.SLACK_ALERT_CHANNEL || '#alerts';
  }
  
  async send(alert: Alert): Promise<void> {
    const levelEmojis = {
      info: ':information_source:',
      warning: ':warning:',
      critical: ':rotating_light:',
      emergency: ':fire:'
    };
    
    const levelColors = {
      info: '#0066cc',
      warning: '#ff9900',
      critical: '#ff0000',
      emergency: '#660000'
    };
    
    await this.client.chat.postMessage({
      channel: this.channel,
      attachments: [{
        color: levelColors[alert.level],
        title: `${levelEmojis[alert.level]} ${alert.title}`,
        text: alert.message,
        fields: [
          {
            title: 'Level',
            value: alert.level.toUpperCase(),
            short: true
          },
          {
            title: 'Type',
            value: alert.type,
            short: true
          }
        ],
        footer: 'T-Developer Monitoring',
        ts: Math.floor(alert.timestamp.getTime() / 1000).toString()
      }]
    });
  }
}

// SMS 알림 채널 (긴급 알림용)
class SMSAlertChannel implements AlertChannel {
  private client: twilio.Twilio;
  
  constructor() {
    this.client = twilio(
      process.env.TWILIO_ACCOUNT_SID,
      process.env.TWILIO_AUTH_TOKEN
    );
  }
  
  async send(alert: Alert): Promise<void> {
    // 긴급 알림만 SMS로 전송
    if (alert.level !== 'critical' && alert.level !== 'emergency') {
      return;
    }
    
    const recipients = process.env.SMS_ALERT_NUMBERS?.split(',') || [];
    
    for (const to of recipients) {
      await this.client.messages.create({
        body: `T-Developer ${alert.level.toUpperCase()}: ${alert.title}\n${alert.message}`,
        from: process.env.TWILIO_PHONE_NUMBER,
        to
      });
    }
  }
}

// 알림 관리자
export class AlertManager {
  private channels: Map<string, AlertChannel> = new Map();
  private alertHistory: Alert[] = [];
  private alertCooldowns: Map<string, number> = new Map();
  
  constructor() {
    this.initializeChannels();
  }
  
  private initializeChannels(): void {
    if (process.env.SMTP_HOST) {
      this.channels.set('email', new EmailAlertChannel());
    }
    
    if (process.env.SLACK_BOT_TOKEN) {
      this.channels.set('slack', new SlackAlertChannel());
    }
    
    if (process.env.TWILIO_ACCOUNT_SID) {
      this.channels.set('sms', new SMSAlertChannel());
    }
  }
  
  async sendAlert(alert: Omit<Alert, 'id' | 'timestamp'>): Promise<void> {
    const fullAlert: Alert = {
      ...alert,
      id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date()
    };
    
    // 중복 알림 방지 (쿨다운)
    const cooldownKey = `${alert.type}:${alert.level}`;
    const lastAlert = this.alertCooldowns.get(cooldownKey);
    
    if (lastAlert && Date.now() - lastAlert < 300000) { // 5분 쿨다운
      logger.debug('Alert suppressed due to cooldown', { cooldownKey });
      return;
    }
    
    // 알림 기록
    this.alertHistory.push(fullAlert);
    this.alertCooldowns.set(cooldownKey, Date.now());
    
    // 로그 기록
    logger.warn('Alert triggered', fullAlert);
    
    // 레벨에 따른 채널 선택
    const channelsToUse = this.selectChannels(fullAlert.level);
    
    // 병렬로 알림 전송
    const sendPromises = channelsToUse.map(channelName => {
      const channel = this.channels.get(channelName);
      if (channel) {
        return channel.send(fullAlert).catch(error => {
          logger.error(`Failed to send alert via ${channelName}`, error);
        });
      }
    });
    
    await Promise.all(sendPromises);
  }
  
  private selectChannels(level: Alert['level']): string[] {
    switch (level) {
      case 'info':
        return ['slack'];
      case 'warning':
        return ['slack', 'email'];
      case 'critical':
        return ['slack', 'email', 'sms'];
      case 'emergency':
        return ['slack', 'email', 'sms'];
      default:
        return ['slack'];
    }
  }
  
  getRecentAlerts(limit: number = 50): Alert[] {
    return this.alertHistory
      .slice(-limit)
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
  }
  
  clearAlertHistory(): void {
    this.alertHistory = [];
    this.alertCooldowns.clear();
  }
}

// 알림 관리자 인스턴스
export const alertManager = new AlertManager();

// 사전 정의된 알림 템플릿
export const alertTemplates = {
  highCPU: (usage: number) => ({
    level: usage > 90 ? 'critical' as const : 'warning' as const,
    type: 'performance',
    title: 'High CPU Usage Detected',
    message: `CPU usage is at ${usage}%. This may impact system performance.`,
    metadata: { cpuUsage: usage }
  }),
  
  highMemory: (usage: number) => ({
    level: usage > 95 ? 'critical' as const : 'warning' as const,
    type: 'performance',
    title: 'High Memory Usage Detected',
    message: `Memory usage is at ${usage}%. Consider scaling or optimizing memory usage.`,
    metadata: { memoryUsage: usage }
  }),
  
  agentFailure: (agentName: string, error: string) => ({
    level: 'critical' as const,
    type: 'agent',
    title: `Agent Failure: ${agentName}`,
    message: `Agent ${agentName} has failed with error: ${error}`,
    metadata: { agentName, error }
  }),
  
  projectCreationFailure: (projectId: string, error: string) => ({
    level: 'warning' as const,
    type: 'project',
    title: 'Project Creation Failed',
    message: `Failed to create project ${projectId}: ${error}`,
    metadata: { projectId, error }
  })
};
```

**🔧 사용자 작업**:
- 모니터링 대시보드 URL 접속 확인
- Prometheus 메트릭 수집 확인: http://localhost:8000/metrics
- Jaeger UI 접속 확인: http://localhost:16686
- 알림 채널 환경 변수 설정 (Slack, Email 등)

---

## 📋 Phase 0 완료 체크리스트

### ✅ 완료된 작업
- [x] 개발 환경 초기 설정 (Task 0.1)
- [x] AWS 리소스 초기 설정 (Task 0.2)
- [x] 프로젝트 의존성 설치 (Task 0.3)
- [x] 보안 및 인증 기초 설정 (Task 0.4)
- [x] 테스트 환경 구축 (Task 0.5)
- [x] 로컬 개발 인프라 구성 (Task 0.6)
- [x] CI/CD 파이프라인 기초 설정 (Task 0.7)
- [x] 문서화 시스템 구축 (Task 0.8)
- [x] 모니터링 및 로깅 시스템 구축 (Task 0.9)

### 🎯 Phase 1 준비 완료

Phase 0의 모든 작업이 완료되었습니다. 이제 Phase 1: 코어 인프라 구축을 시작할 준비가 되었습니다.

**다음 단계**: Phase 1 문서 작성 및 구현 시작
```dockerfile
# backend/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM node:18-alpine
RUN apk add --no-cache dumb-init
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001

WORKDIR /app
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/package.json ./

USER nodejs
EXPOSE 8000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js || exit 1

ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/main.js"]
```

**🔧 사용자 작업**:
- GitHub 저장소에 secrets 설정 (SNYK_TOKEN, NPM_TOKEN)
- Docker registry 권한 설정
- 브랜치 보호 규칙 설정
### SubTask 0.7.4: 테스트 자동화 파이프라인 설정
**목표**: PR 및 머지 시 자동 테스트 실행 설정

**구현 내용**:
```yaml
# .github/workflows/test-automation.yml
name: Automated Testing Pipeline

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [main, develop]

jobs:
  test-matrix:
    name: Test Suite - ${{ matrix.test-suite }}
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        test-suite: [unit, integration, e2e]
        node-version: [18.x, 20.x]
    
    services:
      dynamodb:
        image: amazon/dynamodb-local
        ports:
          - 8000:8000
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: |
          cd backend
          npm ci
      
      - name: Run ${{ matrix.test-suite }} tests
        run: |
          cd backend
          npm run test:${{ matrix.test-suite }} -- --coverage
        timeout-minutes: 30
        env:
          NODE_ENV: test
          DYNAMODB_ENDPOINT: http://localhost:8000
          REDIS_HOST: localhost
      
      - name: Upload coverage reports
        if: matrix.node-version == '18.x'
        uses: actions/upload-artifact@v3
        with:
          name: coverage-${{ matrix.test-suite }}
          path: backend/coverage/
```

### SubTask 0.7.5: 의존성 업데이트 자동화
**목표**: 보안 취약점 및 의존성 업데이트 자동화

**구현 내용**:
```yaml
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/backend"
    schedule:
      interval: "daily"
    open-pull-requests-limit: 5
    groups:
      aws-sdk:
        patterns:
          - "@aws-sdk/*"
      development:
        patterns:
          - "@types/*"
          - "eslint*"
          - "prettier*"
          - "jest*"
    
  - package-ecosystem: "docker"
    directory: "/"
    schedule:
      interval: "weekly"
    
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
```

**🔧 사용자 작업**:
- GitHub 저장소에 secrets 설정 (SNYK_TOKEN, NPM_TOKEN)
- Docker registry 권한 설정
- 브랜치 보호 규칙 설정
- Dependabot 활성화