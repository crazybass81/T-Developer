#### SubTask 2.6.4: 롤백 및 복구 메커니즘
**담당자**: 재해 복구 전문가  
**예상 소요시간**: 10시간

**작업 내용**:
```typescript
// backend/src/data/migration/rollback-recovery.ts
export class RollbackRecoveryManager {
  private snapshotManager: SnapshotManager;
  private auditLog: AuditLog;
  private recoveryOrchestrator: RecoveryOrchestrator;
  
  constructor(
    private dataSource: DataSource,
    private options: RecoveryOptions
  ) {
    this.snapshotManager = new SnapshotManager(dataSource);
    this.auditLog = new AuditLog();
    this.recoveryOrchestrator = new RecoveryOrchestrator();
  }

  // 스냅샷 생성
  async createSnapshot(
    snapshotId: string,
    metadata?: SnapshotMetadata
  ): Promise<Snapshot> {
    const snapshot: Snapshot = {
      id: snapshotId,
      timestamp: new Date(),
      metadata: {
        ...metadata,
        dataVersion: await this.dataSource.getCurrentVersion(),
        itemCount: await this.dataSource.getItemCount()
      },
      status: 'in_progress'
    };

    try {
      // 스냅샷 생성 시작
      await this.auditLog.log('snapshot_started', snapshot);

      // 데이터 백업
      const backupResult = await this.snapshotManager.backup(
        snapshotId,
        {
          compression: this.options.compression || 'gzip',
          encryption: this.options.encryption,
          parallelism: this.options.backupParallelism || 5
        }
      );

      snapshot.status = 'completed';
      snapshot.size = backupResult.totalSize;
      snapshot.location = backupResult.location;

      await this.auditLog.log('snapshot_completed', snapshot);

      return snapshot;

    } catch (error) {
      snapshot.status = 'failed';
      snapshot.error = error.message;
      
      await this.auditLog.log('snapshot_failed', snapshot);
      throw error;
    }
  }

  // 자동 스냅샷 스케줄링
  async scheduleAutoSnapshots(
    schedule: SnapshotSchedule
  ): Promise<void> {
    const scheduler = new CronScheduler();
    
    scheduler.schedule(schedule.cronExpression, async () => {
      try {
        const snapshotId = `auto-${Date.now()}`;
        await this.createSnapshot(snapshotId, {
          type: 'scheduled',
          retention: schedule.retention
        });

        // 오래된 스냅샷 정리
        await this.cleanupOldSnapshots(schedule.retention);
        
      } catch (error) {
        await this.notifySnapshotFailure(error);
      }
    });
  }

  // 포인트 인 타임 복구
  async performPointInTimeRecovery(
    targetTime: Date,
    options?: RecoveryOptions
  ): Promise<RecoveryResult> {
    // 1. 가장 가까운 스냅샷 찾기
    const snapshot = await this.findNearestSnapshot(targetTime);
    
    if (!snapshot) {
      throw new Error('No suitable snapshot found for recovery');
    }

    // 2. 스냅샷 복원
    const restoreResult = await this.restoreSnapshot(
      snapshot.id,
      options
    );

    // 3. 변경 로그 재생
    if (snapshot.timestamp < targetTime) {
      await this.replayChangeLogs(
        snapshot.timestamp,
        targetTime,
        restoreResult.restoredData
      );
    }

    return {
      success: true,
      snapshotUsed: snapshot.id,
      recoveredToTime: targetTime,
      itemsRecovered: restoreResult.itemCount,
      duration: restoreResult.duration
    };
  }

  // 스냅샷 복원
  async restoreSnapshot(
    snapshotId: string,
    options?: RestoreOptions
  ): Promise<RestoreResult> {
    const startTime = Date.now();
    
    try {
      // 복원 전 검증
      if (options?.validate) {
        await this.validateSnapshot(snapshotId);
      }

      // 복원 대상 준비
      if (options?.clearTarget) {
        await this.clearTargetData();
      }

      // 스냅샷 데이터 복원
      const result = await this.snapshotManager.restore(
        snapshotId,
        {
          targetTable: options?.targetTable,
          parallelism: options?.restoreParallelism || 10,
          transformFn: options?.transformFn
        }
      );

      // 복원 후 검증
      if (options?.postValidation) {
        await this.validateRestoredData(result);
      }

      return {
        success: true,
        itemCount: result.restoredItems,
        duration: Date.now() - startTime,
        warnings: result.warnings || []
      };

    } catch (error) {
      await this.handleRestoreFailure(error, snapshotId);
      throw error;
    }
  }

  // 변경 로그 재생
  private async replayChangeLogs(
    fromTime: Date,
    toTime: Date,
    targetData: any
  ): Promise<void> {
    const changeLogs = await this.getChangeLogs(fromTime, toTime);
    
    for (const log of changeLogs) {
      try {
        await this.applyChange(log, targetData);
      } catch (error) {
        if (this.options.stopOnError) {
          throw error;
        }
        await this.logChangeApplicationError(log, error);
      }
    }
  }

  // 부분 롤백
  async performPartialRollback(
    criteria: RollbackCriteria
  ): Promise<PartialRollbackResult> {
    const affectedItems = await this.identifyAffectedItems(criteria);
    const rollbackPlan = await this.createRollbackPlan(affectedItems);

    // 롤백 실행
    const results: ItemRollbackResult[] = [];
    
    for (const item of rollbackPlan.items) {
      try {
        const previousVersion = await this.getPreviousVersion(
          item.id,
          criteria.beforeTime
        );
        
        if (previousVersion) {
          await this.restoreItem(item.id, previousVersion);
          results.push({
            itemId: item.id,
            status: 'success',
            rolledBackTo: previousVersion.version
          });
        }
      } catch (error) {
        results.push({
          itemId: item.id,
          status: 'failed',
          error: error.message
        });
      }
    }

    return {
      totalItems: affectedItems.length,
      successCount: results.filter(r => r.status === 'success').length,
      failureCount: results.filter(r => r.status === 'failed').length,
      results
    };
  }

  // 재해 복구 오케스트레이션
  async orchestrateDisasterRecovery(
    disaster: DisasterEvent
  ): Promise<DisasterRecoveryResult> {
    const plan = await this.recoveryOrchestrator.createPlan(disaster);
    
    // 1. 영향 평가
    const impact = await this.assessImpact(disaster);
    
    // 2. 복구 우선순위 결정
    const priorities = this.determinePriorities(impact);
    
    // 3. 복구 실행
    const recoveryTasks = priorities.map(priority => 
      this.executeRecoveryTask(priority)
    );
    
    const results = await Promise.allSettled(recoveryTasks);
    
    // 4. 복구 검증
    const validation = await this.validateRecovery(results);
    
    return {
      disaster,
      impact,
      recoveryPlan: plan,
      results: results.map((r, i) => ({
        task: priorities[i],
        status: r.status,
        result: r.status === 'fulfilled' ? r.value : r.reason
      })),
      validation,
      totalRecoveryTime: Date.now() - disaster.occurredAt.getTime()
    };
  }

  // 복구 시뮬레이션
  async simulateRecovery(
    scenario: RecoveryScenario
  ): Promise<SimulationResult> {
    const simulator = new RecoverySimulator(this.dataSource);
    
    // 시나리오 실행
    const result = await simulator.run(scenario, {
      dryRun: true,
      collectMetrics: true
    });

    return {
      scenario: scenario.name,
      estimatedRecoveryTime: result.estimatedTime,
      estimatedDataLoss: result.dataLoss,
      requiredResources: result.resources,
      recommendations: this.generateRecommendations(result)
    };
  }

  // 연속 데이터 보호 (CDP)
  async enableContinuousDataProtection(): Promise<void> {
    const cdp = new ContinuousDataProtection({
      captureInterval: this.options.cdpInterval || 1000,
      retentionPeriod: this.options.cdpRetention || 7 * 24 * 60 * 60 * 1000 // 7일
    });

    // 변경 캡처 시작
    cdp.startCapture(this.dataSource, async (changes) => {
      await this.storeChanges(changes);
      
      // 실시간 복제
      if (this.options.realtimeReplication) {
        await this.replicateChanges(changes);
      }
    });

    // 정기적인 체크포인트
    cdp.scheduleCheckpoints(async () => {
      await this.createCheckpoint();
    });
  }
}

// 복구 시뮬레이터
class RecoverySimulator {
  constructor(private dataSource: DataSource) {}

  async run(
    scenario: RecoveryScenario,
    options: SimulationOptions
  ): Promise<SimulationMetrics> {
    const startTime = Date.now();
    const metrics: SimulationMetrics = {
      steps: [],
      estimatedTime: 0,
      dataLoss: 0,
      resources: {}
    };

    // 시나리오 단계별 실행
    for (const step of scenario.steps) {
      const stepResult = await this.simulateStep(step, options);
      metrics.steps.push(stepResult);
      metrics.estimatedTime += stepResult.duration;
    }

    // 리소스 계산
    metrics.resources = this.calculateRequiredResources(metrics.steps);

    return metrics;
  }

  private async simulateStep(
    step: RecoveryStep,
    options: SimulationOptions
  ): Promise<StepResult> {
    switch (step.type) {
      case 'restore_snapshot':
        return this.simulateSnapshotRestore(step);
      case 'replay_logs':
        return this.simulateLogReplay(step);
      case 'validate_data':
        return this.simulateValidation(step);
      default:
        throw new Error(`Unknown step type: ${step.type}`);
    }
  }
}
```

---

### Task 2.7: Redis 캐싱 시스템 구축

#### SubTask 2.7.1: 캐싱 레이어 아키텍처
**담당자**: 캐싱 전문가  
**예상 소요시간**: 10시간

**작업 내용**:
```typescript
// backend/src/cache/architecture/cache-layer.ts
export class CacheLayer {
  private redisCluster: RedisCluster;
  private cacheStrategies: Map<string, CacheStrategy>;
  private metrics: CacheMetrics;
  
  constructor(config: CacheLayerConfig) {
    this.redisCluster = new RedisCluster(config.redis);
    this.cacheStrategies = new Map();
    this.metrics = new CacheMetrics();
    
    this.initializeStrategies();
    this.setupHealthChecks();
  }

  // 캐시 전략 초기화
  private initializeStrategies(): void {
    // 엔티티별 캐싱 전략
    this.cacheStrategies.set('User', new UserCacheStrategy());
    this.cacheStrategies.set('Project', new ProjectCacheStrategy());
    this.cacheStrategies.set('Agent', new AgentCacheStrategy());
    this.cacheStrategies.set('Task', new TaskCacheStrategy());
    
    // 쿼리 결과 캐싱
    this.cacheStrategies.set('Query', new QueryResultCacheStrategy());
    
    // 집계 데이터 캐싱
    this.cacheStrategies.set('Aggregation', new AggregationCacheStrategy());
  }

  // 캐시 읽기
  async get<T>(
    key: string,
    options?: CacheGetOptions
  ): Promise<T | null> {
    const startTime = Date.now();
    
    try {
      // 멀티 레벨 캐시 확인
      const value = await this.getFromMultiLevel(key, options);
      
      if (value !== null) {
        this.metrics.recordHit(key, Date.now() - startTime);
        return value;
      }
      
      this.metrics.recordMiss(key, Date.now() - startTime);
      
      // 캐시 미스 시 로드
      if (options?.loader) {
        return await this.loadAndCache(key, options);
      }
      
      return null;
      
    } catch (error) {
      this.metrics.recordError(key, error);
      
      if (options?.fallbackToSource) {
        return await options.loader?.();
      }
      
      throw error;
    }
  }

  // 멀티 레벨 캐시 조회
  private async getFromMultiLevel(
    key: string,
    options?: CacheGetOptions
  ): Promise<any> {
    // L1: 로컬 메모리 캐시
    if (options?.useL1Cache !== false) {
      const l1Value = this.getFromL1(key);
      if (l1Value !== null) {
        return l1Value;
      }
    }
    
    // L2: Redis 캐시
    const l2Value = await this.getFromL2(key);
    if (l2Value !== null && options?.useL1Cache !== false) {
      // L1 캐시 업데이트
      this.setL1(key, l2Value, options?.l1Ttl);
    }
    
    return l2Value;
  }

  // 캐시 쓰기
  async set<T>(
    key: string,
    value: T,
    options?: CacheSetOptions
  ): Promise<void> {
    const strategy = this.getStrategy(key);
    const ttl = options?.ttl || strategy.getDefaultTTL();
    
    try {
      // 직렬화
      const serialized = await this.serialize(value, options);
      
      // 멀티 레벨 캐시 설정
      if (options?.useL1Cache !== false) {
        this.setL1(key, value, options?.l1Ttl || ttl / 10);
      }
      
      await this.setL2(key, serialized, ttl);
      
      // 캐시 워밍
      if (options?.warmRelated) {
        await this.warmRelatedCaches(key, value);
      }
      
      this.metrics.recordSet(key, serialized.length);
      
    } catch (error) {
      this.metrics.recordError(key, error);
      throw error;
    }
  }

  // 패턴 기반 무효화
  async invalidatePattern(
    pattern: string,
    options?: InvalidateOptions
  ): Promise<number> {
    const keys = await this.scanKeys(pattern);
    let invalidated = 0;
    
    // 배치 처리
    const batches = this.chunk(keys, 1000);
    
    for (const batch of batches) {
      if (options?.useL1Cache !== false) {
        batch.forEach(key => this.invalidateL1(key));
      }
      
      const deleted = await this.redisCluster.del(...batch);
      invalidated += deleted;
      
      // 이벤트 발행
      if (options?.publishEvent) {
        await this.publishInvalidationEvent(batch);
      }
    }
    
    this.metrics.recordInvalidation(pattern, invalidated);
    return invalidated;
  }

  // 캐시 통계
  async getStats(
    timeRange?: TimeRange
  ): Promise<CacheStatistics> {
    const stats = await this.metrics.getStats(timeRange);
    
    return {
      hitRate: stats.hits / (stats.hits + stats.misses),
      missRate: stats.misses / (stats.hits + stats.misses),
      averageLatency: stats.totalLatency / stats.totalRequests,
      totalRequests: stats.totalRequests,
      cacheSize: await this.getCacheSize(),
      evictionRate: stats.evictions / stats.totalRequests,
      errorRate: stats.errors / stats.totalRequests,
      topMissedKeys: stats.topMissedKeys,
      breakdown: await this.getBreakdownByStrategy()
    };
  }

  // 캐시 예열
  async warmup(
    warmupConfig: WarmupConfig
  ): Promise<WarmupResult> {
    const warmer = new CacheWarmer(this);
    
    return await warmer.execute(warmupConfig, {
      onProgress: (progress) => {
        this.metrics.recordWarmupProgress(progress);
      }
    });
  }

  // 적응형 TTL
  private async calculateAdaptiveTTL(
    key: string,
    accessPattern: AccessPattern
  ): Promise<number> {
    const strategy = this.getStrategy(key);
    
    // 접근 빈도 기반 TTL 조정
    if (accessPattern.frequency === 'high') {
      return strategy.getDefaultTTL() * 2;
    } else if (accessPattern.frequency === 'low') {
      return strategy.getDefaultTTL() / 2;
    }
    
    // 변경 빈도 기반 TTL 조정
    if (accessPattern.volatility === 'high') {
      return Math.min(strategy.getDefaultTTL(), 300); // 최대 5분
    }
    
    return strategy.getDefaultTTL();
  }
}

// 캐싱 전략 인터페이스
export abstract class CacheStrategy {
  abstract getDefaultTTL(): number;
  abstract getCacheKey(params: any): string;
  abstract shouldCache(value: any): boolean;
  abstract onCacheMiss(key: string): Promise<void>;
  abstract onCacheHit(key: string): Promise<void>;
}

// User 캐싱 전략
export class UserCacheStrategy extends CacheStrategy {
  getDefaultTTL(): number {
    return 3600; // 1시간
  }
  
  getCacheKey(params: { userId: string }): string {
    return `user:${params.userId}`;
  }
  
  shouldCache(user: User): boolean {
    // 활성 사용자만 캐시
    return user.status === 'active';
  }
  
  async onCacheMiss(key: string): Promise<void> {
    // 캐시 미스 시 프리페치
    const userId = key.split(':')[1];
    await this.prefetchRelatedData(userId);
  }
  
  private async prefetchRelatedData(userId: string): Promise<void> {
    // 사용자의 프로젝트 프리페치
    await this.prefetchUserProjects(userId);
  }
}

// 분산 캐시 관리
export class DistributedCacheManager {
  private nodes: CacheNode[];
  private consistentHash: ConsistentHash;
  
  constructor(config: DistributedCacheConfig) {
    this.nodes = config.nodes.map(n => new CacheNode(n));
    this.consistentHash = new ConsistentHash(this.nodes);
  }

  async get(key: string): Promise<any> {
    const node = this.consistentHash.getNode(key);
    
    try {
      return await node.get(key);
    } catch (error) {
      // 폴백 노드 시도
      const fallbackNode = this.consistentHash.getNextNode(key);
      return await fallbackNode.get(key);
    }
  }

  // 노드 추가/제거 시 리밸런싱
  async rebalance(): Promise<void> {
    const migrations = this.consistentHash.calculateMigrations();
    
    for (const migration of migrations) {
      await this.migrateKeys(
        migration.fromNode,
        migration.toNode,
        migration.keys
      );
    }
  }
}

// 캐시 일관성 관리
export class CacheConsistencyManager {
  private invalidationQueue: Queue;
  private versionManager: VersionManager;
  
  // Write-through 캐싱
  async writeThrough(
    key: string,
    value: any,
    writer: DataWriter
  ): Promise<void> {
    // 1. 데이터베이스 쓰기
    await writer.write(key, value);
    
    // 2. 캐시 업데이트
    await this.cache.set(key, value);
    
    // 3. 관련 캐시 무효화
    await this.invalidateRelated(key);
  }

  // Write-behind 캐싱
  async writeBehind(
    key: string,
    value: any,
    writer: DataWriter
  ): Promise<void> {
    // 1. 캐시 즉시 업데이트
    await this.cache.set(key, value);
    
    // 2. 비동기 데이터베이스 쓰기
    this.writeQueue.push({
      key,
      value,
      writer,
      timestamp: Date.now()
    });
  }

  // 버전 기반 일관성
  async versionedGet(key: string): Promise<VersionedData> {
    const cached = await this.cache.get(key);
    
    if (cached) {
      const currentVersion = await this.versionManager.getVersion(key);
      
      if (cached.version === currentVersion) {
        return cached;
      }
      
      // 버전 불일치 시 재로드
      await this.cache.invalidate(key);
    }
    
    return null;
  }
}
```

#### SubTask 2.7.2: 캐시 무효화 전략
**담당자**: 백엔드 개발자  
**예상 소요시간**: 10시간

**작업 내용**:
```typescript
// backend/src/cache/invalidation/invalidation-strategy.ts
export class CacheInvalidationManager {
  private invalidationStrategies: Map<string, InvalidationStrategy>;
  private eventBus: EventBus;
  private dependencyGraph: DependencyGraph;
  
  constructor(
    private cache: CacheLayer,
    private config: InvalidationConfig
  ) {
    this.invalidationStrategies = new Map();
    this.eventBus = new EventBus();
    this.dependencyGraph = new DependencyGraph();
    
    this.initializeStrategies();
    this.setupEventListeners();
  }

  // 무효화 전략 초기화
  private initializeStrategies(): void {
    // TTL 기반 무효화
    this.registerStrategy('ttl', new TTLInvalidationStrategy());
    
    // 이벤트 기반 무효화
    this.registerStrategy('event', new EventBasedInvalidationStrategy());
    
    // 태그 기반 무효화
    this.registerStrategy('tag', new TagBasedInvalidationStrategy());
    
    // 의존성 기반 무효화
    this.registerStrategy('dependency', new DependencyInvalidationStrategy());
    
    // 스마트 무효화
    this.registerStrategy('smart', new SmartInvalidationStrategy());
  }

  // 엔티티 업데이트 시 무효화
  async invalidateOnUpdate(
    entity: string,
    id: string,
    changes: any
  ): Promise<InvalidationResult> {
    const startTime = Date.now();
    const invalidated: string[] = [];

    try {
      // 1. 직접 캐시 무효화
      const directKey = `${entity}:${id}`;
      await this.cache.invalidate(directKey);
      invalidated.push(directKey);

      // 2. 관련 쿼리 캐시 무효화
      const queryKeys = await this.findRelatedQueryCaches(entity, id);
      for (const key of queryKeys) {
        await this.cache.invalidate(key);
        invalidated.push(key);
      }

      // 3. 의존성 그래프 기반 무효화
      const dependencies = this.dependencyGraph.getDependencies(directKey);
      for (const dep of dependencies) {
        await this.cache.invalidate(dep);
        invalidated.push(dep);
      }

      // 4. 계단식 무효화
      if (this.shouldCascade(entity, changes)) {
        const cascaded = await this.cascadeInvalidation(entity, id);
        invalidated.push(...cascaded);
      }

      // 5. 이벤트 발행
      await this.publishInvalidationEvent({
        entity,
        id,
        invalidatedKeys: invalidated,
        reason: 'update'
      });

      return {
        success: true,
        invalidatedCount: invalidated.length,
        duration: Date.now() - startTime,
        keys: invalidated
      };

    } catch (error) {
      return {
        success: false,
        error: error.message,
        duration: Date.now() - startTime,
        keys: invalidated
      };
    }
  }

  // 태그 기반 무효화
  async invalidateByTags(
    tags: string[]
  ): Promise<InvalidationResult> {
    const strategy = this.invalidationStrategies.get('tag') as TagBasedInvalidationStrategy;
    const keysToInvalidate = new Set<string>();

    // 각 태그에 대한 키 수집
    for (const tag of tags) {
      const keys = await strategy.getKeysByTag(tag);
      keys.forEach(key => keysToInvalidate.add(key));
    }

    // 배치 무효화
    const invalidated = await this.batchInvalidate(
      Array.from(keysToInvalidate)
    );

    return {
      success: true,
      invalidatedCount: invalidated.length,
      tags,
      keys: invalidated
    };
  }

  // 스마트 무효화
  async smartInvalidate(
    context: InvalidationContext
  ): Promise<SmartInvalidationResult> {
    const strategy = this.invalidationStrategies.get('smart') as SmartInvalidationStrategy;
    
    // 무효화 영향 분석
    const impact = await strategy.analyzeImpact(context);
    
    // 무효화 결정
    const decision = await strategy.makeDecision(impact);
    
    if (decision.shouldInvalidate) {
      // 선택적 무효화
      const results = await this.selectiveInvalidate(
        decision.keys,
        decision.priority
      );
      
      return {
        success: true,
        decision,
        impact,
        results,
        optimizationApplied: decision.optimizations
      };
    }
    
    return {
      success: true,
      decision,
      impact,
      results: [],
      optimizationApplied: []
    };
  }

  // 의존성 그래프 구축
  async buildDependencyGraph(
    entities: EntityRelation[]
  ): Promise<void> {
    for (const relation of entities) {
      this.dependencyGraph.addRelation(
        relation.parent,
        relation.child,
        relation.type
      );
    }
    
    // 순환 의존성 감지
    const cycles = this.dependencyGraph.detectCycles();
    if (cycles.length > 0) {
      throw new Error(`Circular dependencies detected: ${cycles.join(', ')}`);
    }
  }

  // 배치 무효화 최적화
  private async batchInvalidate(
    keys: string[]
  ): Promise<string[]> {
    const batchSize = this.config.batchSize || 1000;
    const invalidated: string[] = [];
    
    // Pipeline 사용
    const pipeline = this.cache.pipeline();
    
    for (let i = 0; i < keys.length; i += batchSize) {
      const batch = keys.slice(i, i + batchSize);
      
      for (const key of batch) {
        pipeline.del(key);
      }
      
      await pipeline.exec();
      invalidated.push(...batch);
      
      // 진행 상황 알림
      if (this.config.onProgress) {
        this.config.onProgress({
          processed: invalidated.length,
          total: keys.length
        });
      }
    }
    
    return invalidated;
  }

  // 계단식 무효화
  private async cascadeInvalidation(
    entity: string,
    id: string
  ): Promise<string[]> {
    const cascaded: string[] = [];
    const visited = new Set<string>();
    const queue = [`${entity}:${id}`];
    
    while (queue.length > 0) {
      const current = queue.shift()!;
      
      if (visited.has(current)) continue;
      visited.add(current);
      
      const children = this.dependencyGraph.getChildren(current);
      
      for (const child of children) {
        await this.cache.invalidate(child);
        cascaded.push(child);
        queue.push(child);
      }
    }
    
    return cascaded;
  }

  // 무효화 이벤트 리스너
  private setupEventListeners(): void {
    // 데이터 변경 이벤트
    this.eventBus.on('data:updated', async (event) => {
      await this.invalidateOnUpdate(
        event.entity,
        event.id,
        event.changes
      );
    });
    
    // 일괄 변경 이벤트
    this.eventBus.on('data:bulk-updated', async (event) => {
      await this.invalidateByTags(event.tags);
    });
    
    // 시스템 이벤트
    this.eventBus.on('cache:flush-requested', async (event) => {
      await this.flushCache(event.pattern);
    });
  }
}

// 태그 기반 무효화 전략
export class TagBasedInvalidationStrategy implements InvalidationStrategy {
  private tagIndex: Map<string, Set<string>> = new Map();
  
  async addTags(key: string, tags: string[]): Promise<void> {
    for (const tag of tags) {
      if (!this.tagIndex.has(tag)) {
        this.tagIndex.set(tag, new Set());
      }
      this.tagIndex.get(tag)!.add(key);
    }
    
    // Redis에도 태그 정보 저장
    await this.persistTagMapping(key, tags);
  }
  
  async getKeysByTag(tag: string): Promise<string[]> {
    // 메모리에서 먼저 확인
    if (this.tagIndex.has(tag)) {
      return Array.from(this.tagIndex.get(tag)!);
    }
    
    // Redis에서 로드
    return await this.loadKeysFromRedis(tag);
  }
  
  async invalidateByTag(tag: string): Promise<string[]> {
    const keys = await this.getKeysByTag(tag);
    const invalidated: string[] = [];
    
    for (const key of keys) {
      await this.cache.invalidate(key);
      invalidated.push(key);
    }
    
    // 태그 인덱스 정리
    this.tagIndex.delete(tag);
    
    return invalidated;
  }
}

// 스마트 무효화 전략
export class SmartInvalidationStrategy implements InvalidationStrategy {
  private ml: InvalidationMLModel;
  private metrics: InvalidationMetrics;
  
  constructor() {
    this.ml = new InvalidationMLModel();
    this.metrics = new InvalidationMetrics();
  }
  
  async analyzeImpact(
    context: InvalidationContext
  ): Promise<InvalidationImpact> {
    // 접근 패턴 분석
    const accessPattern = await this.analyzeAccessPattern(context.key);
    
    // 비용 계산
    const cost = this.calculateInvalidationCost(context);
    
    // 이익 계산
    const benefit = this.calculateInvalidationBenefit(context);
    
    // ML 예측
    const prediction = await this.ml.predict({
      context,
      accessPattern,
      historicalData: await this.metrics.getHistoricalData(context.key)
    });
    
    return {
      accessPattern,
      cost,
      benefit,
      prediction,
      score: benefit / cost
    };
  }
  
  async makeDecision(
    impact: InvalidationImpact
  ): Promise<InvalidationDecision> {
    const threshold = this.config.decisionThreshold || 1.5;
    
    if (impact.score < threshold) {
      // 무효화 지연 또는 스킵
      return {
        shouldInvalidate: false,
        reason: 'Low benefit-to-cost ratio',
        alternativeAction: 'refresh_on_next_access'
      };
    }
    
    // 무효화 최적화 결정
    const optimizations = this.determineOptimizations(impact);
    
    return {
      shouldInvalidate: true,
      keys: await this.selectKeysToInvalidate(impact),
      priority: this.calculatePriority(impact),
      optimizations
    };
  }
  
  private determineOptimizations(
    impact: InvalidationImpact
  ): InvalidationOptimization[] {
    const optimizations: InvalidationOptimization[] = [];
    
    // 부분 무효화
    if (impact.accessPattern.hotKeys.length > 0) {
      optimizations.push({
        type: 'partial',
        description: 'Invalidate only hot keys',
        keys: impact.accessPattern.hotKeys
      });
    }
    
    // 지연 무효화
    if (impact.accessPattern.peakHours.includes(new Date().getHours())) {
      optimizations.push({
        type: 'delayed',
        description: 'Delay invalidation until off-peak hours',
        delayUntil: this.getNextOffPeakTime()
      });
    }
    
    // 점진적 무효화
    if (impact.cost > 1000) {
      optimizations.push({
        type: 'gradual',
        description: 'Gradual invalidation to reduce impact',
        phases: this.calculateGradualPhases(impact)
      });
    }
    
    return optimizations;
  }
}

// 무효화 메트릭 수집
export class InvalidationMetrics {
  async trackInvalidation(
    event: InvalidationEvent
  ): Promise<void> {
    await this.recordMetrics({
      timestamp: Date.now(),
      keys: event.keys,
      reason: event.reason,
      duration: event.duration,
      impact: {
        cacheHitRateBefore: await this.getCacheHitRate(),
        estimatedCacheMisses: event.keys.length
      }
    });
  }
  
  async analyzeInvalidationPatterns(): Promise<PatternAnalysis> {
    const data = await this.getInvalidationHistory();
    
    return {
      frequentPatterns: this.findFrequentPatterns(data),
      timeBasedPatterns: this.findTimePatterns(data),
      correlations: this.findCorrelations(data),
      anomalies: this.detectAnomalies(data)
    };
  }
}
```

#### SubTask 2.7.3: 분산 캐싱 및 동기화
**담당자**: 분산 시스템 엔지니어  
**예상 소요시간**: 12시간

**작업 내용**:
```typescript
// backend/src/cache/distributed/distributed-cache.ts
export class DistributedCache {
  private nodes: RedisNode[];
  private hashRing: ConsistentHashRing;
  private replicationManager: ReplicationManager;
  private gossipProtocol: GossipProtocol;
  
  constructor(config: DistributedCacheConfig) {
    this.nodes = this.initializeNodes(config.nodes);
    this.hashRing = new ConsistentHashRing(
      this.nodes,
      config.virtualNodes || 150
    );
    this.replicationManager = new ReplicationManager(
      config.replicationFactor || 3
    );
    this.gossipProtocol = new GossipProtocol(this.nodes);
    
    this.startHealthMonitoring();
    this.startGossipProtocol();
  }

  // 분산 읽기
  async get(key: string): Promise<any> {
    const primaryNode = this.hashRing.getNode(key);
    
    try {
      // 주 노드에서 읽기
      const value = await primaryNode.get(key);
      if (value !== null) {
        return value;
      }
      
      // 복제본에서 읽기 (read repair)
      return await this.readFromReplicas(key);
      
    } catch (error) {
      // 장애 시 복제본에서 읽기
      if (error.code === 'NODE_DOWN') {
        return await this.readFromReplicas(key);
      }
      throw error;
    }
  }

  // 분산 쓰기
  async set(
    key: string,
    value: any,
    options?: DistributedSetOptions
  ): Promise<void> {
    const primaryNode = this.hashRing.getNode(key);
    const replicas = this.replicationManager.getReplicas(key);
    
    // 쓰기 일관성 수준
    const consistency = options?.consistency || 'quorum';
    
    switch (consistency) {
      case 'all':
        await this.writeToAll(key, value, [primaryNode, ...replicas]);
        break;
        
      case 'quorum':
        await this.writeWithQuorum(key, value, [primaryNode, ...replicas]);
        break;
        
      case 'one':
        await this.writeToOne(key, value, primaryNode);
        // 비동기 복제
        this.replicateAsync(key, value, replicas);
        break;
    }
    
    // 메타데이터 업데이트
    await this.updateMetadata(key, {
      version: Date.now(),
      node: primaryNode.id,
      replicas: replicas.map(r => r.id)
    });
  }

  // 쿼럼 쓰기
  private async writeWithQuorum(
    key: string,
    value: any,
    nodes: RedisNode[]
  ): Promise<void> {
    const quorumSize = Math.floor(nodes.length / 2) + 1;
    const promises = nodes.map(node => 
      node.set(key, value).catch(err => ({ error: err, node }))
    );
    
    const results = await Promise.all(promises);
    const successful = results.filter(r => !r.error).length;
    
    if (successful < quorumSize) {
      // 롤백
      await this.rollbackWrites(key, results);
      throw new Error('Quorum write failed');
    }
    
    // 실패한 노드에 대한 힌트 저장
    for (const result of results) {
      if (result.error) {
        await this.storeHintedHandoff(result.node, key, value);
      }
    }
  }

  // 노드 추가/제거
  async addNode(node: RedisNode): Promise<void> {
    // 1. 노드를 해시 링에 추가
    this.hashRing.addNode(node);
    this.nodes.push(node);
    
    // 2. 데이터 재분배 계산
    const migrations = this.calculateDataMigration(node, 'add');
    
    // 3. 데이터 마이그레이션
    await this.migrateData(migrations);
    
    // 4. 가십 프로토콜 업데이트
    this.gossipProtocol.announceNodeAddition(node);
  }

  async removeNode(nodeId: string): Promise<void> {
    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return;
    
    // 1. 데이터 재분배
    const migrations = this.calculateDataMigration(node, 'remove');
    await this.migrateData(migrations);
    
    // 2. 해시 링에서 제거
    this.hashRing.removeNode(nodeId);
    this.nodes = this.nodes.filter(n => n.id !== nodeId);
    
    // 3. 가십 프로토콜 업데이트
    this.gossipProtocol.announceNodeRemoval(nodeId);
  }

  // 데이터 마이그레이션
  private async migrateData(
    migrations: DataMigration[]
  ): Promise<void> {
    const migrationTasks = migrations.map(async (migration) => {
      const keys = await migration.sourceNode.scanKeys(
        migration.keyRange
      );
      
      // 배치 처리
      const batchSize = 100;
      for (let i = 0; i < keys.length; i += batchSize) {
        const batch = keys.slice(i, i + batchSize);
        const values = await migration.sourceNode.mget(batch);
        
        // 대상 노드에 쓰기
        await migration.targetNode.mset(
          batch.map((key, idx) => ({ key, value: values[idx] }))
        );
        
        // 진행 상황 추적
        this.trackMigrationProgress(migration, i + batch.length, keys.length);
      }
      
      // 소스에서 삭제 (선택적)
      if (migration.deleteFromSource) {
        await migration.sourceNode.del(...keys);
      }
    });
    
    await Promise.all(migrationTasks);
  }

  // 동기화 메커니즘
  async syncNodes(): Promise<SyncResult> {
    const syncTasks: SyncTask[] = [];
    
    // 각 노드 쌍에 대해 동기화 확인
    for (let i = 0; i < this.nodes.length; i++) {
      for (let j = i + 1; j < this.nodes.length; j++) {
        const task = await this.createSyncTask(
          this.nodes[i],
          this.nodes[j]
        );
        if (task.hasDifferences) {
          syncTasks.push(task);
        }
      }
    }
    
    // 동기화 실행
    const results = await Promise.all(
      syncTasks.map(task => this.executeSyncTask(task))
    );
    
    return {
      totalTasks: syncTasks.length,
      successful: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      syncedKeys: results.reduce((sum, r) => sum + r.keysSynced, 0)
    };
  }

  // Gossip 프로토콜
  private startGossipProtocol(): void {
    setInterval(async () => {
      // 랜덤 노드 선택
      const peer = this.selectRandomPeer();
      if (!peer) return;
      
      // 상태 교환
      const localState = await this.getLocalState();
      const peerState = await peer.exchangeState(localState);
      
      // 상태 병합
      await this.mergeStates(localState, peerState);
      
      // 멤버십 업데이트
      this.updateMembership(peerState.membership);
      
    }, this.config.gossipInterval || 1000);
  }

  // Anti-Entropy 복구
  async performAntiEntropy(): Promise<void> {
    const merkleTree = await this.buildMerkleTree();
    
    for (const peer of this.nodes) {
      if (peer.id === this.localNode.id) continue;
      
      const peerTree = await peer.getMerkleTree();
      const differences = merkleTree.compare(peerTree);
      
      if (differences.length > 0) {
        await this.reconcileDifferences(peer, differences);
      }
    }
  }

  // 읽기 복구
  private async readFromReplicas(key: string): Promise<any> {
    const replicas = this.replicationManager.getReplicas(key);
    const values: Array<{ value: any; version: number }> = [];
    
    // 모든 복제본에서 읽기
    for (const replica of replicas) {
      try {
        const result = await replica.getWithVersion(key);
        if (result) {
          values.push(result);
        }
      } catch (error) {
        // 복제본 읽기 실패 무시
      }
    }
    
    if (values.length === 0) {
      return null;
    }
    
    // 최신 버전 선택
    const latest = values.reduce((prev, curr) => 
      curr.version > prev.version ? curr : prev
    );
    
    // Read repair
    await this.repairInconsistencies(key, latest, replicas);
    
    return latest.value;
  }

  // 일관성 복구
  private async repairInconsistencies(
    key: string,
    correctValue: { value: any; version: number },
    nodes: RedisNode[]
  ): Promise<void> {
    const repairs = nodes.map(async (node) => {
      try {
        const current = await node.getWithVersion(key);
        if (!current || current.version < correctValue.version) {
          await node.setWithVersion(key, correctValue.value, correctValue.version);
        }
      } catch (error) {
        // 복구 실패 로깅
        this.logger.error(`Failed to repair ${key} on node ${node.id}`, error);
      }
    });
    
    await Promise.all(repairs);
  }

  // 분할 뇌 감지 및 해결
  async detectAndResolveSplitBrain(): Promise<void> {
    const partitions = await this.detectNetworkPartitions();
    
    if (partitions.length > 1) {
      // 분할 뇌 상황 감지
      this.logger.warn('Split brain detected', { partitions });
      
      // 리더 선출
      const leader = await this.electLeader(partitions);
      
      // 데이터 병합
      await this.mergePartitions(partitions, leader);
      
      // 네트워크 복구
      await this.healPartitions(partitions);
    }
  }
}

// 일관된 해싱 링
export class ConsistentHashRing {
  private ring: Map<number, RedisNode>;
  private sortedKeys: number[];
  
  constructor(
    nodes: RedisNode[],
    private virtualNodes: number = 150
  ) {
    this.ring = new Map();
    this.sortedKeys = [];
    
    nodes.forEach(node => this.addNode(node));
  }
  
  addNode(node: RedisNode): void {
    // 가상 노드 생성
    for (let i = 0; i < this.virtualNodes; i++) {
      const hash = this.hash(`${node.id}:${i}`);
      this.ring.set(hash, node);
    }
    
    // 정렬된 키 업데이트
    this.sortedKeys = Array.from(this.ring.keys()).sort((a, b) => a - b);
  }
  
  getNode(key: string): RedisNode {
    const hash = this.hash(key);
    
    // 이진 검색으로 노드 찾기
    let left = 0;
    let right = this.sortedKeys.length - 1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (this.sortedKeys[mid] === hash) {
        return this.ring.get(this.sortedKeys[mid])!;
      } else if (this.sortedKeys[mid] < hash) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    // 다음 노드 반환 (원형)
    const index = left % this.sortedKeys.length;
    return this.ring.get(this.sortedKeys[index])!;
  }
  
  private hash(key: string): number {
    // MurmurHash3 구현
    return murmur3(key);
  }
}

// 복제 관리자
export class ReplicationManager {
  constructor(private replicationFactor: number) {}
  
  getReplicas(key: string): RedisNode[] {
    const primaryNode = this.hashRing.getNode(key);
    const replicas: RedisNode[] = [];
    
    let currentNode = primaryNode;
    for (let i = 0; i < this.replicationFactor - 1; i++) {
      currentNode = this.hashRing.getNextNode(currentNode);
      if (!replicas.includes(currentNode)) {
        replicas.push(currentNode);
      }
    }
    
    return replicas;
  }
  
  async ensureReplication(
    key: string,
    value: any
  ): Promise<void> {
    const replicas = this.getReplicas(key);
    
    // 병렬 복제
    await Promise.all(
      replicas.map(replica => 
        replica.set(key, value).catch(err => {
          // 복제 실패 처리
          this.handleReplicationFailure(replica, key, value, err);
        })
      )
    );
  }
}
```

#### SubTask 2.7.4: 캐시 성능 최적화
**담당자**: 성능 엔지니어  
**예상 소요시간**: 10시간

**작업 내용**:
```typescript
// backend/src/cache/optimization/performance-optimizer.ts
export class CachePerformanceOptimizer {
  private metricsCollector: MetricsCollector;
  private analyzer: PerformanceAnalyzer;
  private tuner: CacheTuner;
  
  constructor(
    private cache: DistributedCache,
    private config: OptimizationConfig
  ) {
    this.metricsCollector = new MetricsCollector(cache);
    this.analyzer = new PerformanceAnalyzer();
    this.tuner = new CacheTuner(cache);
    
    this.startContinuousOptimization();
  }

  // 지속적 최적화
  private startContinuousOptimization(): void {
    setInterval(async () => {
      const metrics = await this.metricsCollector.collect();
      const analysis = await this.analyzer.analyze(metrics);
      
      if (analysis.needsOptimization) {
        await this.applyOptimizations(analysis.recommendations);
      }
    }, this.config.optimizationInterval || 300000); // 5분
  }

  // 메모리 최적화
  async optimizeMemory(): Promise<MemoryOptimizationResult> {
    const memoryStats = await this.cache.getMemoryStats();
    
    // 1. 메모리 단편화 분석
    const fragmentation = this.analyzeFragmentation(memoryStats);
    if (fragmentation.ratio > 1.4) {
      await this.defragmentMemory();
    }
    
    // 2. 퇴거 정책 최적화
    const evictionStats = await this.analyzeEvictionPatterns();
    const optimalPolicy = this.selectOptimalEvictionPolicy(evictionStats);
    await this.cache.setEvictionPolicy(optimalPolicy);
    
    // 3. 메모리 할당 최적화
    const allocation = this.calculateOptimalAllocation(memoryStats);
    await this.adjustMemoryAllocation(allocation);
    
    // 4. 압축 활성화
    if (memoryStats.pressure > 0.8) {
      await this.enableCompression();
    }
    
    return {
      fragmentationReduced: fragmentation.ratio > 1.4,
      evictionPolicyChanged: optimalPolicy !== memoryStats.currentPolicy,
      compressionEnabled: memoryStats.pressure > 0.8,
      memorySaved: await this.calculateMemorySaved()
    };
  }

  // 네트워크 최적화
  async optimizeNetwork(): Promise<NetworkOptimizationResult> {
    // 1. 배치 처리 최적화
    const batchConfig = await this.optimizeBatching();
    
    // 2. 파이프라이닝 설정
    const pipelineConfig = await this.optimizePipelining();
    
    // 3. 압축 프로토콜
    const compressionConfig = await this.selectCompressionProtocol();
    
    // 4. 연결 풀 조정
    const connectionConfig = await this.tuneConnectionPool();
    
    return {
      batchSize: batchConfig.optimalSize,
      pipelineDepth: pipelineConfig.depth,
      compressionEnabled: compressionConfig.enabled,
      connectionPoolSize: connectionConfig.poolSize,
      latencyReduction: await this.measureLatencyReduction()
    };
  }

  // 캐시 워밍 최적화
  async optimizeCacheWarming(): Promise<WarmingOptimizationResult> {
    const accessPatterns = await this.analyzer.getAccessPatterns();
    
    // 1. 핫 데이터 식별
    const hotData = this.identifyHotData(accessPatterns);
    
    // 2. 프리페치 전략
    const prefetchStrategy = this.createPrefetchStrategy(accessPatterns);
    
    // 3. 워밍 스케줄 최적화
    const warmingSchedule = this.optimizeWarmingSchedule(hotData);
    
    // 4. 적응형 워밍
    const adaptiveConfig = await this.configureAdaptiveWarming({
      hotData,
      prefetchStrategy,
      warmingSchedule
    });
    
    return {
      hotDataIdentified: hotData.length,
      prefetchRules: prefetchStrategy.rules,
      warmingSchedule,
      adaptiveConfig,
      hitRateImprovement: await this.measureHitRateImprovement()
    };
  }

  // 쿼리 최적화
  async optimizeQueries(): Promise<QueryOptimizationResult> {
    const queryStats = await this.metricsCollector.getQueryStats();
    
    // 1. 느린 쿼리 분석
    const slowQueries = this.identifySlowQueries(queryStats);
    
    // 2. 쿼리 패턴 최적화
    const optimizedPatterns = await this.optimizeQueryPatterns(slowQueries);
    
    // 3. 인덱스 추천
    const indexRecommendations = this.recommendIndexes(queryStats);
    
    // 4. 쿼리 재작성
    const rewrittenQueries = await this.rewriteQueries(slowQueries);
    
    return {
      slowQueriesOptimized: slowQueries.length,
      patternsOptimized: optimizedPatterns.length,
      indexesRecommended: indexRecommendations,
      queriesRewritten: rewrittenQueries.length,
      performanceGain: await this.measureQueryPerformanceGain()
    };
  }

  // 적응형 TTL 조정
  async adjustTTLDynamically(): Promise<void> {
    const ttlAnalyzer = new TTLAnalyzer(this.cache);
    
    // 각 키 패턴별 분석
    const patterns = await ttlAnalyzer.analyzeKeyPatterns();
    
    for (const pattern of patterns) {
      const optimalTTL = await this.calculateOptimalTTL(pattern);
      
      // TTL 조정
      await this.cache.adjustPatternTTL(
        pattern.pattern,
        optimalTTL
      );
      
      // 모니터링
      this.monitorTTLEffectiveness(pattern.pattern, optimalTTL);
    }
  }

  // 최적 TTL 계산
  private async calculateOptimalTTL(
    pattern: KeyPattern
  ): Promise<number> {
    const factors = {
      accessFrequency: pattern.accessFrequency,
      updateFrequency: pattern.updateFrequency,
      dataVolatility: pattern.volatility,
      memoryPressure: await this.cache.getMemoryPressure(),
      hitRate: pattern.hitRate
    };
    
    // ML 모델을 사용한 TTL 예측
    const predictedTTL = await this.ttlPredictor.predict(factors);
    
    // 제약 조건 적용
    return Math.min(
      Math.max(predictedTTL, this.config.minTTL || 60),
      this.config.maxTTL || 86400
    );
  }

  // 메모리 단편화 해결
  private async defragmentMemory(): Promise<void> {
    const strategy = this.config.defragStrategy || 'active';
    
    switch (strategy) {
      case 'active':
        // 활성 조각 모음
        await this.performActiveDefragmentation();
        break;
        
      case 'lazy':
        // 지연 조각 모음
        await this.scheduleLazyDefragmentation();
        break;
        
      case 'restart':
        // 재시작 기반 조각 모음
        await this.performRollingRestart();
        break;
    }
  }

  // 압축 최적화
  private async enableCompression(): Promise<void> {
    const compressionAnalyzer = new CompressionAnalyzer();
    
    // 데이터 타입별 분석
    const dataTypes = await this.analyzeDataTypes();
    
    for (const dataType of dataTypes) {
      const algorithm = compressionAnalyzer.selectAlgorithm(dataType);
      
      await this.cache.enableCompression({
        pattern: dataType.pattern,
        algorithm,
        threshold: dataType.averageSize,
        level: this.selectCompressionLevel(dataType)
      });
    }
  }

  // 성능 병목 지점 분석
  async identifyBottlenecks(): Promise<Bottleneck[]> {
    const bottlenecks: Bottleneck[] = [];
    
    // CPU 병목
    const cpuStats = await this.metricsCollector.getCPUStats();
    if (cpuStats.usage > 0.8) {
      bottlenecks.push({
        type: 'cpu',
        severity: 'high',
        metrics: cpuStats,
        recommendations: ['Enable lazy deletion', 'Reduce background tasks']
      });
    }
    
    // 네트워크 병목
    const networkStats = await this.metricsCollector.getNetworkStats();
    if (networkStats.saturation > 0.7) {
      bottlenecks.push({
        type: 'network',
        severity: 'medium',
        metrics: networkStats,
        recommendations: ['Enable compression', 'Increase batching']
      });
    }
    
    // 메모리 병목
    const memoryStats = await this.metricsCollector.getMemoryStats();
    if (memoryStats.usage > 0.9) {
      bottlenecks.push({
        type: 'memory',
        severity: 'critical',
        metrics: memoryStats,
        recommendations: ['Adjust eviction policy', 'Scale horizontally']
      });
    }
    
    return bottlenecks;
  }

  // 자동 스케일링
  async autoScale(): Promise<ScalingResult> {
    const metrics = await this.metricsCollector.getScalingMetrics();
    const decision = this.makeScalingDecision(metrics);
    
    if (decision.shouldScale) {
      if (decision.direction === 'up') {
        return await this.scaleUp(decision.count);
      } else {
        return await this.scaleDown(decision.count);
      }
    }
    
    return { scaled: false };
  }

  private async scaleUp(count: number): Promise<ScalingResult> {
    const newNodes: RedisNode[] = [];
    
    for (let i = 0; i < count; i++) {
      const node = await this.provisionNewNode();
      await this.cache.addNode(node);
      newNodes.push(node);
    }
    
    // 데이터 리밸런싱
    await this.rebalanceData();
    
    return {
      scaled: true,
      direction: 'up',
      nodesAdded: newNodes.length,
      newCapacity: await this.cache.getTotalCapacity()
    };
  }
}

// 성능 분석기
export class PerformanceAnalyzer {
  async analyze(metrics: CacheMetrics): Promise<AnalysisResult> {
    const problems = this.identifyProblems(metrics);
    const recommendations = this.generateRecommendations(problems);
    
    return {
      needsOptimization: problems.length > 0,
      problems,
      recommendations,
      estimatedImprovement: this.estimateImprovement(recommendations)
    };
  }
  
  private identifyProblems(metrics: CacheMetrics): Problem[] {
    const problems: Problem[] = [];
    
    // 낮은 히트율
    if (metrics.hitRate < 0.8) {
      problems.push({
        type: 'low_hit_rate',
        severity: 'high',
        value: metrics.hitRate,
        threshold: 0.8
      });
    }
    
    // 높은 지연 시간
    if (metrics.p99Latency > 10) {
      problems.push({
        type: 'high_latency',
        severity: 'medium',
        value: metrics.p99Latency,
        threshold: 10
      });
    }
    
    // 높은 퇴거율
    if (metrics.evictionRate > 0.1) {
      problems.push({
        type: 'high_eviction',
        severity: 'high',
        value: metrics.evictionRate,
        threshold: 0.1
      });
    }
    
    return problems;
  }
}
```

---

### Task 2.8: 캐시 무효화 전략

#### SubTask 2.8.1: 이벤트 기반 무효화 시스템
**담당자**: 이벤트 주도 아키텍트  
**예상 소요시간**: 10시간

**작업 내용**:
```typescript
// backend/src/cache/invalidation/event-based-invalidation.ts
export class EventBasedInvalidationSystem {
  private eventStream: EventStream;
  private invalidationRules: InvalidationRuleEngine;
  private cascadeManager: CascadeInvalidationManager;
  
  constructor(
    private cache: CacheLayer,
    private eventBus: EventBus,
    private config: EventInvalidationConfig
  ) {
    this.eventStream = new EventStream(eventBus);
    this.invalidationRules = new InvalidationRuleEngine();
    this.cascadeManager = new CascadeInvalidationManager(cache);
    
    this.initializeEventHandlers();
    this.loadInvalidationRules();
  }

  // 이벤트 핸들러 초기화
  private initializeEventHandlers(): void {
    // 도메인 이벤트 구독
    this.eventStream.subscribe('domain.*', async (event) => {
      await this.handleDomainEvent(event);
    });
    
    // 시스템 이벤트 구독
    this.eventStream.subscribe('system.*', async (event) => {
      await this.handleSystemEvent(event);
    });
    
    // 커스텀 무효화 이벤트
    this.eventStream.subscribe('cache.invalidate.*', async (event) => {
      await this.handleInvalidationEvent(event);
    });
  }

  // 도메인 이벤트 처리
  private async handleDomainEvent(event: DomainEvent): Promise<void> {
    const rules = this.invalidationRules.getRulesForEvent(event.type);
    
    for (const rule of rules) {
      try {
        const keysToInvalidate = await rule.evaluate(event);
        
        if (keysToInvalidate.length > 0) {
          await this.performInvalidation(keysToInvalidate, {
            reason: `Domain event: ${event.type}`,
            cascade: rule.cascade,
            priority: rule.priority
          });
        }
      } catch (error) {
        this.logger.error(`Rule evaluation failed: ${rule.id}`, error);
      }
    }
  }

  // 무효화 규칙 엔진
  class InvalidationRuleEngine {
    private rules: Map<string, InvalidationRule[]> = new Map();
    
    // 규칙 등록
    registerRule(rule: InvalidationRule): void {
      const eventType = rule.eventPattern;
      
      if (!this.rules.has(eventType)) {
        this.rules.set(eventType, []);
      }
      
      this.rules.get(eventType)!.push(rule);
    }
    
    // 동적 규칙 평가
    async evaluate(
      event: DomainEvent,
      rule: InvalidationRule
    ): Promise<string[]> {
      const context = this.buildContext(event);
      const keysToInvalidate: string[] = [];
      
      // 조건 평가
      if (await this.evaluateCondition(rule.condition, context)) {
        // 키 패턴 생성
        const patterns = this.generateKeyPatterns(rule.keyPatterns, context);
        
        // 실제 키 찾기
        for (const pattern of patterns) {
          const keys = await this.cache.scanKeys(pattern);
          keysToInvalidate.push(...keys);
        }
        
        // 추가 키 계산
        if (rule.computeAdditionalKeys) {
          const additionalKeys = await rule.computeAdditionalKeys(event);
          keysToInvalidate.push(...additionalKeys);
        }
      }
      
      return keysToInvalidate;
    }
    
    // 조건 평가
    private async evaluateCondition(
      condition: InvalidationCondition,
      context: EvaluationContext
    ): Promise<boolean> {
      switch (condition.type) {
        case 'simple':
          return this.evaluateSimpleCondition(condition, context);
          
        case 'complex':
          return await this.evaluateComplexCondition(condition, context);
          
        case 'script':
          return await this.evaluateScriptCondition(condition, context);
          
        default:
          return true;
      }
    }
  }

  // 계단식 무효화 관리자
  class CascadeInvalidationManager {
    private dependencyGraph: DependencyGraph;
    
    constructor(private cache: CacheLayer) {
      this.dependencyGraph = new DependencyGraph();
    }
    
    // 계단식 무효화 실행
    async performCascade(
      initialKeys: string[],
      options: CascadeOptions
    ): Promise<CascadeResult> {
      const visited = new Set<string>();
      const queue = [...initialKeys];
      const invalidated: string[] = [];
      
      while (queue.length > 0 && invalidated.length < options.maxKeys) {
        const key = queue.shift()!;
        
        if (visited.has(key)) continue;
        visited.add(key);
        
        // 키 무효화
        await this.cache.invalidate(key);
        invalidated.push(key);
        
        // 의존성 찾기
        if (options.depth > 0) {
          const dependencies = await this.findDependencies(key);
          
          for (const dep of dependencies) {
            if (!visited.has(dep)) {
              queue.push(dep);
            }
          }
        }
      }
      
      return {
        invalidatedKeys: invalidated,
        cascadeDepth: this.calculateDepth(initialKeys, invalidated),
        truncated: queue.length > 0
      };
    }
    
    // 의존성 찾기
    private async findDependencies(key: string): Promise<string[]> {
      const dependencies: string[] = [];
      
      // 직접 의존성
      const directDeps = this.dependencyGraph.getDirectDependencies(key);
      dependencies.push(...directDeps);
      
      // 패턴 기반 의존성
      const patternDeps = await this.findPatternDependencies(key);
      dependencies.push(...patternDeps);
      
      // 계산된 의존성
      const computedDeps = await this.computeDependencies(key);
      dependencies.push(...computedDeps);
      
      return [...new Set(dependencies)];
    }
  }

  // 실시간 무효화 추적
  async trackInvalidation(
    invalidation: InvalidationEvent
  ): Promise<void> {
    const tracking = {
      id: uuidv4(),
      timestamp: Date.now(),
      keys: invalidation.keys,
      reason: invalidation.reason,
      source: invalidation.source,
      impact: await this.assessImpact(invalidation)
    };
    
    // 메트릭 업데이트
    await this.updateMetrics(tracking);
    
    // 이상 감지
    if (tracking.impact.severity === 'high') {
      await this.handleHighImpactInvalidation(tracking);
    }
    
    // 로깅
    await this.logInvalidation(tracking);
  }

  // 영향 평가
  private async assessImpact(
    invalidation: InvalidationEvent
  ): Promise<InvalidationImpact> {
    const metrics = await this.cache.getMetrics();
    
    return {
      keysInvalidated: invalidation.keys.length,
      estimatedCacheMisses: this.estimateCacheMisses(invalidation),
      affectedUsers: await this.estimateAffectedUsers(invalidation),
      performanceImpact: this.calculatePerformanceImpact(metrics),
      severity: this.calculateSeverity(invalidation)
    };
  }

  // 무효화 최적화
  async optimizeInvalidation(
    event: DomainEvent
  ): Promise<OptimizedInvalidation> {
    const baseKeys = await this.getBaseKeysForInvalidation(event);
    
    // 1. 중복 제거
    const uniqueKeys = this.deduplicateKeys(baseKeys);
    
    // 2. 배치 그룹화
    const batches = this.groupIntoBatches(uniqueKeys);
    
    // 3. 우선순위 정렬
    const prioritized = this.prioritizeKeys(batches);
    
    // 4. 시간 분산
    const scheduled = this.scheduleInvalidation(prioritized);
    
    return {
      original: baseKeys.length,
      optimized: uniqueKeys.length,
      batches: scheduled,
      estimatedDuration: this.estimateDuration(scheduled)
    };
  }
}

// 무효화 규칙 정의
export const invalidationRules: InvalidationRule[] = [
  {
    id: 'user-update-profile',
    eventPattern: 'user.profile.updated',
    condition: {
      type: 'simple',
      field: 'changes',
      operator: 'contains',
      value: ['email', 'username', 'role']
    },
    keyPatterns: [
      'user:{event.userId}',
      'user:{event.userId}:profile',
      'user:email:{event.oldEmail}',
      'user:username:{event.oldUsername}'
    ],
    cascade: true,
    priority: 'high',
    computeAdditionalKeys: async (event) => {
      // 사용자의 프로젝트 캐시도 무효화
      return [
        `user:${event.userId}:projects`,
        `user:${event.userId}:permissions`
      ];
    }
  },
  
  {
    id: 'project-status-change',
    eventPattern: 'project.status.changed',
    condition: {
      type: 'complex',
      expression: `
        event.oldStatus !== event.newStatus && 
        ['active', 'archived'].includes(event.newStatus)
      `
    },
    keyPatterns: [
      'project:{event.projectId}',
      'project:{event.projectId}:*',
      'projects:status:{event.oldStatus}',
      'projects:status:{event.newStatus}'
    ],
    cascade: true,
    priority: 'medium'
  },
  
  {
    id: 'agent-task-completion',
    eventPattern: 'agent.task.completed',
    condition: {
      type: 'simple',
      field: 'success',
      operator: 'equals',
      value: true
    },
    keyPatterns: [
      'agent:{event.agentId}:status',
      'task:{event.taskId}',
      'project:{event.projectId}:tasks',
      'project:{event.projectId}:progress'
    ],
    cascade: false,
    priority: 'low'
  }
];

// 무효화 이벤트 프로세서
export class InvalidationEventProcessor {
  private queue: Queue<InvalidationJob>;
  private workers: InvalidationWorker[];
  
  constructor(
    private cache: CacheLayer,
    private config: ProcessorConfig
  ) {
    this.queue = new Queue('invalidation-jobs');
    this.workers = this.createWorkers(config.workerCount || 4);
  }
  
  // 비동기 처리
  async processAsync(job: InvalidationJob): Promise<void> {
    await this.queue.add(job, {
      priority: this.getPriority(job),
      delay: this.calculateDelay(job),
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 1000
      }
    });
  }
  
  // 워커 생성
  private createWorkers(count: number): InvalidationWorker[] {
    const workers: InvalidationWorker[] = [];
    
    for (let i = 0; i < count; i++) {
      const worker = new InvalidationWorker(this.cache, {
        id: `worker-${i}`,
        batchSize: this.config.batchSize || 100,
        concurrency: this.config.concurrency || 10
      });
      
      worker.on('job:complete', this.onJobComplete.bind(this));
      worker.on('job:failed', this.onJobFailed.bind(this));
      
      workers.push(worker);
    }
    
    return workers;
  }
  
  // 작업 완료 처리
  private async onJobComplete(result: JobResult): Promise<void> {
    await this.updateMetrics(result);
    
    if (result.cascadeRequired) {
      await this.scheduleCascadeJobs(result.cascadeKeys);
    }
  }
}
```

#### SubTask 2.8.2: 지능형 캐시 갱신
**담당자**: ML 엔지니어  
**예상 소요시간**: 12시간

**작업 내용**:
```typescript
// backend/src/cache/intelligent/smart-refresh.ts
export class IntelligentCacheRefresh {
  private predictor: CacheAccessPredictor;
  private refreshScheduler: RefreshScheduler;
  private costAnalyzer: RefreshCostAnalyzer;
  
  constructor(
    private cache: CacheLayer,
    private dataSource: DataSource,
    private config: SmartRefreshConfig
  ) {
    this.predictor = new CacheAccessPredictor();
    this.refreshScheduler = new RefreshScheduler();
    this.costAnalyzer = new RefreshCostAnalyzer();
    
    this.initializeMLModels();
    this.startPredictiveRefresh();
  }

  // ML 모델 초기화
  private async initializeMLModels(): Promise<void> {
    // 접근 패턴 예측 모델
    await this.predictor.loadModel('access-pattern-v2');
    
    // 비용 예측 모델
    await this.costAnalyzer.loadModel('refresh-cost-v1');
    
    // 모델 성능 모니터링
    this.monitorModelPerformance();
  }

  // 예측적 갱신 시작
  private startPredictiveRefresh(): void {
    setInterval(async () => {
      const predictions = await this.generateRefreshPredictions();
      const optimizedPlan = await this.optimizeRefreshPlan(predictions);
      
      await this.executeRefreshPlan(optimizedPlan);
    }, this.config.predictionInterval || 60000); // 1분
  }

  // 갱신 예측 생성
  private async generateRefreshPredictions(): Promise<RefreshPrediction[]> {
    const predictions: RefreshPrediction[] = [];
    
    // 1. 시계열 분석
    const timeSeriesPatterns = await this.analyzeTimeSeriesPatterns();
    
    // 2. 접근 빈도 예측
    const accessPredictions = await this.predictor.predictNextAccess(
      timeSeriesPatterns
    );
    
    // 3. 데이터 변경 확률 예측
    const changeProbabilities = await this.predictDataChanges();
    
    // 4. 통합 예측 생성
    for (const pattern of timeSeriesPatterns) {
      const prediction = await this.createRefreshPrediction(
        pattern,
        accessPredictions.get(pattern.key),
        changeProbabilities.get(pattern.key)
      );
      
      predictions.push(prediction);
    }
    
    return predictions;
  }

  // 갱신 예측 생성
  private async createRefreshPrediction(
    pattern: TimeSeriesPattern,
    accessPrediction: AccessPrediction,
    changeProbability: number
  ): Promise<RefreshPrediction> {
    const now = Date.now();
    
    return {
      key: pattern.key,
      nextAccessTime: accessPrediction.timestamp,
      accessProbability: accessPrediction.probability,
      changeProbability,
      currentAge: now - pattern.lastRefresh,
      ttlRemaining: pattern.ttl - (now - pattern.lastRefresh),
      refreshValue: this.calculateRefreshValue(
        accessPrediction,
        changeProbability,
        pattern
      ),
      recommendedAction: this.determineAction(
        accessPrediction,
        changeProbability,
        pattern
      )
    };
  }

  // 갱신 가치 계산
  private calculateRefreshValue(
    access: AccessPrediction,
    changeProb: number,
    pattern: TimeSeriesPattern
  ): number {
    // 갱신 이익 = (접근 확률 × 히트 가치) - (갱신 비용)
    const hitValue = pattern.averageResponseTime * pattern.accessFrequency;
    const refreshCost = pattern.dataSize * this.config.refreshCostPerByte;
    
    const expectedBenefit = access.probability * hitValue;
    const expectedCost = refreshCost + (changeProb * refreshCost);
    
    return expectedBenefit - expectedCost;
  }

  // 갱신 계획 최적화
  private async optimizeRefreshPlan(
    predictions: RefreshPrediction[]
  ): Promise<RefreshPlan> {
    // 1. 리소스 제약 확인
    const resources = await this.getAvailableResources();
    
    // 2. 우선순위 큐 생성
    const priorityQueue = new PriorityQueue<RefreshTask>(
      (a, b) => b.priority - a.priority
    );
    
    // 3. 태스크 생성 및 우선순위 지정
    for (const prediction of predictions) {
      if (prediction.recommendedAction === 'refresh') {
        const task = await this.createRefreshTask(prediction);
        priorityQueue.enqueue(task);
      }
    }
    
    // 4. 리소스 할당 최적화
    const plan = await this.allocateResources(
      priorityQueue,
      resources
    );
    
    return plan;
  }

  // 적응형 TTL 조정
  async adaptiveTTLAdjustment(): Promise<void> {
    const patterns = await this.cache.getAccessPatterns();
    
    for (const pattern of patterns) {
      const analysis = await this.analyzeTTLEffectiveness(pattern);
      
      if (analysis.needsAdjustment) {
        const newTTL = await this.calculateOptimalTTL(pattern, analysis);
        
        await this.cache.adjustTTL(pattern.key, newTTL);
        
        // 학습
        await this.predictor.learn({
          pattern,
          oldTTL: pattern.ttl,
          newTTL,
          outcome: analysis
        });
      }
    }
  }

  // 최적 TTL 계산
  private async calculateOptimalTTL(
    pattern: AccessPattern,
    analysis: TTLAnalysis
  ): Promise<number> {
    const factors = {
      accessFrequency: pattern.frequency,
      accessVariability: pattern.variability,
      dataVolatility: analysis.changeRate,
      hitRate: analysis.hitRate,
      memoryPressure: await this.cache.getMemoryPressure()
    };
    
    // ML 기반 TTL 예측
    const predictedTTL = await this.predictor.predictOptimalTTL(factors);
    
    // 안전 범위 적용
    return this.constrainTTL(predictedTTL, pattern);
  }

  // 프로액티브 갱신
  async proactiveRefresh(): Promise<ProactiveRefreshResult> {
    const candidates = await this.identifyRefreshCandidates();
    const refreshed: string[] = [];
    const skipped: string[] = [];
    
    for (const candidate of candidates) {
      const decision = await this.makeRefreshDecision(candidate);
      
      if (decision.shouldRefresh) {
        try {
          await this.refreshCacheEntry(candidate.key);
          refreshed.push(candidate.key);
          
          // 성공 학습
          await this.recordRefreshSuccess(candidate, decision);
        } catch (error) {
          // 실패 학습
          await this.recordRefreshFailure(candidate, decision, error);
        }
      } else {
        skipped.push(candidate.key);
      }
    }
    
    return {
      totalCandidates: candidates.length,
      refreshed: refreshed.length,
      skipped: skipped.length,
      successRate: refreshed.length / candidates.length
    };
  }

  // 갱신 후보 식별
  private async identifyRefreshCandidates(): Promise<RefreshCandidate[]> {
    const candidates: RefreshCandidate[] = [];
    
    // 1. TTL 임박 항목
    const expiringKeys = await this.cache.getExpiringKeys(
      this.config.refreshWindow || 300000 // 5분
    );
    
    for (const key of expiringKeys) {
      const metadata = await this.cache.getMetadata(key);
      const score = await this.scoreCandidate(key, metadata);
      
      candidates.push({
        key,
        score,
        metadata,
        reason: 'ttl_expiring'
      });
    }
    
    // 2. 접근 패턴 기반
    const predictedAccess = await this.predictor.getUpcomingAccess();
    
    for (const prediction of predictedAccess) {
      if (!this.cache.exists(prediction.key)) {
        candidates.push({
          key: prediction.key,
          score: prediction.confidence,
          metadata: null,
          reason: 'predicted_access'
        });
      }
    }
    
    // 3. 변경 감지 기반
    const potentialChanges = await this.detectPotentialChanges();
    
    for (const change of potentialChanges) {
      candidates.push({
        key: change.key,
        score: change.probability,
        metadata: await this.cache.getMetadata(change.key),
        reason: 'change_detected'
      });
    }
    
    return candidates.sort((a, b) => b.score - a.score);
  }

  // 갱신 결정
  private async makeRefreshDecision(
    candidate: RefreshCandidate
  ): Promise<RefreshDecision> {
    // 비용-이익 분석
    const cost = await this.costAnalyzer.calculateRefreshCost(candidate);
    const benefit = await this.calculateRefreshBenefit(candidate);
    
    // 리소스 가용성
    const resourceAvailable = await this.checkResourceAvailability();
    
    // ML 예측
    const prediction = await this.predictor.shouldRefresh({
      candidate,
      cost,
      benefit,
      resources: resourceAvailable
    });
    
    return {
      shouldRefresh: prediction.confidence > 0.7 && benefit > cost * 1.5,
      confidence: prediction.confidence,
      reasoning: prediction.reasoning,
      expectedValue: benefit - cost
    };
  }

  // 변경 감지
  private async detectPotentialChanges(): Promise<ChangeDetection[]> {
    const detections: ChangeDetection[] = [];
    
    // 1. 이벤트 스트림 분석
    const recentEvents = await this.eventStream.getRecent(1000);
    const changeSignals = this.analyzeEventsForChanges(recentEvents);
    
    // 2. 데이터 소스 모니터링
    const sourceChanges = await this.monitorDataSources();
    
    // 3. 패턴 기반 감지
    const patternChanges = await this.detectPatternBasedChanges();
    
    // 통합
    for (const signal of [...changeSignals, ...sourceChanges, ...patternChanges]) {
      detections.push({
        key: signal.key,
        probability: signal.probability,
        source: signal.source,
        timestamp: Date.now()
      });
    }
    
    return detections;
  }

  // 갱신 실행
  private async refreshCacheEntry(key: string): Promise<void> {
    const startTime = Date.now();
    
    try {
      // 1. 데이터 소스에서 로드
      const freshData = await this.dataSource.load(key);
      
      // 2. 변환 적용
      const transformed = await this.applyTransformation(freshData);
      
      // 3. 캐시 업데이트
      await this.cache.set(key, transformed, {
        ttl: await this.calculateAdaptiveTTL(key),
        tags: await this.generateTags(key, transformed)
      });
      
      // 4. 메트릭 기록
      await this.recordRefreshMetrics(key, {
        duration: Date.now() - startTime,
        dataSize: JSON.stringify(transformed).length,
        success: true
      });
      
    } catch (error) {
      await this.handleRefreshError(key, error);
      throw error;
    }
  }
}

// 캐시 접근 예측기
export class CacheAccessPredictor {
  private model: TensorFlowModel;
  private featureExtractor: FeatureExtractor;
  
  async predictNextAccess(
    patterns: TimeSeriesPattern[]
  ): Promise<Map<string, AccessPrediction>> {
    const predictions = new Map<string, AccessPrediction>();
    
    for (const pattern of patterns) {
      // 특징 추출
      const features = await this.featureExtractor.extract(pattern);
      
      // 예측
      const prediction = await this.model.predict(features);
      
      predictions.set(pattern.key, {
        timestamp: prediction.nextAccessTime,
        probability: prediction.confidence,
        uncertainty: prediction.uncertainty
      });
    }
    
    return predictions;
  }
  
  // 모델 학습
  async learn(example: LearningExample): Promise<void> {
    const features = await this.featureExtractor.extract(example.pattern);
    const label = example.outcome;
    
    await this.model.train([{ features, label }]);
    
    // 주기적 재학습
    if (this.shouldRetrain()) {
      await this.retrainModel();
    }
  }
}

// 갱신 스케줄러
export class RefreshScheduler {
  private schedule: Map<string, ScheduledRefresh> = new Map();
  private executor: ScheduledExecutor;
  
  async scheduleRefresh(
    key: string,
    time: Date,
    priority: number
  ): Promise<void> {
    const task: ScheduledRefresh = {
      id: uuidv4(),
      key,
      scheduledTime: time,
      priority,
      status: 'pending'
    };
    
    this.schedule.set(task.id, task);
    
    await this.executor.schedule(task.id, time, async () => {
      await this.executeRefresh(task);
    });
  }
  
  // 동적 재스케줄링
  async reschedule(
    taskId: string,
    newTime: Date
  ): Promise<void> {
    const task = this.schedule.get(taskId);
    if (!task || task.status !== 'pending') {
      return;
    }
    
    await this.executor.cancel(taskId);
    task.scheduledTime = newTime;
    
    await this.executor.schedule(taskId, newTime, async () => {
      await this.executeRefresh(task);
    });
  }
  
  // 우선순위 기반 실행
  private async executeRefresh(task: ScheduledRefresh): Promise<void> {
    task.status = 'executing';
    
    try {
      await this.refreshWithPriority(task.key, task.priority);
      task.status = 'completed';
    } catch (error) {
      task.status = 'failed';
      task.error = error;
      
      // 재시도 로직
      if (this.shouldRetry(task)) {
        await this.scheduleRetry(task);
      }
    }
  }
}
```

#### SubTask 2.8.3: 의존성 기반 무효화
**담당자**: 시스템 아키텍트  
**예상 소요시간**: 10시간

**작업 내용**:
```typescript
// backend/src/cache/invalidation/dependency-invalidation.ts
export class DependencyBasedInvalidation {
  private dependencyGraph: CacheDependencyGraph;
  private invalidationEngine: InvalidationEngine;
  private impactAnalyzer: ImpactAnalyzer;
  
  constructor(
    private cache: CacheLayer,
    private config: DependencyConfig
  ) {
    this.dependencyGraph = new CacheDependencyGraph();
    this.invalidationEngine = new InvalidationEngine(cache);
    this.impactAnalyzer = new ImpactAnalyzer();
    
    this.initializeDependencyTracking();
  }

  // 의존성 그래프 구축
  async buildDependencyGraph(
    entities: EntityDefinition[]
  ): Promise<void> {
    // 1. 엔티티 관계 분석
    const relationships = this.analyzeEntityRelationships(entities);
    
    // 2. 캐시 키 의존성 매핑
    for (const rel of relationships) {
      await this.mapCacheDependencies(rel);
    }
    
    // 3. 순환 의존성 검사
    const cycles = this.dependencyGraph.detectCycles();
    if (cycles.length > 0) {
      throw new Error(`Circular dependencies detected: ${cycles}`);
    }
    
    // 4. 최적화
    await this.optimizeDependencyGraph();
  }

  // 캐시 의존성 매핑
  private async mapCacheDependencies(
    relationship: EntityRelationship
  ): Promise<void> {
    const patterns = this.generateDependencyPatterns(relationship);
    
    for (const pattern of patterns) {
      this.dependencyGraph.addDependency(
        pattern.parent,
        pattern.child,
        {
          type: pattern.type,
          propagation: pattern.propagation,
          condition: pattern.condition
        }
      );
    }
  }

  // 의존성 전파 무효화
  async invalidateWithDependencies(
    key: string,
    options?: InvalidationOptions
  ): Promise<DependencyInvalidationResult> {
    const startTime = Date.now();
    const invalidated = new Set<string>();
    
    try {
      // 1. 루트 키 무효화
      await this.cache.invalidate(key);
      invalidated.add(key);
      
      // 2. 직접 의존성 찾기
      const directDeps = this.dependencyGraph.getDirectDependents(key);
      
      // 3. 전이적 의존성 계산
      const transitiveDeps = await this.calculateTransitiveDependencies(
        key,
        options?.maxDepth || 5
      );
      
      // 4. 영향 분석
      const impact = await this.impactAnalyzer.analyze(
        key,
        [...directDeps, ...transitiveDeps]
      );
      
      // 5. 선택적 무효화
      const toInvalidate = await this.selectKeysForInvalidation(
        [...directDeps, ...transitiveDeps],
        impact,
        options
      );
      
      // 6. 배치 무효화 실행
      await this.batchInvalidate(toInvalidate);
      toInvalidate.forEach(k => invalidated.add(k));
      
      return {
        success: true,
        rootKey: key,
        invalidatedCount: invalidated.size,
        directDependencies: directDeps.length,
        transitiveDependencies: transitiveDeps.length,
        duration: Date.now() - startTime,
        impact
      };
      
    } catch (error) {
      return {
        success: false,
        rootKey: key,
        error: error.message,
        invalidatedCount: invalidated.size,
        duration: Date.now() - startTime
      };
    }
  }

  // 전이적 의존성 계산
  private async calculateTransitiveDependencies(
    rootKey: string,
    maxDepth: number
  ): Promise<string[]> {
    const visited = new Set<string>();
    const dependencies: string[] = [];
    const queue: Array<{ key: string; depth: number }> = [
      { key: rootKey, depth: 0 }
    ];
    
    while (queue.length > 0) {
      const { key, depth } = queue.shift()!;
      
      if (visited.has(key) || depth >= maxDepth) {
        continue;
      }
      
      visited.add(key);
      
      const deps = this.dependencyGraph.getDirectDependents(key);
      
      for (const dep of deps) {
        if (!visited.has(dep)) {
          dependencies.push(dep);
          queue.push({ key: dep, depth: depth + 1 });
        }
      }
    }
    
    return dependencies;
  }

  // 선택적 무효화
  private async selectKeysForInvalidation(
    candidates: string[],
    impact: ImpactAnalysis,
    options?: InvalidationOptions
  ): Promise<string[]> {
    const selected: string[] = [];
    
    for (const key of candidates) {
      const shouldInvalidate = await this.evaluateInvalidation(
        key,
        impact,
        options
      );
      
      if (shouldInvalidate) {
        selected.push(key);
      }
    }
    
    return selected;
  }

  // 무효화 평가
  private async evaluateInvalidation(
    key: string,
    impact: ImpactAnalysis,
    options?: InvalidationOptions
  ): Promise<boolean> {
    // 1. 의존성 조건 확인
    const dependency = this.dependencyGraph.getDependency(key);
    if (dependency.condition) {
      const conditionMet = await this.evaluateCondition(
        dependency.condition,
        { key, impact }
      );
      
      if (!conditionMet) {
        return false;
      }
    }
    
    // 2. 전파 정책 확인
    if (dependency.propagation === 'manual') {
      return false;
    }
    
    // 3. 임계값 확인
    if (options?.threshold) {
      const score = this.calculateInvalidationScore(key, impact);
      return score >= options.threshold;
    }
    
    return true;
  }

  // 의존성 그래프 시각화
  async visualizeDependencies(
    rootKey?: string
  ): Promise<DependencyVisualization> {
    const nodes: VisualizationNode[] = [];
    const edges: VisualizationEdge[] = [];
    
    if (rootKey) {
      // 특정 키의 의존성 트리
      await this.buildVisualizationTree(rootKey, nodes, edges);
    } else {
      // 전체 그래프
      await this.buildFullVisualization(nodes, edges);
    }
    
    return {
      nodes,
      edges,
      stats: {
        totalNodes: nodes.length,
        totalEdges: edges.length,
        maxDepth: this.calculateMaxDepth(nodes, edges),
        clusters: this.identifyClusters(nodes, edges)
      },
      layout: this.calculateLayout(nodes, edges)
    };
  }

  // 의존성 최적화
  private async optimizeDependencyGraph(): Promise<void> {
    // 1. 중복 경로 제거
    this.removeDuplicatePaths();
    
    // 2. 약한 의존성 제거
    await this.pruneWeakDependencies();
    
    // 3. 의존성 병합
    this.mergeSimilarDependencies();
    
    // 4. 인덱스 재구성
    this.rebuildIndices();
  }

  // 동적 의존성 추적
  async trackDynamicDependencies(): Promise<void> {
    // 캐시 접근 패턴 모니터링
    this.cache.on('access', async (event) => {
      if (event.context?.parentKey) {
        await this.recordDynamicDependency(
          event.context.parentKey,
          event.key
        );
      }
    });
    
    // 주기적 분석
    setInterval(async () => {
      await this.analyzeDynamicDependencies();
    }, this.config.analysisInterval || 3600000); // 1시간
  }

  // 동적 의존성 기록
  private async recordDynamicDependency(
    parentKey: string,
    childKey: string
  ): Promise<void> {
    const existing = this.dependencyGraph.getDependency(childKey);
    
    if (!existing || existing.type === 'dynamic') {
      await this.dependencyGraph.addDependency(
        parentKey,
        childKey,
        {
          type: 'dynamic',
          confidence: 0.5,
          lastSeen: Date.now()
        }
      );
    }
  }

  // 의존성 패턴 학습
  async learnDependencyPatterns(): Promise<void> {
    const patterns = await this.extractDependencyPatterns();
    
    for (const pattern of patterns) {
      if (pattern.frequency > this.config.patternThreshold) {
        await this.applyPatternToDependencyGraph(pattern);
      }
    }
  }
}

// 캐시 의존성 그래프
export class CacheDependencyGraph {
  private adjacencyList: Map<string, Set<DependencyEdge>>;
  private reverseAdjacencyList: Map<string, Set<DependencyEdge>>;
  private metadata: Map<string, DependencyMetadata>;
  
  constructor() {
    this.adjacencyList = new Map();
    this.reverseAdjacencyList = new Map();
    this.metadata = new Map();
  }
  
  // 의존성 추가
  addDependency(
    parent: string,
    child: string,
    options: DependencyOptions
  ): void {
    const edge: DependencyEdge = {
      from: parent,
      to: child,
      ...options
    };
    
    // 정방향 그래프
    if (!this.adjacencyList.has(parent)) {
      this.adjacencyList.set(parent, new Set());
    }
    this.adjacencyList.get(parent)!.add(edge);
    
    // 역방향 그래프
    if (!this.reverseAdjacencyList.has(child)) {
      this.reverseAdjacencyList.set(child, new Set());
    }
    this.reverseAdjacencyList.get(child)!.add(edge);
    
    // 메타데이터 업데이트
    this.updateMetadata(parent, child);
  }
  
  // 순환 의존성 감지
  detectCycles(): string[][] {
    const cycles: string[][] = [];
    const visited = new Set<string>();
    const recursionStack = new Set<string>();
    
    const dfs = (node: string, path: string[]): void => {
      visited.add(node);
      recursionStack.add(node);
      path.push(node);
      
      const edges = this.adjacencyList.get(node) || new Set();
      
      for (const edge of edges) {
        if (!visited.has(edge.to)) {
          dfs(edge.to, [...path]);
        } else if (recursionStack.has(edge.to)) {
          // 사이클 발견
          const cycleStart = path.indexOf(edge.to);
          cycles.push(path.slice(cycleStart));
        }
      }
      
      recursionStack.delete(node);
    };
    
    // 모든 노드에서 DFS 시작
    for (const node of this.adjacencyList.keys()) {
      if (!visited.has(node)) {
        dfs(node, []);
      }
    }
    
    return cycles;
  }
  
  // 의존성 경로 찾기
  findPaths(
    from: string,
    to: string,
    maxDepth: number = 10
  ): string[][] {
    const paths: string[][] = [];
    
    const dfs = (
      current: string,
      target: string,
      path: string[],
      depth: number
    ): void => {
      if (depth > maxDepth) return;
      
      path.push(current);
      
      if (current === target) {
        paths.push([...path]);
        return;
      }
      
      const edges = this.adjacencyList.get(current) || new Set();
      
      for (const edge of edges) {
        if (!path.includes(edge.to)) {
          dfs(edge.to, target, path, depth + 1);
          path.pop();
        }
      }
    };
    
    dfs(from, to, [], 0);
    return paths;
  }
  
  // 영향 범위 계산
  calculateImpactScope(key: string): ImpactScope {
    const directImpact = new Set<string>();
    const indirectImpact = new Set<string>();
    
    // BFS로 영향 범위 계산
    const queue: Array<{ key: string; distance: number }> = [
      { key, distance: 0 }
    ];
    const visited = new Set<string>();
    
    while (queue.length > 0) {
      const { key: current, distance } = queue.shift()!;
      
      if (visited.has(current)) continue;
      visited.add(current);
      
      const edges = this.adjacencyList.get(current) || new Set();
      
      for (const edge of edges) {
        if (distance === 0) {
          directImpact.add(edge.to);
        } else {
          indirectImpact.add(edge.to);
        }
        
        queue.push({ key: edge.to, distance: distance + 1 });
      }
    }
    
    return {
      direct: Array.from(directImpact),
      indirect: Array.from(indirectImpact),
      total: directImpact.size + indirectImpact.size
    };
  }
}

// 영향 분석기
export class ImpactAnalyzer {
  async analyze(
    rootKey: string,
    affectedKeys: string[]
  ): Promise<ImpactAnalysis> {
    const metrics = await this.collectMetrics(affectedKeys);
    
    return {
      totalKeys: affectedKeys.length,
      estimatedCacheMisses: this.estimateCacheMisses(metrics),
      estimatedLatencyIncrease: this.estimateLatencyIncrease(metrics),
      affectedUsers: await this.estimateAffectedUsers(affectedKeys),
      criticalPaths: this.identifyCriticalPaths(rootKey, affectedKeys),
      severity: this.calculateSeverity(metrics),
      recommendations: this.generateRecommendations(metrics)
    };
  }
  
  private calculateSeverity(metrics: CacheMetrics): 'low' | 'medium' | 'high' | 'critical' {
    const score = 
      metrics.accessFrequency * 0.4 +
      metrics.userImpact * 0.3 +
      metrics.dataImportance * 0.3;
    
    if (score > 0.8) return 'critical';
    if (score > 0.6) return 'high';
    if (score > 0.3) return 'medium';
    return 'low';
  }
}
```

#### SubTask 2.8.4: 무효화 모니터링 및 최적화
**담당자**: 모니터링 전문가  
**예상 소요시간**: 8시간

**작업 내용**:
```typescript
// backend/src/cache/monitoring/invalidation-monitor.ts
export class InvalidationMonitor {
  private metricsCollector: InvalidationMetricsCollector;
  private analyzer: InvalidationAnalyzer;
  private optimizer: InvalidationOptimizer;
  private dashboard: InvalidationDashboard;
  
  constructor(
    private cache: CacheLayer,
    private config: MonitoringConfig
  ) {
    this.metricsCollector = new InvalidationMetricsCollector(cache);
    this.analyzer = new InvalidationAnalyzer();
    this.optimizer = new InvalidationOptimizer();
    this.dashboard = new InvalidationDashboard();
    
    this.startMonitoring();
  }

  // 모니터링 시작
  private startMonitoring(): void {
    // 실시간 메트릭 수집
    this.cache.on('invalidation', async (event) => {
      await this.metricsCollector.record(event);
    });
    
    // 주기적 분석
    setInterval(async () => {
      await this.performAnalysis();
    }, this.config.analysisInterval || 60000);
    
    // 대시보드 업데이트
    setInterval(async () => {
      await this.updateDashboard();
    }, this.config.dashboardInterval || 5000);
  }

  // 무효화 메트릭 수집
  class InvalidationMetricsCollector {
    private metrics: InvalidationMetrics;
    
    async record(event: InvalidationEvent): Promise<void> {
      // 기본 메트릭
      this.metrics.totalInvalidations++;
      this.metrics.invalidationsByType[event.type]++;
      
      // 시간 기반 메트릭
      const hour = new Date().getHours();
      this.metrics.hourlyDistribution[hour]++;
      
      // 성능 메트릭
      this.metrics.avgInvalidationTime = 
        (this.metrics.avgInvalidationTime * (this.metrics.totalInvalidations - 1) + 
         event.duration) / this.metrics.totalInvalidations;
      
      // 영향 메트릭
      this.metrics.totalKeysInvalidated += event.keysInvalidated;
      this.metrics.cascadeDepth = Math.max(
        this.metrics.cascadeDepth,
        event.cascadeDepth || 0
      );
      
      // 패턴 추적
      await this.trackInvalidationPattern(event);
    }
    
    private async trackInvalidationPattern(
      event: InvalidationEvent
    ): Promise<void> {
      const pattern = this.extractPattern(event);
      
      if (!this.metrics.patterns.has(pattern)) {
        this.metrics.patterns.set(pattern, {
          count: 0,
          avgDuration: 0,
          avgKeysAffected: 0,
          lastSeen: null
        });
      }
      
      const patternMetric = this.metrics.patterns.get(pattern)!;
      patternMetric.count++;
      patternMetric.avgDuration = 
        (patternMetric.avgDuration * (patternMetric.count - 1) + event.duration) / 
        patternMetric.count;
      patternMetric.avgKeysAffected = 
        (patternMetric.avgKeysAffected * (patternMetric.count - 1) + event.keysInvalidated) / 
        patternMetric.count;
      patternMetric.lastSeen = new Date();
    }
  }

  // 무효화 분석
  private async performAnalysis(): Promise<void> {
    const metrics = await this.metricsCollector.getMetrics();
    const analysis = await this.analyzer.analyze(metrics);
    
    // 이상 감지
    if (analysis.anomalies.length > 0) {
      await this.handleAnomalies(analysis.anomalies);
    }
    
    // 최적화 기회 식별
    if (analysis.optimizationOpportunities.length > 0) {
      await this.applyOptimizations(analysis.optimizationOpportunities);
    }
    
    // 보고서 생성
    await this.generateReport(analysis);
  }

  // 이상 감지
  class InvalidationAnalyzer {
    async analyze(
      metrics: InvalidationMetrics
    ): Promise<InvalidationAnalysis> {
      const anomalies = await this.detectAnomalies(metrics);
      const patterns = await this.analyzePatterns(metrics);
      const bottlenecks = await this.identifyBottlenecks(metrics);
      const opportunities = await this.findOptimizationOpportunities(metrics);
      
      return {
        anomalies,
        patterns,
        bottlenecks,
        optimizationOpportunities: opportunities,
        summary: this.generateSummary(metrics),
        recommendations: this.generateRecommendations(anomalies, patterns, bottlenecks)
      };
    }
    
    private async detectAnomalies(
      metrics: InvalidationMetrics
    ): Promise<Anomaly[]> {
      const anomalies: Anomaly[] = [];
      
      // 1. 급증 감지
      const spike = this.detectSpike(metrics.hourlyDistribution);
      if (spike) {
        anomalies.push({
          type: 'spike',
          severity: 'high',
          description: `Invalidation spike detected: ${spike.value}x normal`,
          timestamp: spike.timestamp,
          data: spike
        });
      }
      
      // 2. 패턴 이상 감지
      for (const [pattern, data] of metrics.patterns) {
        if (data.avgDuration > metrics.avgInvalidationTime * 3) {
          anomalies.push({
            type: 'slow_pattern',
            severity: 'medium',
            description: `Pattern "${pattern}" is 3x slower than average`,
            pattern,
            data
          });
        }
      }
      
      // 3. 캐스케이드 이상
      if (metrics.cascadeDepth > 5) {
        anomalies.push({
          type: 'deep_cascade',
          severity: 'high',
          description: `Deep cascade detected: ${metrics.cascadeDepth} levels`,
          data: { depth: metrics.cascadeDepth }
        });
      }
      
      return anomalies;
    }
    
    private async identifyBottlenecks(
      metrics: InvalidationMetrics
    ): Promise<Bottleneck[]> {
      const bottlenecks: Bottleneck[] = [];
      
      // 1. 핫스팟 패턴
      const hotPatterns = Array.from(metrics.patterns.entries())
        .filter(([_, data]) => data.count > metrics.totalInvalidations * 0.2)
        .sort((a, b) => b[1].count - a[1].count);
        
      if (hotPatterns.length > 0) {
        bottlenecks.push({
          type: 'hot_pattern',
          impact: 'high',
          patterns: hotPatterns.map(([pattern, data]) => ({
            pattern,
            percentage: (data.count / metrics.totalInvalidations) * 100
          }))
        });
      }
      
      // 2. 시간대별 집중
      const peakHours = this.findPeakHours(metrics.hourlyDistribution);
      if (peakHours.concentration > 0.5) {
        bottlenecks.push({
          type: 'temporal_concentration',
          impact: 'medium',
          hours: peakHours.hours,
          concentration: peakHours.concentration
        });
      }
      
      return bottlenecks;
    }
  }

  // 무효화 최적화
  class InvalidationOptimizer {
    async optimize(
      opportunity: OptimizationOpportunity
    ): Promise<OptimizationResult> {
      switch (opportunity.type) {
        case 'batch_consolidation':
          return await this.consolidateBatches(opportunity);
          
        case 'pattern_caching':
          return await this.cachePatterns(opportunity);
          
        case 'cascade_reduction':
          return await this.reduceCascades(opportunity);
          
        case 'timing_optimization':
          return await this.optimizeTiming(opportunity);
          
        default:
          return { applied: false, reason: 'Unknown optimization type' };
      }
    }
    
    private async consolidateBatches(
      opportunity: OptimizationOpportunity
    ): Promise<OptimizationResult> {
      const config = opportunity.config as BatchConsolidationConfig;
      
      // 배치 크기 조정
      await this.cache.setConfig({
        invalidationBatchSize: config.optimalBatchSize,
        invalidationBatchDelay: config.batchDelay
      });
      
      return {
        applied: true,
        expectedImprovement: {
          latency: '-30%',
          throughput: '+50%'
        }
      };
    }
    
    private async reduceCascades(
      opportunity: OptimizationOpportunity
    ): Promise<OptimizationResult> {
      const config = opportunity.config as CascadeReductionConfig;
      
      // 의존성 그래프 재구성
      for (const optimization of config.graphOptimizations) {
        await this.applyGraphOptimization(optimization);
      }
      
      return {
        applied: true,
        expectedImprovement: {
          cascadeDepth: `-${config.expectedReduction}%`,
          invalidations: '-20%'
        }
      };
    }
  }

  // 무효화 대시보드
  class InvalidationDashboard {
    private realtimeData: RealtimeData;
    private historicalData: HistoricalData;
    
    async update(
      metrics: InvalidationMetrics,
      analysis: InvalidationAnalysis
    ): Promise<void> {
      // 실시간 데이터 업데이트
      this.realtimeData = {
        currentRate: this.calculateRate(metrics),
        activePatterns: this.getActivePatterns(metrics),
        cascadeDepth: metrics.cascadeDepth,
        anomalies: analysis.anomalies,
        timestamp: Date.now()
      };
      
      // 차트 데이터 업데이트
      await this.updateCharts(metrics);
      
      // 알림 확인
      await this.checkAlerts(analysis);
      
      // WebSocket으로 브로드캐스트
      await this.broadcast({
        type: 'dashboard_update',
        data: this.realtimeData
      });
    }
    
    async generateVisualization(): Promise<DashboardVisualization> {
      return {
        overview: {
          totalInvalidations: this.realtimeData.totalInvalidations,
          averageRate: this.realtimeData.currentRate,
          healthScore: this.calculateHealthScore()
        },
        charts: {
          timeline: await this.generateTimelineChart(),
          patterns: await this.generatePatternChart(),
          cascade: await this.generateCascadeChart(),
          heatmap: await this.generateHeatmap()
        },
        alerts: await this.getActiveAlerts(),
        recommendations: await this.getRecommendations()
      };
    }
  }

  // 최적화 적용
  private async applyOptimizations(
    opportunities: OptimizationOpportunity[]
  ): Promise<void> {
    for (const opportunity of opportunities) {
      try {
        const result = await this.optimizer.optimize(opportunity);
        
        if (result.applied) {
          await this.trackOptimization(opportunity, result);
        }
      } catch (error) {
        this.logger.error(`Failed to apply optimization: ${opportunity.type}`, error);
      }
    }
  }

  // 리포트 생성
  private async generateReport(
    analysis: InvalidationAnalysis
  ): Promise<InvalidationReport> {
    const report: InvalidationReport = {
      timestamp: new Date(),
      period: this.config.reportPeriod || '1h',
      summary: analysis.summary,
      metrics: {
        total: analysis.summary.totalInvalidations,
        rate: analysis.summary.averageRate,
        patterns: analysis.patterns.length,
        anomalies: analysis.anomalies.length
      },
      topPatterns: analysis.patterns.slice(0, 10),
      anomalies: analysis.anomalies,
      optimizations: {
        applied: await this.getAppliedOptimizations(),
        pending: analysis.optimizationOpportunities,
        results: await this.getOptimizationResults()
      },
      recommendations: analysis.recommendations
    };
    
    // 리포트 저장
    await this.saveReport(report);
    
    // 이메일 알림 (설정된 경우)
    if (this.config.emailReports) {
      await this.emailReport(report);
    }
    
    return report;
  }

  // 무효화 예측
  async predictInvalidations(
    timeframe: TimeRange
  ): Promise<InvalidationPrediction> {
    const historicalData = await this.getHistoricalData();
    const patterns = await this.analyzer.extractPatterns(historicalData);
    
    // ML 모델을 사용한 예측
    const prediction = await this.mlPredictor.predict({
      historicalData,
      patterns,
      timeframe
    });
    
    return {
      timeframe,
      expectedInvalidations: prediction.count,
      peakTimes: prediction.peaks,
      hotPatterns: prediction.patterns,
      confidence: prediction.confidence,
      recommendations: this.generatePredictiveRecommendations(prediction)
    };
  }
}

// 무효화 최적화 제안
export class InvalidationOptimizationAdvisor {
  async analyzeAndSuggest(
    metrics: InvalidationMetrics
  ): Promise<OptimizationSuggestions> {
    const suggestions: OptimizationSuggestion[] = [];
    
    // 1. 배치 처리 최적화
    if (metrics.avgBatchSize < 10) {
      suggestions.push({
        type: 'increase_batch_size',
        priority: 'high',
        description: 'Increase batch size to reduce overhead',
        expectedBenefit: {
          latency: '-40%',
          throughput: '+60%'
        },
        implementation: {
          currentValue: metrics.avgBatchSize,
          suggestedValue: 50,
          code: `cache.setConfig({ invalidationBatchSize: 50 })`
        }
      });
    }
    
    // 2. 캐스케이드 최적화
    if (metrics.avgCascadeDepth > 3) {
      suggestions.push({
        type: 'reduce_cascade_depth',
        priority: 'medium',
        description: 'Optimize dependency graph to reduce cascade depth',
        expectedBenefit: {
          invalidations: '-30%',
          complexity: '-50%'
        },
        implementation: {
          strategy: 'dependency_flattening',
          steps: [
            'Identify common cascade paths',
            'Create direct dependencies',
            'Remove intermediate nodes'
          ]
        }
      });
    }
    
    // 3. 시간 기반 최적화
    const peakHours = this.findPeakHours(metrics.hourlyDistribution);
    if (peakHours.length > 0) {
      suggestions.push({
        type: 'schedule_invalidations',
        priority: 'low',
        description: 'Schedule non-critical invalidations during off-peak hours',
        expectedBenefit: {
          peakLoad: '-25%',
          userExperience: '+15%'
        },
        implementation: {
          peakHours,
          offPeakHours: this.findOffPeakHours(metrics.hourlyDistribution),
          schedulingStrategy: 'delayed_invalidation'
        }
      });
    }
    
    return {
      suggestions,
      estimatedTotalBenefit: this.calculateTotalBenefit(suggestions),
      implementationPlan: this.createImplementationPlan(suggestions)
    };
  }
}

// 실시간 무효화 추적
export class RealtimeInvalidationTracker {
  private stream: InvalidationStream;
  private buffer: CircularBuffer<InvalidationEvent>;
  
  constructor(bufferSize: number = 10000) {
    this.stream = new InvalidationStream();
    this.buffer = new CircularBuffer(bufferSize);
    
    this.stream.on('invalidation', event => {
      this.buffer.push(event);
      this.processRealtimeEvent(event);
    });
  }
  
  // 실시간 통계
  getRealtimeStats(): RealtimeStats {
    const window = this.buffer.getRecent(1000); // 최근 1000개
    
    return {
      rate: this.calculateRate(window),
      avgLatency: this.calculateAvgLatency(window),
      patterns: this.extractPatterns(window),
      anomalies: this.detectRealtimeAnomalies(window)
    };
  }
  
  // 스트리밍 분석
  async streamAnalysis(
    callback: (analysis: StreamAnalysis) => void
  ): Promise<void> {
    const analyzer = new StreamingAnalyzer();
    
    this.stream.on('invalidation', async (event) => {
      const analysis = await analyzer.analyze(event);
      callback(analysis);
    });
  }
}
```
프로젝트 지식에서 Phase 2 Subtask Planning의 구조와 2.9.1 문서에 대한 정보를 찾아보겠습니다.Phase 2 데이터 레이어 구현의 전체 구조를 바탕으로 Task 2.9부터 작성하겠습니다. Phase 0과 Phase 1의 패턴을 참고하여 Phase 2의 Task 구조를 추정하면:

# Phase 2: 데이터 레이어 구현 - Task 2.9 이후 SubTask 문서

## 🏗️ Phase 2 전체 Task 구조 (추정)

### 데이터 모델링 (Tasks 2.1-2.3)
- Task 2.1: DynamoDB 테이블 설계
- Task 2.2: 엔티티 모델 정의
- Task 2.3: 인덱스 전략 수립

### 데이터 접근 계층 (Tasks 2.4-2.6)
- Task 2.4: Repository 패턴 구현
- Task 2.5: 쿼리 빌더 시스템
- Task 2.6: 트랜잭션 관리

### 캐싱 및 최적화 (Tasks 2.7-2.9)
- Task 2.7: Redis 캐싱 시스템 구축
- Task 2.8: 캐시 무효화 전략
- Task 2.9: 일괄 처리 시스템

### 데이터 동기화 (Tasks 2.10-2.12)
- Task 2.10: 변경 데이터 캡처 (CDC)
- Task 2.11: 이벤트 소싱
- Task 2.12: 데이터 복제 및 동기화

### 백업 및 복구 (Tasks 2.13-2.15)
- Task 2.13: 백업 자동화
- Task 2.14: 재해 복구 계획
- Task 2.15: 데이터 보안 및 암호화

---

## 📝 Task 2.9: 일괄 처리 시스템

### SubTask 2.9.1: 배치 프로세싱 아키텍처 설계
**담당자**: 시니어 백엔드 개발자  
**예상 소요시간**: 12시간

**목표**: 대량 데이터 처리를 위한 효율적인 배치 시스템 설계

**구현 내용**:
```typescript
// backend/src/batch/architecture/batch-processor.ts
import { SQSClient } from '@aws-sdk/client-sqs';
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
import Bull from 'bull';
import { EventEmitter } from 'events';

export interface BatchConfig {
  maxBatchSize: number;
  processingTimeout: number;
  parallelism: number;
  retryAttempts: number;
  scheduleCron?: string;
}

export interface BatchJob<T> {
  id: string;
  type: BatchJobType;
  data: T[];
  status: 'pending' | 'processing' | 'completed' | 'failed';
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  metadata: BatchMetadata;
}

export class BatchProcessor extends EventEmitter {
  private queue: Bull.Queue;
  private workers: Map<string, BatchWorker>;
  private monitor: BatchMonitor;
  
  constructor(
    private config: BatchConfig,
    private dynamoClient: DynamoDBDocumentClient,
    private sqsClient: SQSClient
  ) {
    super();
    this.queue = new Bull('batch-processing', {
      redis: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT || '6379')
      }
    });
    
    this.workers = new Map();
    this.monitor = new BatchMonitor(this.queue);
    
    this.initializeWorkers();
    this.setupScheduler();
  }
  
  private initializeWorkers(): void {
    // 사용자 데이터 배치 처리
    this.registerWorker('UserBatch', new UserBatchWorker());
    
    // 프로젝트 집계 처리
    this.registerWorker('ProjectAggregation', new ProjectAggregationWorker());
    
    // 로그 아카이빙
    this.registerWorker('LogArchiving', new LogArchivingWorker());
    
    // 데이터 정리
    this.registerWorker('DataCleanup', new DataCleanupWorker());
  }
  
  async submitBatch<T>(
    type: BatchJobType,
    data: T[],
    options?: BatchOptions
  ): Promise<string> {
    // 데이터를 청크로 분할
    const chunks = this.chunkData(data, this.config.maxBatchSize);
    
    const jobs: Bull.Job[] = [];
    for (const chunk of chunks) {
      const job = await this.queue.add(type, {
        data: chunk,
        options: options || {},
        timestamp: new Date()
      }, {
        attempts: this.config.retryAttempts,
        backoff: {
          type: 'exponential',
          delay: 2000
        },
        removeOnComplete: false,
        removeOnFail: false
      });
      
      jobs.push(job);
    }
    
    // 배치 그룹 ID 생성
    const batchGroupId = this.generateBatchGroupId();
    await this.saveBatchGroup(batchGroupId, jobs);
    
    return batchGroupId;
  }
  
  private chunkData<T>(data: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < data.length; i += size) {
      chunks.push(data.slice(i, i + size));
    }
    return chunks;
  }
}

// 배치 워커 기본 클래스
export abstract class BatchWorker<T> {
  abstract async process(data: T[], context: BatchContext): Promise<BatchResult>;
  
  async preProcess(data: T[]): Promise<T[]> {
    // 데이터 검증 및 전처리
    return data.filter(item => this.validate(item));
  }
  
  abstract validate(item: T): boolean;
  
  async postProcess(result: BatchResult): Promise<void> {
    // 결과 후처리 및 알림
    if (result.failed.length > 0) {
      await this.handleFailures(result.failed);
    }
  }
  
  protected async handleFailures(failures: any[]): Promise<void> {
    // 실패 항목 처리 로직
    console.error(`Batch processing failed for ${failures.length} items`);
  }
}
```

### SubTask 2.9.2: 스트림 처리 통합
**담당자**: 데이터 엔지니어  
**예상 소요시간**: 14시간

**목표**: DynamoDB Streams와 Kinesis를 활용한 실시간 데이터 처리

**구현 내용**:
```typescript
// backend/src/batch/stream/stream-processor.ts
import { DynamoDBStreamsClient } from '@aws-sdk/client-dynamodb-streams';
import { KinesisClient } from '@aws-sdk/client-kinesis';
import { unmarshall } from '@aws-sdk/util-dynamodb';

export interface StreamConfig {
  streamArn: string;
  shardIteratorType: 'TRIM_HORIZON' | 'LATEST' | 'AT_SEQUENCE_NUMBER';
  batchSize: number;
  parallelProcessing: boolean;
  checkpointInterval: number;
}

export class StreamProcessor {
  private isProcessing: boolean = false;
  private checkpoints: Map<string, string> = new Map();
  private processors: Map<string, StreamRecordProcessor> = new Map();
  
  constructor(
    private config: StreamConfig,
    private streamsClient: DynamoDBStreamsClient,
    private kinesisClient: KinesisClient
  ) {
    this.initializeProcessors();
  }
  
  private initializeProcessors(): void {
    // 레코드 타입별 프로세서 등록
    this.processors.set('INSERT', new InsertRecordProcessor());
    this.processors.set('MODIFY', new ModifyRecordProcessor());
    this.processors.set('REMOVE', new RemoveRecordProcessor());
  }
  
  async startProcessing(): Promise<void> {
    if (this.isProcessing) {
      throw new Error('Stream processing is already running');
    }
    
    this.isProcessing = true;
    
    // 샤드 정보 가져오기
    const shards = await this.getStreamShards();
    
    // 각 샤드에 대해 병렬 처리
    if (this.config.parallelProcessing) {
      await Promise.all(shards.map(shard => this.processShard(shard)));
    } else {
      for (const shard of shards) {
        await this.processShard(shard);
      }
    }
  }
  
  private async processShard(shardId: string): Promise<void> {
    let shardIterator = await this.getShardIterator(shardId);
    
    while (this.isProcessing && shardIterator) {
      try {
        const records = await this.getRecords(shardIterator);
        
        if (records.Records && records.Records.length > 0) {
          // 배치로 레코드 처리
          await this.processBatch(records.Records);
          
          // 체크포인트 저장
          if (records.Records.length > 0) {
            const lastSequenceNumber = records.Records[records.Records.length - 1].dynamodb?.SequenceNumber;
            if (lastSequenceNumber) {
              await this.saveCheckpoint(shardId, lastSequenceNumber);
            }
          }
        }
        
        shardIterator = records.NextShardIterator || null;
        
        // 레코드가 없으면 잠시 대기
        if (!records.Records || records.Records.length === 0) {
          await this.sleep(1000);
        }
      } catch (error) {
        console.error(`Error processing shard ${shardId}:`, error);
        await this.handleShardError(shardId, error);
      }
    }
  }
  
  private async processBatch(records: any[]): Promise<void> {
    const processedRecords = await Promise.all(
      records.map(async record => {
        try {
          const eventName = record.eventName;
          const processor = this.processors.get(eventName);
          
          if (processor) {
            const unmarshalledRecord = this.unmarshallRecord(record);
            return await processor.process(unmarshalledRecord);
          }
        } catch (error) {
          console.error('Error processing record:', error);
          return { success: false, error };
        }
      })
    );
    
    // Kinesis로 처리 결과 전송
    await this.sendToKinesis(processedRecords);
  }
  
  private unmarshallRecord(record: any): any {
    return {
      eventName: record.eventName,
      eventID: record.eventID,
      eventVersion: record.eventVersion,
      dynamodb: {
        Keys: record.dynamodb.Keys ? unmarshall(record.dynamodb.Keys) : undefined,
        NewImage: record.dynamodb.NewImage ? unmarshall(record.dynamodb.NewImage) : undefined,
        OldImage: record.dynamodb.OldImage ? unmarshall(record.dynamodb.OldImage) : undefined,
        SequenceNumber: record.dynamodb.SequenceNumber,
        SizeBytes: record.dynamodb.SizeBytes,
        StreamViewType: record.dynamodb.StreamViewType
      }
    };
  }
}

// 레코드 프로세서 인터페이스
export abstract class StreamRecordProcessor {
  abstract async process(record: any): Promise<ProcessingResult>;
  
  protected async enrichRecord(record: any): Promise<any> {
    // 레코드에 추가 정보 보강
    return {
      ...record,
      processedAt: new Date(),
      processorVersion: '1.0.0'
    };
  }
}
```

### SubTask 2.9.3: 병렬 처리 최적화
**담당자**: 성능 엔지니어  
**예상 소요시간**: 10시간

**목표**: 대규모 데이터 처리를 위한 병렬화 및 성능 최적화

**구현 내용**:
```typescript
// backend/src/batch/optimization/parallel-optimizer.ts
import { Worker } from 'worker_threads';
import os from 'os';
import PQueue from 'p-queue';

export class ParallelOptimizer {
  private workerPool: Worker[] = [];
  private queue: PQueue;
  private metrics: PerformanceMetrics;
  
  constructor(
    private config: ParallelConfig
  ) {
    const concurrency = config.concurrency || os.cpus().length;
    this.queue = new PQueue({ concurrency });
    this.metrics = new PerformanceMetrics();
    
    this.initializeWorkerPool(concurrency);
  }
  
  private initializeWorkerPool(size: number): void {
    for (let i = 0; i < size; i++) {
      const worker = new Worker('./batch-worker.js', {
        workerData: {
          workerId: i,
          config: this.config
        }
      });
      
      worker.on('message', this.handleWorkerMessage.bind(this));
      worker.on('error', this.handleWorkerError.bind(this));
      
      this.workerPool.push(worker);
    }
  }
  
  async processBatchParallel<T, R>(
    items: T[],
    processor: (item: T) => Promise<R>,
    options?: ProcessingOptions
  ): Promise<BatchProcessingResult<R>> {
    const startTime = Date.now();
    const results: R[] = [];
    const errors: ProcessingError[] = [];
    
    // 동적 청크 크기 계산
    const chunkSize = this.calculateOptimalChunkSize(items.length);
    const chunks = this.createChunks(items, chunkSize);
    
    // 각 청크를 병렬로 처리
    const chunkPromises = chunks.map((chunk, index) => 
      this.queue.add(async () => {
        try {
          const chunkResults = await this.processChunk(
            chunk, 
            processor, 
            index
          );
          results.push(...chunkResults);
        } catch (error) {
          errors.push({
            chunkIndex: index,
            error: error as Error,
            items: chunk
          });
        }
      })
    );
    
    await Promise.all(chunkPromises);
    
    // 성능 메트릭 수집
    const processingTime = Date.now() - startTime;
    this.metrics.record({
      totalItems: items.length,
      successfulItems: results.length,
      failedItems: errors.length,
      processingTime,
      throughput: items.length / (processingTime / 1000)
    });
    
    return {
      results,
      errors,
      metrics: this.metrics.getSummary()
    };
  }
  
  private calculateOptimalChunkSize(totalItems: number): number {
    // CPU 코어 수와 메모리를 고려한 최적 청크 크기 계산
    const cpuCount = os.cpus().length;
    const freeMemory = os.freemem();
    const itemSizeEstimate = 1024; // 예상 아이템 크기 (bytes)
    
    const memoryBasedLimit = Math.floor(freeMemory * 0.7 / itemSizeEstimate);
    const cpuBasedLimit = Math.ceil(totalItems / cpuCount);
    
    return Math.min(
      memoryBasedLimit,
      cpuBasedLimit,
      this.config.maxChunkSize || 1000
    );
  }
  
  // 적응형 동시성 제어
  async adaptiveConcurrencyControl<T>(
    tasks: (() => Promise<T>)[]
  ): Promise<T[]> {
    let concurrency = this.config.initialConcurrency || 10;
    const results: T[] = [];
    let taskIndex = 0;
    
    while (taskIndex < tasks.length) {
      const batchSize = Math.min(concurrency, tasks.length - taskIndex);
      const batch = tasks.slice(taskIndex, taskIndex + batchSize);
      
      const startTime = Date.now();
      const batchResults = await Promise.all(
        batch.map(task => this.executeWithTimeout(task))
      );
      const batchTime = Date.now() - startTime;
      
      results.push(...batchResults);
      taskIndex += batchSize;
      
      // 동시성 레벨 조정
      concurrency = this.adjustConcurrency(
        concurrency,
        batchTime,
        batchSize
      );
    }
    
    return results;
  }
  
  private adjustConcurrency(
    current: number,
    executionTime: number,
    batchSize: number
  ): number {
    const targetTime = 1000; // 목표 실행 시간 (ms)
    const ratio = targetTime / executionTime;
    
    if (ratio > 1.2) {
      // 실행이 빠르면 동시성 증가
      return Math.min(current * 1.5, this.config.maxConcurrency || 100);
    } else if (ratio < 0.8) {
      // 실행이 느리면 동시성 감소
      return Math.max(current * 0.7, this.config.minConcurrency || 5);
    }
    
    return current;
  }
}

// 성능 메트릭 수집기
export class PerformanceMetrics {
  private metrics: Metric[] = [];
  
  record(metric: Metric): void {
    this.metrics.push({
      ...metric,
      timestamp: new Date()
    });
    
    // 메트릭을 CloudWatch로 전송
    this.sendToCloudWatch(metric);
  }
  
  getSummary(): MetricsSummary {
    const recentMetrics = this.getRecentMetrics(60); // 최근 60초
    
    return {
      averageThroughput: this.calculateAverage(
        recentMetrics.map(m => m.throughput)
      ),
      successRate: this.calculateSuccessRate(recentMetrics),
      p99ProcessingTime: this.calculatePercentile(
        recentMetrics.map(m => m.processingTime),
        99
      )
    };
  }
}
```

### SubTask 2.9.4: 배치 모니터링 대시보드
**담당자**: 풀스택 개발자  
**예상 소요시간**: 8시간

**목표**: 배치 작업 상태와 성능을 실시간으로 모니터링하는 대시보드 구현

**구현 내용**:
```typescript
// backend/src/batch/monitoring/batch-monitor.ts
import { EventEmitter } from 'events';
import Bull from 'bull';
import { CloudWatchClient } from '@aws-sdk/client-cloudwatch';
import WebSocket from 'ws';

export interface BatchMetrics {
  activeJobs: number;
  completedJobs: number;
  failedJobs: number;
  averageProcessingTime: number;
  throughput: number;
  queueLength: number;
  workerUtilization: number;
}

export class BatchMonitor extends EventEmitter {
  private metrics: BatchMetrics;
  private cloudWatch: CloudWatchClient;
  private wsServer: WebSocket.Server;
  private updateInterval: NodeJS.Timer;
  
  constructor(
    private queue: Bull.Queue,
    private config: MonitorConfig
  ) {
    super();
    this.cloudWatch = new CloudWatchClient({ region: config.region });
    this.wsServer = new WebSocket.Server({ port: config.wsPort || 8080 });
    
    this.initializeMetrics();
    this.setupEventListeners();
    this.startMetricsCollection();
  }
  
  private initializeMetrics(): void {
    this.metrics = {
      activeJobs: 0,
      completedJobs: 0,
      failedJobs: 0,
      averageProcessingTime: 0,
      throughput: 0,
      queueLength: 0,
      workerUtilization: 0
    };
  }
  
  private setupEventListeners(): void {
    // 큐 이벤트 리스너
    this.queue.on('active', this.onJobActive.bind(this));
    this.queue.on('completed', this.onJobCompleted.bind(this));
    this.queue.on('failed', this.onJobFailed.bind(this));
    this.queue.on('stalled', this.onJobStalled.bind(this));
    
    // WebSocket 연결 처리
    this.wsServer.on('connection', (ws) => {
      // 새 클라이언트에게 현재 메트릭 전송
      ws.send(JSON.stringify({
        type: 'metrics',
        data: this.metrics
      }));
      
      // 주기적 업데이트 구독
      const interval = setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'metrics',
            data: this.metrics
          }));
        }
      }, 1000);
      
      ws.on('close', () => clearInterval(interval));
    });
  }
  
  private async collectMetrics(): Promise<void> {
    const [waiting, active, completed, failed] = await Promise.all([
      this.queue.getWaitingCount(),
      this.queue.getActiveCount(),
      this.queue.getCompletedCount(),
      this.queue.getFailedCount()
    ]);
    
    this.metrics = {
      ...this.metrics,
      queueLength: waiting,
      activeJobs: active,
      completedJobs: completed,
      failedJobs: failed,
      throughput: this.calculateThroughput(),
      workerUtilization: this.calculateWorkerUtilization()
    };
    
    // CloudWatch로 메트릭 전송
    await this.publishMetrics();
    
    // 임계값 체크
    this.checkThresholds();
  }
  
  private async publishMetrics(): Promise<void> {
    const metricData = [
      {
        MetricName: 'BatchQueueLength',
        Value: this.metrics.queueLength,
        Unit: 'Count'
      },
      {
        MetricName: 'BatchThroughput',
        Value: this.metrics.throughput,
        Unit: 'Count/Second'
      },
      {
        MetricName: 'BatchWorkerUtilization',
        Value: this.metrics.workerUtilization,
        Unit: 'Percent'
      }
    ];
    
    try {
      await this.cloudWatch.putMetricData({
        Namespace: 'T-Developer/Batch',
        MetricData: metricData
      });
    } catch (error) {
      console.error('Failed to publish metrics:', error);
    }
  }
  
  private checkThresholds(): void {
    // 큐 길이 임계값
    if (this.metrics.queueLength > this.config.queueLengthThreshold) {
      this.emit('threshold:queue_length', {
        current: this.metrics.queueLength,
        threshold: this.config.queueLengthThreshold
      });
    }
    
    // 실패율 임계값
    const failureRate = this.metrics.failedJobs / 
      (this.metrics.completedJobs + this.metrics.failedJobs);
    
    if (failureRate > this.config.failureRateThreshold) {
      this.emit('threshold:failure_rate', {
        current: failureRate,
        threshold: this.config.failureRateThreshold
      });
    }
  }
  
  // 대시보드 API
  async getDashboardData(): Promise<DashboardData> {
    const jobCounts = await this.queue.getJobCounts();
    const workers = await this.queue.getWorkers();
    
    return {
      overview: this.metrics,
      jobDistribution: jobCounts,
      workers: workers.map(w => ({
        id: w.id,
        status: w.status,
        currentJob: w.currentJob,
        startTime: w.startTime
      })),
      recentJobs: await this.getRecentJobs(),
      performanceHistory: await this.getPerformanceHistory()
    };
  }
}

// 대시보드 REST API
export class BatchDashboardAPI {
  constructor(
    private monitor: BatchMonitor,
    private app: any // Express app
  ) {
    this.setupRoutes();
  }
  
  private setupRoutes(): void {
    // 대시보드 데이터
    this.app.get('/api/batch/dashboard', async (req: any, res: any) => {
      try {
        const data = await this.monitor.getDashboardData();
        res.json(data);
      } catch (error) {
        res.status(500).json({ error: 'Failed to get dashboard data' });
      }
    });
    
    // 특정 작업 상세
    this.app.get('/api/batch/jobs/:id', async (req: any, res: any) => {
      try {
        const job = await this.monitor.getJobDetails(req.params.id);
        res.json(job);
      } catch (error) {
        res.status(404).json({ error: 'Job not found' });
      }
    });
    
    // 작업 재시도
    this.app.post('/api/batch/jobs/:id/retry', async (req: any, res: any) => {
      try {
        await this.monitor.retryJob(req.params.id);
        res.json({ success: true });
      } catch (error) {
        res.status(500).json({ error: 'Failed to retry job' });
      }
    });
  }
}
```
## Task 2.10: 변경 데이터 캡처 (CDC)

### SubTask 2.10.1: DynamoDB Streams 설정
**담당자**: 데이터 엔지니어  
**예상 소요시간**: 10시간

**목표**: DynamoDB 테이블에 스트림을 활성화하고 변경 사항 캡처 설정

**구현 내용**:
```typescript
// backend/src/cdc/streams/dynamodb-cdc.ts
import { 
  DynamoDBClient, 
  UpdateTableCommand,
  DescribeTableCommand 
} from '@aws-sdk/client-dynamodb';
import { 
  DynamoDBStreamsClient,
  DescribeStreamCommand,
  GetShardIteratorCommand,
  GetRecordsCommand
} from '@aws-sdk/client-dynamodb-streams';

export interface CDCConfig {
  tableName: string;
  streamViewType: 'NEW_IMAGE' | 'OLD_IMAGE' | 'NEW_AND_OLD_IMAGES' | 'KEYS_ONLY';
  batchSize: number;
  processingInterval: number;
  errorRetryAttempts: number;
}

export class DynamoDBCDC {
  private dynamoClient: DynamoDBClient;
  private streamsClient: DynamoDBStreamsClient;
  private processors: Map<string, CDCProcessor> = new Map();
  private isRunning: boolean = false;
  
  constructor(
    private config: CDCConfig,
    region: string
  ) {
    this.dynamoClient = new DynamoDBClient({ region });
    this.streamsClient = new DynamoDBStreamsClient({ region });
    
    this.initializeProcessors();
  }
  
  // 스트림 활성화
  async enableStreams(): Promise<string> {
    const describeResponse = await this.dynamoClient.send(
      new DescribeTableCommand({ TableName: this.config.tableName })
    );
    
    if (!describeResponse.Table?.StreamSpecification?.StreamEnabled) {
      // 스트림 활성화
      await this.dynamoClient.send(
        new UpdateTableCommand({
          TableName: this.config.tableName,
          StreamSpecification: {
            StreamEnabled: true,
            StreamViewType: this.config.streamViewType
          }
        })
      );
      
      // 스트림이 활성화될 때까지 대기
      await this.waitForStreamEnabled();
    }
    
    return describeResponse.Table?.LatestStreamArn || '';
  }
  
  // CDC 프로세서 초기화
  private initializeProcessors(): void {
    // 엔티티별 CDC 프로세서
    this.processors.set('User', new UserCDCProcessor());
    this.processors.set('Project', new ProjectCDCProcessor());
    this.processors.set('Task', new TaskCDCProcessor());
    this.processors.set('Agent', new AgentCDCProcessor());
  }
  
  // 변경 사항 처리 시작
  async startCDC(streamArn: string): Promise<void> {
    this.isRunning = true;
    
    const streamDescription = await this.streamsClient.send(
      new DescribeStreamCommand({ StreamArn: streamArn })
    );
    
    const shards = streamDescription.StreamDescription?.Shards || [];
    
    // 각 샤드에 대해 병렬 처리
    await Promise.all(
      shards.map(shard => this.processShard(streamArn, shard.ShardId!))
    );
  }
  
  // 샤드 처리
  private async processShard(streamArn: string, shardId: string): Promise<void> {
    let shardIterator = await this.getInitialShardIterator(streamArn, shardId);
    let consecutiveEmptyReads = 0;
    
    while (this.isRunning && shardIterator) {
      try {
        const records = await this.streamsClient.send(
          new GetRecordsCommand({ 
            ShardIterator: shardIterator,
            Limit: this.config.batchSize 
          })
        );
        
        if (records.Records && records.Records.length > 0) {
          await this.processRecords(records.Records);
          consecutiveEmptyReads = 0;
        } else {
          consecutiveEmptyReads++;
          
          // 연속적으로 빈 응답이 오면 대기 시간 증가
          const waitTime = Math.min(
            consecutiveEmptyReads * 100,
            this.config.processingInterval
          );
          await this.sleep(waitTime);
        }
        
        shardIterator = records.NextShardIterator || null;
        
      } catch (error) {
        console.error(`Error processing shard ${shardId}:`, error);
        await this.handleShardError(shardId, error);
        
        // 에러 발생 시 샤드 이터레이터 재획득
        shardIterator = await this.getInitialShardIterator(streamArn, shardId);
      }
    }
  }
  
  // 레코드 처리
  private async processRecords(records: any[]): Promise<void> {
    const changeEvents: ChangeEvent[] = records.map(record => ({
      eventId: record.eventID,
      eventName: record.eventName as ChangeEventType,
      tableName: this.extractTableName(record),
      keys: record.dynamodb.Keys,
      newImage: record.dynamodb.NewImage,
      oldImage: record.dynamodb.OldImage,
      sequenceNumber: record.dynamodb.SequenceNumber,
      timestamp: new Date(record.dynamodb.ApproximateCreationDateTime! * 1000)
    }));
    
    // 배치로 변경 이벤트 처리
    await this.processChangeEvents(changeEvents);
  }
  
  // 변경 이벤트 처리
  private async processChangeEvents(events: ChangeEvent[]): Promise<void> {
    const groupedEvents = this.groupEventsByEntity(events);
    
    for (const [entityType, entityEvents] of groupedEvents) {
      const processor = this.processors.get(entityType);
      
      if (processor) {
        try {
          await processor.processChanges(entityEvents);
        } catch (error) {
          console.error(`Error processing ${entityType} changes:`, error);
          await this.handleProcessingError(entityType, entityEvents, error);
        }
      }
    }
  }
}

// CDC 프로세서 인터페이스
export abstract class CDCProcessor {
  abstract async processChanges(events: ChangeEvent[]): Promise<void>;
  
  protected async handleInsert(event: ChangeEvent): Promise<void> {
    // 새 레코드 삽입 처리
  }
  
  protected async handleModify(event: ChangeEvent): Promise<void> {
    // 레코드 수정 처리
  }
  
  protected async handleRemove(event: ChangeEvent): Promise<void> {
    // 레코드 삭제 처리
  }
}

// 사용자 CDC 프로세서 예시
export class UserCDCProcessor extends CDCProcessor {
  async processChanges(events: ChangeEvent[]): Promise<void> {
    for (const event of events) {
      switch (event.eventName) {
        case 'INSERT':
          await this.handleUserCreated(event);
          break;
        case 'MODIFY':
          await this.handleUserUpdated(event);
          break;
        case 'REMOVE':
          await this.handleUserDeleted(event);
          break;
      }
    }
  }
  
  private async handleUserCreated(event: ChangeEvent): Promise<void> {
    // 사용자 생성 이벤트 발행
    await this.publishEvent('UserCreated', {
      userId: event.keys.userId,
      userData: event.newImage,
      timestamp: event.timestamp
    });
    
    // 검색 인덱스 업데이트
    await this.updateSearchIndex('create', event.newImage);
    
    // 캐시 워밍
    await this.warmCache(event.keys.userId, event.newImage);
  }
}
```

### SubTask 2.10.2: 변경 이벤트 라우팅
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**목표**: 캡처된 변경 사항을 적절한 소비자에게 라우팅하는 시스템 구현

**구현 내용**:
```typescript
// backend/src/cdc/routing/event-router.ts
import { EventBridge } from '@aws-sdk/client-eventbridge';
import { SQSClient } from '@aws-sdk/client-sqs';
import { SNSClient } from '@aws-sdk/client-sns';

export interface RoutingRule {
  id: string;
  name: string;
  eventPattern: EventPattern;
  targets: RoutingTarget[];
  enabled: boolean;
}

export interface EventPattern {
  source?: string[];
  detailType?: string[];
  detail?: {
    eventName?: string[];
    entityType?: string[];
    [key: string]: any;
  };
}

export interface RoutingTarget {
  type: 'sqs' | 'sns' | 'lambda' | 'webhook';
  arn?: string;
  url?: string;
  retryPolicy?: RetryPolicy;
  deadLetterConfig?: DeadLetterConfig;
}

export class EventRouter {
  private eventBridge: EventBridge;
  private sqsClient: SQSClient;
  private snsClient: SNSClient;
  private routingRules: Map<string, RoutingRule> = new Map();
  private metrics: RouterMetrics;
  
  constructor(
    private config: RouterConfig
  ) {
    this.eventBridge = new EventBridge({ region: config.region });
    this.sqsClient = new SQSClient({ region: config.region });
    this.snsClient = new SNSClient({ region: config.region });
    this.metrics = new RouterMetrics();
    
    this.loadRoutingRules();
  }
  
  // 라우팅 규칙 로드
  private async loadRoutingRules(): Promise<void> {
    // 사용자 이벤트 라우팅
    this.addRule({
      id: 'user-events',
      name: 'User Change Events',
      eventPattern: {
        source: ['dynamodb.cdc'],
        detailType: ['User Change'],
        detail: {
          eventName: ['INSERT', 'MODIFY', 'REMOVE']
        }
      },
      targets: [
        {
          type: 'sqs',
          arn: process.env.USER_EVENTS_QUEUE_ARN!,
          retryPolicy: { maxAttempts: 3, backoffRate: 2 }
        },
        {
          type: 'sns',
          arn: process.env.USER_EVENTS_TOPIC_ARN!
        }
      ],
      enabled: true
    });
    
    // 프로젝트 이벤트 라우팅
    this.addRule({
      id: 'project-events',
      name: 'Project Change Events',
      eventPattern: {
        source: ['dynamodb.cdc'],
        detailType: ['Project Change'],
        detail: {
          eventName: ['INSERT', 'MODIFY']
        }
      },
      targets: [
        {
          type: 'lambda',
          arn: process.env.PROJECT_PROCESSOR_LAMBDA_ARN!
        },
        {
          type: 'webhook',
          url: process.env.PROJECT_WEBHOOK_URL!,
          retryPolicy: { maxAttempts: 5, backoffRate: 2 }
        }
      ],
      enabled: true
    });
  }
  
  // 이벤트 라우팅
  async routeEvent(event: ChangeEvent): Promise<RoutingResult> {
    const startTime = Date.now();
    const results: TargetResult[] = [];
    
    // 매칭되는 규칙 찾기
    const matchingRules = this.findMatchingRules(event);
    
    if (matchingRules.length === 0) {
      this.metrics.recordUnroutedEvent(event);
      return { success: false, reason: 'No matching rules' };
    }
    
    // 각 규칙의 타겟으로 이벤트 전송
    for (const rule of matchingRules) {
      if (!rule.enabled) continue;
      
      for (const target of rule.targets) {
        try {
          const result = await this.sendToTarget(event, target);
          results.push({
            targetType: target.type,
            success: true,
            latency: result.latency
          });
        } catch (error) {
          results.push({
            targetType: target.type,
            success: false,
            error: error as Error
          });
          
          // 데드레터 큐로 전송
          if (target.deadLetterConfig) {
            await this.sendToDeadLetter(event, target, error);
          }
        }
      }
    }
    
    // 메트릭 기록
    this.metrics.recordRouting({
      eventType: event.eventName,
      entityType: event.entityType,
      ruleCount: matchingRules.length,
      targetCount: results.length,
      successCount: results.filter(r => r.success).length,
      latency: Date.now() - startTime
    });
    
    return {
      success: results.some(r => r.success),
      results
    };
  }
  
  // 타겟으로 이벤트 전송
  private async sendToTarget(
    event: ChangeEvent, 
    target: RoutingTarget
  ): Promise<SendResult> {
    const startTime = Date.now();
    
    switch (target.type) {
      case 'sqs':
        await this.sendToSQS(event, target.arn!);
        break;
        
      case 'sns':
        await this.sendToSNS(event, target.arn!);
        break;
        
      case 'lambda':
        await this.invokeLambda(event, target.arn!);
        break;
        
      case 'webhook':
        await this.sendToWebhook(event, target.url!);
        break;
        
      default:
        throw new Error(`Unknown target type: ${target.type}`);
    }
    
    return {
      success: true,
      latency: Date.now() - startTime
    };
  }
  
  // 이벤트 변환 및 보강
  private async enrichEvent(event: ChangeEvent): Promise<EnrichedEvent> {
    const enriched: EnrichedEvent = {
      ...event,
      metadata: {
        routedAt: new Date(),
        routerId: this.config.routerId,
        version: '1.0.0'
      }
    };
    
    // 엔티티별 보강 로직
    switch (event.entityType) {
      case 'User':
        enriched.additionalData = await this.enrichUserEvent(event);
        break;
        
      case 'Project':
        enriched.additionalData = await this.enrichProjectEvent(event);
        break;
    }
    
    return enriched;
  }
}

// 이벤트 필터링 및 변환
export class EventFilter {
  private filters: Map<string, FilterFunction> = new Map();
  private transformers: Map<string, TransformFunction> = new Map();
  
  constructor() {
    this.initializeFilters();
    this.initializeTransformers();
  }
  
  private initializeFilters(): void {
    // 민감한 데이터 필터
    this.filters.set('sensitive-data', (event: ChangeEvent) => {
      if (event.newImage) {
        delete event.newImage.password;
        delete event.newImage.ssn;
        delete event.newImage.creditCard;
      }
      return event;
    });
    
    // 내부 필드 필터
    this.filters.set('internal-fields', (event: ChangeEvent) => {
      if (event.newImage) {
        Object.keys(event.newImage).forEach(key => {
          if (key.startsWith('_')) {
            delete event.newImage[key];
          }
        });
      }
      return event;
    });
  }
  
  async filterEvent(
    event: ChangeEvent, 
    filterNames: string[]
  ): Promise<ChangeEvent> {
    let filteredEvent = { ...event };
    
    for (const filterName of filterNames) {
      const filter = this.filters.get(filterName);
      if (filter) {
        filteredEvent = await filter(filteredEvent);
      }
    }
    
    return filteredEvent;
  }
}
```

### SubTask 2.10.3: 변경 사항 추적 및 감사
**담당자**: 보안 엔지니어  
**예상 소요시간**: 10시간

**목표**: 모든 데이터 변경 사항에 대한 감사 로그 및 추적 시스템 구현

**구현 내용**:
```typescript
// backend/src/cdc/audit/audit-trail.ts
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
import { S3Client } from '@aws-sdk/client-s3';
import crypto from 'crypto';

export interface AuditRecord {
  auditId: string;
  timestamp: Date;
  entityType: string;
  entityId: string;
  action: 'CREATE' | 'UPDATE' | 'DELETE' | 'ACCESS';
  userId?: string;
  userRole?: string;
  clientIp?: string;
  userAgent?: string;
  changes?: FieldChange[];
  metadata?: Record<string, any>;
  hash: string;
  previousHash?: string;
}

export interface FieldChange {
  fieldName: string;
  oldValue: any;
  newValue: any;
  encrypted?: boolean;
}

export class AuditTrail {
  private auditTable: string = 'AuditTrail';
  private s3Bucket: string;
  private encryptionKey: Buffer;
  private chainValidator: ChainValidator;
  
  constructor(
    private dynamoClient: DynamoDBDocumentClient,
    private s3Client: S3Client,
    private config: AuditConfig
  ) {
    this.s3Bucket = config.archiveBucket;
    this.encryptionKey = Buffer.from(config.encryptionKey, 'base64');
    this.chainValidator = new ChainValidator(dynamoClient);
  }
  
  // 감사 레코드 생성
  async createAuditRecord(params: CreateAuditParams): Promise<AuditRecord> {
    // 이전 해시 가져오기 (블록체인 스타일)
    const previousHash = await this.getPreviousHash(params.entityType, params.entityId);
    
    // 변경 사항 추출
    const changes = this.extractChanges(params.oldData, params.newData);
    
    // 민감한 필드 암호화
    const encryptedChanges = await this.encryptSensitiveFields(changes);
    
    // 감사 레코드 생성
    const auditRecord: AuditRecord = {
      auditId: this.generateAuditId(),
      timestamp: new Date(),
      entityType: params.entityType,
      entityId: params.entityId,
      action: params.action,
      userId: params.context?.userId,
      userRole: params.context?.userRole,
      clientIp: params.context?.clientIp,
      userAgent: params.context?.userAgent,
      changes: encryptedChanges,
      metadata: params.metadata,
      hash: '',
      previousHash
    };
    
    // 해시 계산
    auditRecord.hash = this.calculateHash(auditRecord);
    
    // DynamoDB에 저장
    await this.saveAuditRecord(auditRecord);
    
    // 실시간 알림 (의심스러운 활동)
    await this.checkSuspiciousActivity(auditRecord);
    
    return auditRecord;
  }
  
  // 변경 사항 추출
  private extractChanges(oldData: any, newData: any): FieldChange[] {
    const changes: FieldChange[] = [];
    const allKeys = new Set([
      ...Object.keys(oldData || {}),
      ...Object.keys(newData || {})
    ]);
    
    for (const key of allKeys) {
      const oldValue = oldData?.[key];
      const newValue = newData?.[key];
      
      if (!this.deepEqual(oldValue, newValue)) {
        changes.push({
          fieldName: key,
          oldValue: this.sanitizeValue(oldValue),
          newValue: this.sanitizeValue(newValue),
          encrypted: this.isSensitiveField(key)
        });
      }
    }
    
    return changes;
  }
  
  // 민감한 필드 암호화
  private async encryptSensitiveFields(
    changes: FieldChange[]
  ): Promise<FieldChange[]> {
    return Promise.all(
      changes.map(async change => {
        if (change.encrypted) {
          return {
            ...change,
            oldValue: change.oldValue ? 
              await this.encrypt(JSON.stringify(change.oldValue)) : null,
            newValue: change.newValue ? 
              await this.encrypt(JSON.stringify(change.newValue)) : null
          };
        }
        return change;
      })
    );
  }
  
  // 감사 로그 쿼리
  async queryAuditLogs(params: AuditQueryParams): Promise<AuditQueryResult> {
    const query = this.buildAuditQuery(params);
    const results = await this.executeQuery(query);
    
    // 체인 무결성 검증
    if (params.verifyIntegrity) {
      const integrityCheck = await this.chainValidator.verifyChain(
        results.records
      );
      
      if (!integrityCheck.valid) {
        throw new Error('Audit chain integrity violation detected');
      }
    }
    
    return {
      records: results.records,
      nextToken: results.nextToken,
      summary: this.generateAuditSummary(results.records)
    };
  }
  
  // 의심스러운 활동 감지
  private async checkSuspiciousActivity(
    record: AuditRecord
  ): Promise<void> {
    const suspiciousPatterns = [
      // 대량 삭제
      {
        pattern: 'mass-deletion',
        check: () => record.action === 'DELETE' && 
                     record.metadata?.affectedCount > 100
      },
      // 권한 상승
      {
        pattern: 'privilege-escalation',
        check: () => record.entityType === 'User' && 
                     record.changes?.some(c => 
                       c.fieldName === 'role' && 
                       this.isPrivilegeEscalation(c.oldValue, c.newValue)
                     )
      },
      // 비정상 접근 시간
      {
        pattern: 'unusual-time',
        check: () => {
          const hour = record.timestamp.getHours();
          return hour < 6 || hour > 22; // 업무 시간 외
        }
      },
      // 비정상 위치
      {
        pattern: 'unusual-location',
        check: async () => {
          if (record.clientIp) {
            const location = await this.getGeoLocation(record.clientIp);
            return this.isUnusualLocation(record.userId!, location);
          }
          return false;
        }
      }
    ];
    
    for (const { pattern, check } of suspiciousPatterns) {
      if (await check()) {
        await this.raiseSuspiciousActivityAlert({
          pattern,
          auditRecord: record,
          severity: this.calculateSeverity(pattern, record)
        });
      }
    }
  }
  
  // 감사 로그 아카이빙
  async archiveAuditLogs(
    startDate: Date,
    endDate: Date
  ): Promise<ArchiveResult> {
    const records = await this.getAuditRecordsForPeriod(startDate, endDate);
    
    // S3에 압축하여 저장
    const archiveKey = `audit-logs/${startDate.toISOString()}-${endDate.toISOString()}.gz`;
    const compressedData = await this.compressData(records);
    
    await this.s3Client.putObject({
      Bucket: this.s3Bucket,
      Key: archiveKey,
      Body: compressedData,
      ServerSideEncryption: 'aws:kms',
      Metadata: {
        recordCount: records.length.toString(),
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
        checksum: this.calculateChecksum(compressedData)
      }
    });
    
    // DynamoDB에서 삭제 (선택적)
    if (this.config.deleteAfterArchive) {
      await this.deleteArchivedRecords(records);
    }
    
    return {
      archivedCount: records.length,
      archiveSize: compressedData.length,
      archiveLocation: `s3://${this.s3Bucket}/${archiveKey}`
    };
  }
}

// 감사 보고서 생성기
export class AuditReporter {
  constructor(
    private auditTrail: AuditTrail,
    private config: ReporterConfig
  ) {}
  
  // 컴플라이언스 보고서 생성
  async generateComplianceReport(
    period: ReportPeriod
  ): Promise<ComplianceReport> {
    const auditData = await this.auditTrail.queryAuditLogs({
      startDate: period.start,
      endDate: period.end,
      verifyIntegrity: true
    });
    
    return {
      period,
      summary: {
        totalActions: auditData.records.length,
        actionBreakdown: this.groupByAction(auditData.records),
        userActivity: this.analyzeUserActivity(auditData.records),
        dataAccessPatterns: this.analyzeAccessPatterns(auditData.records)
      },
      compliance: {
        gdpr: this.checkGDPRCompliance(auditData.records),
        hipaa: this.checkHIPAACompliance(auditData.records),
        sox: this.checkSOXCompliance(auditData.records)
      },
      anomalies: await this.detectAnomalies(auditData.records),
      recommendations: this.generateRecommendations(auditData)
    };
  }
}
```

### SubTask 2.10.4: CDC 성능 최적화
**담당자**: 성능 엔지니어  
**예상 소요시간**: 8시간

**목표**: 대용량 변경 사항 처리를 위한 CDC 성능 최적화

**구현 내용**:
```typescript
// backend/src/cdc/optimization/cdc-optimizer.ts
export class CDCOptimizer {
  private performanceMonitor: CDCPerformanceMonitor;
  private adaptiveController: AdaptiveController;
  private resourceManager: ResourceManager;
  
  constructor(
    private config: OptimizerConfig
  ) {
    this.performanceMonitor = new CDCPerformanceMonitor();
    this.adaptiveController = new AdaptiveController(config);
    this.resourceManager = new ResourceManager();
  }
  
  // 적응형 배치 크기 조정
  async optimizeBatchSize(
    currentMetrics: CDCMetrics
  ): Promise<number> {
    const optimalSize = this.adaptiveController.calculateOptimalBatchSize({
      currentBatchSize: currentMetrics.batchSize,
      processingTime: currentMetrics.avgProcessingTime,
      memoryUsage: currentMetrics.memoryUsage,
      cpuUsage: currentMetrics.cpuUsage,
      errorRate: currentMetrics.errorRate
    });
    
    // 점진적 조정
    const adjustment = Math.min(
      Math.abs(optimalSize - currentMetrics.batchSize) * 0.2,
      100
    );
    
    return currentMetrics.batchSize + 
           (optimalSize > currentMetrics.batchSize ? adjustment : -adjustment);
  }
  
  // 샤드 병렬 처리 최적화
  async optimizeShardProcessing(
    shards: Shard[]
  ): Promise<ShardProcessingPlan> {
    // 샤드별 부하 분석
    const shardLoads = await this.analyzeShardLoads(shards);
    
    // 최적 워커 수 계산
    const optimalWorkers = this.calculateOptimalWorkers(shardLoads);
    
    // 샤드-워커 매핑
    const shardAssignments = this.assignShardsToWorkers(
      shards,
      shardLoads,
      optimalWorkers
    );
    
    return {
      workerCount: optimalWorkers,
      assignments: shardAssignments,
      estimatedThroughput: this.estimateThroughput(shardAssignments)
    };
  }
  
  // 메모리 효율적인 레코드 처리
  async processRecordsEfficiently(
    records: StreamRecord[]
  ): Promise<ProcessingResult[]> {
    // 레코드를 메모리 효율적인 청크로 분할
    const memoryLimit = this.resourceManager.getAvailableMemory() * 0.7;
    const chunks = this.createMemoryEfficientChunks(records, memoryLimit);
    
    const results: ProcessingResult[] = [];
    
    for (const chunk of chunks) {
      // 스트리밍 처리
      const chunkResults = await this.streamProcessChunk(chunk);
      results.push(...chunkResults);
      
      // 가비지 컬렉션 힌트
      if (global.gc) {
        global.gc();
      }
    }
    
    return results;
  }
  
  // 백프레셔 관리
  private backpressureManager = new BackpressureManager({
    highWaterMark: 1000,
    lowWaterMark: 100,
    strategy: 'adaptive'
  });
  
  async handleBackpressure(
    incomingRate: number,
    processingRate: number
  ): Promise<BackpressureAction> {
    if (incomingRate > processingRate * 1.2) {
      return this.backpressureManager.applyBackpressure({
        severity: this.calculateSeverity(incomingRate, processingRate),
        duration: this.estimateRecoveryTime(incomingRate, processingRate)
      });
    }
    
    return { action: 'none' };
  }
}

// CDC 성능 모니터
export class CDCPerformanceMonitor {
  private metrics: Map<string, Metric[]> = new Map();
  private alerts: AlertManager;
  
  async collectMetrics(): Promise<CDCMetrics> {
    const metrics: CDCMetrics = {
      recordsPerSecond: await this.calculateThroughput(),
      avgProcessingTime: await this.getAverageProcessingTime(),
      errorRate: await this.getErrorRate(),
      lagTime: await this.getStreamLag(),
      memoryUsage: process.memoryUsage().heapUsed,
      cpuUsage: await this.getCPUUsage(),
      activeShards: await this.getActiveShardCount()
    };
    
    // 이상 감지
    await this.detectAnomalies(metrics);
    
    return metrics;
  }
  
  // 성능 이상 감지
  private async detectAnomalies(metrics: CDCMetrics): Promise<void> {
    // 처리 지연 감지
    if (metrics.lagTime > this.config.maxAcceptableLag) {
      await this.alerts.send({
        severity: 'high',
        type: 'cdc-lag',
        message: `CDC lag detected: ${metrics.lagTime}ms`,
        metrics
      });
    }
    
    // 에러율 상승 감지
    if (metrics.errorRate > 0.05) { // 5% 이상
      await this.alerts.send({
        severity: 'critical',
        type: 'cdc-errors',
        message: `High CDC error rate: ${metrics.errorRate * 100}%`,
        metrics
      });
    }
  }
}
```

## Task 2.11: 이벤트 소싱

### SubTask 2.11.1: 이벤트 스토어 구현
**담당자**: 시니어 백엔드 개발자  
**예상 소요시간**: 14시간

**목표**: 불변 이벤트 저장소 및 이벤트 스트림 관리 시스템 구현

**구현 내용**:
```typescript
// backend/src/event-sourcing/store/event-store.ts
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
import { EventStoreDBClient } from '@eventstore/db-client';
import { v4 as uuidv4 } from 'uuid';

export interface Event {
  eventId: string;
  streamId: string;
  eventType: string;
  eventVersion: number;
  aggregateId: string;
  aggregateType: string;
  causationId?: string;
  correlationId?: string;
  data: any;
  metadata: EventMetadata;
  timestamp: Date;
  sequenceNumber: number;
}

export interface EventMetadata {
  userId?: string;
  source: string;
  ipAddress?: string;
  userAgent?: string;
  [key: string]: any;
}

export class EventStore {
  private eventStoreDB: EventStoreDBClient;
  private dynamoClient: DynamoDBDocumentClient;
  private projectionManager: ProjectionManager;
  private snapshotStore: SnapshotStore;
  
  constructor(
    private config: EventStoreConfig
  ) {
    this.eventStoreDB = new EventStoreDBClient(
      { endpoint: config.eventStoreEndpoint },
      { insecure: config.insecure }
    );
    
    this.projectionManager = new ProjectionManager(this);
    this.snapshotStore = new SnapshotStore(dynamoClient);
  }
  
  // 이벤트 추가
  async appendEvents(
    streamId: string,
    events: NewEvent[],
    expectedVersion?: number
  ): Promise<AppendResult> {
    // 이벤트 검증
    this.validateEvents(events);
    
    // 낙관적 동시성 제어
    if (expectedVersion !== undefined) {
      const currentVersion = await this.getStreamVersion(streamId);
      if (currentVersion !== expectedVersion) {
        throw new ConcurrencyError(
          `Expected version ${expectedVersion}, but stream is at ${currentVersion}`
        );
      }
    }
    
    // 이벤트 메타데이터 추가
    const enrichedEvents = events.map((event, index) => ({
      eventId: uuidv4(),
      streamId,
      eventType: event.type,
      eventVersion: 1,
      aggregateId: event.aggregateId,
      aggregateType: event.aggregateType,
      causationId: event.causationId,
      correlationId: event.correlationId || uuidv4(),
      data: event.data,
      metadata: {
        ...event.metadata,
        source: this.config.serviceName,
        timestamp: new Date()
      },
      timestamp: new Date(),
      sequenceNumber: (expectedVersion || 0) + index + 1
    }));
    
    // EventStoreDB에 저장
    const writeResult = await this.eventStoreDB.appendToStream(
      streamId,
      enrichedEvents.map(e => ({
        type: e.eventType,
        data: e.data,
        metadata: e.metadata
      })),
      {
        expectedRevision: expectedVersion !== undefined ? 
          BigInt(expectedVersion) : constants.ANY
      }
    );
    
    // DynamoDB에도 저장 (쿼리 최적화)
    await this.saveEventsToDynamoDB(enrichedEvents);
    
    // 프로젝션 업데이트
    await this.projectionManager.handleEvents(enrichedEvents);
    
    // 이벤트 발행
    await this.publishEvents(enrichedEvents);
    
    return {
      nextExpectedVersion: Number(writeResult.nextExpectedRevision),
      events: enrichedEvents
    };
  }
  
  // 이벤트 스트림 읽기
  async readStream(
    streamId: string,
    options?: ReadStreamOptions
  ): Promise<Event[]> {
    const fromRevision = options?.fromVersion !== undefined ?
      BigInt(options.fromVersion) : constants.START;
    
    const direction = options?.direction || 'forwards';
    const maxCount = options?.maxCount || 1000;
    
    const events: Event[] = [];
    
    const stream = this.eventStoreDB.readStream(streamId, {
      direction,
      fromRevision,
      maxCount
    });
    
    for await (const resolvedEvent of stream) {
      events.push(this.mapToEvent(resolvedEvent));
    }
    
    return events;
  }
  
  // 집계 재구성
  async loadAggregate<T extends AggregateRoot>(
    aggregateId: string,
    aggregateType: string,
    AggregateClass: new () => T
  ): Promise<T> {
    // 스냅샷 확인
    const snapshot = await this.snapshotStore.getSnapshot(
      aggregateId,
      aggregateType
    );
    
    let aggregate = new AggregateClass();
    let fromVersion = 0;
    
    if (snapshot) {
      aggregate.loadFromSnapshot(snapshot);
      fromVersion = snapshot.version + 1;
    }
    
    // 스냅샷 이후 이벤트 로드
    const streamId = `${aggregateType}-${aggregateId}`;
    const events = await this.readStream(streamId, {
      fromVersion,
      direction: 'forwards'
    });
    
    // 이벤트 적용
    for (const event of events) {
      aggregate.apply(event);
    }
    
    // 스냅샷 생성 여부 확인
    if (this.shouldCreateSnapshot(aggregate, snapshot)) {
      await this.snapshotStore.saveSnapshot(aggregate);
    }
    
    return aggregate;
  }
  
  // 이벤트 쿼리
  async queryEvents(
    criteria: EventQueryCriteria
  ): Promise<QueryResult<Event>> {
    // EventStoreDB의 프로젝션 사용
    if (criteria.useProjection) {
      return await this.queryProjection(criteria);
    }
    
    // DynamoDB 쿼리 (최적화된)
    const query = this.buildDynamoQuery(criteria);
    const result = await this.dynamoClient.query(query);
    
    const events = result.Items?.map(item => this.mapFromDynamoDB(item)) || [];
    
    return {
      events,
      nextToken: result.LastEvaluatedKey,
      totalCount: result.Count
    };
  }
  
  // 이벤트 재생
  async replayEvents(
    options: ReplayOptions
  ): Promise<ReplayResult> {
    const { fromTimestamp, toTimestamp, eventTypes, targetProjection } = options;
    
    // 이벤트 스트림 필터링
    const events = await this.queryEvents({
      fromTimestamp,
      toTimestamp,
      eventTypes,
      orderBy: 'timestamp',
      direction: 'asc'
    });
    
    // 대상 프로젝션 초기화
    if (targetProjection) {
      await this.projectionManager.resetProjection(targetProjection);
    }
    
    // 배치로 이벤트 재생
    const batchSize = 1000;
    let processedCount = 0;
    
    for (let i = 0; i < events.events.length; i += batchSize) {
      const batch = events.events.slice(i, i + batchSize);
      
      if (targetProjection) {
        await this.projectionManager.replayBatch(targetProjection, batch);
      } else {
        // 모든 프로젝션에 재생
        await this.projectionManager.handleEvents(batch);
      }
      
      processedCount += batch.length;
      
      // 진행 상황 업데이트
      this.emit('replay:progress', {
        processed: processedCount,
        total: events.totalCount,
        percentage: (processedCount / events.totalCount) * 100
      });
    }
    
    return {
      processedEvents: processedCount,
      duration: Date.now() - startTime,
      errors: []
    };
  }
}

// 집계 루트 기본 클래스
export abstract class AggregateRoot {
  protected version: number = 0;
  protected uncommittedEvents: Event[] = [];
  
  abstract get aggregateId(): string;
  abstract get aggregateType(): string;
  
  // 이벤트 적용
  apply(event: Event): void {
    // 이벤트 핸들러 호출
    const handler = this.getEventHandler(event.eventType);
    if (handler) {
      handler.call(this, event);
    }
    
    this.version = event.sequenceNumber;
  }
  
  // 새 이벤트 발생
  protected raiseEvent(eventType: string, data: any): void {
    const event: Event = {
      eventId: uuidv4(),
      streamId: `${this.aggregateType}-${this.aggregateId}`,
      eventType,
      eventVersion: 1,
      aggregateId: this.aggregateId,
      aggregateType: this.aggregateType,
      data,
      metadata: {},
      timestamp: new Date(),
      sequenceNumber: this.version + 1
    };
    
    this.apply(event);
    this.uncommittedEvents.push(event);
  }
  
  // 커밋되지 않은 이벤트 가져오기
  getUncommittedEvents(): Event[] {
    return this.uncommittedEvents;
  }
  
  // 커밋 완료 표시
  markEventsAsCommitted(): void {
    this.uncommittedEvents = [];
  }
  
  private getEventHandler(eventType: string): Function | undefined {
    const handlerName = `on${eventType}`;
    return (this as any)[handlerName];
  }
}
```

### SubTask 2.11.2: 프로젝션 시스템 구축
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**목표**: 이벤트 스트림에서 읽기 모델을 생성하는 프로젝션 시스템 구현

**구현 내용**:
```typescript
// backend/src/event-sourcing/projections/projection-manager.ts
export interface Projection {
  name: string;
  version: string;
  state: ProjectionState;
  handlers: Map<string, ProjectionHandler>;
  dependencies?: string[];
}

export interface ProjectionState {
  status: 'running' | 'stopped' | 'paused' | 'rebuilding';
  lastProcessedEvent?: string;
  lastProcessedTimestamp?: Date;
  checkpointPosition?: bigint;
  errors?: ProjectionError[];
}

export class ProjectionManager {
  private projections: Map<string, Projection> = new Map();
  private checkpointStore: CheckpointStore;
  private readModelStore: ReadModelStore;
  
  constructor(
    private eventStore: EventStore,
    private config: ProjectionConfig
  ) {
    this.checkpointStore = new CheckpointStore();
    this.readModelStore = new ReadModelStore();
    
    this.registerBuiltInProjections();
  }
  
  // 프로젝션 등록
  registerProjection(projection: Projection): void {
    // 의존성 검증
    if (projection.dependencies) {
      for (const dep of projection.dependencies) {
        if (!this.projections.has(dep)) {
          throw new Error(`Dependency ${dep} not found`);
        }
      }
    }
    
    this.projections.set(projection.name, projection);
    
    // 자동 시작
    if (this.config.autoStart) {
      this.startProjection(projection.name);
    }
  }
  
  // 프로젝션 시작
  async startProjection(name: string): Promise<void> {
    const projection = this.projections.get(name);
    if (!projection) {
      throw new Error(`Projection ${name} not found`);
    }
    
    projection.state.status = 'running';
    
    // 체크포인트 로드
    const checkpoint = await this.checkpointStore.getCheckpoint(name);
    const startPosition = checkpoint?.position || BigInt(0);
    
    // 이벤트 구독
    const subscription = await this.eventStore.subscribeToAll({
      fromPosition: startPosition,
      resolveLinkTos: true
    });
    
    // 이벤트 처리 루프
    for await (const event of subscription) {
      try {
        await this.processEvent(projection, event);
        
        // 주기적 체크포인트
        if (this.shouldCheckpoint(projection)) {
          await this.saveCheckpoint(projection);
        }
      } catch (error) {
        await this.handleProjectionError(projection, event, error);
      }
    }
  }
  
  // 이벤트 처리
  private async processEvent(
    projection: Projection,
    event: Event
  ): Promise<void> {
    const handler = projection.handlers.get(event.eventType);
    
    if (!handler) {
      // 이 프로젝션이 처리하지 않는 이벤트
      return;
    }
    
    // 읽기 모델 업데이트
    await this.readModelStore.transaction(async (tx) => {
      const context = this.createProjectionContext(projection, tx);
      await handler(event, context);
    });
    
    // 상태 업데이트
    projection.state.lastProcessedEvent = event.eventId;
    projection.state.lastProcessedTimestamp = event.timestamp;
    projection.state.checkpointPosition = BigInt(event.sequenceNumber);
  }
  
  // 프로젝션 재구축
  async rebuildProjection(
    name: string,
    options?: RebuildOptions
  ): Promise<RebuildResult> {
    const projection = this.projections.get(name);
    if (!projection) {
      throw new Error(`Projection ${name} not found`);
    }
    
    projection.state.status = 'rebuilding';
    
    // 읽기 모델 초기화
    await this.readModelStore.clearProjection(name);
    
    // 체크포인트 리셋
    await this.checkpointStore.resetCheckpoint(name);
    
    // 이벤트 재생
    const startTime = Date.now();
    let processedCount = 0;
    
    const events = this.eventStore.readAll({
      fromPosition: BigInt(0),
      direction: 'forwards',
      maxCount: options?.batchSize || 10000
    });
    
    for await (const event of events) {
      if (projection.handlers.has(event.eventType)) {
        await this.processEvent(projection, event);
        processedCount++;
        
        // 진행 상황 보고
        if (processedCount % 1000 === 0) {
          this.emit('rebuild:progress', {
            projection: name,
            processed: processedCount,
            currentEvent: event.eventId
          });
        }
      }
    }
    
    projection.state.status = 'running';
    
    return {
      projectionName: name,
      eventsProcessed: processedCount,
      duration: Date.now() - startTime,
      finalPosition: projection.state.checkpointPosition
    };
  }
  
  // 내장 프로젝션 등록
  private registerBuiltInProjections(): void {
    // 사용자 프로젝션
    this.registerProjection({
      name: 'UserProjection',
      version: '1.0.0',
      state: { status: 'stopped' },
      handlers: new Map([
        ['UserCreated', this.handleUserCreated.bind(this)],
        ['UserUpdated', this.handleUserUpdated.bind(this)],
        ['UserDeleted', this.handleUserDeleted.bind(this)]
      ])
    });
    
    // 프로젝트 통계 프로젝션
    this.registerProjection({
      name: 'ProjectStatistics',
      version: '1.0.0',
      state: { status: 'stopped' },
      handlers: new Map([
        ['ProjectCreated', this.handleProjectCreatedStats.bind(this)],
        ['TaskAdded', this.handleTaskAddedStats.bind(this)],
        ['TaskCompleted', this.handleTaskCompletedStats.bind(this)]
      ])
    });
  }
  
  // 사용자 이벤트 핸들러
  private async handleUserCreated(
    event: Event,
    context: ProjectionContext
  ): Promise<void> {
    await context.store.put('users', event.aggregateId, {
      userId: event.aggregateId,
      ...event.data,
      createdAt: event.timestamp,
      updatedAt: event.timestamp
    });
  }
}

// 읽기 모델 스토어
export class ReadModelStore {
  constructor(
    private dynamoClient: DynamoDBDocumentClient
  ) {}
  
  async transaction<T>(
    handler: (tx: ReadModelTransaction) => Promise<T>
  ): Promise<T> {
    const tx = new ReadModelTransaction(this.dynamoClient);
    
    try {
      const result = await handler(tx);
      await tx.commit();
      return result;
    } catch (error) {
      await tx.rollback();
      throw error;
    }
  }
  
  async query(
    projection: string,
    criteria: QueryCriteria
  ): Promise<QueryResult> {
    const params = this.buildQueryParams(projection, criteria);
    const result = await this.dynamoClient.query(params);
    
    return {
      items: result.Items || [],
      nextToken: result.LastEvaluatedKey,
      count: result.Count || 0
    };
  }
}
```

### SubTask 2.11.3: CQRS 패턴 구현
**담당자**: 아키텍트  
**예상 소요시간**: 10시간

**목표**: Command와 Query 분리를 통한 읽기/쓰기 최적화

**구현 내용**:
```typescript
// backend/src/event-sourcing/cqrs/command-bus.ts
export interface Command {
  commandId: string;
  commandType: string;
  aggregateId: string;
  payload: any;
  metadata: CommandMetadata;
}

export interface CommandMetadata {
  userId: string;
  correlationId: string;
  causationId?: string;
  timestamp: Date;
}

export class CommandBus {
  private handlers: Map<string, CommandHandler> = new Map();
  private middleware: CommandMiddleware[] = [];
  private eventStore: EventStore;
  private sagaManager: SagaManager;
  
  constructor(
    eventStore: EventStore,
    private config: CommandBusConfig
  ) {
    this.eventStore = eventStore;
    this.sagaManager = new SagaManager(eventStore);
    
    this.registerDefaultMiddleware();
  }
  
  // 커맨드 핸들러 등록
  registerHandler<T extends Command>(
    commandType: string,
    handler: CommandHandler<T>
  ): void {
    if (this.handlers.has(commandType)) {
      throw new Error(`Handler already registered for ${commandType}`);
    }
    
    this.handlers.set(commandType, handler);
  }
  
  // 커맨드 실행
  async execute<T extends Command>(command: T): Promise<CommandResult> {
    // 미들웨어 체인 실행
    const context = await this.runMiddleware(command);
    
    // 핸들러 찾기
    const handler = this.handlers.get(command.commandType);
    if (!handler) {
      throw new Error(`No handler registered for ${command.commandType}`);
    }
    
    try {
      // 커맨드 실행
      const events = await handler.handle(command, context);
      
      // 이벤트 저장
      const appendResult = await this.eventStore.appendEvents(
        `${command.aggregateId}`,
        events.map(e => ({
          ...e,
          causationId: command.commandId,
          correlationId: command.metadata.correlationId
        }))
      );
      
      // 사가 처리
      await this.sagaManager.handleEvents(appendResult.events);
      
      return {
        success: true,
        aggregateId: command.aggregateId,
        version: appendResult.nextExpectedVersion,
        events: appendResult.events
      };
    } catch (error) {
      return {
        success: false,
        error: error as Error,
        aggregateId: command.aggregateId
      };
    }
  }
  
  // 미들웨어 실행
  private async runMiddleware(command: Command): Promise<CommandContext> {
    const context: CommandContext = {
      command,
      metadata: {},
      startTime: Date.now()
    };
    
    for (const middleware of this.middleware) {
      await middleware.process(context);
    }
    
    return context;
  }
  
  // 기본 미들웨어 등록
  private registerDefaultMiddleware(): void {
    // 검증 미들웨어
    this.use(new ValidationMiddleware());
    
    // 인증/인가 미들웨어
    this.use(new AuthorizationMiddleware());
    
    // 로깅 미들웨어
    this.use(new LoggingMiddleware());
    
    // 성능 측정 미들웨어
    this.use(new PerformanceMiddleware());
  }
}

// 쿼리 버스
export class QueryBus {
  private handlers: Map<string, QueryHandler> = new Map();
  private cache: QueryCache;
  private readModelStore: ReadModelStore;
  
  constructor(
    readModelStore: ReadModelStore,
    private config: QueryBusConfig
  ) {
    this.readModelStore = readModelStore;
    this.cache = new QueryCache(config.cache);
  }
  
  // 쿼리 핸들러 등록
  registerHandler<T extends Query, R>(
    queryType: string,
    handler: QueryHandler<T, R>
  ): void {
    this.handlers.set(queryType, handler);
  }
  
  // 쿼리 실행
  async execute<T extends Query, R>(query: T): Promise<R> {
    // 캐시 확인
    const cacheKey = this.getCacheKey(query);
    const cached = await this.cache.get<R>(cacheKey);
    
    if (cached && !query.bypassCache) {
      return cached;
    }
    
    // 핸들러 실행
    const handler = this.handlers.get(query.queryType);
    if (!handler) {
      throw new Error(`No handler registered for ${query.queryType}`);
    }
    
    const result = await handler.handle(query, this.readModelStore);
    
    // 캐시 저장
    if (query.cacheable !== false) {
      await this.cache.set(cacheKey, result, query.cacheTTL);
    }
    
    return result;
  }
  
  // 캐시 무효화
  async invalidateCache(pattern: string): Promise<void> {
    await this.cache.invalidatePattern(pattern);
  }
}

// 커맨드 핸들러 예시
export class CreateUserCommandHandler implements CommandHandler<CreateUserCommand> {
  constructor(
    private userRepository: UserRepository,
    private validator: UserValidator
  ) {}
  
  async handle(
    command: CreateUserCommand,
    context: CommandContext
  ): Promise<Event[]> {
    // 검증
    await this.validator.validateCreateUser(command.payload);
    
    // 중복 확인
    const existing = await this.userRepository.findByEmail(
      command.payload.email
    );
    if (existing) {
      throw new Error('User with this email already exists');
    }
    
    // 집계 생성
    const user = User.create(
      command.aggregateId,
      command.payload.name,
      command.payload.email,
      command.payload.role
    );
    
    // 이벤트 반환
    return user.getUncommittedEvents();
  }
}

// 사가 관리자
export class SagaManager {
  private sagas: Map<string, Saga> = new Map();
  private sagaStore: SagaStore;
  
  constructor(
    private eventStore: EventStore
  ) {
    this.sagaStore = new SagaStore();
    this.registerSagas();
  }
  
  // 사가 등록
  private registerSagas(): void {
    this.register(new UserRegistrationSaga());
    this.register(new ProjectCreationSaga());
    this.register(new PaymentProcessingSaga());
  }
  
  // 이벤트 처리
  async handleEvents(events: Event[]): Promise<void> {
    for (const event of events) {
      const interestedSagas = this.findInterestedSagas(event);
      
      for (const sagaType of interestedSagas) {
        await this.processSagaEvent(sagaType, event);
      }
    }
  }
  
  private async processSagaEvent(
    sagaType: string,
    event: Event
  ): Promise<void> {
    // 사가 인스턴스 찾기 또는 생성
    let sagaInstance = await this.sagaStore.findByCorrelationId(
      sagaType,
      event.correlationId
    );
    
    if (!sagaInstance) {
      const SagaClass = this.sagas.get(sagaType);
      if (!SagaClass) return;
      
      sagaInstance = new SagaClass();
      sagaInstance.correlationId = event.correlationId;
    }
    
    // 이벤트 처리
    const commands = await sagaInstance.handle(event);
    
    // 생성된 커맨드 실행
    for (const command of commands) {
      await this.commandBus.execute(command);
    }
    
    // 사가 상태 저장
    await this.sagaStore.save(sagaInstance);
  }
}
```

### SubTask 2.11.4: 이벤트 버전 관리
**담당자**: 백엔드 개발자  
**예상 소요시간**: 8시간

**목표**: 이벤트 스키마 진화와 호환성 관리 시스템 구현

**구현 내용**:
```typescript
// backend/src/event-sourcing/versioning/event-versioning.ts
export interface EventSchema {
  eventType: string;
  version: number;
  schema: JSONSchema;
  deprecated?: boolean;
  migrationPath?: MigrationPath[];
}

export interface MigrationPath {
  fromVersion: number;
  toVersion: number;
  migrator: EventMigrator;
}

export class EventVersionManager {
  private schemas: Map<string, Map<number, EventSchema>> = new Map();
  private migrators: Map<string, EventMigrator> = new Map();
  private schemaRegistry: SchemaRegistry;
  
  constructor(
    private config: VersioningConfig
  ) {
    this.schemaRegistry = new SchemaRegistry(config.registryUrl);
    this.registerBuiltInSchemas();
  }
  
  // 스키마 등록
  async registerSchema(schema: EventSchema): Promise<void> {
    // 스키마 검증
    await this.validateSchema(schema);
    
    // 버전 충돌 확인
    if (this.hasSchema(schema.eventType, schema.version)) {
      throw new Error(
        `Schema already exists for ${schema.eventType} v${schema.version}`
      );
    }
    
    // 이전 버전과의 호환성 확인
    if (schema.version > 1) {
      await this.checkBackwardCompatibility(schema);
    }
    
    // 스키마 저장
    if (!this.schemas.has(schema.eventType)) {
      this.schemas.set(schema.eventType, new Map());
    }
    this.schemas.get(schema.eventType)!.set(schema.version, schema);
    
    // 레지스트리에 등록
    await this.schemaRegistry.register(schema);
  }
  
  // 이벤트 업그레이드
  async upgradeEvent(
    event: Event,
    targetVersion: number
  ): Promise<Event> {
    const currentVersion = event.eventVersion;
    
    if (currentVersion === targetVersion) {
      return event;
    }
    
    if (currentVersion > targetVersion) {
      throw new Error('Downgrade not supported');
    }
    
    // 마이그레이션 경로 찾기
    const path = this.findMigrationPath(
      event.eventType,
      currentVersion,
      targetVersion
    );
    
    if (!path) {
      throw new Error(
        `No migration path from v${currentVersion} to v${targetVersion}`
      );
    }
    
    // 단계별 마이그레이션
    let migratedEvent = { ...event };
    
    for (const step of path) {
      const migrator = step.migrator;
      migratedEvent = await migrator.migrate(migratedEvent);
      migratedEvent.eventVersion = step.toVersion;
    }
    
    // 최종 스키마 검증
    await this.validateEventAgainstSchema(
      migratedEvent,
      targetVersion
    );
    
    return migratedEvent;
  }
  
  // 이벤트 다운그레이드 (읽기 전용)
  async downgradeEventForReading(
    event: Event,
    targetVersion: number
  ): Promise<any> {
    if (targetVersion >= event.eventVersion) {
      return event.data;
    }
    
    // 다운그레이드 변환
    const downgrader = this.findDowngrader(
      event.eventType,
      event.eventVersion,
      targetVersion
    );
    
    if (!downgrader) {
      throw new Error('Cannot downgrade event for reading');
    }
    
    return await downgrader.transform(event.data);
  }
  
  // 호환성 검사
  private async checkBackwardCompatibility(
    schema: EventSchema
  ): Promise<void> {
    const previousVersion = schema.version - 1;
    const previousSchema = this.getSchema(
      schema.eventType,
      previousVersion
    );
    
    if (!previousSchema) {
      throw new Error(`Previous version ${previousVersion} not found`);
    }
    
    const compatibility = await this.schemaRegistry.checkCompatibility(
      previousSchema.schema,
      schema.schema
    );
    
    if (!compatibility.isCompatible) {
      throw new Error(
        `Schema not backward compatible: ${compatibility.errors.join(', ')}`
      );
    }
  }
  
  // 내장 스키마 등록
  private registerBuiltInSchemas(): void {
    // UserCreated v1
    this.registerSchema({
      eventType: 'UserCreated',
      version: 1,
      schema: {
        type: 'object',
        properties: {
          userId: { type: 'string' },
          email: { type: 'string' },
          name: { type: 'string' }
        },
        required: ['userId', 'email', 'name']
      }
    });
    
    // UserCreated v2 (role 추가)
    this.registerSchema({
      eventType: 'UserCreated',
      version: 2,
      schema: {
        type: 'object',
        properties: {
          userId: { type: 'string' },
          email: { type: 'string' },
          name: { type: 'string' },
          role: { type: 'string', default: 'user' }
        },
        required: ['userId', 'email', 'name', 'role']
      },
      migrationPath: [{
        fromVersion: 1,
        toVersion: 2,
        migrator: new AddDefaultRoleMigrator()
      }]
    });
  }
}

// 이벤트 마이그레이터 예시
export class AddDefaultRoleMigrator implements EventMigrator {
  async migrate(event: Event): Promise<Event> {
    return {
      ...event,
      data: {
        ...event.data,
        role: event.data.role || 'user'
      }
    };
  }
}

// 스키마 레지스트리
export class SchemaRegistry {
  constructor(
    private registryUrl: string
  ) {}
  
  async register(schema: EventSchema): Promise<void> {
    const response = await fetch(`${this.registryUrl}/schemas`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        subject: `${schema.eventType}-v${schema.version}`,
        schema: JSON.stringify(schema.schema)
      })
    });
    
    if (!response.ok) {
      throw new Error('Failed to register schema');
    }
  }
  
  async checkCompatibility(
    oldSchema: JSONSchema,
    newSchema: JSONSchema
  ): Promise<CompatibilityResult> {
    // JSON Schema 호환성 검사 로직
    const validator = new SchemaCompatibilityValidator();
    return validator.check(oldSchema, newSchema);
  }
}
```

## Task 2.12: 데이터 복제 및 동기화

### SubTask 2.12.1: 멀티 리전 복제 설정
**담당자**: 인프라 엔지니어  
**예상 소요시간**: 12시간

**목표**: DynamoDB Global Tables를 활용한 멀티 리전 데이터 복제 구현

**구현 내용**:
```typescript
// backend/src/replication/multi-region/replication-manager.ts
import { 
  DynamoDBClient,
  CreateGlobalTableCommand,
  UpdateGlobalTableCommand,
  DescribeGlobalTableCommand
} from '@aws-sdk/client-dynamodb';

export interface ReplicationConfig {
  primaryRegion: string;
  replicaRegions: string[];
  tables: TableReplicationConfig[];
  conflictResolution: ConflictResolutionStrategy;
}

export interface TableReplicationConfig {
  tableName: string;
  replicationMode: 'ACTIVE_ACTIVE' | 'ACTIVE_PASSIVE';
  readCapacity?: number;
  writeCapacity?: number;
  globalSecondaryIndexes?: GSIReplicationConfig[];
}

export class MultiRegionReplicationManager {
  private clients: Map<string, DynamoDBClient> = new Map();
  private healthMonitor: RegionHealthMonitor;
  private conflictResolver: ConflictResolver;
  
  constructor(
    private config: ReplicationConfig
  ) {
    this.initializeClients();
    this.healthMonitor = new RegionHealthMonitor(this.clients);
    this.conflictResolver = new ConflictResolver(config.conflictResolution);
  }
  
  // 클라이언트 초기화
  private initializeClients(): void {
    const allRegions = [
      this.config.primaryRegion,
      ...this.config.replicaRegions
    ];
    
    for (const region of allRegions) {
      this.clients.set(
        region,
        new DynamoDBClient({ region })
      );
    }
  }
  
  // 글로벌 테이블 생성
  async createGlobalTable(
    tableConfig: TableReplicationConfig
  ): Promise<void> {
    const primaryClient = this.clients.get(this.config.primaryRegion)!;
    
    // 기존 테이블을 글로벌 테이블로 변환
    const replicaUpdates = this.config.replicaRegions.map(region => ({
      Create: {
        RegionName: region,
        GlobalSecondaryIndexes: tableConfig.globalSecondaryIndexes?.map(
          gsi => ({
            IndexName: gsi.indexName,
            ProvisionedThroughputOverride: {
              ReadCapacityUnits: gsi.readCapacity,
              WriteCapacityUnits: gsi.writeCapacity
            }
          })
        )
      }
    }));
    
    await primaryClient.send(
      new UpdateGlobalTableCommand({
        GlobalTableName: tableConfig.tableName,
        ReplicaUpdates: replicaUpdates
      })
    );
    
    // 복제 상태 모니터링
    await this.waitForReplicationActive(tableConfig.tableName);
  }
  
  // 복제 상태 확인
  async getReplicationStatus(
    tableName: string
  ): Promise<ReplicationStatus> {
    const primaryClient = this.clients.get(this.config.primaryRegion)!;
    
    const response = await primaryClient.send(
      new DescribeGlobalTableCommand({
        GlobalTableName: tableName
      })
    );
    
    const globalTable = response.GlobalTableDescription!;
    
    return {
      tableName,
      status: globalTable.GlobalTableStatus as ReplicationStatusType,
      regions: globalTable.ReplicationGroup?.map(replica => ({
        region: replica.RegionName!,
        status: replica.ReplicaStatus!,
        lastUpdated: replica.ReplicaStatusDateTime,
        backlog: replica.ReplicaBacklogSizeBytes
      })) || [],
      creationDateTime: globalTable.CreationDateTime
    };
  }
  
  // 리전별 지연 시간 모니터링
  async monitorReplicationLag(): Promise<ReplicationLagMetrics> {
    const metrics: ReplicationLagMetrics = {
      timestamp: new Date(),
      regions: new Map()
    };
    
    for (const [region, client] of this.clients) {
      const lag = await this.measureReplicationLag(region);
      metrics.regions.set(region, {
        lagMs: lag,
        healthy: lag < this.config.maxAcceptableLagMs
      });
    }
    
    return metrics;
  }
  
  // 복제 충돌 해결
  async resolveConflicts(
    tableName: string,
    conflictRecords: ConflictRecord[]
  ): Promise<ConflictResolutionResult> {
    const resolutions: Resolution[] = [];
    
    for (const conflict of conflictRecords) {
      const resolution = await this.conflictResolver.resolve(conflict);
      
      // 해결된 레코드 적용
      await this.applyResolution(tableName, resolution);
      
      resolutions.push(resolution);
    }
    
    return {
      resolved: resolutions.filter(r => r.status === 'resolved').length,
      failed: resolutions.filter(r => r.status === 'failed').length,
      resolutions
    };
  }
  
  // 리전 페일오버
  async failoverToRegion(
    targetRegion: string
  ): Promise<FailoverResult> {
    // 현재 Primary 리전 상태 확인
    const primaryHealth = await this.healthMonitor.checkRegion(
      this.config.primaryRegion
    );
    
    if (primaryHealth.healthy) {
      throw new Error('Primary region is healthy, failover not needed');
    }
    
    // 타겟 리전 검증
    const targetHealth = await this.healthMonitor.checkRegion(targetRegion);
    if (!targetHealth.healthy) {
      throw new Error(`Target region ${targetRegion} is not healthy`);
    }
    
    // 라우팅 업데이트
    await this.updateRouting(targetRegion);
    
    // 새 Primary 승격
    this.config.primaryRegion = targetRegion;
    
    // 알림 발송
    await this.notifyFailover(targetRegion);
    
    return {
      newPrimaryRegion: targetRegion,
      timestamp: new Date(),
      affectedTables: this.config.tables.map(t => t.tableName)
    };
  }
}

// 충돌 해결자
export class ConflictResolver {
  constructor(
    private strategy: ConflictResolutionStrategy
  ) {}
  
  async resolve(conflict: ConflictRecord): Promise<Resolution> {
    switch (this.strategy) {
      case 'LAST_WRITER_WINS':
        return this.lastWriterWins(conflict);
        
      case 'CUSTOM_LOGIC':
        return this.customResolution(conflict);
        
      case 'MANUAL_REVIEW':
        return this.queueForManualReview(conflict);
        
      default:
        throw new Error(`Unknown strategy: ${this.strategy}`);
    }
  }
  
  private lastWriterWins(conflict: ConflictRecord): Resolution {
    // 타임스탬프 기반 해결
    const winner = conflict.versions.reduce((latest, current) => {
      return current.timestamp > latest.timestamp ? current : latest;
    });
    
    return {
      conflictId: conflict.id,
      winningVersion: winner,
      strategy: 'LAST_WRITER_WINS',
      status: 'resolved'
    };
  }
  
  private async customResolution(
    conflict: ConflictRecord
  ): Promise<Resolution> {
    // 비즈니스 로직에 따른 해결
    if (conflict.entityType === 'User') {
      return this.resolveUserConflict(conflict);
    } else if (conflict.entityType === 'Project') {
      return this.resolveProjectConflict(conflict);
    }
    
    // 기본 전략으로 폴백
    return this.lastWriterWins(conflict);
  }
}

// 리전 건강 모니터
export class RegionHealthMonitor {
  private healthChecks: Map<string, HealthCheck> = new Map();
  
  constructor(
    private clients: Map<string, DynamoDBClient>
  ) {
    this.initializeHealthChecks();
  }
  
  async checkRegion(region: string): Promise<RegionHealth> {
    const client = this.clients.get(region);
    if (!client) {
      return { region, healthy: false, reason: 'No client configured' };
    }
    
    const checks = await Promise.all([
      this.checkConnectivity(client),
      this.checkLatency(client),
      this.checkThroughput(client)
    ]);
    
    const healthy = checks.every(check => check.passed);
    
    return {
      region,
      healthy,
      checks,
      timestamp: new Date()
    };
  }
  
  private async checkConnectivity(
    client: DynamoDBClient
  ): Promise<HealthCheckResult> {
    try {
      await client.send(new ListTablesCommand({ Limit: 1 }));
      return { name: 'connectivity', passed: true };
    } catch (error) {
      return { 
        name: 'connectivity', 
        passed: false, 
        error: error.message 
      };
    }
  }
}
```

### SubTask 2.12.2: 실시간 데이터 동기화
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**목표**: WebSocket과 Server-Sent Events를 활용한 실시간 데이터 동기화

**구현 내용**:
```typescript
// backend/src/sync/realtime/sync-manager.ts
import WebSocket from 'ws';
import { EventEmitter } from 'events';
import { DynamoDBStreamsClient } from '@aws-sdk/client-dynamodb-streams';

export interface SyncConfig {
  wsPort: number;
  sseEndpoint: string;
  syncChannels: SyncChannel[];
  authentication: AuthConfig;
}

export interface SyncChannel {
  name: string;
  entityTypes: string[];
  filters?: SyncFilter[];
  transformers?: DataTransformer[];
}

export class RealtimeSyncManager extends EventEmitter {
  private wsServer: WebSocket.Server;
  private sseClients: Map<string, SSEClient> = new Map();
  private syncEngine: SyncEngine;
  private subscriptionManager: SubscriptionManager;
  
  constructor(
    private config: SyncConfig,
    private streamsClient: DynamoDBStreamsClient
  ) {
    super();
    this.wsServer = new WebSocket.Server({ port: config.wsPort });
    this.syncEngine = new SyncEngine(streamsClient);
    this.subscriptionManager = new SubscriptionManager();
    
    this.initialize();
  }
  
  private initialize(): void {
    // WebSocket 서버 설정
    this.wsServer.on('connection', this.handleWebSocketConnection.bind(this));
    
    // DynamoDB Streams 구독
    this.syncEngine.on('dataChange', this.handleDataChange.bind(this));
    this.syncEngine.start();
  }
  
  // WebSocket 연결 처리
  private async handleWebSocketConnection(
    ws: WebSocket,
    req: any
  ): Promise<void> {
    // 인증
    const auth = await this.authenticate(req);
    if (!auth.valid) {
      ws.close(1008, 'Unauthorized');
      return;
    }
    
    const client = new SyncClient(ws, auth.userId);
    
    // 메시지 핸들러
    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        await this.handleClientMessage(client, message);
      } catch (error) {
        client.sendError('Invalid message format');
      }
    });
    
    // 연결 종료 처리
    ws.on('close', () => {
      this.subscriptionManager.removeClient(client.id);
    });
    
    // 초기 동기화
    await this.performInitialSync(client);
  }
  
  // 클라이언트 메시지 처리
  private async handleClientMessage(
    client: SyncClient,
    message: ClientMessage
  ): Promise<void> {
    switch (message.type) {
      case 'subscribe':
        await this.handleSubscribe(client, message.payload);
        break;
        
      case 'unsubscribe':
        await this.handleUnsubscribe(client, message.payload);
        break;
        
      case 'sync':
        await this.handleSyncRequest(client, message.payload);
        break;
        
      case 'update':
        await this.handleClientUpdate(client, message.payload);
        break;
        
      default:
        client.sendError(`Unknown message type: ${message.type}`);
    }
  }
  
  // 구독 처리
  private async handleSubscribe(
    client: SyncClient,
    payload: SubscribePayload
  ): Promise<void> {
    const { channels, entities, filters } = payload;
    
    // 권한 확인
    const authorized = await this.checkSubscriptionAuth(
      client.userId,
      channels
    );
    
    if (!authorized) {
      client.sendError('Unauthorized subscription');
      return;
    }
    
    // 구독 등록
    const subscription = this.subscriptionManager.subscribe(
      client.id,
      {
        channels,
        entities,
        filters,
        transformers: this.getTransformersForClient(client)
      }
    );
    
    // 구독 확인 전송
    client.send({
      type: 'subscribed',
      subscriptionId: subscription.id,
      channels: subscription.channels
    });
  }
  
  // 데이터 변경 처리
  private async handleDataChange(change: DataChange): Promise<void> {
    // 관련 구독자 찾기
    const subscribers = this.subscriptionManager.findSubscribers(change);
    
    // 각 구독자에게 변경 사항 전송
    for (const subscription of subscribers) {
      const client = this.findClient(subscription.clientId);
      if (!client) continue;
      
      // 필터 적용
      if (!this.applyFilters(change, subscription.filters)) {
        continue;
      }
      
      // 변환 적용
      const transformed = await this.applyTransformers(
        change,
        subscription.transformers
      );
      
      // 전송
      client.send({
        type: 'dataChange',
        subscriptionId: subscription.id,
        change: transformed
      });
    }
  }
  
  // 충돌 감지 및 해결
  private conflictDetector = new ConflictDetector();
  
  private async handleClientUpdate(
    client: SyncClient,
    update: UpdatePayload
  ): Promise<void> {
    // 버전 확인
    const currentVersion = await this.getEntityVersion(
      update.entityType,
      update.entityId
    );
    
    if (update.baseVersion !== currentVersion) {
      // 충돌 감지
      const conflict = await this.conflictDetector.analyze(
        update,
        currentVersion
      );
      
      if (conflict.resolvable) {
        // 자동 해결
        const resolved = await this.autoResolveConflict(conflict);
        await this.applyUpdate(resolved);
        
        client.send({
          type: 'updateAccepted',
          entityId: update.entityId,
          newVersion: resolved.version,
          resolved: true
        });
      } else {
        // 클라이언트에 충돌 알림
        client.send({
          type: 'conflict',
          entityId: update.entityId,
          currentVersion,
          conflictData: conflict.data
        });
      }
    } else {
      // 업데이트 적용
      const result = await this.applyUpdate(update);
      
      client.send({
        type: 'updateAccepted',
        entityId: update.entityId,
        newVersion: result.version
      });
    }
  }
  
  // SSE (Server-Sent Events) 지원
  async handleSSEConnection(
    req: any,
    res: any
  ): Promise<void> {
    // SSE 헤더 설정
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*'
    });
    
    const clientId = uuidv4();
    const sseClient = new SSEClient(clientId, res);
    
    this.sseClients.set(clientId, sseClient);
    
    // 초기 연결 이벤트
    sseClient.send({
      type: 'connected',
      clientId
    });
    
    // 클라이언트 연결 종료 처리
    req.on('close', () => {
      this.sseClients.delete(clientId);
      this.subscriptionManager.removeClient(clientId);
    });
  }
}

// 동기화 엔진
export class SyncEngine extends EventEmitter {
  private isRunning: boolean = false;
  private checkpoints: Map<string, string> = new Map();
  
  constructor(
    private streamsClient: DynamoDBStreamsClient
  ) {
    super();
  }
  
  async start(): Promise<void> {
    this.isRunning = true;
    
    // 모든 테이블의 스트림 구독
    const streams = await this.discoverStreams();
    
    for (const streamArn of streams) {
      this.processStream(streamArn);
    }
  }
  
  private async processStream(streamArn: string): Promise<void> {
    const shards = await this.getStreamShards(streamArn);
    
    for (const shard of shards) {
      this.processShard(streamArn, shard.ShardId!);
    }
  }
  
  private async processShard(
    streamArn: string,
    shardId: string
  ): Promise<void> {
    let shardIterator = await this.getShardIterator(streamArn, shardId);
    
    while (this.isRunning && shardIterator) {
      const records = await this.getRecords(shardIterator);
      
      if (records.Records) {
        for (const record of records.Records) {
          const change = this.parseRecord(record);
          this.emit('dataChange', change);
        }
        
        // 체크포인트 업데이트
        if (records.Records.length > 0) {
          const lastRecord = records.Records[records.Records.length - 1];
          await this.updateCheckpoint(
            shardId,
            lastRecord.dynamodb?.SequenceNumber!
          );
        }
      }
      
      shardIterator = records.NextShardIterator || null;
    }
  }
}

// 구독 관리자
export class SubscriptionManager {
  private subscriptions: Map<string, Subscription> = new Map();
  private clientSubscriptions: Map<string, Set<string>> = new Map();
  private entityIndex: Map<string, Set<string>> = new Map();
  
  subscribe(
    clientId: string,
    options: SubscriptionOptions
  ): Subscription {
    const subscription: Subscription = {
      id: uuidv4(),
      clientId,
      ...options,
      createdAt: new Date()
    };
    
    this.subscriptions.set(subscription.id, subscription);
    
    // 클라이언트 인덱스 업데이트
    if (!this.clientSubscriptions.has(clientId)) {
      this.clientSubscriptions.set(clientId, new Set());
    }
    this.clientSubscriptions.get(clientId)!.add(subscription.id);
    
    // 엔티티 인덱스 업데이트
    for (const entity of options.entities || []) {
      if (!this.entityIndex.has(entity)) {
        this.entityIndex.set(entity, new Set());
      }
      this.entityIndex.get(entity)!.add(subscription.id);
    }
    
    return subscription;
  }
  
  findSubscribers(change: DataChange): Subscription[] {
    const subscribers: Set<string> = new Set();
    
    // 엔티티 타입으로 찾기
    const entitySubs = this.entityIndex.get(change.entityType) || new Set();
    entitySubs.forEach(id => subscribers.add(id));
    
    // 채널로 찾기
    for (const [id, sub] of this.subscriptions) {
      if (sub.channels?.includes(change.channel || 'default')) {
        subscribers.add(id);
      }
    }
    
    return Array.from(subscribers)
      .map(id => this.subscriptions.get(id)!)
      .filter(Boolean);
  }
}
```

### SubTask 2.12.3: 오프라인 동기화 지원
**담당자**: 모바일 개발자  
**예상 소요시간**: 10시간

**목표**: 클라이언트의 오프라인 작업을 지원하는 동기화 메커니즘 구현

**구현 내용**:
```typescript
// backend/src/sync/offline/offline-sync.ts
export interface OfflineSyncConfig {
  conflictResolution: 'client_wins' | 'server_wins' | 'manual';
  syncBatchSize: number;
  compressionEnabled: boolean;
  encryptionEnabled: boolean;
}

export class OfflineSyncManager {
  private syncQueue: SyncQueue;
  private conflictResolver: OfflineConflictResolver;
  private deltaGenerator: DeltaGenerator;
  private encryptionService: EncryptionService;
  
  constructor(
    private config: OfflineSyncConfig,
    private dataStore: DataStore
  ) {
    this.syncQueue = new SyncQueue();
    this.conflictResolver = new OfflineConflictResolver(config.conflictResolution);
    this.deltaGenerator = new DeltaGenerator();
    this.encryptionService = new EncryptionService();
  }
  
  // 오프라인 변경 사항 수신
  async receiveSyncRequest(
    request: SyncRequest
  ): Promise<SyncResponse> {
    // 인증 및 권한 확인
    const auth = await this.validateSyncRequest(request);
    if (!auth.valid) {
      throw new UnauthorizedError('Invalid sync credentials');
    }
    
    // 요청 복호화
    const decryptedData = this.config.encryptionEnabled ?
      await this.encryptionService.decrypt(request.encryptedData) :
      request.data;
    
    // 압축 해제
    const changes = this.config.compressionEnabled ?
      await this.decompress(decryptedData) :
      decryptedData;
    
    // 동기화 처리
    const result = await this.processSyncBatch(
      changes,
      request.clientId,
      request.lastSyncTimestamp
    );
    
    // 응답 준비
    const response = await this.prepareSyncResponse(
      result,
      request.clientId
    );
    
    return response;
  }
  
  // 동기화 배치 처리
  private async processSyncBatch(
    changes: ClientChange[],
    clientId: string,
    lastSyncTimestamp: Date
  ): Promise<SyncResult> {
    const results: ChangeResult[] = [];
    const conflicts: Conflict[] = [];
    
    // 트랜잭션으로 변경 사항 처리
    await this.dataStore.transaction(async (tx) => {
      for (const change of changes) {
        try {
          const result = await this.processChange(
            change,
            clientId,
            tx
          );
          
          if (result.conflict) {
            conflicts.push(result.conflict);
          } else {
            results.push(result);
          }
        } catch (error) {
          results.push({
            changeId: change.id,
            status: 'error',
            error: error.message
          });
        }
      }
    });
    
    // 서버 변경 사항 가져오기
    const serverChanges = await this.getServerChanges(
      clientId,
      lastSyncTimestamp
    );
    
    return {
      clientResults: results,
      serverChanges,
      conflicts,
      newSyncTimestamp: new Date()
    };
  }
  
  // 개별 변경 사항 처리
  private async processChange(
    change: ClientChange,
    clientId: string,
    tx: Transaction
  ): Promise<ChangeResult> {
    // 현재 서버 상태 확인
    const serverEntity = await tx.get(
      change.entityType,
      change.entityId
    );
    
    // 충돌 감지
    if (serverEntity && 
        serverEntity.version !== change.baseVersion) {
      
      // 충돌 해결 시도
      const resolution = await this.conflictResolver.resolve({
        clientChange: change,
        serverState: serverEntity,
        strategy: this.config.conflictResolution
      });
      
      if (resolution.resolved) {
        // 해결된 변경 사항 적용
        await this.applyChange(resolution.mergedData, tx);
        
        return {
          changeId: change.id,
          status: 'resolved',
          newVersion: resolution.newVersion
        };
      } else {
        // 충돌 반환
        return {
          changeId: change.id,
          status: 'conflict',
          conflict: {
            id: uuidv4(),
            changeId: change.id,
            clientData: change.data,
            serverData: serverEntity,
            type: resolution.conflictType
          }
        };
      }
    }
    
    // 충돌 없음 - 변경 사항 적용
    const newVersion = await this.applyChange(change.data, tx);
    
    return {
      changeId: change.id,
      status: 'success',
      newVersion
    };
  }
  
  // 델타 동기화
  async generateDelta(
    entityType: string,
    fromVersion: number,
    toVersion: number
  ): Promise<Delta> {
    const changes = await this.dataStore.getChangesBetween(
      entityType,
      fromVersion,
      toVersion
    );
    
    return this.deltaGenerator.generate(changes);
  }
  
  // 점진적 동기화
  async performIncrementalSync(
    clientId: string,
    syncState: ClientSyncState
  ): Promise<IncrementalSyncResult> {
    const pendingChanges: any[] = [];
    
    // 각 엔티티 타입별로 변경 사항 수집
    for (const [entityType, lastSync] of syncState.entities) {
      const changes = await this.dataStore.getChangesSince(
        entityType,
        lastSync.version,
        lastSync.timestamp
      );
      
      if (changes.length > 0) {
        pendingChanges.push({
          entityType,
          changes: changes.slice(0, this.config.syncBatchSize),
          hasMore: changes.length > this.config.syncBatchSize
        });
      }
    }
    
    // 압축 및 암호화
    let payload = pendingChanges;
    
    if (this.config.compressionEnabled) {
      payload = await this.compress(payload);
    }
    
    if (this.config.encryptionEnabled) {
      payload = await this.encryptionService.encrypt(
        payload,
        clientId
      );
    }
    
    return {
      payload,
      syncToken: this.generateSyncToken(clientId),
      hasMoreChanges: pendingChanges.some(p => p.hasMore)
    };
  }
}

// 오프라인 충돌 해결자
export class OfflineConflictResolver {
  constructor(
    private defaultStrategy: ConflictResolutionStrategy
  ) {}
  
  async resolve(
    conflict: OfflineConflict
  ): Promise<ConflictResolution> {
    // 자동 해결 가능한 경우 확인
    if (this.canAutoResolve(conflict)) {
      return this.autoResolve(conflict);
    }
    
    // 전략에 따른 해결
    switch (this.defaultStrategy) {
      case 'client_wins':
        return this.clientWins(conflict);
        
      case 'server_wins':
        return this.serverWins(conflict);
        
      case 'manual':
        return this.requireManualResolution(conflict);
        
      default:
        throw new Error('Unknown conflict resolution strategy');
    }
  }
  
  private canAutoResolve(conflict: OfflineConflict): boolean {
    // 필드 레벨 충돌 분석
    const clientFields = Object.keys(conflict.clientChange.data);
    const serverFields = Object.keys(conflict.serverState);
    
    // 서로 다른 필드를 수정한 경우 자동 병합 가능
    const conflictingFields = clientFields.filter(
      field => serverFields.includes(field) &&
               conflict.clientChange.data[field] !== 
               conflict.serverState[field]
    );
    
    return conflictingFields.length === 0;
  }
  
  private autoResolve(
    conflict: OfflineConflict
  ): ConflictResolution {
    // 비충돌 필드 병합
    const merged = {
      ...conflict.serverState,
      ...conflict.clientChange.data
    };
    
    return {
      resolved: true,
      mergedData: merged,
      newVersion: conflict.serverState.version + 1,
      strategy: 'auto_merge'
    };
  }
}

// 동기화 큐
export class SyncQueue {
  private queue: PriorityQueue<SyncJob>;
  private processing: Map<string, SyncJob> = new Map();
  
  constructor() {
    this.queue = new PriorityQueue((a, b) => 
      a.priority - b.priority
    );
  }
  
  async enqueue(job: SyncJob): Promise<void> {
    // 중복 확인
    if (this.processing.has(job.id)) {
      throw new Error('Job already processing');
    }
    
    // 우선순위 계산
    job.priority = this.calculatePriority(job);
    
    this.queue.enqueue(job);
  }
  
  private calculatePriority(job: SyncJob): number {
    let priority = 0;
    
    // 작업 타입별 가중치
    if (job.type === 'critical') priority += 100;
    if (job.type === 'user_initiated') priority += 50;
    
    // 대기 시간 고려
    const waitTime = Date.now() - job.createdAt.getTime();
    priority += Math.min(waitTime / 1000, 50);
    
    return priority;
  }
}
```

### SubTask 2.12.4: 데이터 일관성 검증
**담당자**: QA 엔지니어  
**예상 소요시간**: 8시간

**목표**: 분산 환경에서 데이터 일관성을 검증하는 시스템 구현

**구현 내용**:
```typescript
// backend/src/sync/consistency/consistency-validator.ts
export class ConsistencyValidator {
  private validators: Map<string, EntityValidator> = new Map();
  private reconciler: DataReconciler;
  private reporter: ConsistencyReporter;
  
  constructor(
    private config: ConsistencyConfig,
    private dataStores: Map<string, DataStore>
  ) {
    this.reconciler = new DataReconciler();
    this.reporter = new ConsistencyReporter();
    
    this.registerValidators();
  }
  
  // 일관성 검증 실행
  async validateConsistency(
    options: ValidationOptions
  ): Promise<ConsistencyReport> {
    const startTime = Date.now();
    const results: ValidationResult[] = [];
    
    // 엔티티별 검증
    for (const [entityType, validator] of this.validators) {
      if (options.entityTypes && 
          !options.entityTypes.includes(entityType)) {
        continue;
      }
      
      const result = await this.validateEntityType(
        entityType,
        validator,
        options
      );
      
      results.push(result);
    }
    
    // 관계 일관성 검증
    const relationshipResults = await this.validateRelationships(
      results,
      options
    );
    
    // 리포트 생성
    const report = this.reporter.generateReport({
      results,
      relationshipResults,
      duration: Date.now() - startTime,
      timestamp: new Date()
    });
    
    // 불일치 자동 수정 (설정된 경우)
    if (options.autoFix && report.inconsistencies.length > 0) {
      await this.autoFixInconsistencies(report.inconsistencies);
    }
    
    return report;
  }
  
  // 엔티티 타입별 검증
  private async validateEntityType(
    entityType: string,
    validator: EntityValidator,
    options: ValidationOptions
  ): Promise<ValidationResult> {
    const inconsistencies: Inconsistency[] = [];
    
    // 모든 리전의 데이터 가져오기
    const regionData = await this.fetchDataFromAllRegions(
      entityType,
      options
    );
    
    // 기준 리전 설정
    const primaryData = regionData.get(this.config.primaryRegion)!;
    
    // 각 엔티티 검증
    for (const [entityId, primaryEntity] of primaryData) {
      const entityInconsistencies = await this.validateEntity(
        entityType,
        entityId,
        primaryEntity,
        regionData,
        validator
      );
      
      inconsistencies.push(...entityInconsistencies);
    }
    
    return {
      entityType,
      totalEntities: primaryData.size,
      inconsistencyCount: inconsistencies.length,
      inconsistencies
    };
  }
  
  // 개별 엔티티 검증
  private async validateEntity(
    entityType: string,
    entityId: string,
    primaryEntity: any,
    regionData: Map<string, Map<string, any>>,
    validator: EntityValidator
  ): Promise<Inconsistency[]> {
    const inconsistencies: Inconsistency[] = [];
    
    for (const [region, data] of regionData) {
      if (region === this.config.primaryRegion) continue;
      
      const regionEntity = data.get(entityId);
      
      // 존재 여부 확인
      if (!regionEntity) {
        inconsistencies.push({
          type: 'missing',
          entityType,
          entityId,
          primaryRegion: this.config.primaryRegion,
          affectedRegion: region,
          severity: 'high'
        });
        continue;
      }
      
      // 필드별 검증
      const fieldInconsistencies = await validator.validateFields(
        primaryEntity,
        regionEntity,
        region
      );
      
      inconsistencies.push(...fieldInconsistencies);
      
      // 버전 확인
      if (primaryEntity.version !== regionEntity.version) {
        const versionDiff = Math.abs(
          primaryEntity.version - regionEntity.version
        );
        
        inconsistencies.push({
          type: 'version_mismatch',
          entityType,
          entityId,
          primaryRegion: this.config.primaryRegion,
          affectedRegion: region,
          severity: versionDiff > 5 ? 'high' : 'medium',
          details: {
            primaryVersion: primaryEntity.version,
            regionVersion: regionEntity.version
          }
        });
      }
    }
    
    return inconsistencies;
  }
  
  // 관계 일관성 검증
  private async validateRelationships(
    entityResults: ValidationResult[],
    options: ValidationOptions
  ): Promise<RelationshipValidationResult[]> {
    const results: RelationshipValidationResult[] = [];
    
    // 외래 키 검증
    const fkResults = await this.validateForeignKeys(entityResults);
    results.push(...fkResults);
    
    // 양방향 관계 검증
    const bidirectionalResults = await this.validateBidirectionalRelations();
    results.push(...bidirectionalResults);
    
    // 참조 무결성 검증
    const integrityResults = await this.validateReferentialIntegrity();
    results.push(...integrityResults);
    
    return results;
  }
  
  // 자동 수정
  private async autoFixInconsistencies(
    inconsistencies: Inconsistency[]
  ): Promise<FixResult[]> {
    const results: FixResult[] = [];
    
    // 심각도별 그룹화
    const grouped = this.groupBySeverity(inconsistencies);
    
    // 낮은 심각도부터 수정
    for (const severity of ['low', 'medium', 'high']) {
      const group = grouped[severity] || [];
      
      for (const inconsistency of group) {
        try {
          const fixResult = await this.reconciler.reconcile(
            inconsistency
          );
          results.push(fixResult);
        } catch (error) {
          results.push({
            inconsistency,
            status: 'failed',
            error: error.message
          });
        }
      }
    }
    
    return results;
  }
}

// 데이터 조정자
export class DataReconciler {
  async reconcile(
    inconsistency: Inconsistency
  ): Promise<FixResult> {
    switch (inconsistency.type) {
      case 'missing':
        return await this.handleMissingEntity(inconsistency);
        
      case 'field_mismatch':
        return await this.handleFieldMismatch(inconsistency);
        
      case 'version_mismatch':
        return await this.handleVersionMismatch(inconsistency);
        
      default:
        throw new Error(`Unknown inconsistency type: ${inconsistency.type}`);
    }
  }
  
  private async handleMissingEntity(
    inconsistency: Inconsistency
  ): Promise<FixResult> {
    // Primary 리전에서 데이터 복사
    const primaryData = await this.fetchFromPrimary(
      inconsistency.entityType,
      inconsistency.entityId
    );
    
    // 누락된 리전에 데이터 삽입
    await this.insertToRegion(
      inconsistency.affectedRegion,
      inconsistency.entityType,
      primaryData
    );
    
    return {
      inconsistency,
      status: 'fixed',
      action: 'replicated_to_region'
    };
  }
}

// 일관성 리포터
export class ConsistencyReporter {
  generateReport(data: ReportData): ConsistencyReport {
    const summary = this.generateSummary(data);
    const details = this.generateDetails(data);
    const recommendations = this.generateRecommendations(data);
    
    return {
      summary,
      details,
      recommendations,
      metadata: {
        generatedAt: new Date(),
        duration: data.duration,
        regionsChecked: this.getRegionsChecked(data)
      }
    };
  }
  
  private generateSummary(data: ReportData): ReportSummary {
    const totalInconsistencies = data.results.reduce(
      (sum, r) => sum + r.inconsistencyCount,
      0
    );
    
    const severityCounts = this.countBySeverity(
      data.results.flatMap(r => r.inconsistencies)
    );
    
    return {
      totalEntitiesChecked: data.results.reduce(
        (sum, r) => sum + r.totalEntities,
        0
      ),
      totalInconsistencies,
      severityBreakdown: severityCounts,
      affectedEntityTypes: data.results
        .filter(r => r.inconsistencyCount > 0)
        .map(r => r.entityType),
      overallHealth: this.calculateHealthScore(
        totalInconsistencies,
        data.results
      )
    };
  }
}
```

## Task 2.13: 백업 자동화

### SubTask 2.13.1: 자동 백업 스케줄러
**담당자**: DevOps 엔지니어  
**예상 소요시간**: 10시간

**목표**: DynamoDB 테이블의 자동 백업 스케줄링 시스템 구현

**구현 내용**:
```typescript
// backend/src/backup/scheduler/backup-scheduler.ts
import { DynamoDBClient, CreateBackupCommand } from '@aws-sdk/client-dynamodb';
import { EventBridgeClient, PutRuleCommand } from '@aws-sdk/client-eventbridge';
import { S3Client } from '@aws-sdk/client-s3';
import cron from 'node-cron';

export interface BackupSchedule {
  id: string;
  name: string;
  tables: string[];
  schedule: CronSchedule;
  retention: RetentionPolicy;
  destination: BackupDestination;
  enabled: boolean;
  notifications?: NotificationConfig;
}

export interface CronSchedule {
  expression: string;
  timezone: string;
  type: 'continuous' | 'point_in_time';
}

export class BackupScheduler {
  private schedules: Map<string, cron.ScheduledTask> = new Map();
  private backupExecutor: BackupExecutor;
  private retentionManager: RetentionManager;
  private notificationService: NotificationService;
  
  constructor(
    private dynamoClient: DynamoDBClient,
    private s3Client: S3Client,
    private config: BackupConfig
  ) {
    this.backupExecutor = new BackupExecutor(dynamoClient, s3Client);
    this.retentionManager = new RetentionManager();
    this.notificationService = new NotificationService();
    
    this.loadSchedules();
  }
  
  // 백업 스케줄 생성
  async createSchedule(schedule: BackupSchedule): Promise<void> {
    // 크론 표현식 검증
    if (!cron.validate(schedule.schedule.expression)) {
      throw new Error('Invalid cron expression');
    }
    
    // 스케줄 작업 생성
    const task = cron.schedule(
      schedule.schedule.expression,
      async () => {
        await this.executeBackup(schedule);
      },
      {
        scheduled: schedule.enabled,
        timezone: schedule.schedule.timezone
      }
    );
    
    this.schedules.set(schedule.id, task);
    
    // EventBridge 규칙 생성 (고가용성)
    await this.createEventBridgeRule(schedule);
    
    // 스케줄 저장
    await this.saveSchedule(schedule);
  }
  
  // 백업 실행
  private async executeBackup(
    schedule: BackupSchedule
  ): Promise<BackupResult> {
    const backupId = this.generateBackupId();
    const startTime = Date.now();
    
    try {
      // 백업 시작 알림
      await this.notificationService.send({
        type: 'backup_started',
        schedule: schedule.name,
        tables: schedule.tables,
        timestamp: new Date()
      });
      
      // 각 테이블 백업
      const results = await Promise.all(
        schedule.tables.map(table => 
          this.backupTable(table, backupId, schedule)
        )
      );
      
      // 백업 메타데이터 저장
      const metadata = await this.saveBackupMetadata({
        backupId,
        scheduleId: schedule.id,
        tables: results,
        duration: Date.now() - startTime,
        status: 'completed',
        timestamp: new Date()
      });
      
      // 이전 백업 정리
      await this.retentionManager.applyRetentionPolicy(
        schedule.retention,
        schedule.tables
      );
      
      // 성공 알림
      await this.notificationService.send({
        type: 'backup_completed',
        schedule: schedule.name,
        backupId,
        duration: metadata.duration,
        size: this.calculateTotalSize(results)
      });
      
      return {
        success: true,
        backupId,
        metadata
      };
    } catch (error) {
      // 실패 알림
      await this.notificationService.send({
        type: 'backup_failed',
        schedule: schedule.name,
        error: error.message,
        timestamp: new Date()
      });
      
      throw error;
    }
  }
  
  // 테이블 백업
  private async backupTable(
    tableName: string,
    backupId: string,
    schedule: BackupSchedule
  ): Promise<TableBackupResult> {
    if (schedule.schedule.type === 'continuous') {
      // 연속 백업 (Point-in-time Recovery)
      return await this.enableContinuousBackup(tableName);
    } else {
      // 온디맨드 백업
      const backupName = `${tableName}-${backupId}`;
      
      const response = await this.dynamoClient.send(
        new CreateBackupCommand({
          TableName: tableName,
          BackupName: backupName
        })
      );
      
      // S3로 추가 백업 (선택적)
      if (schedule.destination.type === 's3') {
        await this.exportToS3(
          tableName,
          backupId,
          schedule.destination
        );
      }
      
      return {
        tableName,
        backupArn: response.BackupDetails?.BackupArn!,
        backupSize: response.BackupDetails?.BackupSizeBytes,
        status: response.BackupDetails?.BackupStatus!,
        createdAt: response.BackupDetails?.BackupCreationDateTime!
      };
    }
  }
  
  // S3 내보내기
  private async exportToS3(
    tableName: string,
    backupId: string,
    destination: BackupDestination
  ): Promise<void> {
    // DynamoDB Export to S3
    const exportParams = {
      TableArn: await this.getTableArn(tableName),
      S3Bucket: destination.s3Bucket!,
      S3Prefix: `backups/${backupId}/${tableName}/`,
      S3SseAlgorithm: 'AES256',
      ExportFormat: 'DYNAMODB_JSON',
      ExportTime: new Date()
    };
    
    await this.dynamoClient.exportTableToPointInTime(exportParams);
  }
}

// 보존 정책 관리자
export class RetentionManager {
  async applyRetentionPolicy(
    policy: RetentionPolicy,
    tables: string[]
  ): Promise<void> {
    for (const table of tables) {
      await this.cleanupOldBackups(table, policy);
    }
  }
  
  private async cleanupOldBackups(
    tableName: string,
    policy: RetentionPolicy
  ): Promise<void> {
    const backups = await this.listBackups(tableName);
    const now = Date.now();
    
    // 정책별 정리
    const backupsToDelete = backups.filter(backup => {
      const age = now - backup.createdAt.getTime();
      
      // 일일 백업
      if (policy.daily && age > policy.daily * 24 * 60 * 60 * 1000) {
        return !this.isRetainedBackup(backup, policy);
      }
      
      // 주간 백업
      if (policy.weekly && age > policy.weekly * 7 * 24 * 60 * 60 * 1000) {
        return !this.isWeeklyBackup(backup);
      }
      
      // 월간 백업
      if (policy.monthly && age > policy.monthly * 30 * 24 * 60 * 60 * 1000) {
        return !this.isMonthlyBackup(backup);
      }
      
      return false;
    });
    
    // 백업 삭제
    for (const backup of backupsToDelete) {
      await this.deleteBackup(backup);
    }
  }
  
  private isRetainedBackup(
    backup: Backup,
    policy: RetentionPolicy
  ): boolean {
    // 최소 보존 개수 확인
    if (policy.minimumBackups) {
      return true; // 별도 로직으로 처리
    }
    
    // 특별 보존 태그 확인
    return backup.tags?.includes('retain');
  }
}

// 백업 실행자
export class BackupExecutor {
  constructor(
    private dynamoClient: DynamoDBClient,
    private s3Client: S3Client
  ) {}
  
  async executeIncremental(
    tableName: string,
    lastBackupTime: Date
  ): Promise<IncrementalBackupResult> {
    // 변경 사항만 백업
    const changes = await this.getChangesSince(tableName, lastBackupTime);
    
    if (changes.length === 0) {
      return {
        tableName,
        status: 'no_changes',
        itemCount: 0
      };
    }
    
    // S3에 증분 백업 저장
    const key = `incremental/${tableName}/${Date.now()}.json`;
    await this.s3Client.putObject({
      Bucket: this.config.backupBucket,
      Key: key,
      Body: JSON.stringify(changes),
      ServerSideEncryption: 'AES256'
    });
    
    return {
      tableName,
      status: 'completed',
      itemCount: changes.length,
      s3Location: `s3://${this.config.backupBucket}/${key}`
    };
  }
}
```

### SubTask 2.13.2: 백업 검증 및 테스트
**담당자**: QA 엔지니어  
**예상 소요시간**: 10시간

**목표**: 백업 무결성 검증 및 복원 테스트 자동화

**구현 내용**:
```typescript
// backend/src/backup/validation/backup-validator.ts
export class BackupValidator {
  private integrityChecker: IntegrityChecker;
  private restoreTester: RestoreTester;
  private comparisonEngine: ComparisonEngine;
  
  constructor(
    private dynamoClient: DynamoDBClient,
    private config: ValidationConfig
  ) {
    this.integrityChecker = new IntegrityChecker();
    this.restoreTester = new RestoreTester(dynamoClient);
    this.comparisonEngine = new ComparisonEngine();
  }
  
  // 백업 검증 실행
  async validateBackup(
    backupId: string,
    options?: ValidationOptions
  ): Promise<ValidationReport> {
    const startTime = Date.now();
    const results: ValidationResult[] = [];
        
    // 1. 백업 메타데이터 검증
    const metadataResult = await this.validateMetadata(backupId);
    results.push(metadataResult);
    
    // 2. 데이터 무결성 검증
    const integrityResult = await this.validateIntegrity(backupId);
    results.push(integrityResult);
    
    // 3. 복원 가능성 테스트
    if (options?.testRestore) {
      const restoreResult = await this.testRestore(backupId);
      results.push(restoreResult);
    }
    
    // 4. 데이터 일관성 검증
    if (options?.compareWithSource) {
      const comparisonResult = await this.compareWithSource(backupId);
      results.push(comparisonResult);
    }
    
    return {
      backupId,
      validationTime: Date.now() - startTime,
      results,
      overallStatus: this.determineOverallStatus(results),
      recommendations: this.generateRecommendations(results)
    };
  }
  
  // 데이터 무결성 검증
  private async validateIntegrity(
    backupId: string
  ): Promise<ValidationResult> {
    const backup = await this.getBackupDetails(backupId);
    const errors: IntegrityError[] = [];
    
    // 체크섬 검증
    if (backup.checksum) {
      const calculatedChecksum = await this.integrityChecker.calculateChecksum(
        backup.data
      );
      
      if (calculatedChecksum !== backup.checksum) {
        errors.push({
          type: 'checksum_mismatch',
          expected: backup.checksum,
          actual: calculatedChecksum,
          severity: 'critical'
        });
      }
    }
    
    // 레코드 수 검증
    const recordCount = await this.integrityChecker.countRecords(backup);
    if (recordCount !== backup.metadata.recordCount) {
      errors.push({
        type: 'record_count_mismatch',
        expected: backup.metadata.recordCount,
        actual: recordCount,
        severity: 'high'
      });
    }
    
    // 스키마 검증
    const schemaValidation = await this.integrityChecker.validateSchema(
      backup
    );
    if (!schemaValidation.valid) {
      errors.push(...schemaValidation.errors);
    }
    
    return {
      type: 'integrity',
      status: errors.length === 0 ? 'passed' : 'failed',
      errors,
      details: {
        checksumVerified: !errors.some(e => e.type === 'checksum_mismatch'),
        recordCountVerified: !errors.some(e => e.type === 'record_count_mismatch'),
        schemaValid: schemaValidation.valid
      }
    };
  }
  
  // 복원 테스트
  private async testRestore(
    backupId: string
  ): Promise<ValidationResult> {
    const testTableName = `test_restore_${Date.now()}`;
    
    try {
      // 1. 테스트 테이블로 복원
      const restoreResult = await this.restoreTester.restoreToTable(
        backupId,
        testTableName
      );
      
      // 2. 복원된 데이터 검증
      const validation = await this.validateRestoredData(
        testTableName,
        backupId
      );
      
      // 3. 성능 메트릭 수집
      const metrics = {
        restoreTime: restoreResult.duration,
        dataSize: restoreResult.dataSize,
        throughput: restoreResult.dataSize / restoreResult.duration
      };
      
      // 4. 테스트 테이블 정리
      await this.cleanupTestTable(testTableName);
      
      return {
        type: 'restore_test',
        status: validation.success ? 'passed' : 'failed',
        errors: validation.errors,
        details: {
          restoreTime: metrics.restoreTime,
          throughput: metrics.throughput,
          validationResults: validation
        }
      };
    } catch (error) {
      return {
        type: 'restore_test',
        status: 'failed',
        errors: [{
          type: 'restore_failed',
          message: error.message,
          severity: 'critical'
        }]
      };
    } finally {
      // 정리
      await this.cleanupTestTable(testTableName).catch(() => {});
    }
  }
  
  // 원본 데이터와 비교
  private async compareWithSource(
    backupId: string
  ): Promise<ValidationResult> {
    const backup = await this.getBackupDetails(backupId);
    const sourceTable = backup.metadata.sourceTable;
    
    // 샘플링 비교 (전체 비교는 비용이 많이 듦)
    const sampleSize = Math.min(
      1000,
      backup.metadata.recordCount * 0.1
    );
    
    const comparisonResult = await this.comparisonEngine.compare(
      sourceTable,
      backup,
      {
        sampleSize,
        compareFields: ['id', 'version', 'updatedAt'],
        ignoreFields: ['backupTimestamp']
      }
    );
    
    return {
      type: 'data_comparison',
      status: comparisonResult.identical ? 'passed' : 'failed',
      errors: comparisonResult.differences.map(diff => ({
        type: 'data_mismatch',
        field: diff.field,
        sourceValue: diff.sourceValue,
        backupValue: diff.backupValue,
        severity: 'medium'
      })),
      details: {
        samplesCompared: sampleSize,
        differencesFound: comparisonResult.differences.length,
        matchRate: comparisonResult.matchRate
      }
    };
  }
}

// 복원 테스터
export class RestoreTester {
  constructor(
    private dynamoClient: DynamoDBClient
  ) {}
  
  async restoreToTable(
    backupId: string,
    targetTable: string
  ): Promise<RestoreResult> {
    const startTime = Date.now();
    
    // 백업에서 테이블 복원
    const response = await this.dynamoClient.restoreTableFromBackup({
      BackupArn: backupId,
      TargetTableName: targetTable
    });
    
    // 복원 완료 대기
    await this.waitForTableActive(targetTable);
    
    const duration = Date.now() - startTime;
    const tableInfo = await this.getTableInfo(targetTable);
    
    return {
      success: true,
      duration,
      dataSize: tableInfo.TableSizeBytes,
      itemCount: tableInfo.ItemCount
    };
  }
  
  async performRandomSpotChecks(
    sourceTable: string,
    restoredTable: string,
    sampleCount: number
  ): Promise<SpotCheckResult> {
    const mismatches: any[] = [];
    
    // 랜덤 키 선택
    const randomKeys = await this.selectRandomKeys(sourceTable, sampleCount);
    
    for (const key of randomKeys) {
      const sourceItem = await this.getItem(sourceTable, key);
      const restoredItem = await this.getItem(restoredTable, key);
      
      if (!this.deepEqual(sourceItem, restoredItem)) {
        mismatches.push({
          key,
          source: sourceItem,
          restored: restoredItem
        });
      }
    }
    
    return {
      totalChecked: sampleCount,
      mismatches: mismatches.length,
      details: mismatches
    };
  }
}

// 백업 성능 분석기
export class BackupPerformanceAnalyzer {
  async analyzeBackupPerformance(
    backupHistory: BackupRecord[]
  ): Promise<PerformanceAnalysis> {
    return {
      averageBackupTime: this.calculateAverage(
        backupHistory.map(b => b.duration)
      ),
      averageThroughput: this.calculateAverageThroughput(backupHistory),
      peakTimes: this.identifyPeakTimes(backupHistory),
      recommendations: this.generatePerformanceRecommendations(backupHistory)
    };
  }
  
  private calculateAverageThroughput(
    history: BackupRecord[]
  ): number {
    const throughputs = history.map(b => b.dataSize / b.duration);
    return this.calculateAverage(throughputs);
  }
  
  private generatePerformanceRecommendations(
    history: BackupRecord[]
  ): string[] {
    const recommendations: string[] = [];
    
    // 백업 시간 분석
    const avgTime = this.calculateAverage(history.map(b => b.duration));
    if (avgTime > 3600000) { // 1시간 이상
      recommendations.push(
        'Consider using parallel backup streams for large tables'
      );
    }
    
    // 실패율 분석
    const failureRate = history.filter(b => b.status === 'failed').length / 
                       history.length;
    if (failureRate > 0.05) { // 5% 이상
      recommendations.push(
        'High failure rate detected. Review backup configuration and error logs'
      );
    }
    
    return recommendations;
  }
}
```

### SubTask 2.13.3: 증분 백업 시스템
**담당자**: 백엔드 개발자  
**예상 소요시간**: 10시간

**목표**: 변경된 데이터만 백업하는 증분 백업 시스템 구현

**구현 내용**:
```typescript
// backend/src/backup/incremental/incremental-backup.ts
export class IncrementalBackupManager {
  private changeTracker: ChangeTracker;
  private deltaCalculator: DeltaCalculator;
  private backupStorage: BackupStorage;
  
  constructor(
    private dynamoClient: DynamoDBClient,
    private s3Client: S3Client,
    private config: IncrementalBackupConfig
  ) {
    this.changeTracker = new ChangeTracker(dynamoClient);
    this.deltaCalculator = new DeltaCalculator();
    this.backupStorage = new BackupStorage(s3Client);
  }
  
  // 증분 백업 실행
  async performIncrementalBackup(
    tableName: string,
    lastBackupId?: string
  ): Promise<IncrementalBackupResult> {
    // 마지막 백업 시점 확인
    const lastBackup = lastBackupId ? 
      await this.getBackupInfo(lastBackupId) :
      await this.getLastFullBackup(tableName);
    
    if (!lastBackup) {
      // 전체 백업 수행
      return await this.performFullBackup(tableName);
    }
    
    // 변경 사항 추적
    const changes = await this.changeTracker.getChangesSince(
      tableName,
      lastBackup.timestamp
    );
    
    if (changes.totalChanges === 0) {
      return {
        type: 'incremental',
        status: 'no_changes',
        backupId: lastBackup.backupId,
        changesBackedUp: 0
      };
    }
    
    // 델타 계산
    const delta = await this.deltaCalculator.calculate(
      changes,
      lastBackup
    );
    
    // 증분 백업 저장
    const backupId = await this.saveIncrementalBackup(
      tableName,
      delta,
      lastBackup.backupId
    );
    
    return {
      type: 'incremental',
      status: 'completed',
      backupId,
      parentBackupId: lastBackup.backupId,
      changesBackedUp: changes.totalChanges,
      deltaSize: delta.size,
      compression: delta.compressionRatio
    };
  }
  
  // 백업 체인 관리
  async getBackupChain(
    backupId: string
  ): Promise<BackupChain> {
    const chain: BackupNode[] = [];
    let currentId = backupId;
    
    while (currentId) {
      const backup = await this.getBackupInfo(currentId);
      chain.unshift({
        backupId: backup.backupId,
        type: backup.type,
        timestamp: backup.timestamp,
        size: backup.size,
        parentId: backup.parentBackupId
      });
      
      currentId = backup.parentBackupId;
    }
    
    return {
      fullBackupId: chain[0].backupId,
      incrementalBackups: chain.slice(1),
      totalSize: chain.reduce((sum, node) => sum + node.size, 0),
      chainLength: chain.length
    };
  }
  
  // 증분 백업 병합
  async mergeIncrementalBackups(
    chainId: string,
    targetCount: number = 1
  ): Promise<MergeResult> {
    const chain = await this.getBackupChain(chainId);
    
    if (chain.chainLength <= targetCount) {
      return {
        status: 'no_merge_needed',
        originalCount: chain.chainLength,
        mergedCount: chain.chainLength
      };
    }
    
    // 병합 전략 결정
    const mergeStrategy = this.determineMergeStrategy(chain);
    
    // 병합 실행
    const mergedBackups = await this.executeMerge(
      chain,
      mergeStrategy,
      targetCount
    );
    
    // 이전 백업 정리
    await this.cleanupOldBackups(
      chain.incrementalBackups.map(b => b.backupId)
    );
    
    return {
      status: 'completed',
      originalCount: chain.chainLength,
      mergedCount: mergedBackups.length,
      spaceSaved: chain.totalSize - mergedBackups.reduce(
        (sum, b) => sum + b.size, 0
      )
    };
  }
}

// 변경 추적기
export class ChangeTracker {
  constructor(
    private dynamoClient: DynamoDBClient
  ) {}
  
  async getChangesSince(
    tableName: string,
    timestamp: Date
  ): Promise<Changes> {
    const changes: Changes = {
      inserted: [],
      updated: [],
      deleted: [],
      totalChanges: 0,
      timestamp: new Date()
    };
    
    // DynamoDB Streams에서 변경 사항 읽기
    const streamRecords = await this.readStreamRecords(
      tableName,
      timestamp
    );
    
    for (const record of streamRecords) {
      switch (record.eventName) {
        case 'INSERT':
          changes.inserted.push({
            key: record.dynamodb.Keys,
            item: record.dynamodb.NewImage
          });
          break;
          
        case 'MODIFY':
          changes.updated.push({
            key: record.dynamodb.Keys,
            oldItem: record.dynamodb.OldImage,
            newItem: record.dynamodb.NewImage,
            changedFields: this.identifyChangedFields(
              record.dynamodb.OldImage,
              record.dynamodb.NewImage
            )
          });
          break;
          
        case 'REMOVE':
          changes.deleted.push({
            key: record.dynamodb.Keys,
            item: record.dynamodb.OldImage
          });
          break;
      }
    }
    
    changes.totalChanges = 
      changes.inserted.length + 
      changes.updated.length + 
      changes.deleted.length;
    
    return changes;
  }
  
  private identifyChangedFields(
    oldItem: any,
    newItem: any
  ): string[] {
    const changedFields: string[] = [];
    const allFields = new Set([
      ...Object.keys(oldItem || {}),
      ...Object.keys(newItem || {})
    ]);
    
    for (const field of allFields) {
      if (!this.deepEqual(oldItem?.[field], newItem?.[field])) {
        changedFields.push(field);
      }
    }
    
    return changedFields;
  }
}

// 델타 계산기
export class DeltaCalculator {
  async calculate(
    changes: Changes,
    baseBackup: BackupInfo
  ): Promise<Delta> {
    const delta: Delta = {
      baseBackupId: baseBackup.backupId,
      changes: {
        inserted: changes.inserted,
        updated: changes.updated.map(u => ({
          key: u.key,
          patches: this.createPatches(u.oldItem, u.newItem)
        })),
        deleted: changes.deleted.map(d => d.key)
      },
      metadata: {
        timestamp: new Date(),
        changeCount: changes.totalChanges,
        baseVersion: baseBackup.version
      }
    };
    
    // 압축
    const compressed = await this.compress(delta);
    
    return {
      ...delta,
      size: compressed.length,
      compressionRatio: JSON.stringify(delta).length / compressed.length,
      compressedData: compressed
    };
  }
  
  private createPatches(
    oldItem: any,
    newItem: any
  ): Patch[] {
    const patches: Patch[] = [];
    
    // JSON Patch 형식으로 변경 사항 표현
    const diff = this.diff(oldItem, newItem);
    
    for (const operation of diff) {
      patches.push({
        op: operation.op,
        path: operation.path,
        value: operation.value,
        oldValue: operation.oldValue
      });
    }
    
    return patches;
  }
}

// 백업 복원기
export class BackupRestorer {
  async restoreFromIncremental(
    backupId: string,
    targetTable: string
  ): Promise<RestoreResult> {
    // 백업 체인 가져오기
    const chain = await this.getBackupChain(backupId);
    
    // 1. 전체 백업 복원
    await this.restoreFullBackup(
      chain.fullBackupId,
      targetTable
    );
    
    // 2. 증분 백업 순차 적용
    for (const incremental of chain.incrementalBackups) {
      await this.applyIncrementalBackup(
        incremental,
        targetTable
      );
    }
    
    // 3. 검증
    const validation = await this.validateRestore(
      targetTable,
      backupId
    );
    
    return {
      success: validation.success,
      restoredTable: targetTable,
      itemCount: validation.itemCount,
      finalVersion: chain.incrementalBackups.slice(-1)[0]?.version
    };
  }
  
  private async applyIncrementalBackup(
    backup: BackupNode,
    targetTable: string
  ): Promise<void> {
    const delta = await this.loadDelta(backup.backupId);
    
    // 삽입 적용
    for (const insert of delta.changes.inserted) {
      await this.putItem(targetTable, insert.item);
    }
    
    // 업데이트 적용
    for (const update of delta.changes.updated) {
      await this.applyPatches(
        targetTable,
        update.key,
        update.patches
      );
    }
    
    // 삭제 적용
    for (const deleteKey of delta.changes.deleted) {
      await this.deleteItem(targetTable, deleteKey);
    }
  }
}
```

### SubTask 2.13.4: 재해 복구 자동화
**담당자**: DevOps 엔지니어  
**예상 소요시간**: 8시간

**목표**: 재해 발생 시 자동 복구 프로세스 구현

**구현 내용**:
```typescript
// backend/src/backup/disaster-recovery/dr-automation.ts
export class DisasterRecoveryAutomation {
  private healthMonitor: HealthMonitor;
  private failoverManager: FailoverManager;
  private recoveryOrchestrator: RecoveryOrchestrator;
  private alertingService: AlertingService;
  
  constructor(
    private config: DRConfig,
    private backupManager: BackupManager
  ) {
    this.healthMonitor = new HealthMonitor(config.monitoring);
    this.failoverManager = new FailoverManager(config.failover);
    this.recoveryOrchestrator = new RecoveryOrchestrator();
    this.alertingService = new AlertingService(config.alerting);
    
    this.initializeAutomation();
  }
  
  // DR 자동화 초기화
  private initializeAutomation(): void {
    // 헬스 체크 모니터링
    this.healthMonitor.on('unhealthy', async (event) => {
      await this.handleUnhealthyEvent(event);
    });
    
    // 자동 페일오버 트리거
    this.healthMonitor.on('failover_required', async (event) => {
      await this.executeFailover(event);
    });
    
    // 정기 DR 훈련
    if (this.config.drillSchedule) {
      this.scheduleDRDrills();
    }
  }
  
  // 재해 감지 및 대응
  async handleDisasterEvent(
    event: DisasterEvent
  ): Promise<DisasterResponse> {
    const startTime = Date.now();
    
    // 1. 재해 수준 평가
    const assessment = await this.assessDisasterLevel(event);
    
    // 2. 대응 계획 수립
    const recoveryPlan = await this.createRecoveryPlan(assessment);
    
    // 3. 이해관계자 알림
    await this.notifyStakeholders(assessment, recoveryPlan);
    
    // 4. 복구 실행
    const recoveryResult = await this.executeRecovery(recoveryPlan);
    
    // 5. 복구 검증
    const validation = await this.validateRecovery(recoveryResult);
    
    return {
      disasterType: event.type,
      severity: assessment.severity,
      recoveryTime: Date.now() - startTime,
      dataLoss: recoveryResult.dataLoss,
      validation,
      report: await this.generateDRReport(event, recoveryResult)
    };
  }
  
  // 복구 계획 수립
  private async createRecoveryPlan(
    assessment: DisasterAssessment
  ): Promise<RecoveryPlan> {
    const plan: RecoveryPlan = {
      id: uuidv4(),
      priority: this.determinePriority(assessment),
      steps: [],
      estimatedTime: 0,
      resources: []
    };
    
    // 영향받은 서비스 식별
    const affectedServices = await this.identifyAffectedServices(
      assessment
    );
    
    // 서비스별 복구 단계 생성
    for (const service of affectedServices) {
      const steps = await this.createServiceRecoverySteps(
        service,
        assessment
      );
      plan.steps.push(...steps);
    }
    
    // 의존성 순서 정렬
    plan.steps = this.sortByDependencies(plan.steps);
    
    // 리소스 요구사항 계산
    plan.resources = this.calculateRequiredResources(plan.steps);
    
    // 예상 시간 계산
    plan.estimatedTime = this.estimateRecoveryTime(plan.steps);
    
    return plan;
  }
  
  // 복구 실행
  private async executeRecovery(
    plan: RecoveryPlan
  ): Promise<RecoveryResult> {
    const executor = new RecoveryExecutor(plan);
    const result: RecoveryResult = {
      planId: plan.id,
      startTime: new Date(),
      steps: [],
      dataLoss: 0
    };
    
    // 단계별 실행
    for (const step of plan.steps) {
      try {
        const stepResult = await executor.executeStep(step);
        result.steps.push(stepResult);
        
        // 진행 상황 업데이트
        await this.updateProgress(plan.id, step.id, stepResult);
        
      } catch (error) {
        // 복구 실패 처리
        await this.handleRecoveryFailure(step, error);
        
        // 대체 전략 실행
        const fallbackResult = await this.executeFallbackStrategy(
          step,
          error
        );
        result.steps.push(fallbackResult);
      }
    }
    
    result.endTime = new Date();
    result.duration = result.endTime.getTime() - result.startTime.getTime();
    
    return result;
  }
  
  // DR 훈련 스케줄링
  private scheduleDRDrills(): void {
    cron.schedule(this.config.drillSchedule, async () => {
      await this.executeDRDrill();
    });
  }
  
  // DR 훈련 실행
  async executeDRDrill(): Promise<DrillResult> {
    const drill: DRDrill = {
      id: uuidv4(),
      type: this.selectDrillScenario(),
      startTime: new Date(),
      scope: this.config.drillScope
    };
    
    try {
      // 1. 훈련 환경 준비
      await this.prepareDrillEnvironment(drill);
      
      // 2. 재해 시나리오 시뮬레이션
      const disaster = await this.simulateDisaster(drill.type);
      
      // 3. 복구 프로세스 실행
      const recovery = await this.handleDisasterEvent(disaster);
      
      // 4. 결과 평가
      const evaluation = await this.evaluateDrillResults(
        drill,
        recovery
      );
      
      // 5. 개선 사항 도출
      const improvements = this.identifyImprovements(evaluation);
      
      return {
        drillId: drill.id,
        scenario: drill.type,
        duration: Date.now() - drill.startTime.getTime(),
        evaluation,
        improvements,
        nextActions: this.generateActionItems(improvements)
      };
      
    } finally {
      // 훈련 환경 정리
      await this.cleanupDrillEnvironment(drill);
    }
  }
}

// 페일오버 관리자
export class FailoverManager {
  async executeFailover(
    event: FailoverEvent
  ): Promise<FailoverResult> {
    // 1. 현재 상태 스냅샷
    const snapshot = await this.captureCurrentState();
    
    // 2. 타겟 리전 준비
    await this.prepareTargetRegion(event.targetRegion);
    
    // 3. 데이터 동기화 확인
    const syncStatus = await this.verifySyncStatus(
      event.sourceRegion,
      event.targetRegion
    );
    
    if (syncStatus.lag > this.config.maxAcceptableLag) {
      // 긴급 동기화
      await this.performEmergencySync(
        event.sourceRegion,
        event.targetRegion
      );
    }
    
    // 4. 트래픽 전환
    await this.switchTraffic(event.targetRegion);
    
    // 5. 상태 검증
    const validation = await this.validateFailover(
      snapshot,
      event.targetRegion
    );
    
    return {
      success: validation.success,
      sourceRegion: event.sourceRegion,
      targetRegion: event.targetRegion,
      dataLoss: syncStatus.estimatedDataLoss,
      switchoverTime: validation.switchoverTime,
      validation
    };
  }
}

// 복구 오케스트레이터
export class RecoveryOrchestrator {
  async orchestrateRecovery(
    services: AffectedService[]
  ): Promise<OrchestrationResult> {
    // 서비스 의존성 그래프 생성
    const dependencyGraph = this.buildDependencyGraph(services);
    
    // 병렬 복구 가능한 그룹 식별
    const recoveryGroups = this.identifyParallelGroups(dependencyGraph);
    
    // 그룹별 복구 실행
    const results: ServiceRecoveryResult[] = [];
    
    for (const group of recoveryGroups) {
      const groupResults = await Promise.all(
        group.map(service => this.recoverService(service))
      );
      results.push(...groupResults);
    }
    
    return {
      totalServices: services.length,
      recoveredServices: results.filter(r => r.success).length,
      failedServices: results.filter(r => !r.success).length,
      results
    };
  }
}
```

## Task 2.14: 재해 복구 계획

### SubTask 2.14.1: RTO/RPO 목표 구현
**담당자**: 시스템 아키텍트  
**예상 소요시간**: 10시간

**목표**: Recovery Time Objective(RTO)와 Recovery Point Objective(RPO) 목표 달성을 위한 시스템 구현

**구현 내용**:
```typescript
// backend/src/dr/objectives/rto-rpo-manager.ts
export interface RTORPOObjectives {
  serviceName: string;
  rto: number; // 목표 복구 시간 (분)
  rpo: number; // 목표 복구 시점 (분)
  tier: 'critical' | 'high' | 'medium' | 'low';
  dependencies: string[];
}

export class RTORPOManager {
  private objectives: Map<string, RTORPOObjectives> = new Map();
  private metricsCollector: MetricsCollector;
  private complianceMonitor: ComplianceMonitor;
  
  constructor(
    private config: DRConfig,
    private backupManager: BackupManager,
    private replicationManager: ReplicationManager
  ) {
    this.metricsCollector = new MetricsCollector();
    this.complianceMonitor = new ComplianceMonitor();
    
    this.loadObjectives();
    this.initializeMonitoring();
  }
  
  // RTO/RPO 목표 설정
  setObjectives(objectives: RTORPOObjectives): void {
    // 검증
    this.validateObjectives(objectives);
    
    // 실현 가능성 확인
    const feasibility = this.assessFeasibility(objectives);
    if (!feasibility.achievable) {
      throw new Error(
        `Objectives not achievable: ${feasibility.reasons.join(', ')}`
      );
    }
    
    this.objectives.set(objectives.serviceName, objectives);
    
    // 백업 및 복제 전략 조정
    this.adjustStrategies(objectives);
  }
  
  // 실현 가능성 평가
  private assessFeasibility(
    objectives: RTORPOObjectives
  ): FeasibilityAssessment {
    const assessment: FeasibilityAssessment = {
      achievable: true,
      reasons: [],
      recommendations: []
    };
    
    // RPO 평가
    if (objectives.rpo < 5) { // 5분 미만
      assessment.recommendations.push(
        'Enable continuous replication for sub-5 minute RPO'
      );
      
      if (!this.config.continuousReplication) {
        assessment.achievable = false;
        assessment.reasons.push(
          'Continuous replication not enabled'
        );
      }
    }
    
    // RTO 평가
    if (objectives.rto < 15) { // 15분 미만
      assessment.recommendations.push(
        'Implement hot standby for sub-15 minute RTO'
      );
      
      if (!this.config.hotStandby) {
        assessment.achievable = false;
        assessment.reasons.push(
          'Hot standby not configured'
        );
      }
    }
    
    // 의존성 평가
    for (const dep of objectives.dependencies) {
      const depObjective = this.objectives.get(dep);
      if (depObjective && depObjective.rto > objectives.rto) {
        assessment.achievable = false;
        assessment.reasons.push(
          `Dependency ${dep} has longer RTO`
        );
      }
    }
    
    return assessment;
  }
  
  // 전략 조정
  private adjustStrategies(objectives: RTORPOObjectives): void {
    // 백업 전략 조정
    if (objectives.rpo <= 60) { // 1시간 이하
      this.backupManager.enableContinuousBackup(
        objectives.serviceName
      );
    }
    
    // 복제 전략 조정
    if (objectives.rpo <= 5) { // 5분 이하
      this.replicationManager.enableSynchronousReplication(
        objectives.serviceName
      );
    }
    
    // 복구 준비 조정
    if (objectives.rto <= 30) { // 30분 이하
      this.prepareRapidRecovery(objectives.serviceName);
    }
  }
  
  // 컴플라이언스 모니터링
  async monitorCompliance(): Promise<ComplianceReport> {
    const report: ComplianceReport = {
      timestamp: new Date(),
      services: [],
      overallCompliance: 0
    };
    
    for (const [service, objectives] of this.objectives) {
      const metrics = await this.measureActualMetrics(service);
      
      const compliance = {
        service,
        rtoTarget: objectives.rto,
        rtoActual: metrics.actualRTO,
        rtoCompliant: metrics.actualRTO <= objectives.rto,
        rpoTarget: objectives.rpo,
        rpoActual: metrics.actualRPO,
        rpoCompliant: metrics.actualRPO <= objectives.rpo,
        lastTested: metrics.lastDRTest
      };
      
      report.services.push(compliance);
    }
    
    report.overallCompliance = this.calculateOverallCompliance(
      report.services
    );
    
    // 비준수 알림
    await this.alertNonCompliance(report);
    
    return report;
  }
  
  // 실제 메트릭 측정
  private async measureActualMetrics(
    service: string
  ): Promise<ActualMetrics> {
    // 마지막 복구 연습 결과
    const lastDrill = await this.getLastDRDrill(service);
    
    // 백업 주기 확인
    const backupMetrics = await this.backupManager.getMetrics(service);
    
    // 복제 지연 확인
    const replicationLag = await this.replicationManager.getLag(service);
    
    return {
      actualRTO: lastDrill?.recoveryTime || Infinity,
      actualRPO: Math.max(
        backupMetrics.interval,
        replicationLag
      ),
      lastDRTest: lastDrill?.timestamp,
      confidence: this.calculateConfidence(lastDrill, backupMetrics)
    };
  }
}

// RTO 최적화 엔진
export class RTOOptimizer {
  async optimizeRecoveryTime(
    service: string,
    currentRTO: number,
    targetRTO: number
  ): Promise<OptimizationPlan> {
    const optimizations: Optimization[] = [];
    
    // 현재 복구 프로세스 분석
    const analysis = await this.analyzeRecoveryProcess(service);
    
    // 병목 지점 식별
    const bottlenecks = this.identifyBottlenecks(analysis);
    
    // 최적화 전략 생성
    if (bottlenecks.includes('backup_restore')) {
      optimizations.push({
        type: 'parallel_restore',
        estimatedImprovement: 40,
        cost: 'medium',
        implementation: 'Enable parallel table restore'
      });
    }
    
    if (bottlenecks.includes('data_validation')) {
      optimizations.push({
        type: 'async_validation',
        estimatedImprovement: 20,
        cost: 'low',
        implementation: 'Perform validation asynchronously'
      });
    }
    
    if (targetRTO < 15 && !analysis.hasHotStandby) {
      optimizations.push({
        type: 'hot_standby',
        estimatedImprovement: 70,
        cost: 'high',
        implementation: 'Implement hot standby infrastructure'
      });
    }
    
    return {
      currentRTO,
      targetRTO,
      achievableRTO: this.calculateAchievableRTO(
        currentRTO,
        optimizations
      ),
      optimizations,
      implementationPlan: this.createImplementationPlan(optimizations)
    };
  }
}

// RPO 모니터
export class RPOMonitor {
  private lastBackupTimes: Map<string, Date> = new Map();
  private lastReplicationSync: Map<string, Date> = new Map();
  
  async monitorRPO(service: string): Promise<RPOStatus> {
    const objectives = this.getObjectives(service);
    
    // 현재 잠재 데이터 손실 계산
    const potentialDataLoss = await this.calculatePotentialDataLoss(
      service
    );
    
    // RPO 위반 확인
    const violation = potentialDataLoss > objectives.rpo;
    
    if (violation) {
      // 즉시 백업 트리거
      await this.triggerEmergencyBackup(service);
      
      // 알림 발송
      await this.sendRPOViolationAlert({
        service,
        targetRPO: objectives.rpo,
        currentRPO: potentialDataLoss,
        severity: this.calculateSeverity(
          potentialDataLoss,
          objectives.rpo
        )
      });
    }
    
    return {
      service,
      compliant: !violation,
      currentRPO: potentialDataLoss,
      targetRPO: objectives.rpo,
      lastBackup: this.lastBackupTimes.get(service),
      nextBackupIn: this.calculateNextBackupTime(service)
    };
  }
  
  private async calculatePotentialDataLoss(
    service: string
  ): Promise<number> {
    const lastBackup = this.lastBackupTimes.get(service);
    const lastSync = this.lastReplicationSync.get(service);
    
    const now = Date.now();
    const timeSinceBackup = lastBackup ? 
      (now - lastBackup.getTime()) / 60000 : Infinity;
    const timeSinceSync = lastSync ? 
      (now - lastSync.getTime()) / 60000 : Infinity;
    
    return Math.min(timeSinceBackup, timeSinceSync);
  }
}
```

### SubTask 2.14.2: 다중 리전 페일오버
**담당자**: 인프라 엔지니어  
**예상 소요시간**: 12시간

**목표**: 다중 AWS 리전 간 자동 페일오버 시스템 구현

**구현 내용**:
```typescript
// backend/src/dr/failover/multi-region-failover.ts
export interface RegionConfig {
  region: string;
  role: 'primary' | 'secondary' | 'dr';
  priority: number;
  healthEndpoint: string;
  resources: RegionResources;
}

export class MultiRegionFailoverManager {
  private regions: Map<string, RegionConfig> = new Map();
  private healthChecker: RegionHealthChecker;
  private dnsManager: DNSManager;
  private dataSync: DataSyncManager;
  private stateManager: FailoverStateManager;
  
  constructor(
    private config: FailoverConfig
  ) {
    this.healthChecker = new RegionHealthChecker();
    this.dnsManager = new DNSManager(config.route53);
    this.dataSync = new DataSyncManager();
    this.stateManager = new FailoverStateManager();
    
    this.initializeRegions();
    this.startHealthMonitoring();
  }
  
  // 리전 초기화
  private initializeRegions(): void {
    for (const regionConfig of this.config.regions) {
      this.regions.set(regionConfig.region, regionConfig);
      
      // 리전별 리소스 검증
      this.validateRegionResources(regionConfig);
    }
  }
  
  // 페일오버 실행
  async executeFailover(
    fromRegion: string,
    toRegion: string,
    reason: FailoverReason
  ): Promise<FailoverResult> {
    const failoverId = uuidv4();
    const startTime = Date.now();
    
    try {
      // 1. 페일오버 상태 초기화
      await this.stateManager.initializeFailover({
        id: failoverId,
        fromRegion,
        toRegion,
        reason,
        startTime: new Date()
      });
      
      // 2. Pre-failover 검증
      await this.preFailoverValidation(fromRegion, toRegion);
      
      // 3. 데이터 동기화 확인
      const syncStatus = await this.dataSync.checkSyncStatus(
        fromRegion,
        toRegion
      );
      
      if (!syncStatus.synchronized) {
        await this.performEmergencySync(fromRegion, toRegion);
      }
      
      // 4. 애플리케이션 중지 (선택적)
      if (this.config.gracefulShutdown) {
        await this.gracefulShutdown(fromRegion);
      }
      
      // 5. DNS 전환
      await this.switchDNS(fromRegion, toRegion);
      
      // 6. 새 Primary 활성화
      await this.activateNewPrimary(toRegion);
      
      // 7. 상태 검증
      const validation = await this.postFailoverValidation(toRegion);
      
      // 8. 이전 Primary 정리
      await this.decommissionOldPrimary(fromRegion);
      
      const result: FailoverResult = {
        id: failoverId,
        success: true,
        duration: Date.now() - startTime,
        fromRegion,
        toRegion,
        validation,
        dataLoss: syncStatus.estimatedDataLoss
      };
      
      await this.stateManager.completeFailover(failoverId, result);
      
      return result;
      
    } catch (error) {
      // 페일오버 롤백
      await this.rollbackFailover(failoverId, error);
      throw error;
    }
  }
  
  // DNS 전환
  private async switchDNS(
    fromRegion: string,
    toRegion: string
  ): Promise<void> {
    const hostedZone = this.config.route53.hostedZoneId;
    
    // 현재 레코드 백업
    const currentRecords = await this.dnsManager.getRecords(hostedZone);
    await this.stateManager.saveState('dns_backup', currentRecords);
    
    // 새 레코드 생성
    const newRecords = this.generateDNSRecords(toRegion);
    
    // 가중치 기반 전환 (점진적)
    if (this.config.gradualFailover) {
      await this.performGradualDNSSwitch(
        hostedZone,
        fromRegion,
        toRegion,
        newRecords
      );
    } else {
      // 즉시 전환
      await this.dnsManager.updateRecords(
        hostedZone,
        newRecords
      );
    }
    
    // DNS 전파 대기
    await this.waitForDNSPropagation(newRecords);
  }
  
  // 점진적 DNS 전환
  private async performGradualDNSSwitch(
    hostedZone: string,
    fromRegion: string,
    toRegion: string,
    targetRecords: DNSRecord[]
  ): Promise<void> {
    const steps = [10, 25, 50, 75, 100]; // 트래픽 비율
    
    for (const percentage of steps) {
      // 가중치 레코드 생성
      const weightedRecords = this.createWeightedRecords(
        fromRegion,
        toRegion,
        percentage
      );
      
      await this.dnsManager.updateRecords(
        hostedZone,
        weightedRecords
      );
      
      // 모니터링
      await this.monitorTrafficDistribution(
        fromRegion,
        toRegion,
        percentage
      );
      
      // 안정화 대기
      await this.sleep(this.config.stabilizationTime);
    }
  }
  
  // 자동 페일백
  async executeFailback(
    originalRegion: string
  ): Promise<FailbackResult> {
    // 원본 리전 상태 확인
    const health = await this.healthChecker.checkRegion(originalRegion);
    
    if (!health.healthy) {
      throw new Error('Original region not healthy for failback');
    }
    
    // 데이터 역동기화
    const currentPrimary = await this.getCurrentPrimary();
    await this.dataSync.reverseSync(
      currentPrimary,
      originalRegion
    );
    
    // 페일백 실행
    const result = await this.executeFailover(
      currentPrimary,
      originalRegion,
      { type: 'failback', automated: true }
    );
    
    return {
      ...result,
      type: 'failback'
    };
  }
}

// 리전 상태 검사기
export class RegionHealthChecker {
  private checks: HealthCheck[] = [];
  
  constructor() {
    this.initializeHealthChecks();
  }
  
  private initializeHealthChecks(): void {
    // API 엔드포인트 검사
    this.checks.push(new APIHealthCheck());
    
    // 데이터베이스 연결 검사
    this.checks.push(new DatabaseHealthCheck());
    
    // 스토리지 가용성 검사
    this.checks.push(new StorageHealthCheck());
    
    // 네트워크 연결성 검사
    this.checks.push(new NetworkHealthCheck());
    
    // 애플리케이션 상태 검사
    this.checks.push(new ApplicationHealthCheck());
  }
  
  async checkRegion(region: string): Promise<RegionHealth> {
    const results: HealthCheckResult[] = [];
    
    for (const check of this.checks) {
      try {
        const result = await check.execute(region);
        results.push(result);
      } catch (error) {
        results.push({
          check: check.name,
          healthy: false,
          error: error.message
        });
      }
    }
    
    const healthScore = this.calculateHealthScore(results);
    
    return {
      region,
      healthy: healthScore >= this.config.healthThreshold,
      score: healthScore,
      checks: results,
      timestamp: new Date()
    };
  }
  
  private calculateHealthScore(
    results: HealthCheckResult[]
  ): number {
    const weights = {
      'api': 0.3,
      'database': 0.3,
      'storage': 0.2,
      'network': 0.1,
      'application': 0.1
    };
    
    let score = 0;
    for (const result of results) {
      if (result.healthy) {
        score += weights[result.check] || 0;
      }
    }
    
    return score;
  }
}

// 페일오버 상태 관리자
export class FailoverStateManager {
  private state: Map<string, any> = new Map();
  private history: FailoverHistory[] = [];
  
  async initializeFailover(
    failover: FailoverInitiation
  ): Promise<void> {
    // 상태 저장
    this.state.set(failover.id, {
      ...failover,
      status: 'in_progress',
      steps: []
    });
    
    // 이벤트 발생
    await this.emit('failover:started', failover);
    
    // 감사 로그
    await this.auditLog({
      event: 'failover_initiated',
      failoverId: failover.id,
      details: failover
    });
  }
  
  async saveCheckpoint(
    failoverId: string,
    checkpoint: FailoverCheckpoint
  ): Promise<void> {
    const failover = this.state.get(failoverId);
    failover.steps.push(checkpoint);
    
    // 영구 저장
    await this.persistState(failoverId, failover);
  }
  
  async rollback(
    failoverId: string,
    toCheckpoint: string
  ): Promise<void> {
    const failover = this.state.get(failoverId);
    const checkpoint = failover.steps.find(
      s => s.id === toCheckpoint
    );
    
    if (!checkpoint) {
      throw new Error('Checkpoint not found');
    }
    
    // 체크포인트 이후 단계 롤백
    const stepsToRollback = failover.steps.filter(
      s => s.timestamp > checkpoint.timestamp
    );
    
    for (const step of stepsToRollback.reverse()) {
      await this.rollbackStep(step);
    }
  }
}
```

### SubTask 2.14.3: 복구 시뮬레이션
**담당자**: QA 엔지니어  
**예상 소요시간**: 10시간

**목표**: 재해 복구 시나리오 시뮬레이션 및 검증 시스템 구현

**구현 내용**:
```typescript
// backend/src/dr/simulation/dr-simulator.ts
export interface SimulationScenario {
  id: string;
  name: string;
  disasterType: DisasterType;
  affectedComponents: string[];
  dataLossPercentage: number;
  duration: number;
  complexity: 'low' | 'medium' | 'high';
}

export class DisasterRecoverySimulator {
  private scenarioRunner: ScenarioRunner;
  private environmentManager: SimulationEnvironmentManager;
  private metricsCollector: SimulationMetricsCollector;
  private reportGenerator: SimulationReportGenerator;
  
  constructor(
    private config: SimulationConfig
  ) {
    this.scenarioRunner = new ScenarioRunner();
    this.environmentManager = new SimulationEnvironmentManager();
    this.metricsCollector = new SimulationMetricsCollector();
    this.reportGenerator = new SimulationReportGenerator();
  }
  
  // 시뮬레이션 실행
  async runSimulation(
    scenario: SimulationScenario,
    options?: SimulationOptions
  ): Promise<SimulationResult> {
    const simulationId = uuidv4();
    const startTime = Date.now();
    
    try {
      // 1. 시뮬레이션 환경 준비
      const environment = await this.prepareEnvironment(
        scenario,
        options
      );
      
      // 2. 초기 상태 캡처
      const initialState = await this.captureSystemState(environment);
      
      // 3. 재해 시뮬레이션
      await this.simulateDisaster(environment, scenario);
      
      // 4. 복구 프로세스 실행
      const recoveryResult = await this.executeRecovery(
        environment,
        scenario
      );
      
      // 5. 결과 검증
      const validation = await this.validateRecovery(
        environment,
        initialState
      );
      
      // 6. 메트릭 수집
      const metrics = await this.metricsCollector.collect(
        simulationId,
        environment
      );
      
      // 7. 리포트 생성
      const report = await this.reportGenerator.generate({
        simulationId,
        scenario,
        recoveryResult,
        validation,
        metrics
      });
      
      return {
        id: simulationId,
        success: validation.success,
        duration: Date.now() - startTime,
        report,
        learnings: this.extractLearnings(recoveryResult, validation)
      };
      
    } finally {
      // 환경 정리
      await this.cleanupEnvironment(simulationId);
    }
  }
  
  // 시뮬레이션 환경 준비
  private async prepareEnvironment(
    scenario: SimulationScenario,
    options?: SimulationOptions
  ): Promise<SimulationEnvironment> {
    // 격리된 환경 생성
    const environment = await this.environmentManager.create({
      isolated: true,
      copyProductionData: options?.useProductionData || false,
      scale: options?.scale || 0.1 // 10% 규모
    });
    
    // 컴포넌트 배포
    await this.deployComponents(environment, scenario.affectedComponents);
    
    // 데이터 시딩
    await this.seedData(environment, scenario);
    
    // 모니터링 설정
    await this.setupMonitoring(environment);
    
    return environment;
  }
  
  // 재해 시뮬레이션
  private async simulateDisaster(
    environment: SimulationEnvironment,
    scenario: SimulationScenario
  ): Promise<void> {
    const disasterSimulator = this.getDisasterSimulator(
      scenario.disasterType
    );
    
    await disasterSimulator.simulate({
      environment,
      components: scenario.affectedComponents,
      severity: scenario.dataLossPercentage,
      duration: scenario.duration
    });
    
    // 재해 영향 확인
    await this.waitForDisasterImpact(environment);
  }
  
  // 복구 실행
  private async executeRecovery(
    environment: SimulationEnvironment,
    scenario: SimulationScenario
  ): Promise<RecoveryExecutionResult> {
    const recoveryPlan = await this.createRecoveryPlan(scenario);
    const executor = new SimulatedRecoveryExecutor(environment);
    
    const steps: StepResult[] = [];
    
    for (const step of recoveryPlan.steps) {
      const stepResult = await executor.executeStep(step);
      steps.push(stepResult);
      
      // 실시간 메트릭 수집
      await this.metricsCollector.recordStep(stepResult);
    }
    
    return {
      plan: recoveryPlan,
      steps,
      totalTime: steps.reduce((sum, s) => sum + s.duration, 0),
      dataRecovered: this.calculateDataRecovery(steps)
    };
  }
}

// 시나리오 실행기
export class ScenarioRunner {
  private scenarios: Map<string, SimulationScenario> = new Map();
  
  constructor() {
    this.loadBuiltInScenarios();
  }
  
  private loadBuiltInScenarios(): void {
    // 리전 장애 시나리오
    this.scenarios.set('region_failure', {
      id: 'region_failure',
      name: 'Complete Region Failure',
      disasterType: 'region_outage',
      affectedComponents: ['all'],
      dataLossPercentage: 0,
      duration: 3600000, // 1시간
      complexity: 'high'
    });
    
    // 데이터 손상 시나리오
    this.scenarios.set('data_corruption', {
      id: 'data_corruption',
      name: 'Database Corruption',
      disasterType: 'data_corruption',
      affectedComponents: ['database'],
      dataLossPercentage: 30,
      duration: 1800000, // 30분
      complexity: 'medium'
    });
    
    // 랜섬웨어 시나리오
    this.scenarios.set('ransomware', {
      id: 'ransomware',
      name: 'Ransomware Attack',
      disasterType: 'security_breach',
      affectedComponents: ['storage', 'database'],
      dataLossPercentage: 100,
      duration: 7200000, // 2시간
      complexity: 'high'
    });
  }
  
  async runScenario(
    scenarioId: string,
    customizations?: ScenarioCustomization
  ): Promise<ScenarioResult> {
    let scenario = this.scenarios.get(scenarioId);
    
    if (!scenario) {
      throw new Error(`Scenario ${scenarioId} not found`);
    }
    
    // 시나리오 커스터마이징
    if (customizations) {
      scenario = this.applyCustomizations(scenario, customizations);
    }
    
    // 시나리오별 실행 로직
    switch (scenario.disasterType) {
      case 'region_outage':
        return await this.runRegionOutageScenario(scenario);
        
      case 'data_corruption':
        return await this.runDataCorruptionScenario(scenario);
        
      case 'security_breach':
        return await this.runSecurityBreachScenario(scenario);
        
      default:
        throw new Error(`Unknown disaster type: ${scenario.disasterType}`);
    }
  }
}

// 시뮬레이션 검증기
export class SimulationValidator {
  async validateRecovery(
    environment: SimulationEnvironment,
    expectedState: SystemState
  ): Promise<ValidationResult> {
    const currentState = await this.captureSystemState(environment);
    const validators: Validator[] = [
      new DataIntegrityValidator(),
      new ServiceAvailabilityValidator(),
      new PerformanceValidator(),
      new ConsistencyValidator()
    ];
    
    const results: ValidationCheck[] = [];
    
    for (const validator of validators) {
      const result = await validator.validate(
        expectedState,
        currentState
      );
      results.push(result);
    }
    
    return {
      success: results.every(r => r.passed),
      checks: results,
      summary: this.generateValidationSummary(results),
      recommendations: this.generateRecommendations(results)
    };
  }
  
  private generateValidationSummary(
    results: ValidationCheck[]
  ): ValidationSummary {
    return {
      totalChecks: results.length,
      passed: results.filter(r => r.passed).length,
      failed: results.filter(r => !r.passed).length,
      criticalFailures: results.filter(
        r => !r.passed && r.severity === 'critical'
      ).length
    };
  }
}

// 학습 추출기
export class LearningExtractor {
  extractLearnings(
    result: RecoveryExecutionResult,
    validation: ValidationResult
  ): Learning[] {
    const learnings: Learning[] = [];
    
    // 성능 관련 학습
    if (result.totalTime > this.config.targetRTO) {
      learnings.push({
        category: 'performance',
        finding: 'RTO exceeded',
        impact: 'high',
        recommendation: this.generateRTOImprovement(result)
      });
    }
    
    // 데이터 손실 관련 학습
    if (result.dataRecovered < 100) {
      learnings.push({
        category: 'data_integrity',
        finding: `${100 - result.dataRecovered}% data loss`,
        impact: 'critical',
        recommendation: this.generateRPOImprovement(result)
      });
    }
    
    // 프로세스 개선 사항
    const processImprovements = this.analyzeProcessEfficiency(result);
    learnings.push(...processImprovements);
    
    return learnings;
  }
}
```

### SubTask 2.14.4: 비즈니스 연속성 계획
**담당자**: 비즈니스 분석가  
**예상 소요시간**: 8시간

**목표**: 비즈니스 연속성을 보장하는 자동화된 재해 복구 계획 구현

**구현 내용**:
```typescript
// backend/src/dr/bcp/business-continuity-planner.ts
export interface BusinessContinuityPlan {
  id: string;
  version: string;
  businessFunctions: BusinessFunction[];
  dependencies: DependencyMap;
  priorityMatrix: PriorityMatrix;
  communicationPlan: CommunicationPlan;
  escalationProcedures: EscalationProcedure[];
}

export class BusinessContinuityPlanner {
  private plan: BusinessContinuityPlan;
  private impactAnalyzer: BusinessImpactAnalyzer;
  private orchestrator: BCPOrchestrator;
  private notificationManager: NotificationManager;
  
  constructor(
    private config: BCPConfig
  ) {
    this.impactAnalyzer = new BusinessImpactAnalyzer();
    this.orchestrator = new BCPOrchestrator();
    this.notificationManager = new NotificationManager();
    
    this.loadBusinessContinuityPlan();
  }
  
  // BCP 활성화
  async activateBCP(
    incident: Incident
  ): Promise<BCPActivationResult> {
    const activationId = uuidv4();
    
    // 1. 영향 분석
    const impact = await this.impactAnalyzer.analyze(incident);
    
    // 2. 우선순위 결정
    const priorities = this.determinePriorities(impact);
    
    // 3. 이해관계자 알림
    await this.notifyStakeholders(incident, impact);
    
    // 4. 복구 오케스트레이션
    const recoveryPlan = this.createRecoveryPlan(priorities);
    const recoveryResult = await this.orchestrator.execute(recoveryPlan);
    
    // 5. 비즈니스 기능 복원
    const restorationResult = await this.restoreBusinessFunctions(
      priorities,
      recoveryResult
    );
    
    // 6. 상태 보고
    await this.reportStatus(activationId, restorationResult);
    
    return {
      activationId,
      impact,
      recoveryTime: restorationResult.totalTime,
      functionsRestored: restorationResult.restored,
      residualRisk: this.calculateResidualRisk(restorationResult)
    };
  }
  
  // 비즈니스 기능 우선순위 결정
  private determinePriorities(
    impact: BusinessImpact
  ): PrioritizedFunctions[] {
    const prioritized: PrioritizedFunctions[] = [];
    
    for (const func of this.plan.businessFunctions) {
      const priority = this.calculatePriority(func, impact);
      
      prioritized.push({
        function: func,
        priority,
        criticalityScore: func.criticality,
        dependencies: this.plan.dependencies[func.id],
        estimatedDowntime: impact.downtime[func.id]
      });
    }
    
    // 우선순위 정렬
    return prioritized.sort((a, b) => b.priority - a.priority);
  }
  
  // 이해관계자 알림
  private async notifyStakeholders(
    incident: Incident,
    impact: BusinessImpact
  ): Promise<void> {
    const notifications = this.plan.communicationPlan.notifications;
    
    for (const notification of notifications) {
      if (this.shouldNotify(notification, incident, impact)) {
        await this.notificationManager.send({
          recipients: notification.recipients,
          template: notification.template,
          data: {
            incident,
            impact,
            estimatedResolution: this.estimateResolution(impact)
          },
          channels: notification.channels
        });
      }
    }
  }
  
  // 비즈니스 기능 복원
  private async restoreBusinessFunctions(
    priorities: PrioritizedFunctions[],
    recoveryResult: RecoveryResult
  ): Promise<RestorationResult> {
    const results: FunctionRestoration[] = [];
    
    for (const prioritized of priorities) {
      const restoration = await this.restoreFunction(
        prioritized.function,
        recoveryResult
      );
      
      results.push(restoration);
      
      // 중간 상태 보고
      if (prioritized.priority === 'critical') {
        await this.reportFunctionRestoration(restoration);
      }
    }
    
    return {
      restored: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      totalTime: this.calculateTotalTime(results),
      results
    };
  }
}

// 비즈니스 영향 분석기
export class BusinessImpactAnalyzer {
  async analyze(incident: Incident): Promise<BusinessImpact> {
    const impact: BusinessImpact = {
      severity: this.calculateSeverity(incident),
      affectedFunctions: [],
      estimatedLoss: 0,
      downtime: {},
      customers: 0
    };
    
    // 영향받는 기능 식별
    impact.affectedFunctions = await this.identifyAffectedFunctions(
      incident
    );
    
    // 다운타임 예측
    for (const func of impact.affectedFunctions) {
      impact.downtime[func.id] = await this.estimateDowntime(
        func,
        incident
      );
    }
    
    // 재무 영향 계산
    impact.estimatedLoss = await this.calculateFinancialImpact(
      impact.affectedFunctions,
      impact.downtime
    );
    
    // 고객 영향 계산
    impact.customers = await this.estimateCustomerImpact(
      impact.affectedFunctions
    );
    
    return impact;
  }
  
  private async calculateFinancialImpact(
    functions: BusinessFunction[],
    downtime: Record<string, number>
  ): Promise<number> {
    let totalLoss = 0;
    
    for (const func of functions) {
      const hourlyLoss = func.financialImpact.hourlyLoss;
      const downtimeHours = downtime[func.id] / 60;
      
      totalLoss += hourlyLoss * downtimeHours;
      
      // 추가 비용 (복구, 보상 등)
      totalLoss += func.financialImpact.recoveryC

ost || 0;
    }
    
    return totalLoss;
  }
}

// BCP 오케스트레이터
export class BCPOrchestrator {
  async execute(
    plan: RecoveryPlan
  ): Promise<RecoveryResult> {
    const executor = new PlanExecutor(plan);
    const monitor = new ExecutionMonitor();
    
    // 병렬 실행 가능한 작업 식별
    const parallelTasks = this.identifyParallelTasks(plan.tasks);
    
    // 실행 및 모니터링
    const results = await this.executeWithMonitoring(
      parallelTasks,
      executor,
      monitor
    );
    
    return {
      success: results.every(r => r.success),
      tasks: results,
      duration: monitor.getTotalDuration(),
      metrics: monitor.getMetrics()
    };
  }
  
  private async executeWithMonitoring(
    tasks: Task[][],
    executor: PlanExecutor,
    monitor: ExecutionMonitor
  ): Promise<TaskResult[]> {
    const allResults: TaskResult[] = [];
    
    for (const batch of tasks) {
      const batchResults = await Promise.all(
        batch.map(task => 
          executor.executeTask(task)
            .then(result => {
              monitor.recordSuccess(task, result);
              return result;
            })
            .catch(error => {
              monitor.recordFailure(task, error);
              return this.handleTaskFailure(task, error);
            })
        )
      );
      
      allResults.push(...batchResults);
    }
    
    return allResults;
  }
}

// 커뮤니케이션 관리자
export class CommunicationManager {
  private channels: Map<string, CommunicationChannel> = new Map();
  
  constructor() {
    this.initializeChannels();
  }
  
  private initializeChannels(): void {
    this.channels.set('email', new EmailChannel());
    this.channels.set('sms', new SMSChannel());
    this.channels.set('slack', new SlackChannel());
    this.channels.set('teams', new TeamsChannel());
    this.channels.set('voice', new VoiceCallChannel());
  }
  
  async sendEmergencyNotification(
    notification: EmergencyNotification
  ): Promise<void> {
    // 우선순위별 채널 선택
    const channels = this.selectChannelsByPriority(
      notification.priority
    );
    
    // 병렬 전송
    await Promise.all(
      channels.map(channel => 
        this.sendViaChannel(channel, notification)
      )
    );
    
    // 전송 확인
    await this.verifyDelivery(notification);
  }
  
  private selectChannelsByPriority(
    priority: Priority
  ): CommunicationChannel[] {
    switch (priority) {
      case 'critical':
        return [
          this.channels.get('voice')!,
          this.channels.get('sms')!,
          this.channels.get('email')!
        ];
      case 'high':
        return [
          this.channels.get('sms')!,
          this.channels.get('email')!,
          this.channels.get('slack')!
        ];
      default:
        return [
          this.channels.get('email')!,
          this.channels.get('slack')!
        ];
    }
  }
}
```

## Task 2.15: 데이터 보안 및 암호화

### SubTask 2.15.1: 저장 데이터 암호화
**담당자**: 보안 엔지니어  
**예상 소요시간**: 10시간

**목표**: DynamoDB와 S3의 모든 저장 데이터에 대한 암호화 구현

**구현 내용**:
```typescript
// backend/src/security/encryption/data-encryption.ts
import { KMSClient, EncryptCommand, DecryptCommand } from '@aws-sdk/client-kms';
import crypto from 'crypto';

export interface EncryptionConfig {
  kmsKeyId: string;
  algorithm: 'AES-256-GCM' | 'AES-256-CBC';
  rotationPolicy: KeyRotationPolicy;
  fieldLevelEncryption: FieldEncryptionConfig[];
}

export class DataEncryptionManager {
  private kmsClient: KMSClient;
  private keyCache: KeyCache;
  private encryptionService: EncryptionService;
  
  constructor(
    private config: EncryptionConfig
  ) {
    this.kmsClient = new KMSClient({ region: config.region });
    this.keyCache = new KeyCache();
    this.encryptionService = new EncryptionService(config.algorithm);
    
    this.initializeEncryption();
  }
  
  // 필드 레벨 암호화
  async encryptSensitiveFields(
    data: any,
    entityType: string
  ): Promise<any> {
    const encryptionConfig = this.getFieldConfig(entityType);
    if (!encryptionConfig) return data;
    
    const encrypted = { ...data };
    
    for (const field of encryptionConfig.fields) {
      if (data[field.name] !== undefined) {
        encrypted[field.name] = await this.encryptField(
          data[field.name],
          field
        );
      }
    }
    
    // 암호화 메타데이터 추가
    encrypted._encryption = {
      version: this.config.version,
      timestamp: new Date(),
      fields: encryptionConfig.fields.map(f => f.name)
    };
    
    return encrypted;
  }
  
  // 개별 필드 암호화
  private async encryptField(
    value: any,
    fieldConfig: FieldConfig
  ): Promise<EncryptedField> {
    // 데이터 키 생성/캐싱
    const dataKey = await this.getOrGenerateDataKey(fieldConfig.keyId);
    
    // 값 직렬화
    const serialized = this.serialize(value, fieldConfig.type);
    
    // 암호화
    const encrypted = await this.encryptionService.encrypt(
      serialized,
      dataKey.plaintext
    );
    
    return {
      ciphertext: encrypted.ciphertext,
      iv: encrypted.iv,
      authTag: encrypted.authTag,
      keyId: fieldConfig.keyId,
      algorithm: this.config.algorithm
    };
  }
  
  // 데이터 키 관리
  private async getOrGenerateDataKey(
    keyId: string
  ): Promise<DataKey> {
    // 캐시 확인
    let dataKey = await this.keyCache.get(keyId);
    
    if (!dataKey) {
      // KMS에서 새 데이터 키 생성
      const response = await this.kmsClient.send(
        new GenerateDataKeyCommand({
          KeyId: this.config.kmsKeyId,
          KeySpec: 'AES_256'
        })
      );
      
      dataKey = {
        keyId,
        plaintext: response.Plaintext!,
        ciphertext: response.CiphertextBlob!,
        createdAt: new Date()
      };
      
      // 캐시에 저장
      await this.keyCache.set(keyId, dataKey, {
        ttl: 3600 // 1시간
      });
    }
    
    return dataKey;
  }
  
  // 복호화
  async decryptSensitiveFields(
    data: any,
    entityType: string
  ): Promise<any> {
    if (!data._encryption) return data;
    
    const decrypted = { ...data };
    delete decrypted._encryption;
    
    for (const fieldName of data._encryption.fields) {
      if (data[fieldName]) {
        decrypted[fieldName] = await this.decryptField(
          data[fieldName]
        );
      }
    }
    
    return decrypted;
  }
  
  // 키 로테이션
  async rotateKeys(): Promise<KeyRotationResult> {
    const rotationPlan = await this.createRotationPlan();
    const results: RotationResult[] = [];
    
    for (const task of rotationPlan.tasks) {
      try {
        const result = await this.rotateKey(task);
        results.push(result);
      } catch (error) {
        results.push({
          keyId: task.keyId,
          success: false,
          error: error.message
        });
      }
    }
    
    return {
      totalKeys: rotationPlan.tasks.length,
      rotated: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      results
    };
  }
}

// 투명한 암호화 프록시
export class TransparentEncryptionProxy {
  constructor(
    private encryptionManager: DataEncryptionManager,
    private dynamoClient: DynamoDBDocumentClient
  ) {}
  
  async putItem(params: PutItemInput): Promise<PutItemOutput> {
    // 자동 암호화
    const encryptedItem = await this.encryptionManager.encryptSensitiveFields(
      params.Item,
      params.TableName
    );
    
    return this.dynamoClient.put({
      ...params,
      Item: encryptedItem
    });
  }
  
  async getItem(params: GetItemInput): Promise<GetItemOutput> {
    const response = await this.dynamoClient.get(params);
    
    if (response.Item) {
      // 자동 복호화
      response.Item = await this.encryptionManager.decryptSensitiveFields(
        response.Item,
        params.TableName
      );
    }
    
    return response;
  }
  
  async query(params: QueryInput): Promise<QueryOutput> {
    const response = await this.dynamoClient.query(params);
    
    if (response.Items) {
      // 모든 항목 복호화
      response.Items = await Promise.all(
        response.Items.map(item => 
          this.encryptionManager.decryptSensitiveFields(
            item,
            params.TableName
          )
        )
      );
    }
    
    return response;
  }
}

// 암호화 서비스
export class EncryptionService {
  constructor(
    private algorithm: string
  ) {}
  
  async encrypt(
    plaintext: Buffer,
    key: Buffer
  ): Promise<EncryptedData> {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, key, iv);
    
    const encrypted = Buffer.concat([
      cipher.update(plaintext),
      cipher.final()
    ]);
    
    return {
      ciphertext: encrypted,
      iv,
      authTag: (cipher as any).getAuthTag()
    };
  }
  
  async decrypt(
    encryptedData: EncryptedData,
    key: Buffer
  ): Promise<Buffer> {
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      key,
      encryptedData.iv
    );
    
    (decipher as any).setAuthTag(encryptedData.authTag);
    
    return Buffer.concat([
      decipher.update(encryptedData.ciphertext),
      decipher.final()
    ]);
  }
}
```

### SubTask 2.15.2: 전송 중 데이터 암호화
**담당자**: 네트워크 보안 엔지니어  
**예상 소요시간**: 10시간

**목표**: 모든 네트워크 통신에서 데이터 암호화 구현

**구현 내용**:
```typescript
// backend/src/security/encryption/transport-encryption.ts
import tls from 'tls';
import { Agent } from 'https';

export class TransportEncryptionManager {
  private tlsConfig: TLSConfig;
  private certificateManager: CertificateManager;
  private securityHeaders: SecurityHeadersManager;
  
  constructor(
    private config: TransportSecurityConfig
  ) {
    this.tlsConfig = new TLSConfig(config.tls);
    this.certificateManager = new CertificateManager();
    this.securityHeaders = new SecurityHeadersManager();
    
    this.initializeTransportSecurity();
  }
  
  // HTTPS 에이전트 생성
  createSecureAgent(): Agent {
    return new Agent({
      minVersion: 'TLSv1.2',
      ciphers: this.tlsConfig.getSecureCiphers(),
      rejectUnauthorized: true,
      cert: this.certificateManager.getClientCert(),
      key: this.certificateManager.getClientKey(),
      ca: this.certificateManager.getCACerts()
    });
  }
  
  // 상호 TLS 설정
  setupMutualTLS(options: MutualTLSOptions): tls.Server {
    return tls.createServer({
      cert: this.certificateManager.getServerCert(),
      key: this.certificateManager.getServerKey(),
      ca: this.certificateManager.getClientCACerts(),
      requestCert: true,
      rejectUnauthorized: true,
      ciphers: this.tlsConfig.getSecureCiphers(),
      minVersion: 'TLSv1.2'
    }, (socket) => {
      // 클라이언트 인증서 검증
      const cert = socket.getPeerCertificate();
      if (this.validateClientCertificate(cert)) {
        this.handleSecureConnection(socket);
      } else {
        socket.destroy();
      }
    });
  }
  
  // 보안 헤더 미들웨어
  securityHeadersMiddleware() {
    return (req: any, res: any, next: any) => {
      // HSTS
      res.setHeader(
        'Strict-Transport-Security',
        'max-age=31536000; includeSubDomains; preload'
      );
      
      // Certificate Pinning
      res.setHeader(
        'Public-Key-Pins',
        this.generatePinningHeader()
      );
      
      // Content Security Policy
      res.setHeader(
        'Content-Security-Policy',
        this.generateCSPHeader()
      );
      
      // 기타 보안 헤더
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.setHeader('X-Frame-Options', 'DENY');
      res.setHeader('X-XSS-Protection', '1; mode=block');
      
      next();
    };
  }
  
  // API 게이트웨이 보안
  async secureAPIGateway(
    request: APIRequest
  ): Promise<SecuredAPIRequest> {
    // 요청 암호화
    const encryptedPayload = await this.encryptPayload(
      request.body,
      request.headers['x-api-key']
    );
    
    // HMAC 서명 추가
    const signature = this.generateHMAC(
      encryptedPayload,
      request.headers['x-api-key']
    );
    
    return {
      ...request,
      body: encryptedPayload,
      headers: {
        ...request.headers,
        'X-Signature': signature,
        'X-Timestamp': Date.now().toString(),
        'X-Nonce': this.generateNonce()
      }
    };
  }
  
  // WebSocket 보안
  setupSecureWebSocket(ws: WebSocket): SecureWebSocket {
    // 암호화 레이어 추가
    const secureWS = new SecureWebSocket(ws);
    
    // 메시지 암호화/복호화
    secureWS.on('message', async (encryptedMessage) => {
      const decrypted = await this.decryptWSMessage(encryptedMessage);
      secureWS.emit('decrypted-message', decrypted);
    });
    
    secureWS.send = async (data: any) => {
      const encrypted = await this.encryptWSMessage(data);
      ws.send(encrypted);
    };
    
    return secureWS;
  }
  
  // 인증서 검증
  private validateClientCertificate(
    cert: tls.PeerCertificate
  ): boolean {
    // CN 검증
    if (!this.isValidCN(cert.subject.CN)) {
      return false;
    }
    
    // 인증서 체인 검증
    if (!this.validateCertificateChain(cert)) {
      return false;
    }
    
    // 인증서 해지 목록 확인
    if (this.isRevoked(cert)) {
      return false;
    }
    
    // 인증서 유효기간 확인
    if (!this.isValidPeriod(cert)) {
      return false;
    }
    
    return true;
  }
}

// TLS 설정 관리
export class TLSConfig {
  private secureCiphers = [
    'ECDHE-RSA-AES256-GCM-SHA384',
    'ECDHE-RSA-AES128-GCM-SHA256',
    'ECDHE-RSA-AES256-SHA384',
    'ECDHE-RSA-AES128-SHA256'
  ];
  
  getSecureCiphers(): string {
    return this.secureCiphers.join(':');
  }
  
  generateDHParams(): Buffer {
    // 2048비트 DH 파라미터 생성
    return crypto.generateKeyPairSync('dh', {
      primeLength: 2048
    }).publicKey.export({ type: 'spki', format: 'der' });
  }
}

// 엔드투엔드 암호화
export class EndToEndEncryption {
  async establishSecureChannel(
    clientPublicKey: string
  ): Promise<SecureChannel> {
    // ECDH 키 교환
    const serverKeyPair = crypto.generateKeyPairSync('ec', {
      namedCurve: 'P-256'
    });
    
    // 공유 비밀 생성
    const sharedSecret = crypto.diffieHellman({
      privateKey: serverKeyPair.privateKey,
      publicKey: crypto.createPublicKey(clientPublicKey)
    });
    
    // 세션 키 도출
    const sessionKey = crypto.hkdfSync(
      'sha256',
      sharedSecret,
      'salt',
      'info',
      32
    );
    
    return {
      sessionId: uuidv4(),
      sessionKey,
      serverPublicKey: serverKeyPair.publicKey.export({
        type: 'spki',
        format: 'pem'
      }),
      algorithm: 'aes-256-gcm',
      established: new Date()
    };
  }
}
```

### SubTask 2.15.3: 접근 제어 및 감사
**담당자**: 보안 아키텍트  
**예상 소요시간**: 10시간

**목표**: 세분화된 접근 제어와 포괄적인 감사 로깅 시스템 구현

**구현 내용**:
```typescript
// backend/src/security/access-control/access-controller.ts
export interface AccessControlPolicy {
  id: string;
  name: string;
  effect: 'allow' | 'deny';
  principals: Principal[];
  actions: string[];
  resources: string[];
  conditions?: Condition[];
}

export class AccessController {
  private policyEngine: PolicyEngine;
  private attributeResolver: AttributeResolver;
  private auditLogger: AuditLogger;
  
  constructor(
    private config: AccessControlConfig
  ) {
    this.policyEngine = new PolicyEngine();
    this.attributeResolver = new AttributeResolver();
    this.auditLogger = new AuditLogger();
    
    this.loadPolicies();
  }
  
  // 접근 권한 확인
  async authorize(
    request: AccessRequest
  ): Promise<AccessDecision> {
    const startTime = Date.now();
    
    try {
      // 1. 컨텍스트 수집
      const context = await this.buildContext(request);
      
      // 2. 적용 가능한 정책 찾기
      const applicablePolicies = await this.findApplicablePolicies(
        context
      );
      
      // 3. 정책 평가
      const decision = await this.evaluatePolicies(
        applicablePolicies,
        context
      );
      
      // 4. 감사 로깅
      await this.auditLogger.logAccessDecision({
        request,
        context,
        decision,
        duration: Date.now() - startTime
      });
      
      return decision;
      
    } catch (error) {
      // 에러 시 기본 거부
      await this.auditLogger.logAccessError({
        request,
        error: error.message
      });
      
      return {
        allowed: false,
        reason: 'Authorization error',
        error: error.message
      };
    }
  }
  
  // 컨텍스트 구축
  private async buildContext(
    request: AccessRequest
  ): Promise<AccessContext> {
    // 사용자 속성
    const userAttributes = await this.attributeResolver.getUserAttributes(
      request.principalId
    );
    
    // 리소스 속성
    const resourceAttributes = await this.attributeResolver.getResourceAttributes(
      request.resource
    );
    
    // 환경 속성
    const environmentAttributes = {
      sourceIp: request.sourceIp,
      timestamp: new Date(),
      mfaAuthenticated: request.mfaAuthenticated,
      sessionAge: request.sessionAge
    };
    
    return {
      principal: {
        id: request.principalId,
        type: request.principalType,
        attributes: userAttributes
      },
      action: request.action,
      resource: {
        id: request.resource,
        type: request.resourceType,
        attributes: resourceAttributes
      },
      environment: environmentAttributes
    };
  }
  
  // 정책 평가
  private async evaluatePolicies(
    policies: AccessControlPolicy[],
    context: AccessContext
  ): Promise<AccessDecision> {
    let explicitDeny = false;
    let explicitAllow = false;
    const matchedPolicies: string[] = [];
    
    for (const policy of policies) {
      // 조건 평가
      if (policy.conditions) {
        const conditionsMet = await this.evaluateConditions(
          policy.conditions,
          context
        );
        
        if (!conditionsMet) continue;
      }
      
      matchedPolicies.push(policy.id);
      
      if (policy.effect === 'deny') {
        explicitDeny = true;
        break; // Explicit deny는 즉시 중단
      } else if (policy.effect === 'allow') {
        explicitAllow = true;
      }
    }
    
    // 최종 결정
    const allowed = explicitAllow && !explicitDeny;
    
    return {
      allowed,
      matchedPolicies,
      reason: this.generateDecisionReason(
        explicitAllow,
        explicitDeny,
        matchedPolicies
      )
    };
  }
  
  // 조건 평가
  private async evaluateConditions(
    conditions: Condition[],
    context: AccessContext
  ): Promise<boolean> {
    for (const condition of conditions) {
      const met = await this.evaluateCondition(condition, context);
      if (!met) return false;
    }
    
    return true;
  }
  
  // 개별 조건 평가
  private async evaluateCondition(
    condition: Condition,
    context: AccessContext
  ): Promise<boolean> {
    const value = this.resolveValue(condition.key, context);
    
    switch (condition.operator) {
      case 'equals':
        return value === condition.value;
        
      case 'notEquals':
        return value !== condition.value;
        
      case 'contains':
        return Array.isArray(value) && 
               value.includes(condition.value);
        
      case 'ipMatch':
        return this.matchIPAddress(value, condition.value);
        
      case 'dateGreaterThan':
        return new Date(value) > new Date(condition.value);
        
      case 'dateLessThan':
        return new Date(value) < new Date(condition.value);
        
      default:
        throw new Error(`Unknown operator: ${condition.operator}`);
    }
  }
}

// 감사 로거
export class AuditLogger {
  private logStore: AuditLogStore;
  private encryptor: LogEncryptor;
  private alertManager: SecurityAlertManager;
  
  constructor() {
    this.logStore = new AuditLogStore();
    this.encryptor = new LogEncryptor();
    this.alertManager = new SecurityAlertManager();
  }
  
  async logAccessDecision(
    event: AccessDecisionEvent
  ): Promise<void> {
    const auditLog: AuditLog = {
      id: uuidv4(),
      timestamp: new Date(),
      eventType: 'ACCESS_DECISION',
      principalId: event.request.principalId,
      action: event.request.action,
      resource: event.request.resource,
      decision: event.decision.allowed ? 'ALLOW' : 'DENY',
      sourceIp: event.request.sourceIp,
      userAgent: event.request.userAgent,
      duration: event.duration,
      metadata: {
        matchedPolicies: event.decision.matchedPolicies,
        reason: event.decision.reason,
        context: event.context
      }
    };
    
    // 로그 암호화
    const encryptedLog = await this.encryptor.encrypt(auditLog);
    
    // 저장
    await this.logStore.store(encryptedLog);
    
    // 이상 패턴 감지
    await this.detectAnomalies(auditLog);
  }
  
  // 이상 패턴 감지
  private async detectAnomalies(
    log: AuditLog
  ): Promise<void> {
    // 연속 거부
    const recentDenials = await this.getRecentDenials(
      log.principalId,
      5 // 최근 5분
    );
    
    if (recentDenials.length > 10) {
      await this.alertManager.raise({
        type: 'EXCESSIVE_DENIALS',
        severity: 'medium',
        principal: log.principalId,
        count: recentDenials.length
      });
    }
    
    // 비정상 접근 패턴
    if (await this.isUnusualAccess(log)) {
      await this.alertManager.raise({
        type: 'UNUSUAL_ACCESS_PATTERN',
        severity: 'high',
        details: log
      });
    }
    
    // 권한 상승 시도
    if (this.isPrivilegeEscalation(log)) {
      await this.alertManager.raise({
        type: 'PRIVILEGE_ESCALATION_ATTEMPT',
        severity: 'critical',
        details: log
      });
    }
  }
}

// 역할 기반 접근 제어 (RBAC)
export class RBACManager {
  private roleHierarchy: RoleHierarchy;
  private permissionRegistry: PermissionRegistry;
  
  async assignRole(
    principalId: string,
    roleId: string
  ): Promise<void> {
    // 역할 검증
    const role = await this.getRole(roleId);
    if (!role) {
      throw new Error(`Role ${roleId} not found`);
    }
    
    // 순환 참조 확인
    if (await this.wouldCreateCycle(principalId, roleId)) {
      throw new Error('Role assignment would create circular dependency');
    }
    
    // 역할 할당
    await this.roleStore.assignRole(principalId, roleId);
    
    // 감사 로그
    await this.auditLogger.log({
      event: 'ROLE_ASSIGNED',
      principal: principalId,
      role: roleId,
      assignedBy: this.getCurrentUser()
    });
  }
  
  // 유효 권한 계산
  async getEffectivePermissions(
    principalId: string
  ): Promise<Permission[]> {
    const roles = await this.getRoles(principalId);
    const permissions: Set<string> = new Set();
    
    // 역할 계층 구조 탐색
    for (const role of roles) {
      const rolePermissions = await this.getRolePermissions(
        role,
        true // 상속된 권한 포함
      );
      
      rolePermissions.forEach(p => permissions.add(p));
    }
    
    return Array.from(permissions).map(p => 
      this.permissionRegistry.get(p)
    );
  }
}
```

### SubTask 2.15.4: 규정 준수 자동화
**담당자**: 컴플라이언스 전문가  
**예상 소요시간**: 8시간

**목표**: GDPR, HIPAA, SOC2 등 규정 준수를 위한 자동화 시스템 구현

**구현 내용**:
```typescript
// backend/src/security/compliance/compliance-automation.ts
export interface ComplianceFramework {
  name: 'GDPR' | 'HIPAA' | 'SOC2' | 'PCI-DSS' | 'ISO27001';
  requirements: ComplianceRequirement[];
  controls: ComplianceControl[];
  auditSchedule: AuditSchedule;
}

export class ComplianceAutomationManager {
  private frameworks: Map<string, ComplianceFramework> = new Map();
  private controlExecutor: ControlExecutor;
  private evidenceCollector: EvidenceCollector;
  private reportGenerator: ComplianceReportGenerator;
  
  constructor(
    private config: ComplianceConfig
  ) {
    this.controlExecutor = new ControlExecutor();
    this.evidenceCollector = new EvidenceCollector();
    this.reportGenerator = new ComplianceReportGenerator();
    
    this.loadComplianceFrameworks();
    this.scheduleAutomatedAudits();
  }
  
  // GDPR 준수 자동화
  async ensureGDPRCompliance(): Promise<ComplianceResult> {
    const gdprControls = this.frameworks.get('GDPR')!.controls;
    const results: ControlResult[] = [];
    
    // 개인정보 처리 동의
    results.push(
      await this.controlExecutor.execute(
        new ConsentManagementControl()
      )
    );
    
    // 데이터 접근 권한
    results.push(
      await this.controlExecutor.execute(
        new DataAccessRightsControl()
      )
    );
    
    // 삭제 권한 (잊힐 권리)
    results.push(
      await this.controlExecutor.execute(
        new RightToErasureControl()
      )
    );
    
    // 데이터 이동성
    results.push(
      await this.controlExecutor.execute(
        new DataPortabilityControl()
      )
    );
    
    // 침해 통지
    results.push(
      await this.controlExecutor.execute(
        new BreachNotificationControl()
      )
    );
    
    return {
      framework: 'GDPR',
      compliant: results.every(r => r.passed),
      results,
      evidence: await this.collectGDPREvidence()
    };
  }
  
  // 데이터 삭제 자동화 (GDPR)
  async handleDataErasureRequest(
    request: ErasureRequest
  ): Promise<ErasureResult> {
    // 1. 요청 검증
    await this.validateErasureRequest(request);
    
    // 2. 데이터 식별
    const dataMap = await this.identifyPersonalData(request.subjectId);
    
    // 3. 법적 보존 요구사항 확인
    const retentionExceptions = await this.checkLegalRetention(
      dataMap
    );
    
    // 4. 삭제 실행
    const erasureResults = await this.executeErasure(
      dataMap,
      retentionExceptions
    );
    
    // 5. 삭제 증명 생성
    const certificate = await this.generateErasureCertificate(
      request,
      erasureResults
    );
    
    // 6. 감사 로그
    await this.logErasureActivity(request, erasureResults);
    
    return {
      requestId: request.id,
      erasedData: erasureResults.erased,
      retainedData: erasureResults.retained,
      certificate,
      completedAt: new Date()
    };
  }
  
  // HIPAA 준수 자동화
  async ensureHIPAACompliance(): Promise<ComplianceResult> {
    const controls: ControlResult[] = [];
    
    // PHI 암호화
    controls.push(
      await this.verifyPHIEncryption()
    );
    
    // 접근 제어
    controls.push(
      await this.verifyAccessControls()
    );
    
    // 감사 로그
    controls.push(
      await this.verifyAuditLogging()
    );
    
    // 무결성 제어
    controls.push(
      await this.verifyIntegrityControls()
    );
    
    // 전송 보안
    controls.push(
      await this.verifyTransmissionSecurity()
    );
    
    return {
      framework: 'HIPAA',
      compliant: controls.every(c => c.passed),
      results: controls
    };
  }
  
  // 자동 컴플라이언스 스캔
  async runComplianceScan(
    frameworks: string[]
  ): Promise<ComplianceScanResult> {
    const scanId = uuidv4();
    const results: FrameworkResult[] = [];
    
    for (const framework of frameworks) {
      const result = await this.scanFramework(framework);
      results.push(result);
      
      // 실시간 진행 상황 업데이트
      await this.updateScanProgress(scanId, framework, result);
    }
    
    // 종합 보고서 생성
    const report = await this.reportGenerator.generateReport({
      scanId,
      frameworks: results,
      timestamp: new Date(),
      recommendations: this.generateRecommendations(results)
    });
    
    return {
      scanId,
      results,
      report,
      nextSteps: this.identifyRemediationSteps(results)
    };
  }
}

// 증거 수집기
export class EvidenceCollector {
  async collectGDPREvidence(): Promise<Evidence[]> {
    const evidence: Evidence[] = [];
    
    // 동의 기록
    evidence.push(
      await this.collectConsentRecords()
    );
    
    // 데이터 처리 활동 기록
    evidence.push(
      await this.collectProcessingRecords()
    );
    
    // 데이터 보호 영향 평가
    evidence.push(
      await this.collectDPIA()
    );
    
    // 제3자 계약
    evidence.push(
      await this.collectThirdPartyAgreements()
    );
    
    return evidence;
  }
  
  private async collectConsentRecords(): Promise<Evidence> {
    const records = await this.queryConsentDatabase();
    
    return {
      type: 'consent_records',
      description: 'User consent records for data processing',
      artifacts: records.map(r => ({
        id: r.id,
        timestamp: r.timestamp,
        hash: this.hashRecord(r)
      })),
      collectedAt: new Date()
    };
  }
}

// 컴플라이언스 보고서 생성기
export class ComplianceReportGenerator {
  async generateReport(
    data: ReportData
  ): Promise<ComplianceReport> {
    const report: ComplianceReport = {
      id: uuidv4(),
      generatedAt: new Date(),
      executive_summary: this.generateExecutiveSummary(data),
      detailed_findings: this.generateDetailedFindings(data),
      risk_assessment: this.assessRisks(data),
      remediation_plan: this.createRemediationPlan(data),
      evidence_links: this.compileEvidenceLinks(data)
    };
    
    // 보고서 서명
    report.signature = await this.signReport(report);
    
    // 보고서 저장
    await this.storeReport(report);
    
    return report;
  }
  
  private generateExecutiveSummary(
    data: ReportData
  ): ExecutiveSummary {
    const overallCompliance = this.calculateOverallCompliance(data);
    const criticalIssues = this.identifyCriticalIssues(data);
    
    return {
      overallScore: overallCompliance,
      status: overallCompliance > 90 ? 'Compliant' : 'Non-Compliant',
      criticalIssues: criticalIssues.length,
      keyFindings: this.summarizeKeyFindings(data),
      recommendations: this.topRecommendations(data, 3)
    };
  }
}

// 지속적 컴플라이언스 모니터
export class ContinuousComplianceMonitor {
  private monitors: Map<string, ComplianceMonitor> = new Map();
  
  constructor() {
    this.initializeMonitors();
  }
  
  private initializeMonitors(): void {
    // GDPR 모니터
    this.monitors.set('gdpr', new GDPRMonitor());
    
    // HIPAA 모니터
    this.monitors.set('hipaa', new HIPAAMonitor());
    
    // SOC2 모니터
    this.monitors.set('soc2', new SOC2Monitor());
  }
  
  async startMonitoring(): Promise<void> {
    for (const [framework, monitor] of this.monitors) {
      monitor.on('violation', async (violation) => {
        await this.handleViolation(framework, violation);
      });
      
      await monitor.start();
    }
  }
  
  private async handleViolation(
    framework: string,
    violation: ComplianceViolation
  ): Promise<void> {
    // 즉시 알림
    await this.notifyCompliance 팀(violation);
    
    // 자동 수정 시도
    if (violation.autoRemediable) {
      await this.attemptAutoRemediation(violation);
    }
    
    // 인시던트 생성
    await this.createComplianceIncident(framework, violation);
  }
}
```

이렇게 Phase 2 데이터 레이어 구현의 모든 15개 Tasks (각 4개 SubTasks)가 완성되었습니다!

전체 구현 내용:
- **Task 2.1-2.3**: 데이터 모델링 (DynamoDB 설계, 엔티티 모델, 인덱스 전략)
- **Task 2.4-2.6**: 데이터 접근 계층 (Repository 패턴, 쿼리 빌더, 트랜잭션)
- **Task 2.7-2.9**: 캐싱 및 최적화 (Redis 캐싱, 무효화 전략, 일괄 처리)
- **Task 2.10-2.12**: 데이터 동기화 (CDC, 이벤트 소싱, 멀티리전 복제)
- **Task 2.13-2.15**: 백업 및 보안 (자동 백업, 재해 복구, 암호화/컴플라이언스)

각 Task는 실무에서 바로 적용 가능한 상세 코드와 함께 작성되었으며, AWS 서비스 통합, 성능 최적화, 보안, 규정 준수 등 모든 측면을 다루고 있습니다.