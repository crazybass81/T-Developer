프로젝트 지식을 확인하여 Phase 4의 task4.19.1부터 작업지시서를 작성하겠습니다. 먼저 관련 파일들을 검색해보겠습니다.프로젝트 지식을 확인한 결과, Phase 4의 구조를 파악했습니다. task4.18.4까지 작성하셨고, 이제 task4.19.1부터 작성하겠습니다.

# Phase 4: 9개 핵심 에이전트 구현 - Part 2 (UI Selection Agent 계속)

## Task 4.19: UI Selection Agent 배포 준비

### SubTask 4.19.1: UI Agent 컨테이너화

**담당자**: DevOps 엔지니어  
**예상 소요시간**: 8시간

**작업 내용**:

```dockerfile
# backend/src/agents/implementations/ui_selection/Dockerfile
FROM python:3.11-slim AS builder

# 빌드 의존성 설치
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 작업 디렉토리 설정
WORKDIR /app

# 의존성 파일 복사 및 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Agno 프레임워크 설치
RUN pip install agno

# 소스 코드 복사
COPY . .

# 런타임 이미지
FROM python:3.11-slim

# 런타임 의존성 설치
RUN apt-get update && apt-get install -y \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

# 비권한 사용자 생성
RUN useradd -m -u 1000 agent && \
    mkdir -p /app/data /app/logs && \
    chown -R agent:agent /app

WORKDIR /app

# 빌더에서 설치된 패키지 복사
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# 애플리케이션 복사
COPY --chown=agent:agent . .

# 사용자 전환
USER agent

# 헬스체크
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8080/health')"

# 환경 변수
ENV PYTHONUNBUFFERED=1 \
    AGNO_MONITORING_ENABLED=true \
    AGENT_TYPE=ui_selection \
    LOG_LEVEL=INFO

# 포트 노출
EXPOSE 8080

# 엔트리포인트
ENTRYPOINT ["python", "-m", "ui_selection_agent"]
```

**Kubernetes 배포 매니페스트**:

```yaml
# k8s/ui-selection-agent/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ui-selection-agent
  namespace: t-developer
  labels:
    app: ui-selection-agent
    component: agent
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ui-selection-agent
  template:
    metadata:
      labels:
        app: ui-selection-agent
      annotations:
        prometheus.io/scrape: 'true'
        prometheus.io/port: '8080'
        prometheus.io/path: '/metrics'
    spec:
      serviceAccountName: ui-selection-agent
      containers:
        - name: agent
          image: t-developer/ui-selection-agent:latest
          imagePullPolicy: Always
          ports:
            - containerPort: 8080
              name: http
              protocol: TCP
          env:
            - name: AWS_REGION
              value: 'us-east-1'
            - name: BEDROCK_ENDPOINT
              valueFrom:
                configMapKeyRef:
                  name: agent-config
                  key: bedrock.endpoint
            - name: REDIS_URL
              valueFrom:
                secretKeyRef:
                  name: agent-secrets
                  key: redis.url
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          resources:
            requests:
              memory: '512Mi'
              cpu: '500m'
            limits:
              memory: '2Gi'
              cpu: '2000m'
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
          volumeMounts:
            - name: framework-cache
              mountPath: /app/cache
            - name: agent-config
              mountPath: /app/config
      volumes:
        - name: framework-cache
          emptyDir:
            sizeLimit: 1Gi
        - name: agent-config
          configMap:
            name: ui-selection-config
```

**검증 기준**:

- [ ] Docker 이미지 빌드 성공
- [ ] 컨테이너 헬스체크 통과
- [ ] Kubernetes 배포 성공
- [ ] 자동 스케일링 테스트

### SubTask 4.19.2: UI Agent 성능 최적화

**담당자**: 성능 엔지니어  
**예상 소요시간**: 12시간

**작업 내용**:

```python
# backend/src/agents/implementations/ui_selection/performance_optimizer.py
from typing import Dict, List, Optional, Any
import asyncio
from dataclasses import dataclass
import numpy as np
from cachetools import TTLCache
import aioredis

@dataclass
class PerformanceMetrics:
    latency_p50: float
    latency_p95: float
    latency_p99: float
    throughput: float
    error_rate: float
    cache_hit_rate: float
    memory_usage_mb: float
    cpu_usage_percent: float

class UIAgentPerformanceOptimizer:
    """UI Selection Agent 성능 최적화 모듈"""

    def __init__(self):
        # 예측 결과 캐싱 (TTL: 1시간)
        self.prediction_cache = TTLCache(maxsize=10000, ttl=3600)

        # 프레임워크 메타데이터 캐싱
        self.framework_cache = TTLCache(maxsize=100, ttl=86400)

        # 배치 처리 큐
        self.batch_queue = asyncio.Queue(maxsize=100)
        self.batch_processor_task = None

        # Redis 연결 (분산 캐싱)
        self.redis = None

        # 성능 모니터링
        self.metrics_collector = MetricsCollector()

    async def initialize(self):
        """성능 최적화 모듈 초기화"""
        # Redis 연결
        self.redis = await aioredis.create_redis_pool(
            'redis://localhost',
            minsize=5,
            maxsize=20
        )

        # 배치 프로세서 시작
        self.batch_processor_task = asyncio.create_task(
            self._batch_processor()
        )

        # 캐시 예열
        await self._warmup_cache()

    async def optimize_selection(
        self,
        requirements: Dict[str, Any],
        use_cache: bool = True
    ) -> UIFrameworkSelection:
        """최적화된 UI 프레임워크 선택"""

        # 1. 캐시 확인
        if use_cache:
            cache_key = self._generate_cache_key(requirements)
            cached_result = await self._get_from_cache(cache_key)
            if cached_result:
                self.metrics_collector.record_cache_hit()
                return cached_result

        # 2. 배치 처리 가능 여부 확인
        if self._is_batchable(requirements):
            return await self._process_in_batch(requirements)

        # 3. 병렬 처리 최적화
        result = await self._parallel_evaluation(requirements)

        # 4. 결과 캐싱
        if use_cache:
            await self._cache_result(cache_key, result)

        return result

    async def _parallel_evaluation(
        self,
        requirements: Dict[str, Any]
    ) -> UIFrameworkSelection:
        """병렬 프레임워크 평가"""

        # 평가할 프레임워크 목록
        frameworks = await self._get_relevant_frameworks(requirements)

        # 병렬 평가 태스크 생성
        evaluation_tasks = []
        for framework in frameworks:
            task = asyncio.create_task(
                self._evaluate_framework(framework, requirements)
            )
            evaluation_tasks.append(task)

        # 모든 평가 완료 대기
        evaluations = await asyncio.gather(*evaluation_tasks)

        # 최적 프레임워크 선택
        best_framework = max(evaluations, key=lambda x: x.score)

        return UIFrameworkSelection(
            framework=best_framework.framework,
            score=best_framework.score,
            reasoning=best_framework.reasoning,
            performance_metrics=await self._get_current_metrics()
        )

    async def _batch_processor(self):
        """배치 처리 워커"""
        batch = []

        while True:
            try:
                # 배치 수집 (최대 50ms 대기)
                timeout = 0.05
                deadline = asyncio.get_event_loop().time() + timeout

                while len(batch) < 10:  # 최대 배치 크기
                    remaining = deadline - asyncio.get_event_loop().time()
                    if remaining <= 0:
                        break

                    try:
                        item = await asyncio.wait_for(
                            self.batch_queue.get(),
                            timeout=remaining
                        )
                        batch.append(item)
                    except asyncio.TimeoutError:
                        break

                # 배치 처리
                if batch:
                    await self._process_batch(batch)
                    batch = []

            except Exception as e:
                print(f"Batch processor error: {e}")
                await asyncio.sleep(1)

    async def _get_current_metrics(self) -> PerformanceMetrics:
        """현재 성능 메트릭 수집"""
        return PerformanceMetrics(
            latency_p50=await self.metrics_collector.get_percentile(50),
            latency_p95=await self.metrics_collector.get_percentile(95),
            latency_p99=await self.metrics_collector.get_percentile(99),
            throughput=await self.metrics_collector.get_throughput(),
            error_rate=await self.metrics_collector.get_error_rate(),
            cache_hit_rate=await self.metrics_collector.get_cache_hit_rate(),
            memory_usage_mb=await self.metrics_collector.get_memory_usage(),
            cpu_usage_percent=await self.metrics_collector.get_cpu_usage()
        )
```

**최적화 전략 구현**:

```python
# backend/src/agents/implementations/ui_selection/optimization_strategies.py
class CachingStrategy:
    """다계층 캐싱 전략"""

    def __init__(self):
        # L1: 인메모리 캐시 (가장 빠름)
        self.l1_cache = TTLCache(maxsize=1000, ttl=300)

        # L2: Redis 캐시 (분산)
        self.l2_cache = None

        # L3: DynamoDB 캐시 (영구 저장)
        self.l3_cache = None

    async def get(self, key: str) -> Optional[Any]:
        """캐시에서 값 조회"""
        # L1 확인
        if key in self.l1_cache:
            return self.l1_cache[key]

        # L2 확인
        value = await self.l2_cache.get(key)
        if value:
            self.l1_cache[key] = value
            return value

        # L3 확인
        value = await self.l3_cache.get(key)
        if value:
            # 상위 캐시로 승격
            await self.l2_cache.set(key, value)
            self.l1_cache[key] = value
            return value

        return None

class ParallelizationStrategy:
    """병렬 처리 전략"""

    def __init__(self, max_workers: int = 10):
        self.semaphore = asyncio.Semaphore(max_workers)
        self.thread_pool = ThreadPoolExecutor(max_workers=max_workers)

    async def parallel_map(
        self,
        func: Callable,
        items: List[Any]
    ) -> List[Any]:
        """병렬 맵 연산"""
        tasks = []

        for item in items:
            async with self.semaphore:
                task = asyncio.create_task(
                    self._run_in_thread(func, item)
                )
                tasks.append(task)

        return await asyncio.gather(*tasks)
```

**검증 기준**:

- [ ] 응답 시간 50% 개선
- [ ] 캐시 적중률 80% 이상
- [ ] 동시 처리 용량 3배 증가
- [ ] 메모리 사용량 최적화

### SubTask 4.19.3: UI Agent 모니터링 구현

**담당자**: SRE 엔지니어  
**예상 소요시간**: 10시간

**작업 내용**:

```python
# backend/src/agents/implementations/ui_selection/monitoring.py
from prometheus_client import Counter, Histogram, Gauge, Info
import logging
from typing import Dict, Any
import time
import asyncio
from dataclasses import dataclass

# Prometheus 메트릭 정의
ui_selection_requests = Counter(
    'ui_selection_requests_total',
    'Total UI selection requests',
    ['framework', 'status']
)

ui_selection_latency = Histogram(
    'ui_selection_latency_seconds',
    'UI selection request latency',
    ['operation']
)

ui_selection_active = Gauge(
    'ui_selection_active_requests',
    'Currently active UI selection requests'
)

framework_score_distribution = Histogram(
    'ui_framework_scores',
    'Distribution of framework scores',
    ['framework'],
    buckets=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
)

agent_info = Info(
    'ui_selection_agent_info',
    'UI Selection Agent information'
)

class UIAgentMonitoring:
    """UI Selection Agent 모니터링 시스템"""

    def __init__(self):
        self.logger = logging.getLogger('ui_selection_agent')
        self.metrics_buffer = []
        self.alert_manager = AlertManager()

        # 에이전트 정보 설정
        agent_info.info({
            'version': '1.0.0',
            'framework': 'agno',
            'model': 'gpt-4'
        })

    async def monitor_selection(self, func):
        """UI 선택 프로세스 모니터링 데코레이터"""
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            ui_selection_active.inc()

            try:
                # 요청 컨텍스트 추출
                context = self._extract_context(args, kwargs)
                self.logger.info(f"Starting UI selection: {context}")

                # 실제 선택 프로세스 실행
                result = await func(*args, **kwargs)

                # 성공 메트릭 기록
                duration = time.time() - start_time
                ui_selection_requests.labels(
                    framework=result.framework,
                    status='success'
                ).inc()
                ui_selection_latency.labels(
                    operation='selection'
                ).observe(duration)

                # 프레임워크 점수 분포 기록
                framework_score_distribution.labels(
                    framework=result.framework
                ).observe(result.score)

                self.logger.info(
                    f"UI selection completed: {result.framework} "
                    f"(score: {result.score}, duration: {duration:.2f}s)"
                )

                return result

            except Exception as e:
                # 실패 메트릭 기록
                ui_selection_requests.labels(
                    framework='unknown',
                    status='error'
                ).inc()

                self.logger.error(f"UI selection failed: {str(e)}")

                # 알림 발송
                await self.alert_manager.send_alert(
                    level='error',
                    title='UI Selection Failed',
                    message=str(e),
                    context=context
                )

                raise

            finally:
                ui_selection_active.dec()

        return wrapper

    async def collect_performance_metrics(self):
        """성능 메트릭 수집"""
        while True:
            try:
                metrics = {
                    'timestamp': time.time(),
                    'active_requests': ui_selection_active._value.get(),
                    'total_requests': self._get_total_requests(),
                    'error_rate': self._calculate_error_rate(),
                    'avg_latency': self._calculate_avg_latency(),
                    'memory_usage': self._get_memory_usage(),
                    'cpu_usage': self._get_cpu_usage()
                }

                # 메트릭 버퍼에 추가
                self.metrics_buffer.append(metrics)

                # 버퍼가 가득 차면 전송
                if len(self.metrics_buffer) >= 100:
                    await self._flush_metrics()

                # 이상 감지
                await self._detect_anomalies(metrics)

                await asyncio.sleep(10)  # 10초마다 수집

            except Exception as e:
                self.logger.error(f"Metric collection error: {e}")
                await asyncio.sleep(60)
```

**Grafana 대시보드 설정**:

```json
{
  "dashboard": {
    "title": "UI Selection Agent Dashboard",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "rate(ui_selection_requests_total[5m])",
            "legendFormat": "{{framework}} - {{status}}"
          }
        ]
      },
      {
        "title": "Latency Percentiles",
        "targets": [
          {
            "expr": "histogram_quantile(0.50, rate(ui_selection_latency_seconds_bucket[5m]))",
            "legendFormat": "p50"
          },
          {
            "expr": "histogram_quantile(0.95, rate(ui_selection_latency_seconds_bucket[5m]))",
            "legendFormat": "p95"
          },
          {
            "expr": "histogram_quantile(0.99, rate(ui_selection_latency_seconds_bucket[5m]))",
            "legendFormat": "p99"
          }
        ]
      },
      {
        "title": "Framework Score Distribution",
        "targets": [
          {
            "expr": "histogram_quantile(0.5, rate(ui_framework_scores_bucket[1h]))",
            "legendFormat": "{{framework}}"
          }
        ]
      }
    ]
  }
}
```

**검증 기준**:

- [ ] 모든 핵심 메트릭 수집
- [ ] 실시간 대시보드 구성
- [ ] 알림 규칙 설정
- [ ] 이상 감지 구현

### SubTask 4.19.4: UI Agent 통합 테스트

**담당자**: QA 엔지니어  
**예상 소요시간**: 12시간

**작업 내용**:

```python
# backend/tests/agents/ui_selection/test_integration.py
import pytest
import asyncio
from typing import Dict, Any
import json

@pytest.mark.integration
class TestUISelectionAgentIntegration:
    """UI Selection Agent 통합 테스트"""

    @pytest.fixture
    async def ui_agent(self):
        """UI Agent 인스턴스 생성"""
        from ui_selection_agent import UISelectionAgent

        agent = UISelectionAgent()
        await agent.initialize()
        yield agent
        await agent.cleanup()

    @pytest.fixture
    def test_scenarios(self):
        """다양한 테스트 시나리오"""
        return [
            {
                "name": "E-commerce Platform",
                "requirements": {
                    "project_type": "web",
                    "description": "Modern e-commerce platform with real-time inventory",
                    "technical_requirements": [
                        "Server-side rendering for SEO",
                        "Real-time updates",
                        "Mobile responsive",
                        "PWA support"
                    ],
                    "scale": "enterprise",
                    "team_expertise": ["react", "vue"]
                },
                "expected_framework": "next.js",
                "min_score": 0.8
            },
            {
                "name": "Admin Dashboard",
                "requirements": {
                    "project_type": "web",
                    "description": "Internal admin dashboard with complex data tables",
                    "technical_requirements": [
                        "Rich data visualization",
                        "Complex forms",
                        "Role-based access"
                    ],
                    "scale": "medium",
                    "team_expertise": ["angular", "typescript"]
                },
                "expected_framework": "angular",
                "min_score": 0.75
            },
            {
                "name": "Mobile App",
                "requirements": {
                    "project_type": "mobile",
                    "description": "Cross-platform mobile app for iOS and Android",
                    "technical_requirements": [
                        "Native performance",
                        "Offline support",
                        "Push notifications"
                    ],
                    "target_platforms": ["ios", "android"],
                    "team_expertise": ["react", "javascript"]
                },
                "expected_framework": "react-native",
                "min_score": 0.85
            }
        ]

    @pytest.mark.asyncio
    async def test_framework_selection_accuracy(self, ui_agent, test_scenarios):
        """프레임워크 선택 정확도 테스트"""
        results = []

        for scenario in test_scenarios:
            # UI 프레임워크 선택 실행
            selection = await ui_agent.select_ui_framework(
                scenario["requirements"]
            )

            # 결과 검증
            assert selection.framework == scenario["expected_framework"], \
                f"Expected {scenario['expected_framework']} for {scenario['name']}, " \
                f"but got {selection.framework}"

            assert selection.score >= scenario["min_score"], \
                f"Score {selection.score} is below minimum {scenario['min_score']} " \
                f"for {scenario['name']}"

            results.append({
                "scenario": scenario["name"],
                "selected": selection.framework,
                "score": selection.score,
                "passed": True
            })

        # 전체 정확도 계산
        accuracy = len([r for r in results if r["passed"]]) / len(results)
        assert accuracy >= 0.9, f"Overall accuracy {accuracy} is below 90%"

    @pytest.mark.asyncio
    async def test_concurrent_requests(self, ui_agent):
        """동시 요청 처리 테스트"""
        num_requests = 50
        requirements = {
            "project_type": "web",
            "description": "Test application",
            "technical_requirements": ["responsive", "fast"]
        }

        # 동시 요청 생성
        tasks = []
        for i in range(num_requests):
            task = ui_agent.select_ui_framework(requirements)
            tasks.append(task)

        # 모든 요청 완료 대기
        start_time = asyncio.get_event_loop().time()
        results = await asyncio.gather(*tasks)
        end_time = asyncio.get_event_loop().time()

        # 검증
        assert len(results) == num_requests
        assert all(r.framework is not None for r in results)

        # 성능 검증 (50개 요청이 10초 이내 완료)
        total_time = end_time - start_time
        assert total_time < 10, f"Concurrent requests took {total_time}s, expected < 10s"

    @pytest.mark.asyncio
    async def test_error_handling(self, ui_agent):
        """에러 처리 테스트"""
        invalid_requirements = [
            None,  # None 입력
            {},    # 빈 딕셔너리
            {"invalid": "data"},  # 필수 필드 누락
            {"project_type": "unknown"}  # 잘못된 프로젝트 타입
        ]

        for req in invalid_requirements:
            with pytest.raises(Exception):
                await ui_agent.select_ui_framework(req)
```

**부하 테스트 스크립트**:

```python
# backend/tests/agents/ui_selection/load_test.py
from locust import HttpUser, task, between
import json

class UISelectionLoadTest(HttpUser):
    wait_time = between(1, 3)

    def on_start(self):
        """테스트 시작 시 초기화"""
        self.test_data = [
            {
                "project_type": "web",
                "description": "E-commerce platform",
                "technical_requirements": ["ssr", "pwa", "responsive"]
            },
            {
                "project_type": "mobile",
                "description": "Social media app",
                "technical_requirements": ["offline", "push-notifications"]
            },
            {
                "project_type": "desktop",
                "description": "Video editing software",
                "technical_requirements": ["gpu-acceleration", "multi-threading"]
            }
        ]

    @task(3)
    def select_framework(self):
        """프레임워크 선택 요청"""
        import random

        data = random.choice(self.test_data)

        response = self.client.post(
            "/api/v1/agents/ui-selection/select",
            json=data,
            headers={"Content-Type": "application/json"}
        )

        if response.status_code != 200:
            print(f"Request failed: {response.status_code} - {response.text}")

    @task(1)
    def get_framework_info(self):
        """프레임워크 정보 조회"""
        frameworks = ["react", "vue", "angular", "next.js"]
        framework = random.choice(frameworks)

        self.client.get(f"/api/v1/frameworks/{framework}")
```

**검증 기준**:

- [ ] 모든 시나리오 테스트 통과
- [ ] 동시성 테스트 성공
- [ ] 에러 처리 검증
- [ ] 부하 테스트 목표 달성

## Task 4.20: UI Selection Agent 완성 및 문서화

### SubTask 4.20.1: UI Agent API 문서화

**담당자**: 기술 문서 작성자  
**예상 소요시간**: 8시간

**작업 내용**:

```yaml
# docs/agents/ui_selection/api_specification.yaml
openapi: 3.0.3
info:
  title: UI Selection Agent API
  description: |
    AI-powered UI framework selection agent that analyzes project requirements
    and recommends the best UI framework/library for the project.
  version: 1.0.0
  contact:
    name: T-Developer Team
    email: support@t-developer.ai

servers:
  - url: https://api.t-developer.ai/v1
    description: Production server
  - url: http://localhost:8080/v1
    description: Development server

paths:
  /agents/ui-selection/select:
    post:
      summary: Select UI Framework
      description: Analyzes project requirements and selects the most suitable UI framework
      operationId: selectUIFramework
      tags:
        - UI Selection
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UISelectionRequest'
            examples:
              webApp:
                summary: Web Application
                value:
                  project_type: web
                  description: 'Modern e-commerce platform'
                  technical_requirements:
                    - 'Server-side rendering'
                    - 'PWA support'
                    - 'Real-time updates'
                  scale: enterprise
                  team_expertise:
                    - react
                    - typescript
              mobileApp:
                summary: Mobile Application
                value:
                  project_type: mobile
                  description: 'Cross-platform fitness tracking app'
                  technical_requirements:
                    - 'Native performance'
                    - 'Offline support'
                  target_platforms:
                    - ios
                    - android
      responses:
        '200':
          description: Successful framework selection
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UISelectionResponse'
        '400':
          description: Invalid request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '500':
          description: Internal server error

  /agents/ui-selection/frameworks:
    get:
      summary: List Supported Frameworks
      description: Returns a list of all UI frameworks supported by the agent
      operationId: listFrameworks
      tags:
        - UI Selection
      parameters:
        - name: project_type
          in: query
          description: Filter by project type
          schema:
            type: string
            enum: [web, mobile, desktop]
        - name: include_metadata
          in: query
          description: Include detailed metadata
          schema:
            type: boolean
            default: false
      responses:
        '200':
          description: List of frameworks
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Framework'

  /agents/ui-selection/evaluate:
    post:
      summary: Evaluate Framework Fit
      description: Evaluates how well a specific framework fits the requirements
      operationId: evaluateFramework
      tags:
        - UI Selection
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                framework:
                  type: string
                  description: Framework to evaluate
                requirements:
                  $ref: '#/components/schemas/UISelectionRequest'
      responses:
        '200':
          description: Evaluation result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FrameworkEvaluation'

components:
  schemas:
    UISelectionRequest:
      type: object
      required:
        - project_type
        - description
      properties:
        project_type:
          type: string
          enum: [web, mobile, desktop, cli]
          description: Type of project
        description:
          type: string
          description: Natural language project description
          minLength: 10
          maxLength: 5000
        technical_requirements:
          type: array
          items:
            type: string
          description: List of technical requirements
        non_functional_requirements:
          type: array
          items:
            type: string
          description: Performance, security, etc.
        scale:
          type: string
          enum: [prototype, small, medium, enterprise]
          description: Expected scale of the project
        team_expertise:
          type: array
          items:
            type: string
          description: Team's technical expertise
        target_platforms:
          type: array
          items:
            type: string
          description: Target platforms for deployment
        constraints:
          type: object
          properties:
            budget:
              type: string
              enum: [low, medium, high]
            timeline:
              type: string
              enum: [urgent, normal, flexible]
            licensing:
              type: string
              enum: [open-source, commercial, any]

    UISelectionResponse:
      type: object
      properties:
        framework:
          type: string
          description: Selected UI framework
        confidence_score:
          type: number
          format: float
          minimum: 0
          maximum: 1
          description: Confidence in the selection
        reasoning:
          type: string
          description: Explanation for the selection
        alternatives:
          type: array
          items:
            type: object
            properties:
              framework:
                type: string
              score:
                type: number
              pros:
                type: array
                items:
                  type: string
              cons:
                type: array
                items:
                  type: string
        implementation_guide:
          type: object
          properties:
            setup_instructions:
              type: array
              items:
                type: string
            boilerplate_url:
              type: string
            recommended_libraries:
              type: array
              items:
                type: string
            best_practices:
              type: array
              items:
                type: string
```

**사용자 가이드 문서**:

````markdown
# UI Selection Agent 사용자 가이드

## 개요

UI Selection Agent는 프로젝트 요구사항을 분석하여 최적의 UI 프레임워크를 추천하는 AI 에이전트입니다.

## 주요 기능

### 1. 지능형 프레임워크 선택

- 자연어 프로젝트 설명 분석
- 기술적/비기술적 요구사항 고려
- 팀 역량 및 제약사항 반영
- 다중 프레임워크 비교 분석

### 2. 지원 프레임워크

#### 웹 프레임워크

- **React**: 컴포넌트 기반 UI 라이브러리
- **Vue.js**: 점진적 JavaScript 프레임워크
- **Angular**: 엔터프라이즈급 프레임워크
- **Next.js**: React 기반 풀스택 프레임워크
- **Nuxt.js**: Vue 기반 풀스택 프레임워크
- **Svelte**: 컴파일 타임 최적화 프레임워크

#### 모바일 프레임워크

- **React Native**: 크로스 플랫폼 네이티브 앱
- **Flutter**: Google의 UI 툴킷
- **Ionic**: 하이브리드 모바일 앱
- **NativeScript**: JavaScript 네이티브 앱

#### 데스크톱 프레임워크

- **Electron**: 웹 기술 기반 데스크톱 앱
- **Tauri**: Rust 기반 경량 프레임워크

## 사용 방법

### 1. API 호출

```bash
curl -X POST https://api.t-developer.ai/v1/agents/ui-selection/select \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{
    "project_type": "web",
    "description": "실시간 협업 도구를 만들고 싶습니다.
                    여러 사용자가 동시에 문서를 편집할 수 있고,
                    채팅 기능도 포함되어야 합니다.",
    "technical_requirements": [
      "실시간 동기화",
      "WebSocket 지원",
      "모바일 반응형"
    ],
    "scale": "medium",
    "team_expertise": ["javascript", "react"]
  }'
```
````

### 2. 응답 예시

```json
{
  "framework": "next.js",
  "confidence_score": 0.92,
  "reasoning": "Next.js는 실시간 기능을 위한 API Routes와
               WebSocket 통합이 용이하며, React 경험이 있는
               팀에게 적합합니다. Vercel의 Edge Functions를
               활용하면 실시간 협업 기능을 효율적으로 구현할 수 있습니다.",
  "alternatives": [
    {
      "framework": "vue.js",
      "score": 0.85,
      "pros": ["쉬운 학습 곡선", "우수한 문서화"],
      "cons": ["React 경험 활용 어려움"]
    }
  ],
  "implementation_guide": {
    "setup_instructions": [
      "npx create-next-app@latest my-collab-tool",
      "npm install socket.io-client pusher-js",
      "Configure WebSocket connection"
    ],
    "boilerplate_url": "https://github.com/t-developer/nextjs-collab-starter",
    "recommended_libraries": [
      "socket.io",
      "yjs",
      "tiptap"
    ]
  }
}
```

## 베스트 프랙티스

### 1. 상세한 요구사항 제공

- 구체적인 기능 명시
- 성능 요구사항 포함
- 팀 경험 수준 명시

### 2. 제약사항 명확히 하기

- 예산 범위
- 개발 일정
- 라이선스 요구사항

### 3. 결과 검증

- 추천된 프레임워크 POC 구현
- 팀 피드백 수집
- 필요시 재평가 요청

````

**검증 기준**:
- [ ] OpenAPI 3.0 명세 완성
- [ ] 모든 엔드포인트 문서화
- [ ] 사용 예제 포함
- [ ] 베스트 프랙티스 가이드

### SubTask 4.20.2: UI Agent 운영 가이드 작성

**담당자**: DevOps 엔지니어
**예상 소요시간**: 10시간

**작업 내용**:

```markdown
# UI Selection Agent 운영 가이드

## 1. 배포 가이드

### 1.1 사전 요구사항
- Kubernetes 1.24+
- Helm 3.0+
- AWS 계정 (Bedrock 액세스 권한 필요)
- Redis 6.0+
- Prometheus/Grafana 스택

### 1.2 Helm 차트 배포

```bash
# Helm 차트 저장소 추가
helm repo add t-developer https://charts.t-developer.ai
helm repo update

# 네임스페이스 생성
kubectl create namespace t-developer

# 시크릿 생성
kubectl create secret generic ui-agent-secrets \
  --namespace=t-developer \
  --from-literal=openai-api-key=$OPENAI_API_KEY \
  --from-literal=anthropic-api-key=$ANTHROPIC_API_KEY \
  --from-literal=redis-password=$REDIS_PASSWORD

# UI Selection Agent 배포
helm install ui-selection-agent t-developer/ui-selection-agent \
  --namespace t-developer \
  --values values-production.yaml
````

### 1.3 배포 설정 (values-production.yaml)

```yaml
replicaCount: 3

image:
  repository: t-developer/ui-selection-agent
  tag: '1.0.0'
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 8080

ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: '100'
  hosts:
    - host: ui-agent.t-developer.ai
      paths:
        - path: /
          pathType: Prefix

resources:
  requests:
    memory: '1Gi'
    cpu: '1000m'
  limits:
    memory: '2Gi'
    cpu: '2000m'

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

redis:
  enabled: true
  architecture: replication
  auth:
    enabled: true
    existingSecret: ui-agent-secrets
    existingSecretPasswordKey: redis-password

monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s

agentConfig:
  maxConcurrentRequests: 50
  requestTimeout: 30000
  cacheEnabled: true
  cacheTTL: 3600
  batchingEnabled: true
  batchSize: 10
  batchTimeout: 50
```

## 2. 모니터링 설정

### 2.1 Prometheus 알림 규칙

```yaml
# prometheus-rules.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: ui-selection-agent-alerts
  namespace: t-developer
spec:
  groups:
    - name: ui-agent.rules
      interval: 30s
      rules:
        # 높은 에러율 알림
        - alert: HighErrorRate
          expr: |
            rate(ui_selection_requests_total{status="error"}[5m]) > 0.05
          for: 5m
          labels:
            severity: warning
          annotations:
            summary: 'High error rate detected'
            description: 'Error rate is {{ $value | humanizePercentage }} for {{ $labels.instance }}'

        # 응답 시간 알림
        - alert: HighLatency
          expr: |
            histogram_quantile(0.95, rate(ui_selection_latency_seconds_bucket[5m])) > 5
          for: 10m
          labels:
            severity: warning
          annotations:
            summary: 'High latency detected'
            description: '95th percentile latency is {{ $value }}s'

        # 메모리 사용량 알림
        - alert: HighMemoryUsage
          expr: |
            container_memory_usage_bytes{pod=~"ui-selection-agent-.*"} 
            / container_spec_memory_limit_bytes > 0.9
          for: 5m
          labels:
            severity: critical
          annotations:
            summary: 'High memory usage'
            description: 'Memory usage is {{ $value | humanizePercentage }}'
```

### 2.2 Grafana 대시보드 설정

```json
{
  "dashboard": {
    "title": "UI Selection Agent Operations",
    "uid": "ui-selection-ops",
    "panels": [
      {
        "title": "Request Rate by Framework",
        "gridPos": { "x": 0, "y": 0, "w": 12, "h": 8 },
        "targets": [
          {
            "expr": "sum by (framework) (rate(ui_selection_requests_total[5m]))",
            "legendFormat": "{{ framework }}"
          }
        ]
      },
      {
        "title": "Latency Heatmap",
        "gridPos": { "x": 12, "y": 0, "w": 12, "h": 8 },
        "type": "heatmap",
        "targets": [
          {
            "expr": "sum(rate(ui_selection_latency_seconds_bucket[5m])) by (le)",
            "format": "heatmap"
          }
        ]
      },
      {
        "title": "Framework Score Distribution",
        "gridPos": { "x": 0, "y": 8, "w": 12, "h": 8 },
        "targets": [
          {
            "expr": "histogram_quantile(0.5, sum by (framework, le) (rate(ui_framework_scores_bucket[1h])))",
            "legendFormat": "{{ framework }} - median"
          }
        ]
      },
      {
        "title": "Cache Hit Rate",
        "gridPos": { "x": 12, "y": 8, "w": 12, "h": 8 },
        "targets": [
          {
            "expr": "rate(cache_hits_total[5m]) / (rate(cache_hits_total[5m]) + rate(cache_misses_total[5m]))",
            "legendFormat": "Hit Rate"
          }
        ]
      }
    ]
  }
}
```

## 3. 운영 절차

### 3.1 일일 체크리스트

```bash
#!/bin/bash
# daily-check.sh

echo "=== UI Selection Agent Daily Check ==="
echo

# 1. Pod 상태 확인
echo "1. Checking pod status..."
kubectl get pods -n t-developer -l app=ui-selection-agent

# 2. 최근 에러 로그 확인
echo -e "\n2. Recent errors (last 1h)..."
kubectl logs -n t-developer -l app=ui-selection-agent --since=1h | grep ERROR | tail -10

# 3. 메트릭 확인
echo -e "\n3. Key metrics..."
curl -s http://ui-agent.t-developer.ai/metrics | grep -E "(ui_selection_requests_total|ui_selection_latency_seconds)"

# 4. Redis 연결 상태
echo -e "\n4. Redis connection status..."
kubectl exec -n t-developer -it $(kubectl get pod -n t-developer -l app=ui-selection-agent -o jsonpath='{.items[0].metadata.name}') -- redis-cli ping

# 5. 디스크 사용량
echo -e "\n5. Disk usage..."
kubectl exec -n t-developer $(kubectl get pod -n t-developer -l app=ui-selection-agent -o jsonpath='{.items[0].metadata.name}') -- df -h

echo -e "\n=== Check completed ==="
```

### 3.2 장애 대응 절차

#### 시나리오 1: 높은 응답 시간

```bash
# 1. 현재 부하 확인
kubectl top pods -n t-developer -l app=ui-selection-agent

# 2. 스케일 아웃
kubectl scale deployment ui-selection-agent -n t-developer --replicas=5

# 3. 캐시 상태 확인
kubectl exec -n t-developer -it deploy/ui-selection-agent -- \
  python -c "from cache_manager import check_cache_health; check_cache_health()"

# 4. 느린 쿼리 분석
kubectl logs -n t-developer -l app=ui-selection-agent --tail=1000 | \
  grep "duration" | awk '{print $NF}' | sort -rn | head -20
```

#### 시나리오 2: 메모리 부족

```bash
# 1. 메모리 사용 패턴 분석
kubectl exec -n t-developer deploy/ui-selection-agent -- \
  python -c "import tracemalloc; tracemalloc.start(); print(tracemalloc.get_traced_memory())"

# 2. 힙 덤프 생성
kubectl exec -n t-developer $(kubectl get pod -n t-developer -l app=ui-selection-agent -o jsonpath='{.items[0].metadata.name}') -- \
  python -m py_spy dump --pid 1 --format speedscope -o /tmp/heap.dump

# 3. 임시 메모리 증설
kubectl patch deployment ui-selection-agent -n t-developer -p \
  '{"spec":{"template":{"spec":{"containers":[{"name":"agent","resources":{"limits":{"memory":"4Gi"}}}]}}}}'
```

### 3.3 성능 튜닝

```python
# performance-tuning.py
import asyncio
from typing import Dict, Any

class PerformanceTuner:
    """UI Agent 성능 튜닝 도구"""

    async def analyze_performance(self):
        """성능 분석 및 권장사항 제공"""

        metrics = await self.collect_metrics()

        recommendations = []

        # 캐시 적중률 분석
        if metrics['cache_hit_rate'] < 0.7:
            recommendations.append({
                'issue': 'Low cache hit rate',
                'current': f"{metrics['cache_hit_rate']:.2%}",
                'recommendation': 'Increase cache TTL or size',
                'command': 'kubectl set env deployment/ui-selection-agent CACHE_TTL=7200'
            })

        # 응답 시간 분석
        if metrics['p95_latency'] > 2000:  # 2초
            recommendations.append({
                'issue': 'High P95 latency',
                'current': f"{metrics['p95_latency']}ms",
                'recommendation': 'Enable request batching',
                'command': 'kubectl set env deployment/ui-selection-agent ENABLE_BATCHING=true'
            })

        # 메모리 사용률 분석
        if metrics['memory_usage_percent'] > 80:
            recommendations.append({
                'issue': 'High memory usage',
                'current': f"{metrics['memory_usage_percent']}%",
                'recommendation': 'Increase memory limit or optimize caching',
                'command': 'kubectl patch deployment ui-selection-agent -p \'{"spec":{"template":{"spec":{"containers":[{"name":"agent","resources":{"limits":{"memory":"3Gi"}}}]}}}}\''
            })

        return recommendations

# 실행
if __name__ == "__main__":
    tuner = PerformanceTuner()
    recommendations = asyncio.run(tuner.analyze_performance())

    for rec in recommendations:
        print(f"\n❗ {rec['issue']}")
        print(f"   Current: {rec['current']}")
        print(f"   Recommendation: {rec['recommendation']}")
        print(f"   Command: {rec['command']}")
```

## 4. 백업 및 복구

### 4.1 백업 절차

```bash
#!/bin/bash
# backup-ui-agent.sh

TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups/ui-agent/${TIMESTAMP}"

echo "Starting UI Agent backup at ${TIMESTAMP}"

# 1. Redis 데이터 백업
kubectl exec -n t-developer deploy/redis-master -- \
  redis-cli BGSAVE

sleep 5

kubectl cp t-developer/redis-master:/data/dump.rdb \
  ${BACKUP_DIR}/redis-dump.rdb

# 2. 설정 백업
kubectl get configmap -n t-developer ui-selection-config -o yaml > \
  ${BACKUP_DIR}/configmap.yaml

kubectl get secret -n t-developer ui-agent-secrets -o yaml > \
  ${BACKUP_DIR}/secrets.yaml

# 3. 모델 캐시 백업
kubectl exec -n t-developer deploy/ui-selection-agent -- \
  tar czf /tmp/model-cache.tar.gz /app/cache/models

kubectl cp t-developer/deploy/ui-selection-agent:/tmp/model-cache.tar.gz \
  ${BACKUP_DIR}/model-cache.tar.gz

echo "Backup completed at ${BACKUP_DIR}"
```

### 4.2 복구 절차

```bash
#!/bin/bash
# restore-ui-agent.sh

BACKUP_TIMESTAMP=$1
BACKUP_DIR="/backups/ui-agent/${BACKUP_TIMESTAMP}"

if [ -z "$BACKUP_TIMESTAMP" ]; then
    echo "Usage: ./restore-ui-agent.sh <backup_timestamp>"
    exit 1
fi

echo "Restoring UI Agent from backup ${BACKUP_TIMESTAMP}"

# 1. 서비스 중지
kubectl scale deployment ui-selection-agent -n t-developer --replicas=0

# 2. Redis 데이터 복구
kubectl cp ${BACKUP_DIR}/redis-dump.rdb \
  t-developer/redis-master:/data/dump.rdb

kubectl exec -n t-developer deploy/redis-master -- \
  redis-cli SHUTDOWN NOSAVE

kubectl rollout restart deployment/redis-master -n t-developer

# 3. 설정 복구
kubectl apply -f ${BACKUP_DIR}/configmap.yaml
kubectl apply -f ${BACKUP_DIR}/secrets.yaml

# 4. 모델 캐시 복구
kubectl cp ${BACKUP_DIR}/model-cache.tar.gz \
  t-developer/deploy/ui-selection-agent:/tmp/model-cache.tar.gz

kubectl exec -n t-developer deploy/ui-selection-agent -- \
  tar xzf /tmp/model-cache.tar.gz -C /

# 5. 서비스 재시작
kubectl scale deployment ui-selection-agent -n t-developer --replicas=3

echo "Restore completed"
```

````

**검증 기준**:
- [ ] 배포 절차 문서화
- [ ] 모니터링 설정 완료
- [ ] 운영 스크립트 작성
- [ ] 백업/복구 절차 검증

### SubTask 4.20.3: UI Agent 성능 벤치마크 보고서

**담당자**: 성능 엔지니어
**예상 소요시간**: 10시간

**작업 내용**:

```markdown
# UI Selection Agent 성능 벤치마크 보고서

## Executive Summary

UI Selection Agent는 다양한 부하 조건에서 테스트되었으며, 다음과 같은 주요 성능 지표를 달성했습니다:

- **처리량**: 1,200 req/sec (목표: 1,000 req/sec) ✅
- **응답 시간**: P95 < 250ms (목표: 500ms) ✅
- **가용성**: 99.99% (목표: 99.9%) ✅
- **동시성**: 500 동시 요청 처리 (목표: 300) ✅

## 1. 테스트 환경

### 1.1 하드웨어 사양
```yaml
Agent Pods:
  - CPU: 4 vCPU (Intel Xeon Platinum 8375C)
  - Memory: 8GB RAM
  - Network: 10 Gbps
  - Instances: 3 (auto-scaling to 10)

Redis Cluster:
  - Type: ElastiCache for Redis
  - Node Type: cache.r6g.large
  - Nodes: 3 (1 primary, 2 replicas)

Load Generator:
  - Tool: K6
  - Instances: 5
  - Location: Same VPC, different AZ
````

### 1.2 소프트웨어 스택

- **OS**: Amazon Linux 2
- **Runtime**: Python 3.11.6
- **Framework**: Agno 1.0.0
- **AI Models**: GPT-4, Claude-3
- **Container**: Docker 24.0.6
- **Orchestration**: Kubernetes 1.28

## 2. 테스트 시나리오

### 2.1 기준 성능 테스트 (Baseline)

```javascript
// k6-baseline-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '2m', target: 100 }, // Ramp up
    { duration: '5m', target: 100 }, // Steady state
    { duration: '2m', target: 0 }, // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% of requests under 500ms
    http_req_failed: ['rate<0.01'], // Error rate under 1%
  },
};

export default function () {
  const payload = JSON.stringify({
    project_type: 'web',
    description: 'E-commerce platform with real-time features',
    technical_requirements: ['ssr', 'real-time', 'pwa'],
    scale: 'enterprise',
  });

  const params = {
    headers: { 'Content-Type': 'application/json' },
  };

  const res = http.post('http://ui-agent-lb/v1/select', payload, params);

  check(res, {
    'status is 200': (r) => r.status === 200,
    'response has framework': (r) => JSON.parse(r.body).framework !== undefined,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });

  sleep(1);
}
```

**결과**:

```
✓ status is 200: 99.98%
✓ response has framework: 100%
✓ response time < 500ms: 96.5%

http_req_duration..............: avg=187.32ms min=45.2ms med=156.8ms max=892.3ms p(90)=289.2ms p(95)=342.1ms
http_req_failed................: 0.02%
http_reqs......................: 29,847
vus............................: 100
```

### 2.2 스트레스 테스트

```javascript
export const options = {
  stages: [
    { duration: '5m', target: 500 }, // Ramp up to 500 users
    { duration: '10m', target: 500 }, // Stay at 500
    { duration: '5m', target: 1000 }, // Spike to 1000
    { duration: '10m', target: 1000 }, // Stay at 1000
    { duration: '5m', target: 0 }, // Ramp down
  ],
};
```

**결과 그래프**:

```
Throughput (req/sec)
1400 |                                    ▁▃▅▇█████
1200 |                            ▁▃▅▇████████████
1000 |                    ▁▃▅▇█████████████████░░
 800 |            ▁▃▅▇████████████████████░░░░░░
 600 |    ▁▃▅▇████████████████████░░░░░░░░░░░░░
 400 |▃▅▇███████████████░░░░░░░░░░░░░░░░░░░░░░░
 200 |████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
   0 +------------------------------------------
     0    5   10   15   20   25   30   35   Time (min)

Response Time P95 (ms)
500 |░░░░░░░░░░░░░░░░░░░░░░░░░░░▁▃▅▇█████████
400 |░░░░░░░░░░░░░░░░░░░░▁▃▅▇████████████████
300 |░░░░░░░░░░░░▁▃▅▇████████████████████░░░░
200 |░░░░▁▃▅▇████████████████████░░░░░░░░░░░░
100 |▃▅▇███████████████░░░░░░░░░░░░░░░░░░░░░░
  0 +------------------------------------------
    0    5   10   15   20   25   30   35   Time (min)
```

### 2.3 캐시 효율성 테스트

**테스트 코드**:

```python
# cache_efficiency_test.py
import asyncio
import time
from collections import defaultdict

class CacheEfficiencyTest:
    def __init__(self):
        self.results = defaultdict(list)

    async def test_cache_performance(self):
        # 동일한 요청을 반복하여 캐시 효과 측정
        test_requests = [
            {
                "project_type": "web",
                "description": f"Test project {i % 10}",  # 10개 패턴 반복
                "technical_requirements": ["ssr", "pwa"]
            }
            for i in range(1000)
        ]

        # Cold cache
        cold_times = []
        for req in test_requests[:100]:
            start = time.time()
            await self.make_request(req)
            cold_times.append(time.time() - start)

        # Warm cache
        warm_times = []
        for req in test_requests[100:]:
            start = time.time()
            await self.make_request(req)
            warm_times.append(time.time() - start)

        return {
            "cold_cache_avg": sum(cold_times) / len(cold_times),
            "warm_cache_avg": sum(warm_times) / len(warm_times),
            "cache_speedup": sum(cold_times) / sum(warm_times)
        }
```

**결과**:

```
Cache Performance Analysis:
- Cold Cache Average: 245.3ms
- Warm Cache Average: 12.7ms
- Cache Speedup: 19.3x
- Cache Hit Rate: 89.2%
```

## 3. 성능 최적화 결과

### 3.1 최적화 전후 비교

| 메트릭            | 최적화 전 | 최적화 후 | 개선율 |
| ----------------- | --------- | --------- | ------ |
| 처리량 (req/sec)  | 450       | 1,200     | +167%  |
| P50 응답시간 (ms) | 320       | 95        | -70%   |
| P95 응답시간 (ms) | 890       | 245       | -72%   |
| P99 응답시간 (ms) | 1,450     | 380       | -74%   |
| 메모리 사용 (MB)  | 2,100     | 1,200     | -43%   |
| CPU 사용률 (%)    | 85        | 65        | -23%   |
| 캐시 적중률 (%)   | 45        | 89        | +98%   |

### 3.2 주요 최적화 기법

1. **배치 처리 구현**
   - 10개 요청을 50ms 윈도우로 배치
   - AI 모델 호출 횟수 90% 감소

2. **다계층 캐싱**
   - L1: In-memory (TTL: 5분)
   - L2: Redis (TTL: 1시간)
   - L3: DynamoDB (TTL: 24시간)

3. **병렬 처리**
   - Framework 평가 병렬화
   - 동시 처리 용량 5배 증가

4. **연결 풀 최적화**
   - Redis 연결 풀: 20 connections
   - HTTP Keep-Alive 활성화

## 4. 확장성 테스트

### 4.1 수평 확장 테스트

```bash
# Auto-scaling 테스트
kubectl autoscale deployment ui-selection-agent \
  --min=3 --max=10 \
  --cpu-percent=70
```

**결과**:

```
Pods Scaling Behavior:
Time    | Load (req/sec) | Active Pods | Avg CPU | Avg Response Time
00:00   | 100           | 3           | 25%     | 95ms
00:05   | 500           | 3           | 65%     | 110ms
00:10   | 800           | 5           | 55%     | 105ms
00:15   | 1200          | 7           | 60%     | 98ms
00:20   | 1500          | 9           | 58%     | 102ms
00:25   | 800           | 7           | 40%     | 95ms
00:30   | 200           | 3           | 20%     | 88ms
```

### 4.2 장기 안정성 테스트 (72시간)

**설정**:

- 일정 부하: 600 req/sec
- 테스트 기간: 72시간
- 모니터링 간격: 5분

**결과**:

```
Stability Metrics (72 hours):
- Total Requests: 155,520,000
- Success Rate: 99.996%
- Errors: 6,221 (0.004%)
- Memory Leaks: None detected
- Average Response Time: 112ms (±15ms)
- Resource Usage Drift: < 2%
```

## 5. 권장사항

### 5.1 프로덕션 배포 권장 설정

```yaml
Production Configuration:
  Replicas:
    Min: 5
    Max: 15
  Resources:
    CPU Request: 2000m
    CPU Limit: 4000m
    Memory Request: 2Gi
    Memory Limit: 4Gi
  Cache:
    Redis Nodes: 3
    Cache TTL: 3600s
    Max Cache Size: 10GB
  Monitoring:
    Metrics Interval: 30s
    Log Level: INFO
    Trace Sampling: 10%
```

### 5.2 성능 모니터링 KPI

1. **Response Time SLO**
   - P50 < 100ms
   - P95 < 300ms
   - P99 < 500ms

2. **Availability SLO**
   - Uptime: 99.9%
   - Error Rate < 0.1%

3. **Throughput Target**
   - Normal: 600 req/sec
   - Peak: 1,500 req/sec

## 6. 결론

UI Selection Agent는 모든 성능 목표를 초과 달성했으며, 프로덕션 환경에서 안정적으로 운영될 준비가 완료되었습니다. 특히 캐싱 전략과 배치 처리를 통해 AI 모델 호출을 최적화하여 비용 효율성도 크게 개선되었습니다.

### 향후 개선 사항

1. GraphQL 지원으로 네트워크 효율성 개선
2. Edge 캐싱으로 글로벌 응답 시간 단축
3. 모델 양자화로 추론 속도 향상

````

**검증 기준**:
- [ ] 모든 성능 목표 달성
- [ ] 부하 테스트 완료
- [ ] 확장성 검증
- [ ] 장기 안정성 확인

### SubTask 4.20.4: UI Agent 최종 검증 및 배포

**담당자**: 프로젝트 리드
**예상 소요시간**: 8시간

**작업 내용**:

```python
# backend/src/agents/implementations/ui_selection/final_validation.py
from typing import List, Dict, Any, Tuple
import asyncio
from dataclasses import dataclass
import pytest

@dataclass
class ValidationResult:
    category: str
    test_name: str
    passed: bool
    message: str
    details: Dict[str, Any]

class UIAgentFinalValidation:
    """UI Selection Agent 최종 검증"""

    def __init__(self):
        self.validation_results: List[ValidationResult] = []

    async def run_all_validations(self) -> Tuple[bool, List[ValidationResult]]:
        """모든 검증 실행"""

        validations = [
            self.validate_functionality(),
            self.validate_performance(),
            self.validate_security(),
            self.validate_integration(),
            self.validate_documentation(),
            self.validate_deployment()
        ]

        results = await asyncio.gather(*validations)

        all_passed = all(r.passed for result_list in results for r in result_list)
        all_results = [r for result_list in results for r in result_list]

        return all_passed, all_results

    async def validate_functionality(self) -> List[ValidationResult]:
        """기능 검증"""
        results = []

        # 1. 모든 프레임워크 지원 확인
        test_cases = [
            ("web", ["react", "vue", "angular", "next.js", "nuxt.js", "svelte"]),
            ("mobile", ["react-native", "flutter", "ionic"]),
            ("desktop", ["electron", "tauri"])
        ]

        for project_type, expected_frameworks in test_cases:
            try:
                response = await self.test_framework_selection(project_type)
                supported = all(f in response['available_frameworks'] for f in expected_frameworks)

                results.append(ValidationResult(
                    category="functionality",
                    test_name=f"{project_type}_frameworks",
                    passed=supported,
                    message=f"All {project_type} frameworks supported",
                    details={"frameworks": response['available_frameworks']}
                ))
            except Exception as e:
                results.append(ValidationResult(
                    category="functionality",
                    test_name=f"{project_type}_frameworks",
                    passed=False,
                    message=str(e),
                    details={}
                ))

        return results

    async def validate_performance(self) -> List[ValidationResult]:
        """성능 검증"""
        results = []

        # 응답 시간 테스트
        latencies = []
        for _ in range(100):
            start = asyncio.get_event_loop().time()
            await self.make_selection_request()
            latencies.append(asyncio.get_event_loop().time() - start)

        p95 = sorted(latencies)[int(len(latencies) * 0.95)]

        results.append(ValidationResult(
            category="performance",
            test_name="response_time_p95",
            passed=p95 < 0.3,  # 300ms
            message=f"P95 latency: {p95*1000:.2f}ms",
            details={"p95_ms": p95*1000}
        ))

        return results

    async def validate_security(self) -> List[ValidationResult]:
        """보안 검증"""
        results = []

        # API 키 노출 검사
        security_checks = [
            ("api_keys_encrypted", self.check_api_keys_encrypted()),
            ("ssl_enabled", self.check_ssl_enabled()),
            ("rate_limiting", self.check_rate_limiting()),
            ("input_validation", self.check_input_validation())
        ]

        for check_name, check_result in security_checks:
            results.append(ValidationResult(
                category="security",
                test_name=check_name,
                passed=check_result,
                message=f"{check_name.replace('_', ' ').title()} check",
                details={}
            ))

        return results
````

**배포 체크리스트**:

```yaml
# deployment-checklist.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: ui-agent-deployment-checklist
  namespace: t-developer
data:
  checklist.yaml: |
    deployment_checklist:
      pre_deployment:
        - name: "Code Review Completed"
          required: true
          status: "completed"
          reviewer: "senior-engineer"
        
        - name: "All Tests Passing"
          required: true
          status: "completed"
          test_suites:
            - unit_tests: 156/156
            - integration_tests: 48/48
            - e2e_tests: 12/12
        
        - name: "Security Scan"
          required: true
          status: "completed"
          vulnerabilities: 0
        
        - name: "Performance Benchmarks"
          required: true
          status: "completed"
          metrics:
            - p95_latency: "245ms"
            - throughput: "1200 req/sec"
      
      deployment_steps:
        - name: "Database Migration"
          command: "kubectl apply -f migrations/"
          status: "pending"
        
        - name: "Config Update"
          command: "kubectl apply -f configs/"
          status: "pending"
        
        - name: "Canary Deployment"
          command: "helm upgrade --install ui-agent ./chart --set canary.enabled=true"
          status: "pending"
        
        - name: "Health Check"
          command: "kubectl wait --for=condition=ready pod -l app=ui-agent"
          status: "pending"
        
        - name: "Smoke Tests"
          command: "pytest tests/smoke/"
          status: "pending"
        
        - name: "Full Rollout"
          command: "kubectl set image deployment/ui-agent agent=ui-agent:v1.0.0"
          status: "pending"
      
      post_deployment:
        - name: "Monitor Error Rates"
          duration: "30m"
          threshold: "< 0.1%"
        
        - name: "Check Performance Metrics"
          metrics:
            - latency_p95: "< 300ms"
            - cpu_usage: "< 70%"
            - memory_usage: "< 80%"
        
        - name: "Verify Integrations"
          services:
            - redis: "connected"
            - dynamodb: "connected"
            - monitoring: "active"
```

**최종 배포 스크립트**:

```bash
#!/bin/bash
# deploy-ui-agent.sh

set -e

echo "🚀 Starting UI Selection Agent Deployment"

# 1. 검증 실행
echo "📋 Running final validations..."
python -m pytest tests/final_validation/ -v

# 2. 빌드 및 푸시
echo "🔨 Building Docker image..."
docker build -t t-developer/ui-selection-agent:v1.0.0 .
docker push t-developer/ui-selection-agent:v1.0.0

# 3. 배포 전 백업
echo "💾 Creating backup..."
./scripts/backup-ui-agent.sh

# 4. Canary 배포
echo "🐤 Starting canary deployment..."
kubectl apply -f k8s/canary/

# 5. Canary 검증 (10% 트래픽)
echo "✅ Validating canary..."
sleep 300  # 5분 대기

CANARY_ERROR_RATE=$(kubectl exec -n t-developer deploy/prometheus -- \
  promtool query instant 'rate(ui_selection_requests_total{status="error",version="canary"}[5m])' | \
  jq -r '.data.result[0].value[1]')

if (( $(echo "$CANARY_ERROR_RATE > 0.001" | bc -l) )); then
    echo "❌ Canary error rate too high: ${CANARY_ERROR_RATE}"
    kubectl delete -f k8s/canary/
    exit 1
fi

# 6. 전체 배포
echo "🎯 Rolling out to all pods..."
kubectl set image deployment/ui-selection-agent \
  agent=t-developer/ui-selection-agent:v1.0.0 \
  -n t-developer

# 7. 배포 대기
kubectl rollout status deployment/ui-selection-agent -n t-developer

# 8. 최종 검증
echo "🔍 Final verification..."
./scripts/post-deployment-check.sh

echo "✅ UI Selection Agent v1.0.0 deployed successfully!"

# 9. 알림 발송
curl -X POST $SLACK_WEBHOOK_URL \
  -H 'Content-Type: application/json' \
  -d '{
    "text": "🎉 UI Selection Agent v1.0.0 deployed successfully!",
    "attachments": [{
      "color": "good",
      "fields": [
        {"title": "Version", "value": "v1.0.0", "short": true},
        {"title": "Environment", "value": "Production", "short": true},
        {"title": "Replicas", "value": "5", "short": true},
        {"title": "Status", "value": "Healthy", "short": true}
      ]
    }]
  }'
```

**릴리스 노트**:

```markdown
# UI Selection Agent v1.0.0 Release Notes

## 🎉 Release Overview

**Release Date**: 2024-12-20  
**Version**: 1.0.0  
**Type**: Major Release

## ✨ Key Features

### 1. Intelligent Framework Selection

- Support for 15+ UI frameworks across web, mobile, and desktop
- AI-powered analysis using GPT-4 and Claude-3
- Context-aware recommendations based on project requirements

### 2. High Performance

- Sub-300ms P95 response time
- 1,200+ requests/second throughput
- 19x performance boost with intelligent caching

### 3. Enterprise Ready

- 99.99% availability
- Horizontal auto-scaling
- Comprehensive monitoring and alerting
- Multi-region deployment support

### 4. Developer Experience

- Simple REST API
- Detailed reasoning for selections
- Implementation guides and boilerplate links
- Alternative framework suggestions

## 📊 Performance Metrics

- **Response Time**: P95 < 250ms
- **Throughput**: 1,200 req/sec
- **Cache Hit Rate**: 89%
- **Memory Usage**: 1.2GB per pod
- **Startup Time**: < 30 seconds

## 🔧 Technical Details

### Supported Frameworks

**Web**: React, Vue.js, Angular, Next.js, Nuxt.js, Svelte, SvelteKit  
**Mobile**: React Native, Flutter, Ionic, NativeScript  
**Desktop**: Electron, Tauri

### API Endpoints

- `POST /v1/agents/ui-selection/select` - Select UI framework
- `GET /v1/agents/ui-selection/frameworks` - List frameworks
- `POST /v1/agents/ui-selection/evaluate` - Evaluate specific framework

## 🐛 Known Issues

- Cache invalidation delay in multi-region setup (< 30s)
- Occasional timeout with very complex requirements (being optimized)

## 🔮 Coming Next

- GraphQL API support (v1.1)
- WebAssembly framework support (v1.2)
- Real-time collaboration features (v1.3)

## 📝 Documentation

- [API Documentation](https://docs.t-developer.ai/agents/ui-selection)
- [Integration Guide](https://docs.t-developer.ai/guides/ui-selection)
- [Performance Tuning](https://docs.t-developer.ai/operations/ui-selection)

## 🙏 Acknowledgments

Thanks to all contributors and beta testers who helped shape this release!

---

For questions or support, contact: support@t-developer.ai
```

**검증 기준**:

- [ ] 모든 테스트 통과
- [ ] Canary 배포 성공
- [ ] 성능 목표 달성
- [ ] 문서화 완료

---

# Phase 4: 9개 핵심 에이전트 구현 - Parser Agent (Tasks 4.21-4.23)

## 3. Parser Agent (요구사항 파싱 에이전트)

### Task 4.21: Parser Agent 코어 구현

#### SubTask 4.21.1: Parser Agent 기본 아키텍처 구현

**담당자**: 시니어 백엔드 개발자  
**예상 소요시간**: 14시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser_agent.py
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import re
import asyncio
from agno.agent import Agent
from agno.models.aws import AwsBedrock
from agno.models.openai import OpenAIChat

@dataclass
class RequirementType(Enum):
    FUNCTIONAL = "functional"
    NON_FUNCTIONAL = "non_functional"
    TECHNICAL = "technical"
    BUSINESS = "business"
    CONSTRAINT = "constraint"
    ASSUMPTION = "assumption"

@dataclass
class ParsedRequirement:
    id: str
    type: RequirementType
    category: str
    description: str
    priority: str  # high, medium, low
    dependencies: List[str] = field(default_factory=list)
    acceptance_criteria: List[str] = field(default_factory=list)
    technical_details: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ParsedProject:
    project_info: Dict[str, Any]
    functional_requirements: List[ParsedRequirement]
    non_functional_requirements: List[ParsedRequirement]
    technical_requirements: List[ParsedRequirement]
    business_requirements: List[ParsedRequirement]
    constraints: List[ParsedRequirement]
    assumptions: List[ParsedRequirement]
    user_stories: List[Dict[str, Any]]
    use_cases: List[Dict[str, Any]]
    data_models: List[Dict[str, Any]]
    api_specifications: List[Dict[str, Any]]
    ui_components: List[Dict[str, Any]]
    integration_points: List[Dict[str, Any]]

class ParserAgent:
    """요구사항 파싱 및 구조화 에이전트"""

    def __init__(self):
        # 주 파서 - Claude 3 (긴 문맥 처리에 최적화)
        self.main_parser = Agent(
            name="Requirements-Parser",
            model=AwsBedrock(
                id="anthropic.claude-3-sonnet-v2:0",
                region="us-east-1"
            ),
            role="Expert requirements analyst and system architect",
            instructions=[
                "Parse and structure project requirements from natural language",
                "Identify functional and non-functional requirements",
                "Extract technical specifications and constraints",
                "Create user stories and use cases",
                "Define data models and API specifications",
                "Identify dependencies and relationships between requirements"
            ],
            temperature=0.2,  # 낮은 온도로 일관성 있는 파싱
            max_retries=3
        )

        # 보조 파서 - GPT-4 (세부 분석)
        self.detail_parser = Agent(
            name="Detail-Parser",
            model=OpenAIChat(id="gpt-4-turbo-preview"),
            role="Technical requirements specialist",
            instructions=[
                "Extract technical details from requirements",
                "Identify specific technologies and frameworks mentioned",
                "Parse API endpoints and data structures",
                "Extract performance and security requirements"
            ],
            temperature=0.1
        )

        # 전문 파서들
        self.requirement_extractor = RequirementExtractor()
        self.user_story_generator = UserStoryGenerator()
        self.data_model_parser = DataModelParser()
        self.api_spec_parser = APISpecificationParser()
        self.constraint_analyzer = ConstraintAnalyzer()

        # 파싱 규칙 엔진
        self.parsing_rules = ParsingRuleEngine()

        # 검증기
        self.requirement_validator = RequirementValidator()

    async def parse_requirements(
        self,
        raw_description: str,
        project_context: Optional[Dict[str, Any]] = None,
        parsing_options: Optional[Dict[str, Any]] = None
    ) -> ParsedProject:
        """프로젝트 요구사항 파싱"""

        # 1. 전처리
        preprocessed_text = await self._preprocess_text(
            raw_description,
            project_context
        )

        # 2. 기본 구조 파싱
        base_structure = await self._parse_base_structure(preprocessed_text)

        # 3. 병렬 상세 파싱
        parsing_tasks = [
            self._parse_functional_requirements(base_structure),
            self._parse_non_functional_requirements(base_structure),
            self._parse_technical_requirements(base_structure),
            self._parse_business_requirements(base_structure),
            self._parse_constraints(base_structure),
            self._parse_assumptions(base_structure),
            self._generate_user_stories(base_structure),
            self._extract_use_cases(base_structure),
            self._parse_data_models(base_structure),
            self._parse_api_specifications(base_structure),
            self._identify_ui_components(base_structure),
            self._identify_integration_points(base_structure)
        ]

        results = await asyncio.gather(*parsing_tasks)

        # 4. 결과 조합
        parsed_project = ParsedProject(
            project_info=base_structure.get('project_info', {}),
            functional_requirements=results[0],
            non_functional_requirements=results[1],
            technical_requirements=results[2],
            business_requirements=results[3],
            constraints=results[4],
            assumptions=results[5],
            user_stories=results[6],
            use_cases=results[7],
            data_models=results[8],
            api_specifications=results[9],
            ui_components=results[10],
            integration_points=results[11]
        )

        # 5. 검증 및 보완
        validated_project = await self._validate_and_enrich(parsed_project)

        return validated_project

    async def _preprocess_text(
        self,
        text: str,
        context: Optional[Dict[str, Any]]
    ) -> str:
        """텍스트 전처리"""
        # 구조화된 섹션 감지
        sections = self._detect_sections(text)

        # 약어 및 전문 용어 확장
        expanded_text = self._expand_abbreviations(text, context)

        # 참조 해결
        resolved_text = self._resolve_references(expanded_text, context)

        # 형식 정규화
        normalized_text = self._normalize_format(resolved_text)

        return normalized_text

    async def _parse_base_structure(self, text: str) -> Dict[str, Any]:
        """기본 구조 파싱"""
        prompt = f"""
        Parse the following project requirements and extract the basic structure:

        {text}

        Extract:
        1. Project name and description
        2. Project type (web, mobile, desktop, api, etc.)
        3. Target users and stakeholders
        4. High-level goals and objectives
        5. Key features and functionalities
        6. Technical context and constraints
        7. Timeline and milestones
        8. Success criteria

        Return as structured JSON.
        """

        result = await self.main_parser.arun(prompt)
        return self._parse_json_response(result.content)

    async def _parse_functional_requirements(
        self,
        base_structure: Dict[str, Any]
    ) -> List[ParsedRequirement]:
        """기능 요구사항 파싱"""
        features = base_structure.get('key_features', [])
        requirements = []

        for idx, feature in enumerate(features):
            # 각 기능을 상세 요구사항으로 분해
            detailed_reqs = await self.requirement_extractor.extract_functional(
                feature,
                context=base_structure
            )

            for req in detailed_reqs:
                parsed_req = ParsedRequirement(
                    id=f"FR-{idx+1:03d}-{len(requirements)+1:02d}",
                    type=RequirementType.FUNCTIONAL,
                    category=req.get('category', 'general'),
                    description=req.get('description', ''),
                    priority=req.get('priority', 'medium'),
                    dependencies=req.get('dependencies', []),
                    acceptance_criteria=req.get('acceptance_criteria', []),
                    technical_details=req.get('technical_details', {}),
                    metadata={
                        'feature': feature,
                        'extracted_at': datetime.utcnow().isoformat()
                    }
                )
                requirements.append(parsed_req)

        return requirements
```

**파싱 규칙 엔진**:

```python
# backend/src/agents/implementations/parser/parsing_rules.py
from typing import Dict, List, Any, Pattern
import re
from dataclasses import dataclass

@dataclass
class ParsingRule:
    name: str
    pattern: Pattern
    extractor: callable
    category: str
    priority: int

class ParsingRuleEngine:
    """요구사항 파싱 규칙 엔진"""

    def __init__(self):
        self.rules = self._initialize_rules()
        self.keyword_mappings = self._load_keyword_mappings()

    def _initialize_rules(self) -> List[ParsingRule]:
        """파싱 규칙 초기화"""
        return [
            # 성능 요구사항 규칙
            ParsingRule(
                name="performance_requirement",
                pattern=re.compile(
                    r'(should|must|need to)\s+(respond|load|process|handle)'
                    r'.*?within\s+(\d+)\s*(ms|milliseconds|seconds|s)',
                    re.IGNORECASE
                ),
                extractor=self._extract_performance_requirement,
                category="performance",
                priority=1
            ),

            # 사용자 수 요구사항
            ParsingRule(
                name="user_capacity",
                pattern=re.compile(
                    r'(support|handle|accommodate)\s+'
                    r'(up to\s+)?(\d+[,\d]*)\s+'
                    r'(concurrent\s+)?(users|connections|requests)',
                    re.IGNORECASE
                ),
                extractor=self._extract_capacity_requirement,
                category="scalability",
                priority=1
            ),

            # API 엔드포인트 규칙
            ParsingRule(
                name="api_endpoint",
                pattern=re.compile(
                    r'(GET|POST|PUT|DELETE|PATCH)\s+'
                    r'(/[\w/\-{}]+)',
                    re.IGNORECASE
                ),
                extractor=self._extract_api_endpoint,
                category="api",
                priority=2
            ),

            # 데이터 모델 규칙
            ParsingRule(
                name="data_model",
                pattern=re.compile(
                    r'(entity|model|table|collection)\s+'
                    r'["\']?(\w+)["\']?\s+'
                    r'(with|contains|has)\s+'
                    r'(fields?|attributes?|properties?):?\s*'
                    r'([^.]+)',
                    re.IGNORECASE
                ),
                extractor=self._extract_data_model,
                category="data",
                priority=2
            ),

            # 보안 요구사항 규칙
            ParsingRule(
                name="security_requirement",
                pattern=re.compile(
                    r'(require|implement|use|enable)\s+'
                    r'(authentication|authorization|encryption|ssl|tls|oauth|jwt)',
                    re.IGNORECASE
                ),
                extractor=self._extract_security_requirement,
                category="security",
                priority=1
            )
        ]

    def apply_rules(self, text: str) -> Dict[str, List[Any]]:
        """텍스트에 규칙 적용"""
        results = {
            'performance': [],
            'scalability': [],
            'api': [],
            'data': [],
            'security': [],
            'other': []
        }

        # 우선순위 순으로 규칙 적용
        sorted_rules = sorted(self.rules, key=lambda r: r.priority)

        for rule in sorted_rules:
            matches = rule.pattern.finditer(text)
            for match in matches:
                extracted = rule.extractor(match, text)
                if extracted:
                    results[rule.category].append(extracted)

        return results
```

**검증 기준**:

- [ ] 다양한 형식의 요구사항 파싱
- [ ] 구조화된 데이터 출력
- [ ] 파싱 규칙 엔진 동작
- [ ] 멀티 모델 협업 구현

#### SubTask 4.21.2: 자연어 처리 파이프라인 구현

**담당자**: NLP 엔지니어  
**예상 소요시간**: 12시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser/nlp_pipeline.py
from typing import List, Dict, Any, Tuple
import spacy
import nltk
from transformers import pipeline
import asyncio
from dataclasses import dataclass

@dataclass
class NLPResult:
    tokens: List[str]
    entities: List[Dict[str, Any]]
    dependencies: List[Tuple[str, str, str]]
    sentiment: Dict[str, float]
    key_phrases: List[str]
    intent: str
    modality: str  # must, should, could, won't

class NLPPipeline:
    """자연어 처리 파이프라인"""

    def __init__(self):
        # SpaCy 모델 로드
        self.nlp = spacy.load("en_core_web_lg")

        # 추가 NLP 컴포넌트
        self.ner_pipeline = pipeline("ner", model="dbmdz/bert-large-cased-finetuned-conll03-english")
        self.sentiment_pipeline = pipeline("sentiment-analysis")
        self.summarization_pipeline = pipeline("summarization", model="facebook/bart-large-cnn")

        # 커스텀 컴포넌트
        self.requirement_classifier = RequirementClassifier()
        self.modality_detector = ModalityDetector()
        self.domain_entity_recognizer = DomainEntityRecognizer()

        # NLTK 설정
        nltk.download('punkt', quiet=True)
        nltk.download('stopwords', quiet=True)
        nltk.download('wordnet', quiet=True)

    async def process_text(self, text: str) -> NLPResult:
        """텍스트 NLP 처리"""
        # 병렬 처리를 위한 태스크 생성
        tasks = [
            self._tokenize_and_parse(text),
            self._extract_entities(text),
            self._analyze_sentiment(text),
            self._extract_key_phrases(text),
            self._classify_intent(text),
            self._detect_modality(text)
        ]

        results = await asyncio.gather(*tasks)

        return NLPResult(
            tokens=results[0]['tokens'],
            entities=results[1],
            dependencies=results[0]['dependencies'],
            sentiment=results[2],
            key_phrases=results[3],
            intent=results[4],
            modality=results[5]
        )

    async def _tokenize_and_parse(self, text: str) -> Dict[str, Any]:
        """토큰화 및 구문 분석"""
        doc = self.nlp(text)

        tokens = [token.text for token in doc]
        pos_tags = [(token.text, token.pos_) for token in doc]
        dependencies = [(token.text, token.dep_, token.head.text) for token in doc]

        # 문장 분리
        sentences = [sent.text.strip() for sent in doc.sents]

        return {
            'tokens': tokens,
            'pos_tags': pos_tags,
            'dependencies': dependencies,
            'sentences': sentences
        }

    async def _extract_entities(self, text: str) -> List[Dict[str, Any]]:
        """개체명 인식"""
        # SpaCy NER
        doc = self.nlp(text)
        spacy_entities = [
            {
                'text': ent.text,
                'label': ent.label_,
                'start': ent.start_char,
                'end': ent.end_char
            }
            for ent in doc.ents
        ]

        # Transformer 기반 NER
        transformer_entities = self.ner_pipeline(text)

        # 도메인 특화 엔티티
        domain_entities = await self.domain_entity_recognizer.recognize(text)

        # 결과 병합 및 중복 제거
        all_entities = self._merge_entities(
            spacy_entities,
            transformer_entities,
            domain_entities
        )

        return all_entities

    async def _extract_key_phrases(self, text: str) -> List[str]:
        """핵심 구문 추출"""
        doc = self.nlp(text)

        # 명사구 추출
        noun_phrases = [chunk.text for chunk in doc.noun_chunks]

        # TF-IDF 기반 키워드 추출
        tfidf_keywords = self._extract_tfidf_keywords(text)

        # RAKE 알고리즘
        rake_keywords = self._extract_rake_keywords(text)

        # 결합 및 순위 매기기
        all_phrases = list(set(noun_phrases + tfidf_keywords + rake_keywords))
        ranked_phrases = self._rank_phrases(all_phrases, text)

        return ranked_phrases[:20]  # 상위 20개

    def _extract_requirement_patterns(self, text: str) -> List[Dict[str, Any]]:
        """요구사항 패턴 추출"""
        patterns = []

        # RFC 2119 키워드 (MUST, SHOULD, MAY 등)
        rfc_pattern = r'\b(MUST|SHALL|SHOULD|MAY|REQUIRED|RECOMMENDED|OPTIONAL)\b'

        # 요구사항 표현 패턴
        requirement_patterns = [
            r'(system|application|user)\s+(shall|must|should|will)\s+([^.]+)',
            r'(need|require|want)\s+to\s+([^.]+)',
            r'(it\s+is\s+)?(required|necessary|important)\s+(that|to)\s+([^.]+)',
            r'(ensure|make sure|guarantee)\s+(that\s+)?([^.]+)'
        ]

        for pattern in requirement_patterns:
            matches = re.finditer(pattern, text, re.IGNORECASE)
            for match in matches:
                patterns.append({
                    'pattern': pattern,
                    'match': match.group(),
                    'groups': match.groups(),
                    'position': match.span()
                })

        return patterns
```

**도메인 특화 엔티티 인식기**:

```python
# backend/src/agents/implementations/parser/domain_entity_recognizer.py
class DomainEntityRecognizer:
    """도메인 특화 엔티티 인식"""

    def __init__(self):
        self.domain_patterns = {
            'ui_component': [
                r'\b(button|form|input|dropdown|modal|navbar|sidebar|menu|table|list|grid|card)\b',
                r'\b(header|footer|section|container|wrapper|layout)\b'
            ],
            'api_component': [
                r'\b(endpoint|route|api|rest|graphql|webhook|websocket)\b',
                r'\b(request|response|payload|parameter|query|body)\b'
            ],
            'database': [
                r'\b(database|table|collection|schema|index|query|transaction)\b',
                r'\b(sql|nosql|mongodb|postgres|mysql|redis)\b'
            ],
            'authentication': [
                r'\b(auth|authentication|authorization|login|logout|session|token)\b',
                r'\b(oauth|jwt|sso|ldap|saml|2fa|mfa)\b'
            ],
            'deployment': [
                r'\b(deploy|deployment|docker|kubernetes|container|ci/cd)\b',
                r'\b(aws|azure|gcp|cloud|server|hosting)\b'
            ]
        }

    async def recognize(self, text: str) -> List[Dict[str, Any]]:
        """도메인 엔티티 인식"""
        entities = []

        for domain, patterns in self.domain_patterns.items():
            for pattern in patterns:
                matches = re.finditer(pattern, text, re.IGNORECASE)
                for match in matches:
                    entities.append({
                        'text': match.group(),
                        'label': f'DOMAIN_{domain.upper()}',
                        'start': match.start(),
                        'end': match.end(),
                        'confidence': 0.9
                    })

        # 컨텍스트 기반 검증
        validated_entities = await self._validate_with_context(entities, text)

        return validated_entities
```

**검증 기준**:

- [ ] SpaCy 통합 완료
- [ ] 멀티 모델 NER 구현
- [ ] 도메인 특화 인식 동작
- [ ] 병렬 처리 최적화

#### SubTask 4.21.3: 요구사항 분류 및 우선순위 시스템

**담당자**: 백엔드 개발자  
**예상 소요시간**: 10시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser/requirement_classifier.py
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
import joblib
import numpy as np
from typing import List, Dict, Any, Tuple

class RequirementClassifier:
    """요구사항 분류 및 우선순위 결정"""

    def __init__(self):
        # 사전 훈련된 분류 모델 로드
        self.type_classifier = self._load_type_classifier()
        self.priority_classifier = self._load_priority_classifier()
        self.category_classifier = self._load_category_classifier()

        # TF-IDF 벡터라이저
        self.vectorizer = TfidfVectorizer(
            max_features=1000,
            ngram_range=(1, 3),
            stop_words='english'
        )

        # 우선순위 규칙 엔진
        self.priority_rules = PriorityRuleEngine()

        # 의존성 분석기
        self.dependency_analyzer = DependencyAnalyzer()

    async def classify_requirements(
        self,
        requirements: List[str],
        context: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        """요구사항 분류"""
        classified_requirements = []

        # 벡터화
        if requirements:
            vectors = self.vectorizer.fit_transform(requirements)
        else:
            return []

        # 병렬 분류
        tasks = []
        for idx, req in enumerate(requirements):
            task = self._classify_single_requirement(
                req,
                vectors[idx],
                context
            )
            tasks.append(task)

        results = await asyncio.gather(*tasks)

        # 의존성 분석
        dependency_graph = await self.dependency_analyzer.analyze(results)

        # 우선순위 조정
        adjusted_results = self._adjust_priorities(results, dependency_graph)

        return adjusted_results

    async def _classify_single_requirement(
        self,
        requirement: str,
        vector: Any,
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """단일 요구사항 분류"""

        # 타입 분류
        req_type = self.type_classifier.predict(vector)[0]
        type_proba = self.type_classifier.predict_proba(vector)[0]

        # 카테고리 분류
        category = self.category_classifier.predict(vector)[0]
        category_proba = self.category_classifier.predict_proba(vector)[0]

        # 우선순위 예측
        base_priority = self.priority_classifier.predict(vector)[0]

        # 규칙 기반 우선순위 조정
        adjusted_priority = await self.priority_rules.adjust_priority(
            requirement,
            base_priority,
            context
        )

        # 복잡도 추정
        complexity = self._estimate_complexity(requirement, vector)

        return {
            'requirement': requirement,
            'type': req_type,
            'type_confidence': float(max(type_proba)),
            'category': category,
            'category_confidence': float(max(category_proba)),
            'priority': adjusted_priority,
            'complexity': complexity,
            'metadata': {
                'keywords': self._extract_keywords(requirement),
                'estimated_effort': self._estimate_effort(complexity),
                'risk_level': self._assess_risk(requirement, context)
            }
        }

    def _estimate_complexity(self, requirement: str, vector: Any) -> str:
        """복잡도 추정"""
        # 복잡도 지표
        indicators = {
            'simple': ['basic', 'simple', 'standard', 'common'],
            'medium': ['integrate', 'connect', 'process', 'manage'],
            'complex': ['optimize', 'scale', 'distributed', 'real-time'],
            'very_complex': ['ai', 'machine learning', 'blockchain', 'quantum']
        }

        requirement_lower = requirement.lower()
        scores = {}

        for level, keywords in indicators.items():
            score = sum(1 for keyword in keywords if keyword in requirement_lower)
            scores[level] = score

        # 벡터 기반 복잡도 추가
        vector_complexity = self._calculate_vector_complexity(vector)

        # 최종 복잡도 결정
        if vector_complexity > 0.8 or scores.get('very_complex', 0) > 0:
            return 'very_complex'
        elif vector_complexity > 0.6 or scores.get('complex', 0) > 1:
            return 'complex'
        elif vector_complexity > 0.3 or scores.get('medium', 0) > 1:
            return 'medium'
        else:
            return 'simple'
```

**우선순위 규칙 엔진**:

```python
# backend/src/agents/implementations/parser/priority_rules.py
class PriorityRuleEngine:
    """우선순위 결정 규칙 엔진"""

    def __init__(self):
        self.rules = [
            SecurityPriorityRule(),
            CompliancePriorityRule(),
            PerformancePriorityRule(),
            UserImpactPriorityRule(),
            BusinessValuePriorityRule(),
            TechnicalDebtPriorityRule()
        ]

    async def adjust_priority(
        self,
        requirement: str,
        base_priority: str,
        context: Dict[str, Any]
    ) -> str:
        """규칙 기반 우선순위 조정"""

        priority_scores = {
            'critical': 4,
            'high': 3,
            'medium': 2,
            'low': 1
        }

        current_score = priority_scores.get(base_priority, 2)
        adjustments = []

        # 각 규칙 적용
        for rule in self.rules:
            adjustment = await rule.evaluate(requirement, context)
            if adjustment != 0:
                adjustments.append({
                    'rule': rule.name,
                    'adjustment': adjustment,
                    'reason': rule.last_reason
                })
                current_score += adjustment

        # 점수를 우선순위로 변환
        final_priority = self._score_to_priority(current_score)

        return final_priority

    def _score_to_priority(self, score: float) -> str:
        """점수를 우선순위로 변환"""
        if score >= 4:
            return 'critical'
        elif score >= 3:
            return 'high'
        elif score >= 2:
            return 'medium'
        else:
            return 'low'

class SecurityPriorityRule:
    """보안 관련 우선순위 규칙"""

    name = "security"

    def __init__(self):
        self.security_keywords = [
            'security', 'authentication', 'authorization',
            'encryption', 'vulnerability', 'exploit',
            'password', 'access control', 'data protection'
        ]
        self.last_reason = ""

    async def evaluate(self, requirement: str, context: Dict[str, Any]) -> float:
        """보안 요구사항 평가"""
        requirement_lower = requirement.lower()

        # 보안 키워드 확인
        security_mentions = sum(
            1 for keyword in self.security_keywords
            if keyword in requirement_lower
        )

        if security_mentions > 2:
            self.last_reason = "Multiple security concerns identified"
            return 1.5
        elif security_mentions > 0:
            self.last_reason = "Security requirement detected"
            return 0.5

        # 컨텍스트에서 보안 중요도 확인
        if context.get('security_critical', False):
            self.last_reason = "Project marked as security critical"
            return 1.0

        return 0
```

**검증 기준**:

- [ ] 요구사항 타입 분류 정확도 90% 이상
- [ ] 우선순위 자동 결정
- [ ] 복잡도 추정 구현
- [ ] 의존성 분석 동작

#### SubTask 4.21.4: Parser Agent 통합 테스트

**담당자**: QA 엔지니어  
**예상 소요시간**: 12시간

**작업 내용**:

```python
# backend/tests/agents/parser/test_parser_integration.py
import pytest
import asyncio
from typing import Dict, Any, List

@pytest.mark.integration
class TestParserAgentIntegration:
    """Parser Agent 통합 테스트"""

    @pytest.fixture
    async def parser_agent(self):
        """Parser Agent 인스턴스"""
        from parser_agent import ParserAgent

        agent = ParserAgent()
        await agent.initialize()
        yield agent
        await agent.cleanup()

    @pytest.fixture
    def test_requirements(self):
        """다양한 테스트 요구사항"""
        return [
            {
                "name": "E-commerce Platform",
                "description": """
                We need to build a modern e-commerce platform that supports multiple vendors.

                The system MUST support user registration and authentication using OAuth 2.0.
                Users SHALL be able to browse products, add items to cart, and checkout.

                The platform SHOULD handle at least 10,000 concurrent users and respond
                within 200ms for product searches. Payment processing MUST be PCI compliant.

                Key features include:
                - Product catalog with categories and filters
                - Shopping cart with session persistence
                - Order management system
                - Inventory tracking with real-time updates
                - Customer reviews and ratings
                - Admin dashboard for vendors

                The system will integrate with Stripe for payments, SendGrid for emails,
                and use PostgreSQL for the main database with Redis for caching.

                Mobile apps for iOS and Android are required, using React Native.
                The web frontend should be built with Next.js for SEO optimization.

                API endpoints needed:
                - GET /api/products?category={category}&page={page}
                - POST /api/cart/items
                - PUT /api/orders/{orderId}/status
                - DELETE /api/cart/items/{itemId}

                Data models:
                - User entity with fields: id, email, name, password_hash, created_at
                - Product entity with fields: id, name, description, price, stock_quantity
                - Order entity with fields: id, user_id, total_amount, status, created_at
                """,
                "expected_counts": {
                    "functional_requirements": 15,
                    "non_functional_requirements": 5,
                    "technical_requirements": 8,
                    "api_endpoints": 4,
                    "data_models": 3
                }
            },
            {
                "name": "Healthcare Management System",
                "description": """
                Develop a HIPAA-compliant healthcare management system for clinics.

                CRITICAL REQUIREMENTS:
                - All patient data MUST be encrypted at rest and in transit
                - System MUST maintain audit logs for all data access
                - Role-based access control is REQUIRED

                The system should support appointment scheduling, patient records,
                prescription management, and billing. Integration with insurance
                providers is needed via HL7 FHIR standards.

                Performance requirements:
                - Support 500 concurrent users per clinic
                - Database queries must return within 100ms
                - 99.9% uptime SLA required
                - Automated backups every 6 hours
                """,
                "expected_counts": {
                    "functional_requirements": 8,
                    "non_functional_requirements": 7,
                    "constraints": 4,
                    "business_requirements": 3
                }
            }
        ]

    @pytest.mark.asyncio
    async def test_comprehensive_parsing(self, parser_agent, test_requirements):
        """포괄적인 파싱 테스트"""

        for test_case in test_requirements:
            # 요구사항 파싱
            result = await parser_agent.parse_requirements(
                test_case["description"],
                project_context={
                    "name": test_case["name"],
                    "domain": "e-commerce" if "e-commerce" in test_case["name"] else "healthcare"
                }
            )

            # 기본 구조 검증
            assert result.project_info is not None
            assert len(result.functional_requirements) > 0

            # 예상 카운트 검증
            expected = test_case["expected_counts"]

            if "functional_requirements" in expected:
                assert len(result.functional_requirements) >= expected["functional_requirements"] * 0.8

            if "api_endpoints" in expected:
                assert len(result.api_specifications) >= expected["api_endpoints"]

            if "data_models" in expected:
                assert len(result.data_models) >= expected["data_models"]

            # 각 요구사항 검증
            for req in result.functional_requirements:
                assert req.id is not None
                assert req.description != ""
                assert req.priority in ['critical', 'high', 'medium', 'low']
                assert req.type == RequirementType.FUNCTIONAL

    @pytest.mark.asyncio
    async def test_nlp_accuracy(self, parser_agent):
        """NLP 처리 정확도 테스트"""

        test_sentences = [
            {
                "text": "The system MUST authenticate users with JWT tokens",
                "expected_modality": "must",
                "expected_entities": ["JWT"],
                "expected_category": "security"
            },
            {
                "text": "Response time SHOULD be under 200ms for API calls",
                "expected_modality": "should",
                "expected_entities": ["200ms", "API"],
                "expected_category": "performance"
            }
        ]

        for test in test_sentences:
            result = await parser_agent._process_single_requirement(test["text"])

            assert result["modality"] == test["expected_modality"]
            assert result["category"] == test["expected_category"]

            # 엔티티 확인
            found_entities = [e["text"] for e in result["entities"]]
            for expected_entity in test["expected_entities"]:
                assert any(expected_entity in entity for entity in found_entities)

    @pytest.mark.asyncio
    async def test_dependency_analysis(self, parser_agent):
        """의존성 분석 테스트"""

        requirements_with_dependencies = """
        1. User authentication system with OAuth 2.0
        2. User profile management (depends on authentication)
        3. Shopping cart functionality
        4. Order processing (depends on cart and payment)
        5. Payment integration with Stripe
        6. Email notifications (depends on user profile)
        """

        result = await parser_agent.parse_requirements(requirements_with_dependencies)

        # 의존성 그래프 확인
        dependencies = {}
        for req in result.functional_requirements:
            if req.dependencies:
                dependencies[req.id] = req.dependencies

        # 예상 의존성 확인
        assert len(dependencies) >= 3

        # Order processing이 cart와 payment에 의존하는지 확인
        order_req = next(
            (r for r in result.functional_requirements if "order" in r.description.lower()),
            None
        )
        assert order_req is not None
        assert len(order_req.dependencies) >= 2
```

**성능 테스트**:

```python
# backend/tests/agents/parser/test_parser_performance.py
import time
import statistics

class TestParserPerformance:
    """Parser Agent 성능 테스트"""

    @pytest.mark.performance
    async def test_parsing_speed(self, parser_agent):
        """파싱 속도 테스트"""

        # 다양한 길이의 요구사항
        test_texts = [
            "Simple requirement" * 10,  # 짧은 텍스트
            "Medium complexity requirement with details" * 50,  # 중간
            "Complex requirement with multiple sections" * 200  # 긴 텍스트
        ]

        parsing_times = []

        for text in test_texts:
            start_time = time.time()
            await parser_agent.parse_requirements(text)
            elapsed = time.time() - start_time
            parsing_times.append(elapsed)

        # 성능 메트릭
        avg_time = statistics.mean(parsing_times)
        max_time = max(parsing_times)

        # 성능 기준
        assert avg_time < 2.0  # 평균 2초 이내
        assert max_time < 5.0  # 최대 5초 이내

    @pytest.mark.performance
    async def test_concurrent_parsing(self, parser_agent):
        """동시 파싱 성능 테스트"""

        num_concurrent = 20
        test_requirement = "Build a web application with user authentication"

        async def parse_task():
            return await parser_agent.parse_requirements(test_requirement)

        start_time = time.time()
        tasks = [parse_task() for _ in range(num_concurrent)]
        results = await asyncio.gather(*tasks)
        total_time = time.time() - start_time

        # 모든 결과가 성공적으로 반환되었는지 확인
        assert len(results) == num_concurrent
        assert all(r is not None for r in results)

        # 동시 처리 성능 확인 (20개 요청이 10초 이내)
        assert total_time < 10.0
```

**검증 기준**:

- [ ] 모든 테스트 케이스 통과
- [ ] NLP 정확도 85% 이상
- [ ] 의존성 분석 정확도
- [ ] 성능 목표 달성

### Task 4.22: Parser Agent 요구사항 분석 기능

#### SubTask 4.22.1: 기능/비기능 요구사항 분리기

**담당자**: 요구사항 분석가  
**예상 소요시간**: 10시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser/requirement_separator.py
from typing import List, Dict, Any, Tuple
from dataclasses import dataclass
from enum import Enum
import re

class RequirementSeparator:
    """기능/비기능 요구사항 분리기"""

    def __init__(self):
        # 비기능 요구사항 패턴
        self.nfr_patterns = {
            'performance': [
                r'(response time|latency|throughput|speed|performance)',
                r'within\s+\d+\s*(ms|milliseconds|seconds)',
                r'(handle|support)\s+\d+\s*(users|requests|transactions)',
                r'(fast|quick|rapid|efficient|optimize)'
            ],
            'security': [
                r'(secure|security|encrypt|authentication|authorization)',
                r'(protect|safeguard|defend|shield)',
                r'(compliance|compliant|conform|adhere)',
                r'(vulnerability|threat|risk|attack)'
            ],
            'scalability': [
                r'(scale|scalable|scalability|elastic)',
                r'(grow|expand|extend|increase)',
                r'(concurrent|simultaneous|parallel)',
                r'(distributed|cluster|load balance)'
            ],
            'reliability': [
                r'(reliable|reliability|availability|uptime)',
                r'(fault tolerant|failover|redundancy|backup)',
                r'(recover|recovery|resilient|robust)',
                r'\d+(\.\d+)?%\s*(uptime|availability|SLA)'
            ],
            'usability': [
                r'(user friendly|easy to use|intuitive|simple)',
                r'(accessibility|accessible|WCAG|ADA)',
                r'(responsive|mobile|cross-platform)',
                r'(user experience|UX|user interface|UI)'
            ],
            'maintainability': [
                r'(maintainable|maintainability|modular|extensible)',
                r'(documented|documentation|readable|clean code)',
                r'(testable|test coverage|unit test)',
                r'(refactor|technical debt|code quality)'
            ]
        }

        # 기능 요구사항 패턴
        self.fr_patterns = [
            r'(user|system|application)\s+(shall|must|should|can|will)\s+',
            r'(feature|function|capability|ability)\s+',
            r'(create|read|update|delete|manage|process)',
            r'(display|show|present|render|visualize)',
            r'(calculate|compute|generate|produce|transform)'
        ]

    async def separate_requirements(
        self,
        requirements: List[str],
        context: Optional[Dict[str, Any]] = None
    ) -> Tuple[List[ParsedRequirement], List[ParsedRequirement]]:
        """요구사항을 기능/비기능으로 분리"""

        functional_reqs = []
        non_functional_reqs = []

        for req_text in requirements:
            # 요구사항 타입 결정
            req_type = await self._determine_requirement_type(req_text)

            # 세부 분석
            if req_type == 'functional':
                parsed_req = await self._parse_functional_requirement(req_text)
                functional_reqs.append(parsed_req)
            else:
                parsed_req = await self._parse_non_functional_requirement(
                    req_text,
                    req_type
                )
                non_functional_reqs.append(parsed_req)

        # 교차 검증
        validated_functional, validated_non_functional = await self._cross_validate(
            functional_reqs,
            non_functional_reqs
        )

        return validated_functional, validated_non_functional

    async def _determine_requirement_type(self, text: str) -> str:
        """요구사항 타입 결정"""
        text_lower = text.lower()

        # NFR 점수 계산
        nfr_scores = {}
        for category, patterns in self.nfr_patterns.items():
            score = 0
            for pattern in patterns:
                if re.search(pattern, text_lower):
                    score += 1
            nfr_scores[category] = score

        # FR 점수 계산
        fr_score = 0
        for pattern in self.fr_patterns:
            if re.search(pattern, text_lower):
                fr_score += 1

        # 최고 NFR 점수
        max_nfr_category = max(nfr_scores, key=nfr_scores.get)
        max_nfr_score = nfr_scores[max_nfr_category]

        # 타입 결정
        if max_nfr_score > fr_score and max_nfr_score > 0:
            return max_nfr_category  # NFR 카테고리 반환
        else:
            return 'functional'

    async def _parse_functional_requirement(
        self,
        text: str
    ) -> ParsedRequirement:
        """기능 요구사항 파싱"""

        # 액터 추출
        actor = self._extract_actor(text)

        # 동작 추출
        action = self._extract_action(text)

        # 객체 추출
        object_info = self._extract_object(text)

        # 조건 추출
        conditions = self._extract_conditions(text)

        # 수용 기준 생성
        acceptance_criteria = self._generate_acceptance_criteria(
            actor, action, object_info, conditions
        )

        return ParsedRequirement(
            id=self._generate_id('FR'),
            type=RequirementType.FUNCTIONAL,
            category='feature',
            description=text,
            priority='medium',
            acceptance_criteria=acceptance_criteria,
            technical_details={
                'actor': actor,
                'action': action,
                'object': object_info,
                'conditions': conditions
            }
        )

    async def _parse_non_functional_requirement(
        self,
        text: str,
        category: str
    ) -> ParsedRequirement:
        """비기능 요구사항 파싱"""

        # 메트릭 추출
        metrics = self._extract_metrics(text)

        # 임계값 추출
        thresholds = self._extract_thresholds(text)

        # 조건 추출
        conditions = self._extract_nfr_conditions(text)

        # 측정 방법 결정
        measurement_method = self._determine_measurement_method(
            category,
            metrics,
            text
        )

        return ParsedRequirement(
            id=self._generate_id('NFR'),
            type=RequirementType.NON_FUNCTIONAL,
            category=category,
            description=text,
            priority=self._determine_nfr_priority(category, metrics),
            acceptance_criteria=self._generate_nfr_acceptance_criteria(
                category,
                metrics,
                thresholds
            ),
            technical_details={
                'metrics': metrics,
                'thresholds': thresholds,
                'conditions': conditions,
                'measurement_method': measurement_method
            }
        )
```

**메트릭 추출기**:

```python
# backend/src/agents/implementations/parser/metric_extractor.py
class MetricExtractor:
    """요구사항에서 메트릭 추출"""

    def __init__(self):
        self.metric_patterns = {
            'time': {
                'pattern': r'(\d+(?:\.\d+)?)\s*(ms|milliseconds?|seconds?|minutes?|hours?)',
                'unit_map': {
                    'ms': 'milliseconds',
                    'millisecond': 'milliseconds',
                    'milliseconds': 'milliseconds',
                    'second': 'seconds',
                    'seconds': 'seconds',
                    'minute': 'minutes',
                    'minutes': 'minutes',
                    'hour': 'hours',
                    'hours': 'hours'
                }
            },
            'percentage': {
                'pattern': r'(\d+(?:\.\d+)?)\s*%',
                'unit': 'percent'
            },
            'count': {
                'pattern': r'(\d+(?:,\d{3})*|\d+)\s*(users?|requests?|transactions?|connections?)',
                'unit_map': {
                    'user': 'users',
                    'users': 'users',
                    'request': 'requests',
                    'requests': 'requests',
                    'transaction': 'transactions',
                    'transactions': 'transactions',
                    'connection': 'connections',
                    'connections': 'connections'
                }
            },
            'data_size': {
                'pattern': r'(\d+(?:\.\d+)?)\s*(KB|MB|GB|TB|bytes?)',
                'unit_map': {
                    'byte': 'bytes',
                    'bytes': 'bytes',
                    'KB': 'kilobytes',
                    'MB': 'megabytes',
                    'GB': 'gigabytes',
                    'TB': 'terabytes'
                }
            },
            'frequency': {
                'pattern': r'(\d+)\s*(?:times?\s*)?(?:per|/)\s*(second|minute|hour|day)',
                'unit': 'per_time'
            }
        }

    def extract_metrics(self, text: str) -> List[Dict[str, Any]]:
        """텍스트에서 메트릭 추출"""
        metrics = []

        for metric_type, config in self.metric_patterns.items():
            pattern = config['pattern']
            matches = re.finditer(pattern, text, re.IGNORECASE)

            for match in matches:
                value = match.group(1)

                # 숫자 변환
                numeric_value = self._parse_number(value)

                # 단위 추출
                if 'unit_map' in config:
                    raw_unit = match.group(2).lower()
                    unit = config['unit_map'].get(raw_unit, raw_unit)
                elif 'unit' in config:
                    unit = config['unit']
                else:
                    unit = match.group(2) if match.lastindex >= 2 else None

                metrics.append({
                    'type': metric_type,
                    'value': numeric_value,
                    'unit': unit,
                    'raw_text': match.group(0),
                    'position': match.span()
                })

        return metrics

    def _parse_number(self, text: str) -> float:
        """숫자 텍스트를 float로 변환"""
        # 쉼표 제거
        text = text.replace(',', '')

        try:
            return float(text)
        except ValueError:
            return 0.0
```

**검증 기준**:

- [ ] 기능/비기능 분리 정확도 90% 이상
- [ ] 메트릭 추출 정확도
- [ ] 수용 기준 자동 생성
- [ ] 카테고리별 분류 동작

#### SubTask 4.22.2: 사용자 스토리 생성기

**담당자**: 비즈니스 분석가  
**예상 소요시간**: 12시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser/user_story_generator.py
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import re

@dataclass
class UserStory:
    id: str
    title: str
    narrative: str  # As a... I want... So that...
    acceptance_criteria: List[str]
    story_points: Optional[int]
    priority: str
    epic: Optional[str]
    technical_notes: List[str]
    dependencies: List[str]

class UserStoryGenerator:
    """사용자 스토리 자동 생성기"""

    def __init__(self):
        self.story_templates = {
            'authentication': {
                'template': "As a {actor}, I want to {action} so that {benefit}",
                'common_actions': [
                    'sign up with email',
                    'log in securely',
                    'reset my password',
                    'enable two-factor authentication'
                ]
            },
            'data_management': {
                'template': "As a {actor}, I want to {action} {object} so that {benefit}",
                'common_actions': [
                    'create new',
                    'view existing',
                    'update',
                    'delete',
                    'search for',
                    'filter',
                    'export'
                ]
            },
            'workflow': {
                'template': "As a {actor}, I want to {action} so that {benefit}",
                'common_actions': [
                    'approve requests',
                    'receive notifications',
                    'track progress',
                    'collaborate with team'
                ]
            }
        }

        self.story_point_estimator = StoryPointEstimator()
        self.acceptance_criteria_generator = AcceptanceCriteriaGenerator()

    async def generate_user_stories(
        self,
        requirements: List[ParsedRequirement],
        project_context: Dict[str, Any]
    ) -> List[UserStory]:
        """요구사항에서 사용자 스토리 생성"""

        user_stories = []
        story_counter = 1

        # 액터 식별
        actors = await self._identify_actors(requirements, project_context)

        # 에픽 그룹화
        epics = await self._group_into_epics(requirements)

        for req in requirements:
            if req.type == RequirementType.FUNCTIONAL:
                # 요구사항을 여러 스토리로 분해
                stories = await self._decompose_requirement(
                    req,
                    actors,
                    epics
                )

                for story_data in stories:
                    # 스토리 생성
                    story = UserStory(
                        id=f"US-{story_counter:04d}",
                        title=story_data['title'],
                        narrative=story_data['narrative'],
                        acceptance_criteria=await self.acceptance_criteria_generator.generate(
                            story_data,
                            req
                        ),
                        story_points=await self.story_point_estimator.estimate(
                            story_data,
                            req
                        ),
                        priority=self._inherit_priority(req.priority),
                        epic=story_data.get('epic'),
                        technical_notes=self._extract_technical_notes(req),
                        dependencies=self._identify_dependencies(req, requirements)
                    )

                    user_stories.append(story)
                    story_counter += 1

        # 스토리 간 관계 분석
        user_stories = await self._analyze_story_relationships(user_stories)

        return user_stories

    async def _decompose_requirement(
        self,
        requirement: ParsedRequirement,
        actors: List[str],
        epics: Dict[str, List[ParsedRequirement]]
    ) -> List[Dict[str, Any]]:
        """요구사항을 사용자 스토리로 분해"""

        stories = []

        # 요구사항 분석
        req_analysis = await self._analyze_requirement_for_stories(
            requirement.description
        )

        # 각 액터별로 스토리 생성
        for actor in self._get_relevant_actors(requirement, actors):
            for action in req_analysis['actions']:
                # 스토리 내러티브 생성
                narrative = await self._create_narrative(
                    actor,
                    action,
                    req_analysis['benefits']
                )

                # 스토리 제목 생성
                title = self._create_story_title(action, req_analysis['object'])

                stories.append({
                    'title': title,
                    'narrative': narrative,
                    'actor': actor,
                    'action': action,
                    'object': req_analysis.get('object'),
                    'benefits': req_analysis['benefits'],
                    'epic': self._find_epic(requirement, epics),
                    'original_requirement': requirement.id
                })

        return stories

    async def _create_narrative(
        self,
        actor: str,
        action: str,
        benefits: List[str]
    ) -> str:
        """사용자 스토리 내러티브 생성"""

        # 기본 템플릿
        template = "As a {actor}, I want to {action} so that {benefit}"

        # 가장 관련성 높은 benefit 선택
        primary_benefit = benefits[0] if benefits else "I can complete my task efficiently"

        # 내러티브 생성
        narrative = template.format(
            actor=actor,
            action=action,
            benefit=primary_benefit
        )

        return narrative

    def _create_story_title(self, action: str, obj: Optional[str]) -> str:
        """스토리 제목 생성"""
        if obj:
            # 동작 + 객체
            title = f"{action.title()} {obj.title()}"
        else:
            # 동작만
            title = action.title()

        # 제목 정리
        title = title.replace('_', ' ').strip()

        # 최대 길이 제한
        if len(title) > 50:
            title = title[:47] + "..."

        return title
```

**수용 기준 생성기**:

```python
# backend/src/agents/implementations/parser/acceptance_criteria_generator.py
class AcceptanceCriteriaGenerator:
    """수용 기준 자동 생성"""

    def __init__(self):
        self.criteria_templates = {
            'given_when_then': {
                'template': "GIVEN {context}\nWHEN {action}\nTHEN {outcome}",
                'priority': 1
            },
            'checklist': {
                'template': "□ {criterion}",
                'priority': 2
            },
            'rule': {
                'template': "The system shall {behavior} when {condition}",
                'priority': 3
            }
        }

    async def generate(
        self,
        story_data: Dict[str, Any],
        requirement: ParsedRequirement
    ) -> List[str]:
        """수용 기준 생성"""

        criteria = []

        # Given-When-Then 형식
        gwt_criteria = await self._generate_gwt_criteria(story_data)
        criteria.extend(gwt_criteria)

        # 체크리스트 형식
        checklist_criteria = await self._generate_checklist_criteria(
            story_data,
            requirement
        )
        criteria.extend(checklist_criteria)

        # 검증 규칙
        validation_rules = await self._generate_validation_rules(
            story_data,
            requirement
        )
        criteria.extend(validation_rules)

        # 중복 제거 및 정렬
        criteria = list(dict.fromkeys(criteria))

        return criteria[:10]  # 최대 10개

    async def _generate_gwt_criteria(
        self,
        story_data: Dict[str, Any]
    ) -> List[str]:
        """Given-When-Then 형식 기준 생성"""

        criteria = []

        # 기본 성공 시나리오
        basic_criterion = (
            f"GIVEN I am a logged-in {story_data['actor']}\n"
            f"WHEN I {story_data['action']}\n"
            f"THEN I should see confirmation of the action"
        )
        criteria.append(basic_criterion)

        # 에러 시나리오
        error_criterion = (
            f"GIVEN I am a {story_data['actor']} with invalid permissions\n"
            f"WHEN I attempt to {story_data['action']}\n"
            f"THEN I should see an error message"
        )
        criteria.append(error_criterion)

        # 데이터 검증 시나리오
        if 'object' in story_data and story_data['object']:
            validation_criterion = (
                f"GIVEN I provide invalid {story_data['object']} data\n"
                f"WHEN I {story_data['action']}\n"
                f"THEN I should see validation errors"
            )
            criteria.append(validation_criterion)

        return criteria
```

**스토리 포인트 추정기**:

```python
class StoryPointEstimator:
    """스토리 포인트 자동 추정"""

    def __init__(self):
        self.complexity_factors = {
            'ui_complexity': {
                'simple': 1,    # 단순 폼, 리스트
                'medium': 2,    # 인터랙티브 UI
                'complex': 3    # 복잡한 대시보드
            },
            'business_logic': {
                'simple': 1,    # CRUD 작업
                'medium': 3,    # 비즈니스 규칙
                'complex': 5    # 복잡한 알고리즘
            },
            'integration': {
                'none': 0,
                'simple': 2,    # 단일 API 호출
                'complex': 5    # 여러 시스템 통합
            },
            'data_complexity': {
                'simple': 1,    # 단일 엔티티
                'medium': 2,    # 여러 엔티티
                'complex': 3    # 복잡한 관계
            }
        }

        self.fibonacci_sequence = [1, 2, 3, 5, 8, 13, 21]

    async def estimate(
        self,
        story_data: Dict[str, Any],
        requirement: ParsedRequirement
    ) -> int:
        """스토리 포인트 추정"""

        # 복잡도 요소 분석
        ui_complexity = await self._assess_ui_complexity(story_data)
        logic_complexity = await self._assess_logic_complexity(story_data)
        integration_complexity = await self._assess_integration_complexity(requirement)
        data_complexity = await self._assess_data_complexity(story_data)

        # 총 복잡도 점수
        total_score = (
            self.complexity_factors['ui_complexity'][ui_complexity] +
            self.complexity_factors['business_logic'][logic_complexity] +
            self.complexity_factors['integration'][integration_complexity] +
            self.complexity_factors['data_complexity'][data_complexity]
        )

        # 피보나치 수열로 매핑
        story_points = self._map_to_fibonacci(total_score)

        return story_points

    def _map_to_fibonacci(self, score: int) -> int:
        """점수를 피보나치 수열로 매핑"""
        if score <= 3:
            return 1
        elif score <= 5:
            return 2
        elif score <= 7:
            return 3
        elif score <= 10:
            return 5
        elif score <= 14:
            return 8
        elif score <= 19:
            return 13
        else:
            return 21
```

**검증 기준**:

- [ ] 사용자 스토리 형식 준수
- [ ] 수용 기준 자동 생성
- [ ] 스토리 포인트 추정 정확도
- [ ] 에픽 그룹화 기능

#### SubTask 4.22.3: 데이터 모델 및 API 추출기

**담당자**: 데이터 아키텍트  
**예상 소요시간**: 12시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser/data_model_extractor.py
from typing import List, Dict, Any, Optional
import re
from dataclasses import dataclass

@dataclass
class DataModel:
    name: str
    fields: List[Dict[str, Any]]
    relationships: List[Dict[str, Any]]
    constraints: List[str]
    indexes: List[str]
    description: Optional[str]

@dataclass
class APIEndpoint:
    method: str
    path: str
    description: str
    parameters: List[Dict[str, Any]]
    request_body: Optional[Dict[str, Any]]
    response: Dict[str, Any]
    authentication: bool
    rate_limit: Optional[str]

class DataModelExtractor:
    """데이터 모델 추출기"""

    def __init__(self):
        self.field_type_mapper = {
            'id': 'uuid',
            'name': 'string',
            'email': 'email',
            'password': 'password',
            'date': 'date',
            'created_at': 'timestamp',
            'updated_at': 'timestamp',
            'price': 'decimal',
            'amount': 'decimal',
            'quantity': 'integer',
            'count': 'integer',
            'status': 'enum',
            'description': 'text',
            'content': 'text',
            'url': 'url',
            'phone': 'phone',
            'address': 'object'
        }

        self.relationship_patterns = [
            r'(\w+)\s+has\s+(many|one)\s+(\w+)',
            r'(\w+)\s+belongs\s+to\s+(\w+)',
            r'(\w+)\s+and\s+(\w+)\s+are\s+related',
            r'(\w+)\s+references?\s+(\w+)'
        ]

    async def extract_data_models(
        self,
        text: str,
        requirements: List[ParsedRequirement]
    ) -> List[DataModel]:
        """텍스트에서 데이터 모델 추출"""

        models = []

        # 명시적 모델 정의 추출
        explicit_models = await self._extract_explicit_models(text)
        models.extend(explicit_models)

        # 암시적 모델 추출
        implicit_models = await self._extract_implicit_models(text, requirements)
        models.extend(implicit_models)

        # 관계 분석
        models = await self._analyze_relationships(models, text)

        # 제약사항 추가
        models = await self._add_constraints(models, requirements)

        # 중복 제거 및 병합
        models = self._merge_duplicate_models(models)

        return models

    async def _extract_explicit_models(self, text: str) -> List[DataModel]:
        """명시적으로 정의된 모델 추출"""

        models = []

        # 패턴: "User entity with fields: id, name, email"
        entity_pattern = r'(\w+)\s+(?:entity|model|table)\s+with\s+fields?:?\s*([^.]+?)(?:\.|$)'

        matches = re.finditer(entity_pattern, text, re.IGNORECASE | re.MULTILINE)

        for match in matches:
            model_name = match.group(1)
            fields_text = match.group(2)

            # 필드 파싱
            fields = await self._parse_fields(fields_text)

            model = DataModel(
                name=model_name,
                fields=fields,
                relationships=[],
                constraints=[],
                indexes=[],
                description=f"Extracted from: {match.group(0)[:100]}..."
            )

            models.append(model)

        return models

    async def _parse_fields(self, fields_text: str) -> List[Dict[str, Any]]:
        """필드 텍스트 파싱"""

        fields = []

        # 필드 분리 (쉼표, 세미콜론, 줄바꿈)
        field_items = re.split(r'[,;\n]', fields_text)

        for item in field_items:
            item = item.strip()
            if not item:
                continue

            # 필드 정보 추출
            field_info = self._extract_field_info(item)
            if field_info:
                fields.append(field_info)

        return fields

    def _extract_field_info(self, field_text: str) -> Optional[Dict[str, Any]]:
        """필드 정보 추출"""

        # 패턴: "field_name (type)" 또는 "field_name: type"
        patterns = [
            r'(\w+)\s*\((\w+)\)',
            r'(\w+)\s*:\s*(\w+)',
            r'(\w+)\s+(\w+)',
            r'(\w+)'  # 타입 없이 이름만
        ]

        for pattern in patterns:
            match = re.match(pattern, field_text.strip())
            if match:
                field_name = match.group(1)
                field_type = match.group(2) if match.lastindex >= 2 else None

                # 타입 추론
                if not field_type:
                    field_type = self._infer_field_type(field_name)

                return {
                    'name': field_name,
                    'type': field_type,
                    'required': self._is_required_field(field_name),
                    'unique': self._is_unique_field(field_name),
                    'indexed': self._should_index_field(field_name)
                }

        return None

    def _infer_field_type(self, field_name: str) -> str:
        """필드 이름에서 타입 추론"""

        field_lower = field_name.lower()

        # 타입 매핑 확인
        for key, type_value in self.field_type_mapper.items():
            if key in field_lower:
                return type_value

        # 기본 타입
        return 'string'
```

**API 추출기**:

```python
# backend/src/agents/implementations/parser/api_extractor.py
class APIExtractor:
    """API 엔드포인트 추출기"""

    def __init__(self):
        self.http_methods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE']
        self.common_paths = {
            'list': '/{resource}',
            'create': '/{resource}',
            'get': '/{resource}/{id}',
            'update': '/{resource}/{id}',
            'delete': '/{resource}/{id}',
            'search': '/{resource}/search',
            'bulk': '/{resource}/bulk'
        }

    async def extract_api_endpoints(
        self,
        text: str,
        data_models: List[DataModel]
    ) -> List[APIEndpoint]:
        """API 엔드포인트 추출"""

        endpoints = []

        # 명시적 API 정의 추출
        explicit_endpoints = await self._extract_explicit_endpoints(text)
        endpoints.extend(explicit_endpoints)

        # 데이터 모델에서 CRUD API 생성
        crud_endpoints = await self._generate_crud_endpoints(data_models)
        endpoints.extend(crud_endpoints)

        # 비즈니스 로직 API 추출
        business_endpoints = await self._extract_business_endpoints(text)
        endpoints.extend(business_endpoints)

        # API 문서 보강
        endpoints = await self._enrich_api_documentation(endpoints, text)

        # 중복 제거
        endpoints = self._deduplicate_endpoints(endpoints)

        return endpoints

    async def _extract_explicit_endpoints(self, text: str) -> List[APIEndpoint]:
        """명시적으로 정의된 API 추출"""

        endpoints = []

        # 패턴: "GET /api/products"
        api_pattern = r'(GET|POST|PUT|PATCH|DELETE)\s+(/[\w/\-{}]+)'

        matches = re.finditer(api_pattern, text, re.IGNORECASE)

        for match in matches:
            method = match.group(1).upper()
            path = match.group(2)

            # 파라미터 추출
            parameters = self._extract_path_parameters(path)

            # 쿼리 파라미터 추출
            query_params = await self._extract_query_parameters(text, path)

            endpoint = APIEndpoint(
                method=method,
                path=path,
                description=self._generate_endpoint_description(method, path),
                parameters=parameters + query_params,
                request_body=self._infer_request_body(method, path),
                response=self._infer_response(method, path),
                authentication=True,  # 기본값
                rate_limit=None
            )

            endpoints.append(endpoint)

        return endpoints

    async def _generate_crud_endpoints(
        self,
        data_models: List[DataModel]
    ) -> List[APIEndpoint]:
        """데이터 모델에서 CRUD API 생성"""

        endpoints = []

        for model in data_models:
            resource_name = self._pluralize(model.name.lower())

            # List/Create
            endpoints.append(APIEndpoint(
                method='GET',
                path=f'/api/{resource_name}',
                description=f'List all {resource_name}',
                parameters=[
                    {'name': 'page', 'type': 'integer', 'required': False},
                    {'name': 'limit', 'type': 'integer', 'required': False},
                    {'name': 'sort', 'type': 'string', 'required': False}
                ],
                request_body=None,
                response={
                    'type': 'array',
                    'items': self._model_to_schema(model)
                },
                authentication=True,
                rate_limit='100/hour'
            ))

            endpoints.append(APIEndpoint(
                method='POST',
                path=f'/api/{resource_name}',
                description=f'Create a new {model.name}',
                parameters=[],
                request_body=self._model_to_schema(model, exclude=['id']),
                response=self._model_to_schema(model),
                authentication=True,
                rate_limit='50/hour'
            ))

            # Get/Update/Delete
            endpoints.append(APIEndpoint(
                method='GET',
                path=f'/api/{resource_name}/{{id}}',
                description=f'Get {model.name} by ID',
                parameters=[
                    {'name': 'id', 'type': 'uuid', 'required': True, 'in': 'path'}
                ],
                request_body=None,
                response=self._model_to_schema(model),
                authentication=True,
                rate_limit='1000/hour'
            ))

            # ... (PUT, DELETE 엔드포인트도 유사하게 생성)

        return endpoints

    def _model_to_schema(
        self,
        model: DataModel,
        exclude: List[str] = None
    ) -> Dict[str, Any]:
        """데이터 모델을 API 스키마로 변환"""

        exclude = exclude or []

        properties = {}
        required = []

        for field in model.fields:
            if field['name'] not in exclude:
                properties[field['name']] = {
                    'type': self._map_field_type_to_json(field['type']),
                    'description': f"{model.name} {field['name']}"
                }

                if field.get('required', False):
                    required.append(field['name'])

        return {
            'type': 'object',
            'properties': properties,
            'required': required
        }
```

**검증 기준**:

- [ ] 데이터 모델 추출 정확도
- [ ] API 엔드포인트 자동 생성
- [ ] 필드 타입 추론 정확도
- [ ] CRUD 패턴 인식

#### SubTask 4.22.4: 요구사항 검증 및 완성도 체크

**담당자**: QA 리드  
**예상 소요시간**: 10시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser/requirement_validator.py
from typing import List, Dict, Any, Set, Tuple
from dataclasses import dataclass
from enum import Enum

class ValidationSeverity(Enum):
    ERROR = "error"
    WARNING = "warning"
    INFO = "info"

@dataclass
class ValidationIssue:
    severity: ValidationSeverity
    category: str
    message: str
    requirement_id: Optional[str]
    suggestion: Optional[str]

class RequirementValidator:
    """요구사항 검증 및 완성도 체크"""

    def __init__(self):
        self.validation_rules = [
            AmbiguityChecker(),
            CompletenessChecker(),
            ConsistencyChecker(),
            FeasibilityChecker(),
            TestabilityChecker(),
            TracabilityChecker()
        ]

        self.quality_metrics = {
            'clarity': 0,
            'completeness': 0,
            'consistency': 0,
            'feasibility': 0,
            'testability': 0,
            'traceability': 0
        }

    async def validate_requirements(
        self,
        parsed_project: ParsedProject
    ) -> Dict[str, Any]:
        """요구사항 전체 검증"""

        validation_results = {
            'issues': [],
            'metrics': {},
            'summary': {},
            'recommendations': []
        }

        # 모든 요구사항 수집
        all_requirements = self._collect_all_requirements(parsed_project)

        # 각 검증 규칙 적용
        for rule in self.validation_rules:
            issues = await rule.validate(all_requirements, parsed_project)
            validation_results['issues'].extend(issues)

        # 품질 메트릭 계산
        validation_results['metrics'] = await self._calculate_quality_metrics(
            all_requirements,
            validation_results['issues']
        )

        # 요약 생성
        validation_results['summary'] = self._generate_summary(
            validation_results['issues'],
            validation_results['metrics']
        )

        # 개선 권장사항
        validation_results['recommendations'] = await self._generate_recommendations(
            validation_results['issues'],
            parsed_project
        )

        return validation_results

    async def _calculate_quality_metrics(
        self,
        requirements: List[ParsedRequirement],
        issues: List[ValidationIssue]
    ) -> Dict[str, float]:
        """품질 메트릭 계산"""

        total_reqs = len(requirements)
        if total_reqs == 0:
            return {metric: 0.0 for metric in self.quality_metrics}

        # 각 카테고리별 이슈 카운트
        issue_counts = {}
        for issue in issues:
            if issue.severity == ValidationSeverity.ERROR:
                issue_counts[issue.category] = issue_counts.get(issue.category, 0) + 1

        # 메트릭 계산
        metrics = {}

        # 명확성 (Clarity)
        ambiguity_issues = issue_counts.get('ambiguity', 0)
        metrics['clarity'] = max(0, 1 - (ambiguity_issues / total_reqs))

        # 완전성 (Completeness)
        missing_count = sum(1 for req in requirements if not req.acceptance_criteria)
        metrics['completeness'] = 1 - (missing_count / total_reqs)

        # 일관성 (Consistency)
        consistency_issues = issue_counts.get('consistency', 0)
        metrics['consistency'] = max(0, 1 - (consistency_issues / total_reqs))

        # 실현가능성 (Feasibility)
        feasibility_issues = issue_counts.get('feasibility', 0)
        metrics['feasibility'] = max(0, 1 - (feasibility_issues / total_reqs))

        # 테스트가능성 (Testability)
        testable_count = sum(1 for req in requirements if req.acceptance_criteria)
        metrics['testability'] = testable_count / total_reqs

        # 추적가능성 (Traceability)
        traced_count = sum(1 for req in requirements if req.id and req.dependencies is not None)
        metrics['traceability'] = traced_count / total_reqs

        # 전체 품질 점수
        metrics['overall'] = sum(metrics.values()) / len(metrics)

        return metrics
```

**검증 규칙 구현**:

```python
# backend/src/agents/implementations/parser/validation_rules.py
class AmbiguityChecker:
    """모호성 검사기"""

    def __init__(self):
        self.ambiguous_terms = [
            'appropriate', 'adequate', 'as needed', 'as required',
            'efficient', 'fast', 'user-friendly', 'intuitive',
            'secure', 'scalable', 'flexible', 'robust',
            'etc', 'and so on', 'various', 'multiple',
            'some', 'many', 'few', 'several'
        ]

        self.vague_quantifiers = [
            'high', 'low', 'good', 'bad', 'acceptable',
            'reasonable', 'sufficient', 'optimal', 'minimal'
        ]

    async def validate(
        self,
        requirements: List[ParsedRequirement],
        project: ParsedProject
    ) -> List[ValidationIssue]:
        """모호한 요구사항 검사"""

        issues = []

        for req in requirements:
            # 모호한 용어 검사
            ambiguous_found = self._check_ambiguous_terms(req.description)
            if ambiguous_found:
                issues.append(ValidationIssue(
                    severity=ValidationSeverity.WARNING,
                    category='ambiguity',
                    message=f"Ambiguous terms found: {', '.join(ambiguous_found)}",
                    requirement_id=req.id,
                    suggestion="Use specific, measurable terms instead"
                ))

            # 정량화되지 않은 요구사항
            if self._lacks_quantification(req):
                issues.append(ValidationIssue(
                    severity=ValidationSeverity.WARNING,
                    category='ambiguity',
                    message="Requirement lacks specific quantification",
                    requirement_id=req.id,
                    suggestion="Add specific numbers, thresholds, or ranges"
                ))

        return issues

    def _check_ambiguous_terms(self, text: str) -> List[str]:
        """모호한 용어 확인"""
        text_lower = text.lower()
        found_terms = []

        for term in self.ambiguous_terms + self.vague_quantifiers:
            if term in text_lower:
                found_terms.append(term)

        return found_terms

class CompletenessChecker:
    """완전성 검사기"""

    async def validate(
        self,
        requirements: List[ParsedRequirement],
        project: ParsedProject
    ) -> List[ValidationIssue]:
        """요구사항 완전성 검사"""

        issues = []

        # 필수 섹션 확인
        if not project.functional_requirements:
            issues.append(ValidationIssue(
                severity=ValidationSeverity.ERROR,
                category='completeness',
                message="No functional requirements found",
                requirement_id=None,
                suggestion="Add functional requirements describing what the system should do"
            ))

        if not project.non_functional_requirements:
            issues.append(ValidationIssue(
                severity=ValidationSeverity.WARNING,
                category='completeness',
                message="No non-functional requirements found",
                requirement_id=None,
                suggestion="Add performance, security, and usability requirements"
            ))

        # 각 요구사항의 완전성 확인
        for req in requirements:
            if not req.acceptance_criteria:
                issues.append(ValidationIssue(
                    severity=ValidationSeverity.WARNING,
                    category='completeness',
                    message="Missing acceptance criteria",
                    requirement_id=req.id,
                    suggestion="Add specific criteria to verify requirement completion"
                ))

            if req.priority == 'TBD' or not req.priority:
                issues.append(ValidationIssue(
                    severity=ValidationSeverity.INFO,
                    category='completeness',
                    message="Priority not assigned",
                    requirement_id=req.id,
                    suggestion="Assign priority: critical, high, medium, or low"
                ))

        return issues
```

**검증 보고서 생성기**:

```python
class ValidationReportGenerator:
    """검증 보고서 생성"""

    async def generate_report(
        self,
        validation_results: Dict[str, Any],
        parsed_project: ParsedProject
    ) -> str:
        """HTML 검증 보고서 생성"""

        report_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Requirements Validation Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .summary { background: #f0f0f0; padding: 15px; border-radius: 5px; }
                .metric { display: inline-block; margin: 10px; }
                .issue { margin: 10px 0; padding: 10px; border-left: 3px solid; }
                .error { border-color: #ff4444; background: #ffeeee; }
                .warning { border-color: #ffaa00; background: #fff8ee; }
                .info { border-color: #0088ff; background: #eef8ff; }
                .chart { width: 100%; height: 300px; }
            </style>
        </head>
        <body>
            <h1>Requirements Validation Report</h1>

            <div class="summary">
                <h2>Summary</h2>
                <p>Total Requirements: {total_requirements}</p>
                <p>Quality Score: {quality_score:.1%}</p>
                <p>Issues Found: {total_issues} ({errors} errors, {warnings} warnings)</p>
            </div>

            <h2>Quality Metrics</h2>
            <div id="metricsChart" class="chart"></div>

            <h2>Issues</h2>
            {issues_html}

            <h2>Recommendations</h2>
            <ul>
                {recommendations_html}
            </ul>

            <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
            <script>
                {chart_script}
            </script>
        </body>
        </html>
        """

        # 데이터 준비
        total_reqs = len(self._collect_all_requirements(parsed_project))
        quality_score = validation_results['metrics'].get('overall', 0)

        issues_by_severity = self._group_issues_by_severity(
            validation_results['issues']
        )

        # HTML 생성
        return report_template.format(
            total_requirements=total_reqs,
            quality_score=quality_score,
            total_issues=len(validation_results['issues']),
            errors=len(issues_by_severity.get('error', [])),
            warnings=len(issues_by_severity.get('warning', [])),
            issues_html=self._generate_issues_html(validation_results['issues']),
            recommendations_html=self._generate_recommendations_html(
                validation_results['recommendations']
            ),
            chart_script=self._generate_chart_script(validation_results['metrics'])
        )
```

**검증 기준**:

- [ ] 모든 검증 규칙 구현
- [ ] 품질 메트릭 계산 정확도
- [ ] 검증 보고서 생성
- [ ] 개선 권장사항 제공

### Task 4.23: Parser Agent 도메인 특화 파싱

#### SubTask 4.23.1: 도메인별 용어 사전 구축

**담당자**: 도메인 전문가  
**예상 소요시간**: 10시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser/domain_dictionary.py
from typing import Dict, List, Any, Set
import json
from dataclasses import dataclass

@dataclass
class DomainTerm:
    term: str
    canonical_form: str
    aliases: List[str]
    definition: str
    category: str
    related_terms: List[str]
    context_examples: List[str]

class DomainDictionary:
    """도메인별 용어 사전"""

    def __init__(self):
        self.dictionaries = {
            'e-commerce': ECommerceDictionary(),
            'healthcare': HealthcareDictionary(),
            'finance': FinanceDictionary(),
            'education': EducationDictionary(),
            'social_media': SocialMediaDictionary(),
            'iot': IoTDictionary(),
            'gaming': GamingDictionary(),
            'enterprise': EnterpriseDictionary()
        }

        self.general_terms = self._load_general_terms()
        self.abbreviations = self._load_abbreviations()

    async def get_domain_terms(
        self,
        domain: str
    ) -> Dict[str, DomainTerm]:
        """특정 도메인의 용어 사전 반환"""

        if domain in self.dictionaries:
            return await self.dictionaries[domain].get_terms()

        # 도메인이 없으면 일반 용어만
        return self.general_terms

    async def expand_term(
        self,
        term: str,
        domain: str,
        context: str
    ) -> DomainTerm:
        """용어 확장 및 정규화"""

        # 도메인 사전에서 검색
        domain_terms = await self.get_domain_terms(domain)

        # 정확한 매치
        if term.lower() in domain_terms:
            return domain_terms[term.lower()]

        # 별칭 검색
        for dt in domain_terms.values():
            if term.lower() in [alias.lower() for alias in dt.aliases]:
                return dt

        # 약어 확장
        if term.upper() in self.abbreviations:
            expanded = self.abbreviations[term.upper()]
            if expanded.lower() in domain_terms:
                return domain_terms[expanded.lower()]

        # 컨텍스트 기반 추론
        inferred_term = await self._infer_from_context(term, context, domain)
        if inferred_term:
            return inferred_term

        # 기본 용어 생성
        return DomainTerm(
            term=term,
            canonical_form=term,
            aliases=[],
            definition="Unknown term",
            category="general",
            related_terms=[],
            context_examples=[]
        )

class ECommerceDictionary:
    """전자상거래 도메인 사전"""

    def __init__(self):
        self.terms = {
            'cart': DomainTerm(
                term='cart',
                canonical_form='shopping_cart',
                aliases=['basket', 'shopping basket', 'bag'],
                definition='Temporary storage for items customer intends to purchase',
                category='customer_feature',
                related_terms=['checkout', 'order', 'wishlist'],
                context_examples=[
                    'add item to cart',
                    'view shopping cart',
                    'empty cart'
                ]
            ),
            'checkout': DomainTerm(
                term='checkout',
                canonical_form='checkout_process',
                aliases=['check out', 'purchase', 'buy'],
                definition='Process of completing a purchase transaction',
                category='transaction',
                related_terms=['payment', 'shipping', 'order'],
                context_examples=[
                    'proceed to checkout',
                    'guest checkout',
                    'express checkout'
                ]
            ),
            'sku': DomainTerm(
                term='sku',
                canonical_form='stock_keeping_unit',
                aliases=['SKU', 'product code', 'item number'],
                definition='Unique identifier for each distinct product and service',
                category='inventory',
                related_terms=['barcode', 'upc', 'product variant'],
                context_examples=[
                    'SKU management',
                    'generate SKU',
                    'SKU tracking'
                ]
            ),
            'fulfillment': DomainTerm(
                term='fulfillment',
                canonical_form='order_fulfillment',
                aliases=['fulfilment', 'shipping', 'delivery'],
                definition='Process of receiving, processing and delivering orders',
                category='operations',
                related_terms=['warehouse', 'logistics', 'tracking'],
                context_examples=[
                    'order fulfillment center',
                    'fulfillment status',
                    'dropship fulfillment'
                ]
            )
        }

    async def get_terms(self) -> Dict[str, DomainTerm]:
        """전자상거래 용어 반환"""
        return self.terms

class HealthcareDictionary:
    """헬스케어 도메인 사전"""

    def __init__(self):
        self.terms = {
            'ehr': DomainTerm(
                term='ehr',
                canonical_form='electronic_health_record',
                aliases=['EHR', 'EMR', 'electronic medical record'],
                definition='Digital version of patient health information',
                category='health_it',
                related_terms=['patient record', 'medical history', 'clinical data'],
                context_examples=[
                    'EHR integration',
                    'access patient EHR',
                    'update medical records'
                ]
            ),
            'hipaa': DomainTerm(
                term='hipaa',
                canonical_form='health_insurance_portability_accountability_act',
                aliases=['HIPAA', 'hipaa compliance'],
                definition='US law protecting patient health information privacy',
                category='compliance',
                related_terms=['phi', 'privacy', 'security'],
                context_examples=[
                    'HIPAA compliant system',
                    'HIPAA audit',
                    'HIPAA training'
                ]
            ),
            'phi': DomainTerm(
                term='phi',
                canonical_form='protected_health_information',
                aliases=['PHI', 'patient data', 'health data'],
                definition='Any health information that can identify an individual',
                category='data_privacy',
                related_terms=['pii', 'medical records', 'confidentiality'],
                context_examples=[
                    'PHI encryption',
                    'access to PHI',
                    'PHI disclosure'
                ]
            )
        }
```

**도메인 패턴 인식기**:

```python
# backend/src/agents/implementations/parser/domain_pattern_recognizer.py
class DomainPatternRecognizer:
    """도메인 특화 패턴 인식"""

    def __init__(self):
        self.domain_patterns = {
            'e-commerce': {
                'patterns': [
                    r'(add|remove)\s+to\s+(cart|basket)',
                    r'(checkout|payment)\s+process',
                    r'product\s+(catalog|listing|search)',
                    r'(order|shipping)\s+tracking',
                    r'inventory\s+management',
                    r'customer\s+reviews?'
                ],
                'keywords': [
                    'product', 'cart', 'order', 'payment',
                    'shipping', 'customer', 'inventory'
                ]
            },
            'healthcare': {
                'patterns': [
                    r'patient\s+(record|data|information)',
                    r'(appointment|scheduling)\s+system',
                    r'(medical|clinical)\s+data',
                    r'(prescription|medication)\s+management',
                    r'(lab|test)\s+results?',
                    r'hipaa\s+complian(t|ce)'
                ],
                'keywords': [
                    'patient', 'doctor', 'appointment', 'medical',
                    'clinical', 'diagnosis', 'treatment'
                ]
            },
            'finance': {
                'patterns': [
                    r'(account|transaction)\s+management',
                    r'(payment|transfer)\s+processing',
                    r'(balance|statement)\s+inquiry',
                    r'(fraud|risk)\s+detection',
                    r'(loan|credit)\s+application',
                    r'regulatory\s+compliance'
                ],
                'keywords': [
                    'account', 'transaction', 'payment', 'balance',
                    'transfer', 'investment', 'portfolio'
                ]
            }
        }

    async def identify_domain(
        self,
        text: str,
        context: Optional[Dict[str, Any]] = None
    ) -> Tuple[str, float]:
        """텍스트에서 도메인 식별"""

        domain_scores = {}

        for domain, config in self.domain_patterns.items():
            score = 0

            # 패턴 매칭
            for pattern in config['patterns']:
                matches = re.findall(pattern, text, re.IGNORECASE)
                score += len(matches) * 2  # 패턴 매치는 가중치 2

            # 키워드 매칭
            text_lower = text.lower()
            for keyword in config['keywords']:
                if keyword in text_lower:
                    score += 1

            # 정규화
            domain_scores[domain] = score / (len(config['patterns']) + len(config['keywords']))

        # 컨텍스트 고려
        if context and 'domain_hint' in context:
            hint_domain = context['domain_hint']
            if hint_domain in domain_scores:
                domain_scores[hint_domain] *= 1.5

        # 최고 점수 도메인
        if domain_scores:
            best_domain = max(domain_scores, key=domain_scores.get)
            confidence = domain_scores[best_domain]

            # 임계값 확인
            if confidence > 0.3:
                return best_domain, confidence

        return 'general', 0.0
```

**검증 기준**:

- [ ] 주요 도메인 용어 사전 구축
- [ ] 용어 확장 및 정규화
- [ ] 도메인 자동 인식
- [ ] 별칭 및 약어 처리

#### SubTask 4.23.2: 도메인 특화 요구사항 템플릿

**담당자**: 도메인 전문가  
**예상 소요시간**: 12시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser/domain_templates.py
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

@dataclass
class RequirementTemplate:
    domain: str
    category: str
    name: str
    description: str
    template_structure: Dict[str, Any]
    example: str
    validation_rules: List[Dict[str, Any]]

class DomainTemplateManager:
    """도메인별 요구사항 템플릿 관리"""

    def __init__(self):
        self.templates = {
            'e-commerce': self._load_ecommerce_templates(),
            'healthcare': self._load_healthcare_templates(),
            'finance': self._load_finance_templates(),
            'education': self._load_education_templates()
        }

    def _load_ecommerce_templates(self) -> List[RequirementTemplate]:
        """전자상거래 템플릿"""
        return [
            RequirementTemplate(
                domain='e-commerce',
                category='product_management',
                name='Product Catalog Requirements',
                description='Requirements for product listing and management',
                template_structure={
                    'product_attributes': [
                        'name', 'description', 'price', 'sku',
                        'category', 'images', 'variants'
                    ],
                    'search_capabilities': [
                        'text_search', 'filter_by_category',
                        'filter_by_price', 'sort_options'
                    ],
                    'inventory_tracking': [
                        'stock_levels', 'low_stock_alerts',
                        'out_of_stock_handling'
                    ]
                },
                example="""
                The system shall allow vendors to manage product catalogs with:
                - Product creation with name, description, price, SKU
                - Multiple product images (up to 10)
                - Product variants (size, color)
                - Category assignment (multi-level)
                - Inventory tracking with real-time updates
                - Search functionality with filters
                """,
                validation_rules=[
                    {
                        'rule': 'product_must_have_sku',
                        'message': 'Each product must have unique SKU'
                    },
                    {
                        'rule': 'price_must_be_positive',
                        'message': 'Product price must be greater than 0'
                    }
                ]
            ),
            RequirementTemplate(
                domain='e-commerce',
                category='checkout_process',
                name='Checkout Flow Requirements',
                description='Requirements for checkout and payment process',
                template_structure={
                    'checkout_steps': [
                        'cart_review', 'shipping_address',
                        'shipping_method', 'payment_info',
                        'order_review', 'confirmation'
                    ],
                    'payment_methods': [
                        'credit_card', 'debit_card',
                        'paypal', 'apple_pay', 'google_pay'
                    ],
                    'shipping_options': [
                        'standard', 'express', 'overnight'
                    ],
                    'guest_checkout': True,
                    'save_payment_info': True
                },
                example="""
                The checkout process shall include:
                - Guest checkout option
                - Multiple payment methods (Credit card, PayPal, etc.)
                - Address validation
                - Shipping cost calculation
                - Order summary before confirmation
                - Email confirmation with order details
                """,
                validation_rules=[
                    {
                        'rule': 'payment_security',
                        'message': 'Payment processing must be PCI compliant'
                    }
                ]
            )
        ]

    def _load_healthcare_templates(self) -> List[RequirementTemplate]:
        """헬스케어 템플릿"""
        return [
            RequirementTemplate(
                domain='healthcare',
                category='patient_management',
                name='Patient Record Requirements',
                description='Requirements for patient data management',
                template_structure={
                    'patient_info': [
                        'demographics', 'contact_info',
                        'emergency_contacts', 'insurance'
                    ],
                    'medical_history': [
                        'conditions', 'medications',
                        'allergies', 'procedures'
                    ],
                    'clinical_data': [
                        'vitals', 'lab_results',
                        'imaging', 'notes'
                    ],
                    'compliance': [
                        'hipaa', 'audit_trail',
                        'access_control', 'encryption'
                    ]
                },
                example="""
                The patient management system shall:
                - Store patient demographics securely
                - Track medical history including conditions and medications
                - Record vital signs with timestamps
                - Manage lab results and imaging studies
                - Maintain HIPAA compliance
                - Provide role-based access control
                - Keep audit trail of all data access
                """,
                validation_rules=[
                    {
                        'rule': 'hipaa_compliance',
                        'message': 'All PHI must be encrypted at rest and in transit'
                    },
                    {
                        'rule': 'audit_required',
                        'message': 'All patient data access must be logged'
                    }
                ]
            )
        ]

    async def apply_template(
        self,
        requirement_text: str,
        domain: str,
        category: Optional[str] = None
    ) -> Dict[str, Any]:
        """템플릿을 적용하여 요구사항 구조화"""

        # 적절한 템플릿 찾기
        templates = self.templates.get(domain, [])

        if category:
            templates = [t for t in templates if t.category == category]

        if not templates:
            return {'error': 'No matching template found'}

        # 가장 적합한 템플릿 선택
        best_template = await self._select_best_template(
            requirement_text,
            templates
        )

        # 템플릿 적용
        structured_req = await self._apply_template_structure(
            requirement_text,
            best_template
        )

        # 검증 규칙 적용
        validation_results = await self._validate_against_template(
            structured_req,
            best_template
        )

        return {
            'template_used': best_template.name,
            'structured_requirement': structured_req,
            'validation_results': validation_results
        }
```

**도메인 규칙 엔진**:

```python
# backend/src/agents/implementations/parser/domain_rule_engine.py
class DomainRuleEngine:
    """도메인별 비즈니스 규칙 처리"""

    def __init__(self):
        self.rule_sets = {
            'e-commerce': ECommerceRules(),
            'healthcare': HealthcareRules(),
            'finance': FinanceRules()
        }

    async def apply_domain_rules(
        self,
        requirements: List[ParsedRequirement],
        domain: str
    ) -> List[ParsedRequirement]:
        """도메인 규칙 적용"""

        if domain not in self.rule_sets:
            return requirements

        rule_set = self.rule_sets[domain]

        # 각 요구사항에 규칙 적용
        enhanced_requirements = []

        for req in requirements:
            # 필수 요구사항 추가
            mandatory_reqs = await rule_set.get_mandatory_requirements(req)
            enhanced_requirements.extend(mandatory_reqs)

            # 규정 준수 요구사항
            compliance_reqs = await rule_set.get_compliance_requirements(req)
            enhanced_requirements.extend(compliance_reqs)

            # 원본 요구사항 보강
            enhanced_req = await rule_set.enhance_requirement(req)
            enhanced_requirements.append(enhanced_req)

        return enhanced_requirements

class ECommerceRules:
    """전자상거래 도메인 규칙"""

    async def get_mandatory_requirements(
        self,
        requirement: ParsedRequirement
    ) -> List[ParsedRequirement]:
        """필수 요구사항 생성"""

        mandatory = []

        # 결제 관련 요구사항이면 PCI 준수 추가
        if 'payment' in requirement.description.lower():
            mandatory.append(ParsedRequirement(
                id=f"{requirement.id}-PCI",
                type=RequirementType.NON_FUNCTIONAL,
                category='security',
                description="Payment processing must be PCI DSS compliant",
                priority='critical',
                acceptance_criteria=[
                    "All payment data encrypted with AES-256",
                    "No storage of CVV codes",
                    "Tokenization for stored payment methods"
                ]
            ))

        # 개인정보 처리 요구사항이면 GDPR 추가
        if any(term in requirement.description.lower()
               for term in ['user data', 'personal information', 'customer data']):
            mandatory.append(ParsedRequirement(
                id=f"{requirement.id}-GDPR",
                type=RequirementType.NON_FUNCTIONAL,
                category='compliance',
                description="Personal data handling must be GDPR compliant",
                priority='high',
                acceptance_criteria=[
                    "User consent for data collection",
                    "Right to data deletion",
                    "Data portability support"
                ]
            ))

        return mandatory
```

**검증 기준**:

- [ ] 도메인별 템플릿 구현
- [ ] 템플릿 자동 매칭
- [ ] 도메인 규칙 적용
- [ ] 규정 준수 요구사항 자동 추가

#### SubTask 4.23.3: 업계 표준 매핑 시스템

**담당자**: 표준 전문가  
**예상 소요시간**: 10시간

**작업 내용**:

```python
# backend/src/agents/implementations/parser/industry_standards.py
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

@dataclass
class IndustryStandard:
    name: str
    acronym: str
    domain: str
    category: str
    description: str
    requirements: List[Dict[str, Any]]
    references: List[str]

class IndustryStandardsMapper:
    """업계 표준 매핑 시스템"""

    def __init__(self):
        self.standards = {
            'ISO_27001': IndustryStandard(
                name='ISO 27001',
                acronym='ISO27001',
                domain='general',
                category='information_security',
                description='Information security management systems',
                requirements=[
                    {
                        'id': 'A.5.1.1',
                        'title': 'Policies for information security',
                        'description': 'Information security policy and topic-specific policies'
                    },
                    {
                        'id': 'A.8.2.3',
                        'title': 'Handling of assets',
                        'description': 'Procedures for handling assets in accordance with classification'
                    }
                ],
                references=[
                    'https://www.iso.org/standard/27001'
                ]
            ),
            'PCI_DSS': IndustryStandard(
                name='Payment Card Industry Data Security Standard',
                acronym='PCI-DSS',
                domain='e-commerce',
                category='payment_security',
                description='Security standards for payment card data',
                requirements=[
                    {
                        'id': '3.4',
                        'title': 'Render PAN unreadable',
                        'description': 'Render PAN unreadable anywhere it is stored'
                    },
                    {
                        'id': '8.2.3',
                        'title': 'Strong passwords',
                        'description': 'Passwords must meet minimum complexity requirements'
                    }
                ],
                references=[
                    'https://www.pcisecuritystandards.org/'
                ]
            ),
            'HIPAA': IndustryStandard(
                name='Health Insurance Portability and Accountability Act',
                acronym='HIPAA',
                domain='healthcare',
                category='privacy_security',
                description='Standards for protecting health information',
                requirements=[
                    {
                        'id': '164.308(a)(1)',
                        'title': 'Security risk analysis',
                        'description': 'Conduct risk analysis of PHI'
                    },
                    {
                        'id': '164.312(a)(1)',
                        'title': 'Access control',
                        'description': 'Unique user identification and automatic logoff'
                    }
                ],
                references=[
                    'https://www.hhs.gov/hipaa/'
                ]
            )
        }

        self.mapping_engine = StandardMappingEngine()

    async def map_to_standards(
        self,
        requirements: List[ParsedRequirement],
        domain: str
    ) -> Dict[str, Any]:
        """요구사항을 업계 표준에 매핑"""

        relevant_standards = self._get_relevant_standards(domain)
        mapping_results = {
            'mapped_standards': [],
            'coverage_analysis': {},
            'gap_analysis': [],
            'recommendations': []
        }

        for standard in relevant_standards:
            # 요구사항과 표준 매핑
            mappings = await self.mapping_engine.map_requirements_to_standard(
                requirements,
                standard
            )

            if mappings:
                mapping_results['mapped_standards'].append({
                    'standard': standard.name,
                    'mappings': mappings,
                    'coverage': self._calculate_coverage(mappings, standard)
                })

                # 갭 분석
                gaps = self._identify_gaps(mappings, standard)
                mapping_results['gap_analysis'].extend(gaps)

        # 권장사항 생성
        mapping_results['recommendations'] = await self._generate_recommendations(
            mapping_results['gap_analysis'],
            domain
        )

        return mapping_results

    def _calculate_coverage(
        self,
        mappings: List[Dict[str, Any]],
        standard: IndustryStandard
    ) -> float:
        """표준 충족도 계산"""

        total_requirements = len(standard.requirements)
        mapped_requirements = len(set(
            m['standard_requirement_id']
            for m in mappings
        ))

        return mapped_requirements / total_requirements if total_requirements > 0 else 0

class StandardMappingEngine:
    """표준 매핑 엔진"""

    async def map_requirements_to_standard(
        self,
        requirements: List[ParsedRequirement],
        standard: IndustryStandard
    ) -> List[Dict[str, Any]]:
        """요구사항을 표준에 매핑"""

        mappings = []

        for req in requirements:
            for std_req in standard.requirements:
                similarity = await self._calculate_similarity(
                    req.description,
                    std_req['description']
                )

                if similarity > 0.7:  # 70% 이상 유사도
                    mappings.append({
                        'requirement_id': req.id,
                        'standard_requirement_id': std_req['id'],
                        'standard_requirement_title': std_req['title'],
                        'similarity_score': similarity,
                        'mapping_type': 'direct' if similarity > 0.9 else 'partial'
                    })

        return mappings

    async def _calculate_similarity(
        self,
        text1: str,
        text2: str
    ) -> float:
        """텍스트 유사도 계산"""

        # 간단한 Jaccard 유사도 구현
        # 실제로는 더 정교한 NLP 기법 사용

        words1 = set(text1.lower().split())
        words2 = set(text2.lower().split())

        intersection = words1.intersection(words2)
        union = words1.union(words2)

        return len(intersection) / len(union) if union else 0.0
```

**규정 준수 체크리스트 생성기**:

```python
class ComplianceChecklistGenerator:
    """규정 준수 체크리스트 자동 생성"""

    async def generate_compliance_checklist(
        self,
        project: ParsedProject,
        standards: List[str]
    ) -> Dict[str, Any]:
        """프로젝트에 대한 규정 준수 체크리스트 생성"""

        checklist = {
            'project_id': project.project_info.get('id'),
            'standards': standards,
            'checklist_items': [],
            'priority_items': [],
            'estimated_effort': {}
        }

        for standard_name in standards:
            if standard_name in self.standards:
                standard = self.standards[standard_name]

                # 체크리스트 항목 생성
                items = await self._generate_checklist_items(
                    project,
                    standard
                )

                checklist['checklist_items'].extend(items)

                # 우선순위 항목 식별
                priority_items = [
                    item for item in items
                    if item['priority'] == 'critical'
                ]
                checklist['priority_items'].extend(priority_items)

                # 노력 추정
                effort = await self._estimate_compliance_effort(
                    items,
                    project
                )
                checklist['estimated_effort'][standard_name] = effort

        return checklist
```

**검증 기준**:

- [ ] 주요 업계 표준 데이터베이스
- [ ] 자동 매핑 정확도 70% 이상
- [ ] 갭 분석 기능
- [ ] 규정 준수 체크리스트 생성

#### SubTask 4.23.4: Parser Agent 도메인 통합 테스트

**담당자**: QA 엔지니어  
**예상 소요시간**: 12시간

**작업 내용**:

```python
# backend/tests/agents/parser/test_domain_parsing.py
import pytest
from typing import Dict, Any

@pytest.mark.integration
class TestDomainParsing:
    """도메인 특화 파싱 테스트"""

    @pytest.fixture
    def domain_test_cases(self):
        """도메인별 테스트 케이스"""
        return {
            'e-commerce': {
                'description': """
                Build an e-commerce platform for B2B wholesale marketplace.

                The platform must support multiple vendors with individual storefronts.
                Products should have SKUs, bulk pricing tiers, and minimum order quantities.

                Key features:
                - Vendor onboarding with KYC verification
                - Product catalog with categories, attributes, and variants
                - Shopping cart supporting bulk orders
                - B2B specific checkout with PO support
                - Order management with approval workflows
                - Integration with ERP systems (SAP, Oracle)
                - Real-time inventory sync across warehouses
                - Customer-specific pricing and catalogs

                Payment methods: Wire transfer, ACH, Net 30/60/90 terms

                The system must handle 50,000 SKUs and 1,000 concurrent users.
                All transactions must be PCI compliant.
                """,
                'expected_domain': 'e-commerce',
                'expected_terms': ['sku', 'cart', 'checkout', 'inventory', 'vendor'],
                'expected_standards': ['PCI_DSS'],
                'expected_requirements_count': {
                    'functional': 15,
                    'non_functional': 5,
                    'business': 3
                }
            },
            'healthcare': {
                'description': """
                Develop a telemedicine platform for remote patient consultations.

                The system must be HIPAA compliant and support:
                - Patient registration with medical history
                - Doctor profiles with specialization and availability
                - Video consultation with screen sharing
                - E-prescription with pharmacy integration
                - Lab result sharing and viewing
                - Appointment scheduling with reminders
                - Patient health records (EHR/EMR integration)
                - Insurance verification and claims

                Security requirements:
                - All PHI must be encrypted at rest and in transit
                - Role-based access control (RBAC)
                - Audit logs for all data access
                - Two-factor authentication for providers

                Performance: Support 500 concurrent video sessions
                Availability: 99.9% uptime SLA
                """,
                'expected_domain': 'healthcare',
                'expected_terms': ['patient', 'ehr', 'phi', 'hipaa', 'appointment'],
                'expected_standards': ['HIPAA'],
                'expected_requirements_count': {
                    'functional': 12,
                    'non_functional': 8,
                    'compliance': 4
                }
            }
        }

    @pytest.mark.asyncio
    async def test_domain_identification(self, parser_agent, domain_test_cases):
        """도메인 자동 식별 테스트"""

        for domain, test_case in domain_test_cases.items():
            # 도메인 식별
            identified_domain, confidence = await parser_agent.domain_recognizer.identify_domain(
                test_case['description']
            )

            assert identified_domain == test_case['expected_domain'], \
                f"Expected {test_case['expected_domain']}, got {identified_domain}"
            assert confidence > 0.7, \
                f"Domain confidence {confidence} is below threshold"

    @pytest.mark.asyncio
    async def test_domain_term_extraction(self, parser_agent, domain_test_cases):
        """도메인 용어 추출 테스트"""

        for domain, test_case in domain_test_cases.items():
            # 파싱 실행
            result = await parser_agent.parse_requirements(
                test_case['description'],
                project_context={'domain_hint': domain}
            )

            # 추출된 도메인 용어 확인
            extracted_terms = []
            for req in result.functional_requirements:
                terms = await parser_agent.domain_dictionary.extract_domain_terms(
                    req.description,
                    domain
                )
                extracted_terms.extend(terms)

            # 예상 용어가 모두 추출되었는지 확인
            extracted_term_names = [t.canonical_form for t in extracted_terms]
            for expected_term in test_case['expected_terms']:
                assert any(expected_term in term for term in extracted_term_names), \
                    f"Expected term '{expected_term}' not found"

    @pytest.mark.asyncio
    async def test_standard_mapping(self, parser_agent, domain_test_cases):
        """업계 표준 매핑 테스트"""

        for domain, test_case in domain_test_cases.items():
            # 파싱 실행
            result = await parser_agent.parse_requirements(
                test_case['description']
            )

            # 표준 매핑
            mapping_results = await parser_agent.standards_mapper.map_to_standards(
                result.functional_requirements + result.non_functional_requirements,
                domain
            )

            # 예상 표준이 매핑되었는지 확인
            mapped_standard_names = [
                ms['standard'] for ms in mapping_results['mapped_standards']
            ]

            for expected_standard in test_case['expected_standards']:
                assert any(expected_standard in name for name in mapped_standard_names), \
                    f"Expected standard '{expected_standard}' not mapped"

    @pytest.mark.asyncio
    async def test_domain_template_application(self, parser_agent):
        """도메인 템플릿 적용 테스트"""

        test_requirement = """
        Create a product management system where vendors can add products
        with multiple images, variants (size, color), and track inventory levels.
        """

        # 템플릿 적용
        result = await parser_agent.template_manager.apply_template(
            test_requirement,
            domain='e-commerce',
            category='product_management'
        )

        assert 'template_used' in result
        assert result['template_used'] == 'Product Catalog Requirements'

        # 구조화된 요구사항 확인
        structured = result['structured_requirement']
        assert 'product_attributes' in structured
        assert 'inventory_tracking' in structured

        # 검증 결과 확인
        validation = result['validation_results']
        assert all(v['passed'] for v in validation)
```

**도메인 특화 파싱 성능 테스트**:

```python
# backend/tests/agents/parser/test_domain_performance.py
import time
import asyncio

class TestDomainParsingPerformance:
    """도메인 파싱 성능 테스트"""

    @pytest.mark.performance
    async def test_large_domain_document_parsing(self, parser_agent):
        """대용량 도메인 문서 파싱 성능"""

        # 대용량 요구사항 문서 생성 (실제 프로젝트 시뮬레이션)
        large_document = self._generate_large_requirement_document(
            domain='healthcare',
            num_requirements=100
        )

        start_time = time.time()

        # 파싱 실행
        result = await parser_agent.parse_requirements(large_document)

        parsing_time = time.time() - start_time

        # 성능 검증
        assert parsing_time < 30, f"Parsing took {parsing_time}s, expected < 30s"
        assert len(result.functional_requirements) >= 80
        assert len(result.non_functional_requirements) >= 20

        # 도메인 특화 기능 성능
        domain_processing_start = time.time()

        # 용어 추출
        terms = await parser_agent.domain_dictionary.extract_all_terms(
            large_document,
            'healthcare'
        )

        # 표준 매핑
        mappings = await parser_agent.standards_mapper.map_to_standards(
            result.functional_requirements,
            'healthcare'
        )

        domain_processing_time = time.time() - domain_processing_start

        assert domain_processing_time < 10, \
            f"Domain processing took {domain_processing_time}s, expected < 10s"

    def _generate_large_requirement_document(
        self,
        domain: str,
        num_requirements: int
    ) -> str:
        """테스트용 대용량 문서 생성"""

        templates = {
            'healthcare': [
                "The system shall allow patients to {action} their {record_type}",
                "Healthcare providers must be able to {action} patient {data_type}",
                "The platform shall support {feature} with HIPAA compliance",
                "Integration with {system} for {purpose} is required"
            ]
        }

        actions = ['view', 'update', 'share', 'export', 'delete']
        record_types = ['medical records', 'lab results', 'prescriptions', 'appointments']
        data_types = ['vitals', 'diagnoses', 'medications', 'allergies']
        features = ['video consultation', 'e-prescription', 'appointment scheduling']
        systems = ['EHR systems', 'pharmacy networks', 'insurance providers']
        purposes = ['data exchange', 'verification', 'claims processing']

        requirements = []

        for i in range(num_requirements):
            template = templates[domain][i % len(templates[domain])]
            requirement = template.format(
                action=actions[i % len(actions)],
                record_type=record_types[i % len(record_types)],
                data_type=data_types[i % len(data_types)],
                feature=features[i % len(features)],
                system=systems[i % len(systems)],
                purpose=purposes[i % len(purposes)]
            )
            requirements.append(requirement)

        return "\n".join(requirements)
```

**도메인 간 비교 테스트**:

```python
class TestCrossDomainComparison:
    """도메인 간 파싱 비교 테스트"""

    @pytest.mark.asyncio
    async def test_multi_domain_project(self, parser_agent):
        """여러 도메인이 혼재된 프로젝트 테스트"""

        # 핀테크 프로젝트 (전자상거래 + 금융)
        fintech_requirements = """
        Build a payment processing platform for e-commerce businesses.

        Features:
        - Merchant onboarding with KYC/AML checks
        - Payment gateway supporting multiple methods
        - Real-time fraud detection using ML
        - Transaction monitoring and reporting
        - PCI DSS compliant card processing
        - Integration with banking APIs
        - Automated settlement and reconciliation
        """

        result = await parser_agent.parse_requirements(fintech_requirements)

        # 다중 도메인 인식 확인
        domains = await parser_agent.identify_all_domains(fintech_requirements)

        assert 'e-commerce' in domains
        assert 'finance' in domains

        # 각 도메인의 요구사항이 적절히 분류되었는지 확인
        ecommerce_reqs = [
            r for r in result.functional_requirements
            if 'merchant' in r.description.lower() or 'payment gateway' in r.description.lower()
        ]

        finance_reqs = [
            r for r in result.functional_requirements
            if 'kyc' in r.description.lower() or 'aml' in r.description.lower()
        ]

        assert len(ecommerce_reqs) > 0
        assert len(finance_reqs) > 0

        # 복합 표준 매핑 확인
        standards = await parser_agent.identify_applicable_standards(result)

        assert 'PCI_DSS' in standards  # 전자상거래
        assert 'ISO_27001' in standards  # 일반 보안
```

**검증 기준**:

- [ ] 모든 도메인 테스트 통과
- [ ] 도메인 식별 정확도 85% 이상
- [ ] 대용량 문서 처리 성능
- [ ] 다중 도메인 프로젝트 지원

이제 Task 4.21, 4.22, 4.23 (Parser Agent)의 모든 SubTask가 완료되었습니다. Parser Agent는 다음과 같은 핵심 기능을 갖추게 되었습니다:

1. **자연어 처리**: SpaCy와 Transformer 모델을 활용한 고급 NLP
2. **요구사항 구조화**: 기능/비기능 요구사항 자동 분리 및 분류
3. **사용자 스토리 생성**: 요구사항을 사용자 스토리로 자동 변환
4. **데이터 모델/API 추출**: 텍스트에서 데이터 구조와 API 자동 추출
5. **도메인 특화 파싱**: 8개 주요 도메인별 전문 용어 및 패턴 인식
6. **업계 표준 매핑**: ISO, PCI-DSS, HIPAA 등 표준 자동 매핑
7. **검증 및 품질 평가**: 요구사항 완성도 및 품질 자동 평가

---
