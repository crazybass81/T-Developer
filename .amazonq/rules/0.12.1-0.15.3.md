## Task 0.12: 개발 워크플로우 최적화

### SubTask 0.12.1: 자동화된 코드 생성 도구
**목표**: 반복적인 코드 작성을 위한 자동화 도구 구축

**구현 내용**:
```typescript
// scripts/code-generator/generator.ts
import { Command } from 'commander';
import inquirer from 'inquirer';
import { promises as fs } from 'fs';
import path from 'path';
import Handlebars from 'handlebars';
import chalk from 'chalk';

// 템플릿 매니저
class TemplateManager {
  private templatesDir = path.join(__dirname, 'templates');
  private templates: Map<string, HandlebarsTemplateDelegate> = new Map();
  
  async loadTemplates(): Promise<void> {
    const templateFiles = await fs.readdir(this.templatesDir);
    
    for (const file of templateFiles) {
      if (file.endsWith('.hbs')) {
        const name = path.basename(file, '.hbs');
        const content = await fs.readFile(
          path.join(this.templatesDir, file),
          'utf-8'
        );
        this.templates.set(name, Handlebars.compile(content));
      }
    }
    
    this.registerHelpers();
  }
  
  private registerHelpers(): void {
    // 케이스 변환 헬퍼
    Handlebars.registerHelper('camelCase', (str: string) => 
      str.replace(/-./g, x => x[1].toUpperCase())
    );
    
    Handlebars.registerHelper('pascalCase', (str: string) => {
      const camel = str.replace(/-./g, x => x[1].toUpperCase());
      return camel.charAt(0).toUpperCase() + camel.slice(1);
    });
    
    Handlebars.registerHelper('kebabCase', (str: string) =>
      str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`).replace(/^-/, '')
    );
    
    // 조건부 헬퍼
    Handlebars.registerHelper('if_eq', function(a, b, options) {
      if (a === b) {
        return options.fn(this);
      }
      return options.inverse(this);
    });
  }
  
  render(templateName: string, data: any): string {
    const template = this.templates.get(templateName);
    if (!template) {
      throw new Error(`Template '${templateName}' not found`);
    }
    return template(data);
  }
}

// 코드 생성기
class CodeGenerator {
  private templateManager = new TemplateManager();
  
  async initialize(): Promise<void> {
    await this.templateManager.loadTemplates();
  }
  
  // 에이전트 생성
  async generateAgent(name: string): Promise<void> {
    const answers = await inquirer.prompt([
      {
        type: 'list',
        name: 'type',
        message: 'Select agent type:',
        choices: [
          'processing',
          'analysis',
          'generation',
          'integration'
        ]
      },
      {
        type: 'checkbox',
        name: 'capabilities',
        message: 'Select agent capabilities:',
        choices: [
          'database-access',
          'file-operations',
          'api-calls',
          'llm-integration',
          'caching'
        ]
      },
      {
        type: 'input',
        name: 'description',
        message: 'Agent description:'
      }
    ]);
    
    const data = {
      name,
      className: this.toPascalCase(name),
      ...answers
    };
    
    // 에이전트 파일 생성
    const agentCode = this.templateManager.render('agent', data);
    const agentPath = path.join(
      process.cwd(),
      'backend/src/agents',
      `${name}-agent.ts`
    );
    
    await fs.writeFile(agentPath, agentCode);
    
    // 테스트 파일 생성
    const testCode = this.templateManager.render('agent-test', data);
    const testPath = path.join(
      process.cwd(),
      'backend/tests/agents',
      `${name}-agent.test.ts`
    );
    
    await fs.writeFile(testPath, testCode);
    
    // 문서 생성
    const docCode = this.templateManager.render('agent-doc', data);
    const docPath = path.join(
      process.cwd(),
      'docs/agents',
      `${name}-agent.md`
    );
    
    await fs.writeFile(docPath, docCode);
    
    console.log(chalk.green(`✅ Agent '${name}' generated successfully!`));
    console.log(chalk.blue('Generated files:'));
    console.log(`  - ${agentPath}`);
    console.log(`  - ${testPath}`);
    console.log(`  - ${docPath}`);
  }
  
  // API 엔드포인트 생성
  async generateEndpoint(resource: string): Promise<void> {
    const answers = await inquirer.prompt([
      {
        type: 'checkbox',
        name: 'methods',
        message: 'Select HTTP methods:',
        choices: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
        default: ['GET', 'POST', 'PUT', 'DELETE']
      },
      {
        type: 'confirm',
        name: 'authentication',
        message: 'Require authentication?',
        default: true
      },
      {
        type: 'confirm',
        name: 'validation',
        message: 'Include validation?',
        default: true
      },
      {
        type: 'confirm',
        name: 'pagination',
        message: 'Include pagination?',
        default: true
      }
    ]);
    
    const data = {
      resource,
      resourceName: this.toPascalCase(resource),
      ...answers
    };
    
    // 컨트롤러 생성
    const controllerCode = this.templateManager.render('controller', data);
    const controllerPath = path.join(
      process.cwd(),
      'backend/src/controllers',
      `${resource}.controller.ts`
    );
    
    await fs.writeFile(controllerPath, controllerCode);
    
    // 서비스 생성
    const serviceCode = this.templateManager.render('service', data);
    const servicePath = path.join(
      process.cwd(),
      'backend/src/services',
      `${resource}.service.ts`
    );
    
    await fs.writeFile(servicePath, serviceCode);
    
    // 라우트 생성
    const routeCode = this.templateManager.render('route', data);
    const routePath = path.join(
      process.cwd(),
      'backend/src/routes',
      `${resource}.routes.ts`
    );
    
    await fs.writeFile(routePath, routeCode);
    
    // 검증 스키마 생성
    if (answers.validation) {
      const validationCode = this.templateManager.render('validation', data);
      const validationPath = path.join(
        process.cwd(),
        'backend/src/validations',
        `${resource}.validation.ts`
      );
      
      await fs.writeFile(validationPath, validationCode);
    }
    
    console.log(chalk.green(`✅ API endpoint '${resource}' generated successfully!`));
  }
  
  // React 컴포넌트 생성
  async generateComponent(name: string): Promise<void> {
    const answers = await inquirer.prompt([
      {
        type: 'list',
        name: 'type',
        message: 'Component type:',
        choices: ['functional', 'class']
      },
      {
        type: 'confirm',
        name: 'typescript',
        message: 'Use TypeScript?',
        default: true
      },
      {
        type: 'confirm',
        name: 'styles',
        message: 'Include styles?',
        default: true
      },
      {
        type: 'confirm',
        name: 'tests',
        message: 'Include tests?',
        default: true
      },
      {
        type: 'checkbox',
        name: 'hooks',
        message: 'Select hooks to use:',
        choices: ['useState', 'useEffect', 'useContext', 'useReducer', 'useMemo', 'useCallback']
      }
    ]);
    
    const data = {
      name,
      componentName: this.toPascalCase(name),
      ...answers
    };
    
    const ext = answers.typescript ? 'tsx' : 'jsx';
    const styleExt = 'module.css';
    
    // 컴포넌트 디렉토리 생성
    const componentDir = path.join(
      process.cwd(),
      'frontend/src/components',
      name
    );
    await fs.mkdir(componentDir, { recursive: true });
    
    // 컴포넌트 파일 생성
    const componentCode = this.templateManager.render('react-component', data);
    const componentPath = path.join(componentDir, `index.${ext}`);
    await fs.writeFile(componentPath, componentCode);
    
    // 스타일 파일 생성
    if (answers.styles) {
      const styleCode = this.templateManager.render('component-styles', data);
      const stylePath = path.join(componentDir, `styles.${styleExt}`);
      await fs.writeFile(stylePath, styleCode);
    }
    
    // 테스트 파일 생성
    if (answers.tests) {
      const testCode = this.templateManager.render('component-test', data);
      const testPath = path.join(componentDir, `${name}.test.${ext}`);
      await fs.writeFile(testPath, testCode);
    }
    
    // 스토리북 파일 생성
    const storyCode = this.templateManager.render('component-story', data);
    const storyPath = path.join(componentDir, `${name}.stories.${ext}`);
    await fs.writeFile(storyPath, storyCode);
    
    console.log(chalk.green(`✅ Component '${name}' generated successfully!`));
  }
  
  // 유틸리티 메서드
  private toPascalCase(str: string): string {
    return str
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
  }
}

// CLI 설정
const program = new Command();
const generator = new CodeGenerator();

program
  .name('t-dev-gen')
  .description('T-Developer code generator')
  .version('1.0.0');

program
  .command('agent <name>')
  .description('Generate a new agent')
  .action(async (name) => {
    await generator.initialize();
    await generator.generateAgent(name);
  });

program
  .command('api <resource>')
  .description('Generate API endpoint')
  .action(async (resource) => {
    await generator.initialize();
    await generator.generateEndpoint(resource);
  });

program
  .command('component <name>')
  .description('Generate React component')
  .action(async (name) => {
    await generator.initialize();
    await generator.generateComponent(name);
  });

program.parse();
```

```handlebars
<!-- scripts/code-generator/templates/agent.hbs -->
import { Agent } from '@/core/agent';
import { logger } from '@/config/logger';
{{#if (includes capabilities 'database-access')}}
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
{{/if}}
{{#if (includes capabilities 'llm-integration')}}
import { BedrockClient } from '@aws-sdk/client-bedrock';
{{/if}}

/**
 * {{description}}
 */
export class {{className}}Agent extends Agent {
  static readonly AGENT_NAME = '{{name}}';
  static readonly AGENT_TYPE = '{{type}}';
  
  {{#if (includes capabilities 'database-access')}}
  private docClient: DynamoDBDocumentClient;
  {{/if}}
  {{#if (includes capabilities 'llm-integration')}}
  private bedrockClient: BedrockClient;
  {{/if}}
  
  constructor() {
    super({
      name: {{className}}Agent.AGENT_NAME,
      type: {{className}}Agent.AGENT_TYPE,
      capabilities: [
        {{#each capabilities}}
        '{{this}}',
        {{/each}}
      ]
    });
    
    this.initialize();
  }
  
  private initialize(): void {
    {{#if (includes capabilities 'database-access')}}
    this.docClient = this.createDynamoDBClient();
    {{/if}}
    {{#if (includes capabilities 'llm-integration')}}
    this.bedrockClient = this.createBedrockClient();
    {{/if}}
  }
  
  async execute(input: any): Promise<any> {
    logger.info(`Executing ${this.name} agent`, { input });
    
    try {
      // Validate input
      this.validateInput(input);
      
      // Process input
      const result = await this.process(input);
      
      // Return result
      return {
        success: true,
        data: result,
        metadata: {
          agentName: this.name,
          executionTime: Date.now(),
          version: '1.0.0'
        }
      };
      
    } catch (error) {
      logger.error(`Error in ${this.name} agent`, error);
      throw error;
    }
  }
  
  private validateInput(input: any): void {
    // TODO: Implement input validation
    if (!input) {
      throw new Error('Input is required');
    }
  }
  
  private async process(input: any): Promise<any> {
    // TODO: Implement processing logic
    {{#if_eq type 'processing'}}
    // Processing agent logic
    return this.processData(input);
    {{/if_eq}}
    {{#if_eq type 'analysis'}}
    // Analysis agent logic
    return this.analyzeData(input);
    {{/if_eq}}
    {{#if_eq type 'generation'}}
    // Generation agent logic
    return this.generateOutput(input);
    {{/if_eq}}
    {{#if_eq type 'integration'}}
    // Integration agent logic
    return this.integrateServices(input);
    {{/if_eq}}
  }
  
  {{#if_eq type 'processing'}}
  private async processData(data: any): Promise<any> {
    // TODO: Implement data processing
    return data;
  }
  {{/if_eq}}
  
  {{#if_eq type 'analysis'}}
  private async analyzeData(data: any): Promise<any> {
    // TODO: Implement data analysis
    return { analyzed: true };
  }
  {{/if_eq}}
  
  {{#if_eq type 'generation'}}
  private async generateOutput(input: any): Promise<any> {
    // TODO: Implement output generation
    return { generated: true };
  }
  {{/if_eq}}
  
  {{#if_eq type 'integration'}}
  private async integrateServices(input: any): Promise<any> {
    // TODO: Implement service integration
    return { integrated: true };
  }
  {{/if_eq}}
}
```
---

### SubTask 0.12.2: Hot Module Replacement (HMR) 설정
**목표**: 개발 중 빠른 피드백을 위한 HMR 구성

**구현 내용**:
```typescript
// backend/src/dev/hot-reload.ts
import { spawn, ChildProcess } from 'child_process';
import chokidar from 'chokidar';
import { EventEmitter } from 'events';
import path from 'path';
import { logger } from '../config/logger';
import WebSocket from 'ws';

// HMR 매니저
export class HotModuleReplacementManager extends EventEmitter {
  private watcher?: chokidar.FSWatcher;
  private process?: ChildProcess;
  private wsServer?: WebSocket.Server;
  private reloadTimer?: NodeJS.Timeout;
  private isRestarting = false;
  
  constructor(private config: HMRConfig) {
    super();
  }
  
  // HMR 시작
  async start(): Promise<void> {
    logger.info('Starting Hot Module Replacement...');
    
    // WebSocket 서버 시작 (브라우저 새로고침용)
    this.startWebSocketServer();
    
    // 초기 프로세스 시작
    await this.startProcess();
    
    // 파일 감시 시작
    this.startWatching();
  }
  
  // WebSocket 서버
  private startWebSocketServer(): void {
    this.wsServer = new WebSocket.Server({ port: this.config.wsPort || 3001 });
    
    this.wsServer.on('connection', (ws) => {
      logger.debug('HMR client connected');
      
      ws.on('close', () => {
        logger.debug('HMR client disconnected');
      });
    });
  }
  
  // 파일 감시
  private startWatching(): void {
    const watchPaths = this.config.watchPaths || ['src'];
    const ignorePaths = this.config.ignorePaths || [
      'node_modules',
      'dist',
      'coverage',
      '.git',
      '**/*.test.ts',
      '**/*.spec.ts'
    ];
    
    this.watcher = chokidar.watch(watchPaths, {
      ignored: ignorePaths,
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 300,
        pollInterval: 100
      }
    });
    
    // 파일 변경 이벤트
    this.watcher.on('change', (filePath) => this.handleFileChange(filePath));
    this.watcher.on('add', (filePath) => this.handleFileChange(filePath));
    this.watcher.on('unlink', (filePath) => this.handleFileChange(filePath));
  }
  
  // 파일 변경 처리
  private handleFileChange(filePath: string): void {
    logger.info(`File changed: ${filePath}`);
    
    // 디바운싱
    if (this.reloadTimer) {
      clearTimeout(this.reloadTimer);
    }
    
    this.reloadTimer = setTimeout(() => {
      const ext = path.extname(filePath);
      
      if (this.config.hotReloadableExtensions?.includes(ext)) {
        // Hot reload 가능한 파일
        this.hotReload(filePath);
      } else {
        // 전체 재시작 필요
        this.restartProcess();
      }
    }, this.config.debounceDelay || 100);
  }
  
  // Hot reload 수행
  private async hotReload(filePath: string): Promise<void> {
    try {
      // 캐시에서 모듈 제거
      this.clearModuleCache(filePath);
      
      // 모듈 특정 핫 리로드 로직
      if (filePath.includes('/agents/')) {
        await this.reloadAgent(filePath);
      } else if (filePath.includes('/routes/')) {
        await this.reloadRoute(filePath);
      } else if (filePath.includes('/services/')) {
        await this.reloadService(filePath);
      } else {
        // 기본 핫 리로드
        this.emit('module:reload', filePath);
      }
      
      // 브라우저 새로고침
      this.notifyClients('reload');
      
      logger.info(`Hot reloaded: ${filePath}`);
      
    } catch (error) {
      logger.error('Hot reload failed:', error);
      // 실패 시 전체 재시작
      this.restartProcess();
    }
  }
  
  // 에이전트 리로드
  private async reloadAgent(filePath: string): Promise<void> {
    const agentName = path.basename(filePath, '.ts').replace('-agent', '');
    
    // 에이전트 매니저에 리로드 요청
    if (global.agentManager) {
      await global.agentManager.reloadAgent(agentName);
    }
  }
  
  // 라우트 리로드
  private async reloadRoute(filePath: string): Promise<void> {
    // Express 라우터 재등록
    if (global.app) {
      const routeName = path.basename(filePath, '.ts');
      delete require.cache[require.resolve(filePath)];
      const newRouter = require(filePath).default;
      
      // 기존 라우트 제거 및 새 라우트 등록
      global.app._router.stack = global.app._router.stack.filter(
        (layer: any) => !layer.regexp.test(`/${routeName}`)
      );
      global.app.use(`/api/${routeName}`, newRouter);
    }
  }
  
  // 서비스 리로드
  private async reloadService(filePath: string): Promise<void> {
    const serviceName = path.basename(filePath, '.ts');
    
    // 서비스 컨테이너에서 재등록
    if (global.serviceContainer) {
      delete require.cache[require.resolve(filePath)];
      const ServiceClass = require(filePath).default;
      global.serviceContainer.register(serviceName, new ServiceClass());
    }
  }
  
  // 모듈 캐시 제거
  private clearModuleCache(filePath: string): void {
    const resolvedPath = require.resolve(filePath);
    delete require.cache[resolvedPath];
    
    // 의존성도 함께 제거
    Object.keys(require.cache).forEach((key) => {
      if (require.cache[key]?.children.some(child => child.id === resolvedPath)) {
        delete require.cache[key];
      }
    });
  }
  
  // 프로세스 재시작
  private async restartProcess(): Promise<void> {
    if (this.isRestarting) return;
    
    this.isRestarting = true;
    logger.info('Restarting application...');
    
    // 기존 프로세스 종료
    if (this.process) {
      await this.stopProcess();
    }
    
    // 새 프로세스 시작
    await this.startProcess();
    
    this.isRestarting = false;
    this.notifyClients('restart');
  }
  
  // 프로세스 시작
  private async startProcess(): Promise<void> {
    const command = this.config.command || 'npm';
    const args = this.config.args || ['run', 'dev'];
    
    this.process = spawn(command, args, {
      stdio: 'inherit',
      env: {
        ...process.env,
        NODE_ENV: 'development',
        HMR_ENABLED: 'true'
      }
    });
    
    this.process.on('exit', (code) => {
      if (code !== 0 && !this.isRestarting) {
        logger.error(`Process exited with code ${code}`);
        setTimeout(() => this.restartProcess(), 1000);
      }
    });
    
    // 프로세스 준비 대기
    await this.waitForProcessReady();
  }
  
  // 프로세스 종료
  private async stopProcess(): Promise<void> {
    if (!this.process) return;
    
    return new Promise((resolve) => {
      this.process!.once('exit', resolve);
      this.process!.kill('SIGTERM');
      
      // 강제 종료 타이머
      setTimeout(() => {
        if (this.process) {
          this.process.kill('SIGKILL');
        }
        resolve(undefined);
      }, 5000);
    });
  }
  
  // 프로세스 준비 대기
  private async waitForProcessReady(): Promise<void> {
    const maxAttempts = 30;
    const checkInterval = 1000;
    
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const response = await fetch(`http://localhost:${this.config.appPort || 3000}/health`);
        if (response.ok) {
          logger.info('Application is ready');
          return;
        }
      } catch (error) {
        // 아직 준비되지 않음
      }
      
      await new Promise(resolve => setTimeout(resolve, checkInterval));
    }
    
    throw new Error('Application failed to start');
  }
  
  // 클라이언트에 알림
  private notifyClients(action: string): void {
    if (!this.wsServer) return;
    
    const message = JSON.stringify({ action, timestamp: Date.now() });
    
    this.wsServer.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  }
  
  // HMR 중지
  async stop(): Promise<void> {
    logger.info('Stopping Hot Module Replacement...');
    
    if (this.watcher) {
      await this.watcher.close();
    }
    
    if (this.process) {
      await this.stopProcess();
    }
    
    if (this.wsServer) {
      this.wsServer.close();
    }
  }
}

// TypeScript 변환기
export class TypeScriptTranspiler {
  private tsNode: any;
  
  constructor() {
    this.tsNode = require('ts-node').register({
      transpileOnly: true,
      compilerOptions: {
        module: 'commonjs',
        target: 'es2020',
        lib: ['es2020'],
        allowJs: true,
        esModuleInterop: true,
        skipLibCheck: true
      }
    });
  }
  
  // 런타임 변환
  transpile(code: string, fileName: string): string {
    const ts = require('typescript');
    
    const result = ts.transpileModule(code, {
      compilerOptions: {
        module: ts.ModuleKind.CommonJS,
        target: ts.ScriptTarget.ES2020,
        esModuleInterop: true
      },
      fileName
    });
    
    return result.outputText;
  }
  
  // require 훅 설치
  installRequireHook(): void {
    const Module = require('module');
    const originalRequire = Module.prototype.require;
    
    Module.prototype.require = function(id: string) {
      // HMR이 활성화된 모듈인지 확인
      if (global.HMR_MODULES?.has(id)) {
        logger.debug(`HMR: Loading module ${id}`);
        
        // 캐시 무효화
        delete require.cache[require.resolve(id)];
      }
      
      return originalRequire.apply(this, arguments);
    };
  }
}

// 프론트엔드 HMR 클라이언트
export const hmrClient = `
(function() {
  const ws = new WebSocket('ws://localhost:3001');
  
  ws.onopen = () => {
    console.log('[HMR] Connected');
  };
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    switch (data.action) {
      case 'reload':
        console.log('[HMR] Reloading page...');
        window.location.reload();
        break;
        
      case 'restart':
        console.log('[HMR] Server restarted');
        // 재연결 시도
        setTimeout(() => {
          window.location.reload();
        }, 1000);
        break;
        
      case 'css':
        console.log('[HMR] Updating CSS...');
        updateCSS(data.file);
        break;
    }
  };
  
  ws.onclose = () => {
    console.log('[HMR] Disconnected. Retrying...');
    setTimeout(() => {
      window.location.reload();
    }, 2000);
  };
  
  function updateCSS(file) {
    const links = document.querySelectorAll('link[rel="stylesheet"]');
    const link = Array.from(links).find(l => l.href.includes(file));
    
    if (link) {
      const newLink = link.cloneNode();
      newLink.href = link.href.split('?')[0] + '?t=' + Date.now();
      link.parentNode.replaceChild(newLink, link);
    }
  }
})();
`;

// HMR 설정 타입
interface HMRConfig {
  watchPaths?: string[];
  ignorePaths?: string[];
  hotReloadableExtensions?: string[];
  debounceDelay?: number;
  command?: string;
  args?: string[];
  appPort?: number;
  wsPort?: number;
}

// Express 앱에 HMR 미들웨어 추가
export function setupHMRMiddleware(app: any): void {
  if (process.env.NODE_ENV !== 'development') return;
  
  // HMR 클라이언트 주입
  app.use((req: any, res: any, next: any) => {
    if (req.path.endsWith('.html')) {
      const originalSend = res.send;
      res.send = function(html: string) {
        if (typeof html === 'string' && html.includes('</body>')) {
          html = html.replace('</body>', `<script>${hmrClient}</script></body>`);
        }
        originalSend.call(this, html);
      };
    }
    next();
  });
  
  // 전역 객체 설정
  global.app = app;
  global.HMR_MODULES = new Set();
}
```

### SubTask 0.12.3: 개발용 데이터 모킹 시스템
**목표**: 외부 의존성 없이 개발할 수 있는 모킹 시스템

**구현 내용**:
```typescript
// backend/src/dev/mock-system.ts
import { faker } from '@faker-js/faker';
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';

// 모킹 서비스 매니저
export class MockServiceManager {
  private mockServers: Map<string, any> = new Map();
  private mockData: Map<string, any> = new Map();
  
  // 모든 모킹 서비스 시작
  async startAll(): Promise<void> {
    await Promise.all([
      this.startBedrockMock(),
      this.startDynamoDBMock(),
      this.startS3Mock(),
      this.startExternalAPIMocks()
    ]);
    
    console.log('✅ All mock services started');
  }
  
  // Bedrock API 모킹
  private async startBedrockMock(): Promise<void> {
    const app = express();
    app.use(express.json());
    
    // Claude 모델 응답 모킹
    app.post('/model/anthropic.claude-*/invoke', async (req, res) => {
      const { prompt } = req.body;
      
      // 지연 시뮬레이션
      await this.simulateLatency(500, 2000);
      
      // 모의 응답 생성
      const response = this.generateMockLLMResponse(prompt);
      
      res.json({
        completion: response,
        stop_reason: 'stop_sequence',
        model: req.params[0],
        usage: {
          input_tokens: prompt.split(' ').length * 1.3,
          output_tokens: response.split(' ').length * 1.3
        }
      });
    });
    
    const server = app.listen(4567, () => {
      console.log('🤖 Bedrock mock server running on port 4567');
    });
    
    this.mockServers.set('bedrock', server);
  }
  
  // DynamoDB 모킹
  private async startDynamoDBMock(): Promise<void> {
    const app = express();
    app.use(express.json());
    
    // 테이블별 데이터 저장소
    const tables: Map<string, any[]> = new Map();
    
    // PutItem
    app.post('/tables/:tableName/items', (req, res) => {
      const { tableName } = req.params;
      const item = req.body.Item;
      
      if (!tables.has(tableName)) {
        tables.set(tableName, []);
      }
      
      const tableData = tables.get(tableName)!;
      const existingIndex = tableData.findIndex(i => i.id === item.id);
      
      if (existingIndex >= 0) {
        tableData[existingIndex] = item;
      } else {
        tableData.push(item);
      }
      
      res.json({ Attributes: item });
    });
    
    // GetItem
    app.get('/tables/:tableName/items/:id', (req, res) => {
      const { tableName, id } = req.params;
      const tableData = tables.get(tableName) || [];
      const item = tableData.find(i => i.id === id);
      
      if (item) {
        res.json({ Item: item });
      } else {
        res.status(404).json({ message: 'Item not found' });
      }
    });
    
    // Query
    app.post('/tables/:tableName/query', (req, res) => {
      const { tableName } = req.params;
      const { KeyConditionExpression, ExpressionAttributeValues } = req.body;
      
      const tableData = tables.get(tableName) || [];
      
      // 간단한 쿼리 시뮬레이션
      const results = tableData.filter(item => {
        // 실제 구현에서는 KeyConditionExpression 파싱 필요
        return true;
      });
      
      res.json({
        Items: results,
        Count: results.length,
        ScannedCount: results.length
      });
    });
    
    const server = app.listen(8000, () => {
      console.log('🗃️  DynamoDB mock server running on port 8000');
    });
    
    this.mockServers.set('dynamodb', server);
    
    // 초기 데이터 시딩
    await this.seedDynamoDBData(tables);
  }
  
  // S3 모킹
  private async startS3Mock(): Promise<void> {
    const app = express();
    app.use(express.json());
    app.use(express.raw({ type: '*/*', limit: '100mb' }));
    
    const buckets: Map<string, Map<string, any>> = new Map();
    
    // CreateBucket
    app.put('/:bucket', (req, res) => {
      const { bucket } = req.params;
      
      if (!buckets.has(bucket)) {
        buckets.set(bucket, new Map());
        res.status(200).send();
      } else {
        res.status(409).json({ 
          Code: 'BucketAlreadyExists',
          Message: 'The requested bucket name is not available'
        });
      }
    });
    
    // PutObject
    app.put('/:bucket/:key(*)', (req, res) => {
      const { bucket, key } = req.params;
      
      if (!buckets.has(bucket)) {
        return res.status(404).json({ Code: 'NoSuchBucket' });
      }
      
      const bucketData = buckets.get(bucket)!;
      bucketData.set(key, {
        Body: req.body,
        ContentType: req.headers['content-type'],
        ContentLength: req.body.length,
        ETag: `"${faker.string.alphanumeric(32)}"`,
        LastModified: new Date().toISOString()
      });
      
      res.json({ ETag: bucketData.get(key).ETag });
    });
    
    // GetObject
    app.get('/:bucket/:key(*)', (req, res) => {
      const { bucket, key } = req.params;
      
      if (!buckets.has(bucket)) {
        return res.status(404).json({ Code: 'NoSuchBucket' });
      }
      
      const bucketData = buckets.get(bucket)!;
      const object = bucketData.get(key);
      
      if (!object) {
        return res.status(404).json({ Code: 'NoSuchKey' });
      }
      
      res.set({
        'Content-Type': object.ContentType,
        'Content-Length': object.ContentLength,
        'ETag': object.ETag,
        'Last-Modified': object.LastModified
      });
      
      res.send(object.Body);
    });
    
    const server = app.listen(4568, () => {
      console.log('☁️  S3 mock server running on port 4568');
    });
    
    this.mockServers.set('s3', server);
  }
  
  // 외부 API 모킹
  private async startExternalAPIMocks(): Promise<void> {
    const app = express();
    app.use(express.json());
    
    // NPM Registry 모킹
    app.get('/npm/:package', (req, res) => {
      const packageInfo = this.generateMockNPMPackage(req.params.package);
      res.json(packageInfo);
    });
    
    // GitHub API 모킹
    app.get('/github/repos/:owner/:repo', (req, res) => {
      const repoInfo = this.generateMockGitHubRepo(req.params.owner, req.params.repo);
      res.json(repoInfo);
    });
    
    // PyPI 모킹
    app.get('/pypi/:package', (req, res) => {
      const packageInfo = this.generateMockPyPIPackage(req.params.package);
      res.json(packageInfo);
    });
    
    const server = app.listen(4569, () => {
      console.log('🌐 External API mock server running on port 4569');
    });
    
    this.mockServers.set('external', server);
  }
  
  // 모의 LLM 응답 생성
  private generateMockLLMResponse(prompt: string): string {
    const responses: Record<string, string> = {
      'analyze': 'Based on my analysis, this appears to be a web application project that requires user authentication, data storage, and a RESTful API.',
      'generate': 'Here\'s the generated code:\n\n```javascript\nclass ExampleService {\n  async getData() {\n    return { success: true, data: [] };\n  }\n}\n```',
      'default': faker.lorem.paragraphs(2)
    };
    
    const keyword = Object.keys(responses).find(k => prompt.toLowerCase().includes(k));
    return responses[keyword || 'default'];
  }
  
  // NPM 패키지 정보 생성
  private generateMockNPMPackage(packageName: string): any {
    return {
      name: packageName,
      version: faker.system.semver(),
      description: faker.lorem.sentence(),
      keywords: faker.lorem.words(5).split(' '),
      author: faker.person.fullName(),
      license: faker.helpers.arrayElement(['MIT', 'Apache-2.0', 'GPL-3.0']),
      repository: {
        type: 'git',
        url: `https://github.com/${faker.internet.userName()}/${packageName}`
      },
      dependencies: this.generateMockDependencies(),
      devDependencies: this.generateMockDependencies(),
      downloads: {
        weekly: faker.number.int({ min: 1000, max: 1000000 })
      }
    };
  }
  
  // GitHub 리포지토리 정보 생성
  private generateMockGitHubRepo(owner: string, repo: string): any {
    return {
      id: faker.number.int({ min: 1000000, max: 9999999 }),
      name: repo,
      full_name: `${owner}/${repo}`,
      owner: {
        login: owner,
        avatar_url: faker.image.avatar()
      },
      description: faker.lorem.sentence(),
      fork: false,
      created_at: faker.date.past().toISOString(),
      updated_at: faker.date.recent().toISOString(),
      pushed_at: faker.date.recent().toISOString(),
      stargazers_count: faker.number.int({ min: 0, max: 50000 }),
      watchers_count: faker.number.int({ min: 0, max: 5000 }),
      forks_count: faker.number.int({ min: 0, max: 10000 }),
      language: faker.helpers.arrayElement(['JavaScript', 'TypeScript', 'Python', 'Java', 'Go']),
      license: {
        key: 'mit',
        name: 'MIT License'
      }
    };
  }
  
  // PyPI 패키지 정보 생성
  private generateMockPyPIPackage(packageName: string): any {
    return {
      info: {
        name: packageName,
        version: faker.system.semver(),
        summary: faker.lorem.sentence(),
        author: faker.person.fullName(),
        author_email: faker.internet.email(),
        license: faker.helpers.arrayElement(['MIT', 'Apache-2.0', 'GPL-3.0']),
        keywords: faker.lorem.words(5),
        classifiers: [
          'Development Status :: 4 - Beta',
          'Intended Audience :: Developers',
          'Programming Language :: Python :: 3'
        ]
      },
      releases: this.generateMockReleases()
    };
  }
  
  // 의존성 생성
  private generateMockDependencies(): Record<string, string> {
    const deps: Record<string, string> = {};
    const count = faker.number.int({ min: 3, max: 10 });
    
    for (let i = 0; i < count; i++) {
      const packageName = faker.helpers.arrayElement([
        'express', 'react', 'vue', 'lodash', 'axios',
        'moment', 'uuid', 'bcrypt', 'jsonwebtoken', 'dotenv'
      ]);
      deps[packageName] = `^${faker.system.semver()}`;
    }
    
    return deps;
  }
  
  // 릴리스 정보 생성
  private generateMockReleases(): Record<string, any[]> {
    const releases: Record<string, any[]> = {};
    const versionCount = faker.number.int({ min: 3, max: 10 });
    
    for (let i = 0; i < versionCount; i++) {
      const version = faker.system.semver();
      releases[version] = [{
        filename: `package-${version}.tar.gz`,
        size: faker.number.int({ min: 10000, max: 1000000 }),
        upload_time: faker.date.past().toISOString()
      }];
    }
    
    return releases;
  }
  
  // DynamoDB 초기 데이터 시딩
  private async seedDynamoDBData(tables: Map<string, any[]>): Promise<void> {
    // Projects 테이블
    const projects = [];
    for (let i = 0; i < 20; i++) {
      projects.push({
        id: `proj_${faker.string.uuid()}`,
        name: faker.commerce.productName(),
        description: faker.lorem.paragraph(),
        status: faker.helpers.arrayElement(['analyzing', 'building', 'completed']),
        createdAt: faker.date.past().toISOString()
      });
    }
    tables.set('T-Developer-Projects', projects);
    
    // Components 테이블
    const components = [];
    for (let i = 0; i < 50; i++) {
      components.push({
        id: `comp_${faker.string.uuid()}`,
        name: faker.hacker.noun(),
        version: faker.system.semver(),
        language: faker.helpers.arrayElement(['javascript', 'typescript', 'python']),
        downloads: faker.number.int({ min: 100, max: 100000 })
      });
    }
    tables.set('T-Developer-Components', components);
  }
  
  // 지연 시뮬레이션
  private async simulateLatency(min: number, max: number): Promise<void> {
    const delay = faker.number.int({ min, max });
    await new Promise(resolve => setTimeout(resolve, delay));
  }
  
  // 모든 모킹 서비스 중지
  async stopAll(): Promise<void> {
    for (const [name, server] of this.mockServers) {
      server.close();
      console.log(`🛑 ${name} mock server stopped`);
    }
    
    this.mockServers.clear();
    this.mockData.clear();
  }
}

// WebSocket 모킹
export class WebSocketMockServer {
  private io: Server;
  
  constructor(httpServer: any) {
    this.io = new Server(httpServer, {
      cors: {
        origin: '*',
        methods: ['GET', 'POST']
      }
    });
    
    this.setupHandlers();
  }
  
  private setupHandlers(): void {
    this.io.on('connection', (socket) => {
      console.log('Mock WebSocket client connected');
      
      // 프로젝트 상태 업데이트 시뮬레이션
      this.simulateProjectUpdates(socket);
      
      // 에이전트 실행 상태 시뮬레이션
      this.simulateAgentExecutions(socket);
      
      socket.on('disconnect', () => {
        console.log('Mock WebSocket client disconnected');
      });
    });
  }
  
  private simulateProjectUpdates(socket: any): void {
    const projectId = `proj_${faker.string.uuid()}`;
    const statuses = ['analyzing', 'designing', 'building', 'testing', 'completed'];
    let currentIndex = 0;
    
    const interval = setInterval(() => {
      if (currentIndex >= statuses.length) {
        clearInterval(interval);
        return;
      }
      
      socket.emit('project:update', {
        projectId,
        status: statuses[currentIndex],
        progress: (currentIndex + 1) / statuses.length * 100,
        timestamp: new Date().toISOString()
      });
      
      currentIndex++;
    }, 3000);
  }
  
  private simulateAgentExecutions(socket: any): void {
    const agents = [
      'nl-input', 'ui-selection', 'parsing', 'component-decision',
      'matching-rate', 'search', 'generation', 'assembly', 'download'
    ];
    
    agents.forEach((agent, index) => {
      setTimeout(() => {
        socket.emit('agent:start', {
          agentName: agent,
          timestamp: new Date().toISOString()
        });
        
        setTimeout(() => {
          socket.emit('agent:complete', {
            agentName: agent,
            result: 'success',
            duration: faker.number.int({ min: 1000, max: 5000 }),
            timestamp: new Date().toISOString()
          });
        }, faker.number.int({ min: 2000, max: 8000 }));
      }, index * 2000);
    });
  }
}

// 모킹 설정
export const mockConfig = {
  enabled: process.env.USE_MOCKS === 'true',
  services: {
    bedrock: process.env.MOCK_BEDROCK === 'true',
    dynamodb: process.env.MOCK_DYNAMODB === 'true',
    s3: process.env.MOCK_S3 === 'true',
    external: process.env.MOCK_EXTERNAL_APIS === 'true'
  },
  endpoints: {
    bedrock: 'http://localhost:4567',
    dynamodb: 'http://localhost:8000',
    s3: 'http://localhost:4568',
    npm: 'http://localhost:4569/npm',
    github: 'http://localhost:4569/github',
    pypi: 'http://localhost:4569/pypi'
  }
};
```
---

### SubTask 0.12.4: 디버깅 도구 통합
**목표**: 효율적인 디버깅을 위한 도구 및 설정

**구현 내용**:
```typescript
// backend/src/dev/debugging-tools.ts
import { InspectorSession } from 'inspector';
import { performance } from 'perf_hooks';
import { AsyncLocalStorage } from 'async_hooks';
import util from 'util';
import chalk from 'chalk';

// 트레이스 컨텍스트 관리
export const traceContext = new AsyncLocalStorage<TraceContext>();

interface TraceContext {
  traceId: string;
  spanId: string;
  parentSpanId?: string;
  startTime: number;
  metadata: Record<string, any>;
}

// 고급 디버거
export class AdvancedDebugger {
  private session: InspectorSession;
  private breakpoints: Map<string, Breakpoint> = new Map();
  private profiles: Map<string, any> = new Map();
  
  constructor() {
    this.session = new InspectorSession();
    this.session.connect();
  }
  
  // 조건부 브레이크포인트 설정
  async setConditionalBreakpoint(
    file: string,
    line: number,
    condition: string,
    logMessage?: string
  ): Promise<void> {
    const scriptId = await this.getScriptId(file);
    
    await this.post('Debugger.setBreakpoint', {
      location: {
        scriptId,
        lineNumber: line - 1
      },
      condition
    });
    
    this.breakpoints.set(`${file}:${line}`, {
      file,
      line,
      condition,
      logMessage,
      hitCount: 0
    });
    
    if (logMessage) {
      // 로그 브레이크포인트
      await this.post('Runtime.addBinding', {
        name: 'logpoint',
        executionContextId: 1
      });
    }
  }
  
  // 성능 프로파일링 시작
  async startProfiling(profileName: string): Promise<void> {
    await this.post('Profiler.enable');
    await this.post('Profiler.start');
    
    this.profiles.set(profileName, {
      startTime: Date.now(),
      name: profileName
    });
  }
  
  // 성능 프로파일링 중지
  async stopProfiling(profileName: string): Promise<CPUProfile> {
    const result = await this.post('Profiler.stop');
    await this.post('Profiler.disable');
    
    const profile = this.profiles.get(profileName);
    if (profile) {
      profile.endTime = Date.now();
      profile.data = result.profile;
    }
    
    return this.analyzeCPUProfile(result.profile);
  }
  
  // 메모리 스냅샷
  async takeHeapSnapshot(tag?: string): Promise<string> {
    await this.post('HeapProfiler.enable');
    
    const chunks: string[] = [];
    
    this.session.on('HeapProfiler.addHeapSnapshotChunk', (message) => {
      chunks.push(message.params.chunk);
    });
    
    await this.post('HeapProfiler.takeHeapSnapshot', {
      reportProgress: true,
      treatGlobalObjectsAsRoots: true
    });
    
    await this.post('HeapProfiler.disable');
    
    const snapshot = chunks.join('');
    const filename = `heapsnapshot-${tag || Date.now()}.json`;
    
    await fs.writeFile(filename, snapshot);
    
    return filename;
  }
  
  // 비동기 스택 트레이스 활성화
  async enableAsyncStackTraces(): Promise<void> {
    await this.post('Debugger.enable');
    await this.post('Debugger.setAsyncCallStackDepth', { maxDepth: 32 });
  }
  
  // 런타임 평가
  async evaluate(expression: string, contextId?: number): Promise<any> {
    const result = await this.post('Runtime.evaluate', {
      expression,
      generatePreview: true,
      includeCommandLineAPI: true,
      contextId
    });
    
    if (result.exceptionDetails) {
      throw new Error(result.exceptionDetails.text);
    }
    
    return result.result.value;
  }
  
  // CPU 프로파일 분석
  private analyzeCPUProfile(profile: any): CPUProfile {
    const nodes = new Map<number, any>();
    let totalTime = 0;
    
    // 노드 맵 생성
    profile.nodes.forEach((node: any) => {
      nodes.set(node.id, {
        ...node,
        selfTime: 0,
        totalTime: 0,
        children: []
      });
    });
    
    // 부모-자식 관계 설정
    profile.nodes.forEach((node: any) => {
      if (node.parent) {
        const parent = nodes.get(node.parent);
        if (parent) {
          parent.children.push(node.id);
        }
      }
    });
    
    // 시간 계산
    if (profile.samples && profile.timeDeltas) {
      let currentTime = profile.startTime;
      
      profile.samples.forEach((sample: number, index: number) => {
        const node = nodes.get(sample);
        if (node) {
          const delta = profile.timeDeltas[index];
          node.selfTime += delta;
          totalTime += delta;
          
          // 부모 노드들의 totalTime 업데이트
          let current = node;
          while (current) {
            current.totalTime += delta;
            current = nodes.get(current.parent);
          }
        }
        
        currentTime += profile.timeDeltas[index];
      });
    }
    
    // 핫스팟 찾기
    const hotspots = Array.from(nodes.values())
      .filter(node => node.selfTime > 0)
      .sort((a, b) => b.selfTime - a.selfTime)
      .slice(0, 10)
      .map(node => ({
        functionName: node.callFrame.functionName || '(anonymous)',
        url: node.callFrame.url,
        lineNumber: node.callFrame.lineNumber,
        selfTime: node.selfTime,
        totalTime: node.totalTime,
        percentage: (node.selfTime / totalTime) * 100
      }));
    
    return {
      totalTime,
      hotspots,
      profile
    };
  }
  
  // Inspector 세션 명령 실행
  private post(method: string, params?: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.session.post(method, params, (err, result) => {
        if (err) reject(err);
        else resolve(result);
      });
    });
  }
  
  // 스크립트 ID 가져오기
  private async getScriptId(filename: string): Promise<string> {
    const result = await this.post('Debugger.enable');
    // 실제 구현에서는 스크립트 목록에서 파일명으로 검색
    return '1'; // 임시
  }
}

// 실행 추적기
export class ExecutionTracer {
  private traces: Map<string, Trace[]> = new Map();
  
  // 함수 추적 데코레이터
  trace(options: TraceOptions = {}) {
    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
      const originalMethod = descriptor.value;
      
      descriptor.value = async function(...args: any[]) {
        const traceId = traceContext.getStore()?.traceId || generateTraceId();
        const spanId = generateSpanId();
        const startTime = performance.now();
        
        const trace: Trace = {
          traceId,
          spanId,
          method: `${target.constructor.name}.${propertyKey}`,
          args: options.logArgs ? args : undefined,
          startTime,
          metadata: {}
        };
        
        // 추적 시작
        if (options.log) {
          console.log(chalk.blue(`→ ${trace.method}`), {
            traceId,
            spanId,
            args: options.logArgs ? args : '[hidden]'
          });
        }
        
        try {
          // 컨텍스트 설정
          const result = await traceContext.run(
            {
              traceId,
              spanId,
              parentSpanId: traceContext.getStore()?.spanId,
              startTime,
              metadata: {}
            },
            async () => await originalMethod.apply(this, args)
          );
          
          trace.endTime = performance.now();
          trace.duration = trace.endTime - trace.startTime;
          trace.result = options.logResult ? result : undefined;
          trace.success = true;
          
          // 추적 완료
          if (options.log) {
            console.log(
              chalk.green(`← ${trace.method}`),
              chalk.gray(`(${trace.duration.toFixed(2)}ms)`),
              {
                traceId,
                spanId,
                result: options.logResult ? result : '[hidden]'
              }
            );
          }
          
          return result;
          
        } catch (error) {
          trace.endTime = performance.now();
          trace.duration = trace.endTime - trace.startTime;
          trace.error = error;
          trace.success = false;
          
          // 에러 추적
          if (options.log) {
            console.log(
              chalk.red(`✗ ${trace.method}`),
              chalk.gray(`(${trace.duration.toFixed(2)}ms)`),
              {
                traceId,
                spanId,
                error: error.message
              }
            );
          }
          
          throw error;
          
        } finally {
          // 추적 저장
          this.saveTrace(trace);
        }
      };
      
      return descriptor;
    };
  }
  
  // 수동 추적
  async traceExecution<T>(
    name: string,
    fn: () => Promise<T>,
    metadata?: Record<string, any>
  ): Promise<T> {
    const traceId = traceContext.getStore()?.traceId || generateTraceId();
    const spanId = generateSpanId();
    const startTime = performance.now();
    
    console.log(chalk.blue(`→ ${name}`), { traceId, spanId });
    
    try {
      const result = await traceContext.run(
        {
          traceId,
          spanId,
          parentSpanId: traceContext.getStore()?.spanId,
          startTime,
          metadata: metadata || {}
        },
        fn
      );
      
      const duration = performance.now() - startTime;
      console.log(
        chalk.green(`← ${name}`),
        chalk.gray(`(${duration.toFixed(2)}ms)`)
      );
      
      return result;
      
    } catch (error) {
      const duration = performance.now() - startTime;
      console.log(
        chalk.red(`✗ ${name}`),
        chalk.gray(`(${duration.toFixed(2)}ms)`),
        error
      );
      throw error;
    }
  }
  
  // 추적 저장
  private saveTrace(trace: Trace): void {
    if (!this.traces.has(trace.traceId)) {
      this.traces.set(trace.traceId, []);
    }
    
    this.traces.get(trace.traceId)!.push(trace);
  }
  
  // 추적 조회
  getTrace(traceId: string): Trace[] | undefined {
    return this.traces.get(traceId);
  }
  
  // 추적 시각화
  visualizeTrace(traceId: string): string {
    const traces = this.getTrace(traceId);
    if (!traces) return 'Trace not found';
    
    const sorted = traces.sort((a, b) => a.startTime - b.startTime);
    const lines: string[] = [''];
    
    sorted.forEach((trace, index) => {
      const indent = '  '.repeat(trace.metadata.depth || 0);
      const duration = trace.duration?.toFixed(2) || '?';
      const status = trace.success ? '✓' : '✗';
      
      lines.push(
        `${indent}${status} ${trace.method} (${duration}ms)`
      );
    });
    
    return lines.join('\n');
  }
}

// 향상된 콘솔 로깅
export class EnhancedConsole {
  private originalConsole = { ...console };
  
  install(): void {
    // console.log 오버라이드
    console.log = (...args: any[]) => {
      const enhanced = this.enhance(args);
      this.originalConsole.log(...enhanced);
    };
    
    // console.error 오버라이드
    console.error = (...args: any[]) => {
      const enhanced = this.enhance(args, 'error');
      this.originalConsole.error(...enhanced);
    };
    
    // console.table 개선
    const originalTable = console.table;
    console.table = (data: any, columns?: string[]) => {
      if (typeof data === 'object' && data !== null) {
        // 더 나은 포맷팅
        this.originalConsole.log(chalk.cyan('┌─ Table ─────────────────────┐'));
        originalTable.call(console, data, columns);
        this.originalConsole.log(chalk.cyan('└─────────────────────────────┘'));
      } else {
        originalTable.call(console, data, columns);
      }
    };
  }
  
  private enhance(args: any[], type: string = 'log'): any[] {
    const ctx = traceContext.getStore();
    const timestamp = new Date().toISOString();
    
    // 컬러 및 포맷팅
    const prefix = type === 'error' 
      ? chalk.red(`[${timestamp}]`)
      : chalk.gray(`[${timestamp}]`);
    
    // 트레이스 정보 추가
    const traceInfo = ctx 
      ? chalk.dim(`[${ctx.traceId.slice(0, 8)}/${ctx.spanId.slice(0, 8)}]`)
      : '';
    
    // 객체 깊은 검사
    const enhanced = args.map(arg => {
      if (typeof arg === 'object' && arg !== null) {
        return util.inspect(arg, {
          colors: true,
          depth: 4,
          maxArrayLength: 100,
          breakLength: 80,
          compact: false
        });
      }
      return arg;
    });
    
    return [prefix, traceInfo, ...enhanced];
  }
}

// 디버그 프록시
export function createDebugProxy<T extends object>(
  target: T,
  name: string = 'Object'
): T {
  return new Proxy(target, {
    get(obj, prop, receiver) {
      const value = Reflect.get(obj, prop, receiver);
      console.log(chalk.yellow(`[Proxy:${name}] GET`), prop, '→', value);
      return value;
    },
    
    set(obj, prop, value, receiver) {
      console.log(chalk.yellow(`[Proxy:${name}] SET`), prop, '←', value);
      return Reflect.set(obj, prop, value, receiver);
    },
    
    deleteProperty(obj, prop) {
      console.log(chalk.yellow(`[Proxy:${name}] DELETE`), prop);
      return Reflect.deleteProperty(obj, prop);
    },
    
    has(obj, prop) {
      const exists = Reflect.has(obj, prop);
      console.log(chalk.yellow(`[Proxy:${name}] HAS`), prop, '→', exists);
      return exists;
    }
  });
}

// 타입 정의
interface Breakpoint {
  file: string;
  line: number;
  condition?: string;
  logMessage?: string;
  hitCount: number;
}

interface CPUProfile {
  totalTime: number;
  hotspots: Array<{
    functionName: string;
    url: string;
    lineNumber: number;
    selfTime: number;
    totalTime: number;
    percentage: number;
  }>;
  profile: any;
}

interface TraceOptions {
  log?: boolean;
  logArgs?: boolean;
  logResult?: boolean;
}

interface Trace {
  traceId: string;
  spanId: string;
  method: string;
  args?: any[];
  result?: any;
  error?: any;
  startTime: number;
  endTime?: number;
  duration?: number;
  success?: boolean;
  metadata: Record<string, any>;
}

// 유틸리티 함수
function generateTraceId(): string {
  return crypto.randomBytes(16).toString('hex');
}

function generateSpanId(): string {
  return crypto.randomBytes(8).toString('hex');
}

// 디버깅 미들웨어
export function debuggingMiddleware() {
  return (req: Request, res: Response, next: NextFunction) => {
    const traceId = req.headers['x-trace-id'] as string || generateTraceId();
    const spanId = generateSpanId();
    
    // 요청 로깅
    console.log(chalk.blue('→ HTTP Request'), {
      method: req.method,
      path: req.path,
      traceId,
      spanId,
      headers: req.headers,
      body: req.body
    });
    
    // 트레이스 컨텍스트 설정
    traceContext.run(
      {
        traceId,
        spanId,
        startTime: Date.now(),
        metadata: {
          method: req.method,
          path: req.path
        }
      },
      () => {
        // 응답 로깅
        const originalSend = res.send;
        res.send = function(data: any) {
          console.log(chalk.green('← HTTP Response'), {
            traceId,
            spanId,
            statusCode: res.statusCode,
            body: data
          });
          
          return originalSend.call(this, data);
        };
        
        next();
      }
    );
  };
}
```

### SubTask 0.12.5: 개발 환경 프리셋 관리
**목표**: 다양한 개발 시나리오를 위한 환경 프리셋

**구현 내용**:
```typescript
// backend/src/dev/environment-presets.ts
import { promises as fs } from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import dotenv from 'dotenv';

// 환경 프리셋 매니저
export class EnvironmentPresetManager {
  private presets: Map<string, EnvironmentPreset> = new Map();
  private currentPreset?: string;
  
  constructor(private presetsDir: string = './config/presets') {}
  
  // 프리셋 로드
  async loadPresets(): Promise<void> {
    const files = await fs.readdir(this.presetsDir);
    
    for (const file of files) {
      if (file.endsWith('.yaml') || file.endsWith('.yml')) {
        const content = await fs.readFile(
          path.join(this.presetsDir, file),
          'utf-8'
        );
        
        const preset = yaml.load(content) as EnvironmentPreset;
        const name = path.basename(file, path.extname(file));
        
        this.presets.set(name, preset);
        console.log(`📦 Loaded preset: ${name}`);
      }
    }
  }
  
  // 프리셋 활성화
  async activatePreset(name: string): Promise<void> {
    const preset = this.presets.get(name);
    if (!preset) {
      throw new Error(`Preset '${name}' not found`);
    }
    
    console.log(`🚀 Activating preset: ${name}`);
    
    // 환경 변수 설정
    await this.applyEnvironmentVariables(preset.env);
    
    // 서비스 시작
    await this.startServices(preset.services);
    
    // Mock 설정
    await this.configureMocks(preset.mocks);
    
    // 초기 데이터 설정
    await this.loadInitialData(preset.data);
    
    // 스크립트 실행
    await this.runScripts(preset.scripts?.setup);
    
    this.currentPreset = name;
    console.log(`✅ Preset '${name}' activated`);
  }
  
  // 프리셋 비활성화
  async deactivatePreset(): Promise<void> {
    if (!this.currentPreset) return;
    
    const preset = this.presets.get(this.currentPreset);
    if (!preset) return;
    
    console.log(`🛑 Deactivating preset: ${this.currentPreset}`);
    
    // 정리 스크립트 실행
    await this.runScripts(preset.scripts?.teardown);
    
    // 서비스 중지
    await this.stopServices(preset.services);
    
    this.currentPreset = undefined;
  }
  
  // 환경 변수 적용
  private async applyEnvironmentVariables(
    env?: Record<string, string | number | boolean>
  ): Promise<void> {
    if (!env) return;
    
    // 현재 환경 변수 백업
    const backup = { ...process.env };
    
    // 새 환경 변수 적용
    Object.entries(env).forEach(([key, value]) => {
      process.env[key] = String(value);
    });
    
    // .env 파일 업데이트
    const envPath = path.join(process.cwd(), '.env.preset');
    const envContent = Object.entries(env)
      .map(([key, value]) => `${key}=${value}`)
      .join('\n');
    
    await fs.writeFile(envPath, envContent);
    dotenv.config({ path: envPath, override: true });
  }
  
  // 서비스 시작
  private async startServices(services?: ServiceConfig[]): Promise<void> {
    if (!services) return;
    
    for (const service of services) {
      console.log(`🔧 Starting service: ${service.name}`);
      
      switch (service.type) {
        case 'docker':
          await this.startDockerService(service);
          break;
        case 'process':
          await this.startProcessService(service);
          break;
        case 'mock':
          await this.startMockService(service);
          break;
      }
    }
  }
  
  // Docker 서비스 시작
  private async startDockerService(service: ServiceConfig): Promise<void> {
    const { spawn } = require('child_process');
    
    const args = ['run', '--rm', '-d'];
    
    // 포트 매핑
    if (service.ports) {
      service.ports.forEach(port => {
        args.push('-p', port);
      });
    }
    
    // 환경 변수
    if (service.env) {
      Object.entries(service.env).forEach(([key, value]) => {
        args.push('-e', `${key}=${value}`);
      });
    }
    
    // 컨테이너 이름
    args.push('--name', `t-dev-${service.name}`);
    
    // 이미지
    args.push(service.image!);
    
    const docker = spawn('docker', args);
    
    docker.on('error', (error) => {
      console.error(`Failed to start ${service.name}:`, error);
    });
  }
  
  // 프로세스 서비스 시작
  private async startProcessService(service: ServiceConfig): Promise<void> {
    const { spawn } = require('child_process');
    
    const [command, ...args] = service.command!.split(' ');
    
    const process = spawn(command, args, {
      env: { ...process.env, ...service.env },
      cwd: service.cwd,
      detached: true
    });
    
    process.unref();
  }
  
  // Mock 서비스 시작
  private async startMockService(service: ServiceConfig): Promise<void> {
    const { MockServiceManager } = await import('./mock-system');
    const mockManager = new MockServiceManager();
    
    if (service.name === 'all') {
      await mockManager.startAll();
    } else {
      // 특정 서비스만 시작
      await mockManager[`start${service.name}Mock`]();
    }
  }
  
  // 서비스 중지
  private async stopServices(services?: ServiceConfig[]): Promise<void> {
    if (!services) return;
    
    for (const service of services) {
      console.log(`🛑 Stopping service: ${service.name}`);
      
      if (service.type === 'docker') {
        const { exec } = require('child_process');
        exec(`docker stop t-dev-${service.name}`);
      }
    }
  }
  
  // Mock 설정
  private async configureMocks(mocks?: MockConfig): Promise<void> {
    if (!mocks) return;
    
    // Mock 응답 설정
    if (mocks.responses) {
      // 실제 구현에서는 Mock 시스템에 응답 설정
    }
    
    // 지연 설정
    if (mocks.latency) {
      process.env.MOCK_LATENCY_MIN = String(mocks.latency.min);
      process.env.MOCK_LATENCY_MAX = String(mocks.latency.max);
    }
    
    // 에러 시뮬레이션
    if (mocks.errors) {
      process.env.MOCK_ERROR_RATE = String(mocks.errors.rate);
    }
  }
  
  // 초기 데이터 로드
  private async loadInitialData(data?: DataConfig): Promise<void> {
    if (!data) return;
    
    console.log('📊 Loading initial data...');
    
    // 파일에서 로드
    if (data.files) {
      for (const file of data.files) {
        const content = await fs.readFile(file, 'utf-8');
        const items = JSON.parse(content);
        
        // 데이터베이스에 삽입
        await this.insertData(data.target, items);
      }
    }
    
    // 생성기로 생성
    if (data.generators) {
      for (const generator of data.generators) {
        const { generateTestData } = await import('./test-data-generator');
        const items = await generateTestData(generator.type, generator.count);
        
        await this.insertData(data.target, items);
      }
    }
  }
  
  // 데이터 삽입
  private async insertData(target: string, items: any[]): Promise<void> {
    // 실제 구현에서는 DynamoDB 또는 다른 데이터베이스에 삽입
    console.log(`💾 Inserted ${items.length} items into ${target}`);
  }
  
  // 스크립트 실행
  private async runScripts(scripts?: string[]): Promise<void> {
    if (!scripts) return;
    
    for (const script of scripts) {
      console.log(`📜 Running script: ${script}`);
      
      const { exec } = require('child_process');
      const { promisify } = require('util');
      const execAsync = promisify(exec);
      
      try {
        const { stdout, stderr } = await execAsync(script);
        if (stdout) console.log(stdout);
        if (stderr) console.error(stderr);
      } catch (error) {
        console.error(`Script failed: ${script}`, error);
      }
    }
  }
  
  // 프리셋 목록
  listPresets(): PresetInfo[] {
    return Array.from(this.presets.entries()).map(([name, preset]) => ({
      name,
      description: preset.description,
      active: name === this.currentPreset
    }));
  }
  
  // 프리셋 생성
  async createPreset(name: string, config: EnvironmentPreset): Promise<void> {
    const filePath = path.join(this.presetsDir, `${name}.yaml`);
    const content = yaml.dump(config);
    
    await fs.writeFile(filePath, content);
    this.presets.set(name, config);
    
    console.log(`✅ Created preset: ${name}`);
  }
}

// 프리셋 타입 정의
interface EnvironmentPreset {
  name: string;
  description: string;
  env?: Record<string, string | number | boolean>;
  services?: ServiceConfig[];
  mocks?: MockConfig;
  data?: DataConfig;
  scripts?: {
    setup?: string[];
    teardown?: string[];
  };
}

interface ServiceConfig {
  name: string;
  type: 'docker' | 'process' | 'mock';
  image?: string;
  command?: string;
  ports?: string[];
  env?: Record<string, string>;
  cwd?: string;
}

interface MockConfig {
  enabled: boolean;
  services?: string[];
  responses?: Record<string, any>;
  latency?: {
    min: number;
    max: number;
  };
  errors?: {
    rate: number;
    types?: string[];
  };
}

interface DataConfig {
  target: string;
  files?: string[];
  generators?: Array<{
    type: string;
    count: number;
    options?: any;
  }>;
}

interface PresetInfo {
  name: string;
  description: string;
  active: boolean;
}

// 프리셋 예시
const examplePresets = {
  'minimal': {
    name: 'minimal',
    description: 'Minimal setup for quick development',
    env: {
      NODE_ENV: 'development',
      USE_MOCKS: false,
      LOG_LEVEL: 'debug'
    },
    services: [
      {
        name: 'dynamodb',
        type: 'docker',
        image: 'amazon/dynamodb-local',
        ports: ['8000:8000']
      }
    ]
  },
  
  'full-mocks': {
    name: 'full-mocks',
    description: 'All services mocked for offline development',
    env: {
      NODE_ENV: 'development',
      USE_MOCKS: true,
      MOCK_LATENCY: true
    },
    mocks: {
      enabled: true,
      services: ['bedrock', 'dynamodb', 's3', 'external'],
      latency: {
        min: 100,
        max: 500
      }
    },
    data: {
      target: 'dynamodb',
      generators: [
        { type: 'projects', count: 50 },
        { type: 'components', count: 200 }
      ]
    }
  },
  
  'integration-test': {
    name: 'integration-test',
    description: 'Environment for integration testing',
    env: {
      NODE_ENV: 'test',
      USE_MOCKS: true,
      LOG_LEVEL: 'error'
    },
    services: [
      {
        name: 'dynamodb',
        type: 'docker',
        image: 'amazon/dynamodb-local',
        ports: ['8000:8000']
      },
      {
        name: 'redis',
        type: 'docker',
        image: 'redis:7-alpine',
        ports: ['6379:6379']
      }
    ],
    scripts: {
      setup: [
        'npm run db:migrate:test',
        'npm run seed:test'
      ],
      teardown: [
        'npm run db:clean:test'
      ]
    }
  },
  
  'performance-test': {
    name: 'performance-test',
    description: 'Environment for performance testing',
    env: {
      NODE_ENV: 'production',
      USE_MOCKS: false,
      ENABLE_PROFILING: true,
      LOG_LEVEL: 'warn'
    },
    services: [
      {
        name: 'dynamodb',
        type: 'docker',
        image: 'amazon/dynamodb-local',
        ports: ['8000:8000'],
        env: {
          JAVA_OPTS: '-Xmx2048m'
        }
      }
    ],
    data: {
      target: 'dynamodb',
      generators: [
        { type: 'projects', count: 1000 },
        { type: 'components', count: 5000 }
      ]
    },
    scripts: {
      setup: [
        'npm run build',
        'npm run optimize'
      ]
    }
  }
};

// CLI 명령어
export function setupPresetCLI(program: any): void {
  const presetCmd = program
    .command('preset')
    .description('Manage development environment presets');
  
  presetCmd
    .command('list')
    .description('List available presets')
    .action(async () => {
      const manager = new EnvironmentPresetManager();
      await manager.loadPresets();
      
      const presets = manager.listPresets();
      console.table(presets);
    });
  
  presetCmd
    .command('activate <name>')
    .description('Activate a preset')
    .action(async (name: string) => {
      const manager = new EnvironmentPresetManager();
      await manager.loadPresets();
      await manager.activatePreset(name);
    });
  
  presetCmd
    .command('deactivate')
    .description('Deactivate current preset')
    .action(async () => {
      const manager = new EnvironmentPresetManager();
      await manager.deactivatePreset();
    });
  
  presetCmd
    .command('create <name>')
    .description('Create a new preset')
    .action(async (name: string) => {
      // 대화형 프리셋 생성
      const inquirer = require('inquirer');
      
      const answers = await inquirer.prompt([
        {
          type: 'input',
          name: 'description',
          message: 'Preset description:'
        },
        {
          type: 'checkbox',
          name: 'services',
          message: 'Select services:',
          choices: ['dynamodb', 'redis', 'elasticsearch', 'mocks']
        },
        {
          type: 'confirm',
          name: 'useMocks',
          message: 'Enable mocking?'
        }
      ]);
      
      const preset: EnvironmentPreset = {
        name,
        description: answers.description,
        env: {
          NODE_ENV: 'development',
          USE_MOCKS: answers.useMocks
        },
        services: answers.services.map((s: string) => ({
          name: s,
          type: s === 'mocks' ? 'mock' : 'docker',
          image: s === 'dynamodb' ? 'amazon/dynamodb-local' :
                 s === 'redis' ? 'redis:7-alpine' :
                 s === 'elasticsearch' ? 'elasticsearch:8.11.0' : undefined
        }))
      };
      
      const manager = new EnvironmentPresetManager();
      await manager.createPreset(name, preset);
    });
}
```

**🔧 사용자 작업**:
- 프리셋 디렉토리 생성: `mkdir -p config/presets`
- 기본 프리셋 YAML 파일 생성
- 개발 시나리오별 프리셋 구성
- `npm run dev:preset minimal` 같은 스크립트 추가

---

## Task 0.13: 에이전트 개발 환경 설정

### SubTask 0.13.1: 에이전트 프레임워크 기초 설정
**목표**: 9개 핵심 에이전트 개발을 위한 기본 프레임워크 구성

**구현 내용**:
```typescript
// backend/src/agents/framework/base-agent.ts
import { EventEmitter } from 'events';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from 'winston';
import { metrics } from '../../utils/monitoring';

export interface AgentContext {
  projectId: string;
  userId: string;
  sessionId: string;
  parentAgent?: string;
  metadata: Record<string, any>;
}

export interface AgentMessage {
  id: string;
  type: 'request' | 'response' | 'event' | 'error';
  source: string;
  target: string;
  payload: any;
  timestamp: Date;
  correlationId?: string;
}

export interface AgentCapability {
  name: string;
  description: string;
  inputSchema: any;
  outputSchema: any;
  version: string;
}

export abstract class BaseAgent extends EventEmitter {
  protected readonly id: string;
  protected readonly name: string;
  protected readonly version: string;
  protected readonly logger: Logger;
  protected context?: AgentContext;
  protected capabilities: Map<string, AgentCapability> = new Map();
  protected status: 'idle' | 'busy' | 'error' = 'idle';
  protected metrics: any;
  
  constructor(
    name: string,
    version: string,
    logger: Logger
  ) {
    super();
    this.id = `${name}-${uuidv4()}`;
    this.name = name;
    this.version = version;
    this.logger = logger;
    this.metrics = metrics;
    
    this.initialize();
  }
  
  protected abstract initialize(): void;
  protected abstract process(message: AgentMessage): Promise<any>;
  
  // 에이전트 생명주기 메서드
  async start(context: AgentContext): Promise<void> {
    this.context = context;
    this.status = 'idle';
    
    this.logger.info(`Agent ${this.name} started`, {
      agentId: this.id,
      context
    });
    
    this.metrics.increment('agent.started', 1, [`agent:${this.name}`]);
    this.emit('started', { agentId: this.id, context });
    
    await this.onStart();
  }
  
  async stop(): Promise<void> {
    this.status = 'idle';
    
    this.logger.info(`Agent ${this.name} stopped`, {
      agentId: this.id
    });
    
    this.metrics.increment('agent.stopped', 1, [`agent:${this.name}`]);
    this.emit('stopped', { agentId: this.id });
    
    await this.onStop();
  }
  
  // 메시지 처리
  async handleMessage(message: AgentMessage): Promise<AgentMessage> {
    const startTime = Date.now();
    this.status = 'busy';
    
    try {
      this.logger.debug(`Agent ${this.name} processing message`, {
        agentId: this.id,
        messageId: message.id,
        type: message.type
      });
      
      const result = await this.process(message);
      
      const response: AgentMessage = {
        id: uuidv4(),
        type: 'response',
        source: this.id,
        target: message.source,
        payload: result,
        timestamp: new Date(),
        correlationId: message.id
      };
      
      this.metrics.timing('agent.processing_time', Date.now() - startTime, [
        `agent:${this.name}`,
        `message_type:${message.type}`
      ]);
      
      this.status = 'idle';
      return response;
      
    } catch (error) {
      this.status = 'error';
      this.logger.error(`Agent ${this.name} error`, {
        agentId: this.id,
        messageId: message.id,
        error
      });
      
      this.metrics.increment('agent.errors', 1, [`agent:${this.name}`]);
      
      return {
        id: uuidv4(),
        type: 'error',
        source: this.id,
        target: message.source,
        payload: { error: error.message },
        timestamp: new Date(),
        correlationId: message.id
      };
    }
  }
  
  // 능력(Capability) 관리
  registerCapability(capability: AgentCapability): void {
    this.capabilities.set(capability.name, capability);
    this.logger.info(`Capability registered: ${capability.name}`, {
      agentId: this.id,
      capability
    });
  }
  
  getCapabilities(): AgentCapability[] {
    return Array.from(this.capabilities.values());
  }
  
  // 상태 관리
  getStatus(): string {
    return this.status;
  }
  
  getMetrics(): any {
    return {
      agentId: this.id,
      name: this.name,
      status: this.status,
      capabilities: this.getCapabilities().length
    };
  }
  
  // Hook 메서드들 (하위 클래스에서 구현)
  protected async onStart(): Promise<void> {}
  protected async onStop(): Promise<void> {}
}
```

### SubTask 0.13.2: 에이전트 통신 프로토콜 설정
**목표**: 에이전트 간 효율적인 통신을 위한 프로토콜 정의

**구현 내용**:
```typescript
// backend/src/agents/framework/communication.ts
import { EventEmitter } from 'events';
import Redis from 'ioredis';
import { AgentMessage } from './base-agent';

export interface MessageBus {
  publish(channel: string, message: AgentMessage): Promise<void>;
  subscribe(channel: string, handler: (message: AgentMessage) => void): void;
  unsubscribe(channel: string): void;
}

// Redis 기반 메시지 버스
export class RedisMessageBus implements MessageBus {
  private publisher: Redis;
  private subscriber: Redis;
  private handlers: Map<string, Set<(message: AgentMessage) => void>> = new Map();
  
  constructor(redisUrl: string) {
    this.publisher = new Redis(redisUrl);
    this.subscriber = new Redis(redisUrl);
    
    this.subscriber.on('message', (channel, data) => {
      const message = JSON.parse(data) as AgentMessage;
      const channelHandlers = this.handlers.get(channel);
      
      if (channelHandlers) {
        channelHandlers.forEach(handler => handler(message));
      }
    });
  }
  
  async publish(channel: string, message: AgentMessage): Promise<void> {
    await this.publisher.publish(channel, JSON.stringify(message));
  }
  
  subscribe(channel: string, handler: (message: AgentMessage) => void): void {
    if (!this.handlers.has(channel)) {
      this.handlers.set(channel, new Set());
      this.subscriber.subscribe(channel);
    }
    
    this.handlers.get(channel)!.add(handler);
  }
  
  unsubscribe(channel: string): void {
    this.handlers.delete(channel);
    this.subscriber.unsubscribe(channel);
  }
}

// 에이전트 통신 매니저
export class AgentCommunicationManager {
  private messageBus: MessageBus;
  private agents: Map<string, any> = new Map();
  private routingTable: Map<string, string[]> = new Map();
  
  constructor(messageBus: MessageBus) {
    this.messageBus = messageBus;
  }
  
  // 에이전트 등록
  registerAgent(agentId: string, agent: any, channels: string[]): void {
    this.agents.set(agentId, agent);
    
    channels.forEach(channel => {
      if (!this.routingTable.has(channel)) {
        this.routingTable.set(channel, []);
      }
      this.routingTable.get(channel)!.push(agentId);
      
      // 채널 구독
      this.messageBus.subscribe(channel, async (message) => {
        if (message.target === agentId || message.target === 'broadcast') {
          const response = await agent.handleMessage(message);
          
          if (response && response.type === 'response') {
            await this.sendMessage(response);
          }
        }
      });
    });
  }
  
  // 메시지 전송
  async sendMessage(message: AgentMessage): Promise<void> {
    // Direct 메시징
    if (message.target && message.target !== 'broadcast') {
      await this.messageBus.publish(`agent:${message.target}`, message);
      return;
    }
    
    // Broadcast 메시징
    if (message.target === 'broadcast') {
      await this.messageBus.publish('agent:broadcast', message);
    }
  }
  
  // 라우팅 정보 조회
  getRoutingInfo(): Map<string, string[]> {
    return new Map(this.routingTable);
  }
  
  // 에이전트 상태 조회
  getAgentStatus(agentId: string): any {
    const agent = this.agents.get(agentId);
    return agent ? agent.getStatus() : null;
  }
}

// 에이전트 간 RPC 지원
export class AgentRPC {
  private communicationManager: AgentCommunicationManager;
  private pendingCalls: Map<string, {
    resolve: (value: any) => void;
    reject: (error: any) => void;
    timeout: NodeJS.Timeout;
  }> = new Map();
  
  constructor(communicationManager: AgentCommunicationManager) {
    this.communicationManager = communicationManager;
  }
  
  // RPC 호출
  async call(
    targetAgent: string,
    method: string,
    params: any,
    timeout: number = 30000
  ): Promise<any> {
    const callId = `rpc-${Date.now()}-${Math.random()}`;
    
    const message: AgentMessage = {
      id: callId,
      type: 'request',
      source: 'rpc-client',
      target: targetAgent,
      payload: {
        method,
        params
      },
      timestamp: new Date()
    };
    
    return new Promise((resolve, reject) => {
      // 타임아웃 설정
      const timeoutHandle = setTimeout(() => {
        this.pendingCalls.delete(callId);
        reject(new Error(`RPC call timeout: ${method}`));
      }, timeout);
      
      // 대기 중인 호출 등록
      this.pendingCalls.set(callId, {
        resolve,
        reject,
        timeout: timeoutHandle
      });
      
      // 메시지 전송
      this.communicationManager.sendMessage(message);
    });
  }
  
  // RPC 응답 처리
  handleResponse(message: AgentMessage): void {
    if (message.correlationId && this.pendingCalls.has(message.correlationId)) {
      const call = this.pendingCalls.get(message.correlationId)!;
      clearTimeout(call.timeout);
      
      if (message.type === 'response') {
        call.resolve(message.payload);
      } else if (message.type === 'error') {
        call.reject(new Error(message.payload.error));
      }
      
      this.pendingCalls.delete(message.correlationId);
    }
  }
}
```

### SubTask 0.13.3: AWS Bedrock AgentCore 통합 준비
**목표**: Bedrock AgentCore와의 통합을 위한 기초 설정

**구현 내용**:
```typescript
// backend/src/integrations/bedrock/agentcore-config.ts
import { 
  BedrockAgentRuntimeClient,
  InvokeAgentCommand,
  RetrieveCommand
} from '@aws-sdk/client-bedrock-agent-runtime';
import { Logger } from 'winston';

export interface AgentCoreConfig {
  agentId: string;
  agentAliasId: string;
  region: string;
  knowledgeBaseId?: string;
  instructionTemplate?: string;
}

export class BedrockAgentCoreManager {
  private client: BedrockAgentRuntimeClient;
  private logger: Logger;
  private config: AgentCoreConfig;
  
  constructor(
    config: AgentCoreConfig,
    logger: Logger
  ) {
    this.config = config;
    this.logger = logger;
    
    this.client = new BedrockAgentRuntimeClient({
      region: config.region
    });
  }
  
  // 에이전트 호출
  async invokeAgent(
    sessionId: string,
    inputText: string,
    sessionAttributes?: Record<string, string>
  ): Promise<any> {
    try {
      const command = new InvokeAgentCommand({
        agentId: this.config.agentId,
        agentAliasId: this.config.agentAliasId,
        sessionId,
        inputText,
        sessionState: {
          sessionAttributes
        }
      });
      
      const response = await this.client.send(command);
      
      // 스트리밍 응답 처리
      const chunks: any[] = [];
      
      if (response.completion) {
        for await (const chunk of response.completion) {
          chunks.push(chunk);
          
          // 청크 타입별 처리
          if (chunk.chunk) {
            this.handleChunk(chunk.chunk);
          }
        }
      }
      
      return {
        sessionId,
        response: chunks,
        metadata: {
          agentId: this.config.agentId,
          timestamp: new Date()
        }
      };
      
    } catch (error) {
      this.logger.error('Bedrock AgentCore invocation failed', {
        error,
        sessionId,
        inputText
      });
      throw error;
    }
  }
  
  // Knowledge Base 검색
  async retrieveFromKnowledgeBase(
    query: string,
    numberOfResults: number = 5
  ): Promise<any> {
    if (!this.config.knowledgeBaseId) {
      throw new Error('Knowledge base ID not configured');
    }
    
    try {
      const command = new RetrieveCommand({
        knowledgeBaseId: this.config.knowledgeBaseId,
        retrievalQuery: {
          text: query
        },
        retrievalConfiguration: {
          vectorSearchConfiguration: {
            numberOfResults
          }
        }
      });
      
      const response = await this.client.send(command);
      
      return {
        results: response.retrievalResults || [],
        metadata: {
          knowledgeBaseId: this.config.knowledgeBaseId,
          query,
          timestamp: new Date()
        }
      };
      
    } catch (error) {
      this.logger.error('Knowledge base retrieval failed', {
        error,
        query,
        knowledgeBaseId: this.config.knowledgeBaseId
      });
      throw error;
    }
  }
  
  // 청크 처리
  private handleChunk(chunk: any): void {
    if (chunk.bytes) {
      // 바이너리 데이터 처리
      const text = Buffer.from(chunk.bytes).toString('utf-8');
      this.logger.debug('Received text chunk', { text });
    }
    
    if (chunk.attribution) {
      // 속성 정보 처리
      this.logger.debug('Received attribution', {
        attribution: chunk.attribution
      });
    }
  }
  
  // 세션 관리
  async createSession(userId: string, metadata?: any): Promise<string> {
    const sessionId = `${userId}-${Date.now()}`;
    
    this.logger.info('Created Bedrock session', {
      sessionId,
      userId,
      metadata
    });
    
    return sessionId;
  }
}

// Bedrock 에이전트 래퍼
export abstract class BedrockAgent extends BaseAgent {
  protected bedrockManager: BedrockAgentCoreManager;
  
  constructor(
    name: string,
    version: string,
    logger: Logger,
    bedrockConfig: AgentCoreConfig
  ) {
    super(name, version, logger);
    
    this.bedrockManager = new BedrockAgentCoreManager(
      bedrockConfig,
      logger
    );
  }
  
  // Bedrock 기능을 활용한 처리
  protected async processWithBedrock(
    input: string,
    sessionId?: string
  ): Promise<any> {
    const session = sessionId || await this.bedrockManager.createSession(
      this.context?.userId || 'anonymous'
    );
    
    return this.bedrockManager.invokeAgent(session, input);
  }
  
  // Knowledge Base 활용
  protected async searchKnowledgeBase(query: string): Promise<any> {
    return this.bedrockManager.retrieveFromKnowledgeBase(query);
  }
}
```

### SubTask 0.13.4: Agent Squad 통합 준비
**목표**: AWS Agent Squad와의 통합을 위한 기초 설정

**구현 내용**:
```typescript
// backend/src/integrations/agent-squad/squad-config.ts
import { EventEmitter } from 'events';
import { Logger } from 'winston';

export interface SquadConfig {
  supervisorConfig: {
    name: string;
    role: 'orchestrator' | 'coordinator' | 'monitor';
    capabilities: string[];
  };
  workers: Array<{
    name: string;
    type: string;
    count: number;
    capabilities: string[];
  }>;
  communication: {
    protocol: 'redis' | 'sqs' | 'eventbridge';
    endpoint: string;
  };
}

// Supervisor Agent 구현
export class SupervisorAgent extends EventEmitter {
  private config: SquadConfig['supervisorConfig'];
  private logger: Logger;
  private workers: Map<string, WorkerAgent[]> = new Map();
  private taskQueue: TaskQueue;
  
  constructor(
    config: SquadConfig['supervisorConfig'],
    logger: Logger
  ) {
    super();
    this.config = config;
    this.logger = logger;
    this.taskQueue = new TaskQueue();
    
    this.initialize();
  }
  
  private initialize(): void {
    this.logger.info('Supervisor Agent initialized', {
      name: this.config.name,
      role: this.config.role,
      capabilities: this.config.capabilities
    });
  }
  
  // Worker 관리
  async addWorker(worker: WorkerAgent): Promise<void> {
    const type = worker.getType();
    
    if (!this.workers.has(type)) {
      this.workers.set(type, []);
    }
    
    this.workers.get(type)!.push(worker);
    
    this.logger.info('Worker added to squad', {
      supervisorName: this.config.name,
      workerType: type,
      workerId: worker.getId()
    });
    
    // Worker 이벤트 구독
    worker.on('taskCompleted', (result) => {
      this.handleWorkerTaskCompletion(worker, result);
    });
    
    worker.on('error', (error) => {
      this.handleWorkerError(worker, error);
    });
  }
  
  // 작업 분배
  async distributeTask(task: Task): Promise<void> {
    const workerType = this.selectWorkerType(task);
    const workers = this.workers.get(workerType);
    
    if (!workers || workers.length === 0) {
      throw new Error(`No workers available for type: ${workerType}`);
    }
    
    // 로드 밸런싱: 가장 idle한 worker 선택
    const selectedWorker = this.selectIdleWorker(workers);
    
    if (!selectedWorker) {
      // 모든 worker가 busy하면 큐에 추가
      await this.taskQueue.enqueue(task);
      return;
    }
    
    await selectedWorker.executeTask(task);
  }
  
  // Worker 선택 로직
  private selectWorkerType(task: Task): string {
    // 작업 타입과 capability 매칭
    for (const [type, workers] of this.workers) {
      if (workers.some(w => w.canHandle(task))) {
        return type;
      }
    }
    
    throw new Error(`No suitable worker for task: ${task.type}`);
  }
  
  private selectIdleWorker(workers: WorkerAgent[]): WorkerAgent | null {
    return workers.find(w => w.getStatus() === 'idle') || null;
  }
  
  // 이벤트 핸들러
  private handleWorkerTaskCompletion(
    worker: WorkerAgent,
    result: any
  ): void {
    this.logger.info('Worker task completed', {
      workerId: worker.getId(),
      result
    });
    
    this.emit('taskCompleted', {
      worker: worker.getId(),
      result
    });
    
    // 큐에서 다음 작업 할당
    this.assignNextTask(worker);
  }
  
  private handleWorkerError(
    worker: WorkerAgent,
    error: Error
  ): void {
    this.logger.error('Worker error', {
      workerId: worker.getId(),
      error
    });
    
    this.emit('workerError', {
      worker: worker.getId(),
      error
    });
  }
  
  private async assignNextTask(worker: WorkerAgent): Promise<void> {
    const nextTask = await this.taskQueue.dequeue(worker.getType());
    
    if (nextTask) {
      await worker.executeTask(nextTask);
    }
  }
  
  // 상태 모니터링
  getSquadStatus(): any {
    const status = {
      supervisor: {
        name: this.config.name,
        role: this.config.role
      },
      workers: {} as any,
      queueSize: this.taskQueue.size()
    };
    
    for (const [type, workers] of this.workers) {
      status.workers[type] = {
        count: workers.length,
        idle: workers.filter(w => w.getStatus() === 'idle').length,
        busy: workers.filter(w => w.getStatus() === 'busy').length
      };
    }
    
    return status;
  }
}

// Worker Agent 기본 클래스
export abstract class WorkerAgent extends EventEmitter {
  protected id: string;
  protected type: string;
  protected status: 'idle' | 'busy' | 'error' = 'idle';
  protected capabilities: string[];
  protected logger: Logger;
  
  constructor(
    type: string,
    capabilities: string[],
    logger: Logger
  ) {
    super();
    this.id = `worker-${type}-${Date.now()}`;
    this.type = type;
    this.capabilities = capabilities;
    this.logger = logger;
  }
  
  getId(): string {
    return this.id;
  }
  
  getType(): string {
    return this.type;
  }
  
  getStatus(): string {
    return this.status;
  }
  
  canHandle(task: Task): boolean {
    return this.capabilities.includes(task.capability);
  }
  
  async executeTask(task: Task): Promise<void> {
    this.status = 'busy';
    
    try {
      const result = await this.process(task);
      
      this.emit('taskCompleted', result);
      this.status = 'idle';
      
    } catch (error) {
      this.status = 'error';
      this.emit('error', error);
      
      setTimeout(() => {
        this.status = 'idle';
      }, 5000); // 5초 후 복구
    }
  }
  
  protected abstract process(task: Task): Promise<any>;
}

// 작업 큐 구현
class TaskQueue {
  private queues: Map<string, Task[]> = new Map();
  
  async enqueue(task: Task): Promise<void> {
    const type = task.workerType || 'default';
    
    if (!this.queues.has(type)) {
      this.queues.set(type, []);
    }
    
    this.queues.get(type)!.push(task);
  }
  
  async dequeue(type: string): Promise<Task | null> {
    const queue = this.queues.get(type);
    
    if (!queue || queue.length === 0) {
      return null;
    }
    
    return queue.shift() || null;
  }
  
  size(): number {
    let total = 0;
    for (const queue of this.queues.values()) {
      total += queue.length;
    }
    return total;
  }
}

// 타입 정의
interface Task {
  id: string;
  type: string;
  capability: string;
  workerType?: string;
  payload: any;
  priority?: number;
  timeout?: number;
}
```

### SubTask 0.13.5: Agno 모니터링 통합 준비
**목표**: Agno 플랫폼과의 모니터링 통합 설정

**구현 내용**:
```typescript
// backend/src/integrations/agno/monitoring-config.ts
import axios, { AxiosInstance } from 'axios';
import { Logger } from 'winston';

export interface AgnoConfig {
  apiKey: string;
  endpoint: string;
  projectId: string;
  environment: string;
  batchSize?: number;
  flushInterval?: number;
}

export interface AgnoMetric {
  name: string;
  value: number;
  tags?: Record<string, string>;
  timestamp?: Date;
}

export interface AgnoEvent {
  type: string;
  data: any;
  userId?: string;
  sessionId?: string;
  timestamp?: Date;
  metadata?: Record<string, any>;
}

export interface AgnoTrace {
  traceId: string;
  spanId: string;
  parentSpanId?: string;
  operation: string;
  startTime: Date;
  endTime?: Date;
  duration?: number;
  status: 'success' | 'error';
  metadata?: Record<string, any>;
}

export class AgnoMonitoringClient {
  private config: AgnoConfig;
  private client: AxiosInstance;
  private logger: Logger;
  private metricBuffer: AgnoMetric[] = [];
  private eventBuffer: AgnoEvent[] = [];
  private traceBuffer: AgnoTrace[] = [];
  private flushTimer?: NodeJS.Timer;
  
  constructor(config: AgnoConfig, logger: Logger) {
    this.config = {
      batchSize: 100,
      flushInterval: 10000, // 10초
      ...config
    };
    this.logger = logger;
    
    this.client = axios.create({
      baseURL: config.endpoint,
      headers: {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json',
        'X-Project-ID': config.projectId,
        'X-Environment': config.environment
      }
    });
    
    this.startFlushTimer();
  }
  
  // 메트릭 전송
  async sendMetric(metric: AgnoMetric): Promise<void> {
    this.metricBuffer.push({
      ...metric,
      timestamp: metric.timestamp || new Date()
    });
    
    if (this.metricBuffer.length >= this.config.batchSize!) {
      await this.flushMetrics();
    }
  }
  
  // 이벤트 전송
  async sendEvent(event: AgnoEvent): Promise<void> {
    this.eventBuffer.push({
      ...event,
      timestamp: event.timestamp || new Date()
    });
    
    if (this.eventBuffer.length >= this.config.batchSize!) {
      await this.flushEvents();
    }
  }
  
  // 트레이스 전송
  async sendTrace(trace: AgnoTrace): Promise<void> {
    this.traceBuffer.push(trace);
    
    if (this.traceBuffer.length >= this.config.batchSize!) {
      await this.flushTraces();
    }
  }
  
  // 에이전트 성능 모니터링
  async monitorAgentPerformance(
    agentName: string,
    operation: string,
    duration: number,
    success: boolean,
    metadata?: any
  ): Promise<void> {
    // 메트릭 전송
    await this.sendMetric({
      name: `agent.${agentName}.duration`,
      value: duration,
      tags: {
        agent: agentName,
        operation,
        status: success ? 'success' : 'failure'
      }
    });
    
    // 이벤트 전송
    await this.sendEvent({
      type: 'agent_operation',
      data: {
        agent: agentName,
        operation,
        duration,
        success,
        ...metadata
      }
    });
  }
  
  // 프로젝트 진행상황 모니터링
  async monitorProjectProgress(
    projectId: string,
    phase: string,
    progress: number,
    metadata?: any
  ): Promise<void> {
    await this.sendEvent({
      type: 'project_progress',
      data: {
        projectId,
        phase,
        progress,
        ...metadata
      }
    });
    
    await this.sendMetric({
      name: 'project.progress',
      value: progress,
      tags: {
        project: projectId,
        phase
      }
    });
  }
  
  // 에러 추적
  async trackError(
    error: Error,
    context: {
      agent?: string;
      operation?: string;
      userId?: string;
      projectId?: string;
    }
  ): Promise<void> {
    await this.sendEvent({
      type: 'error',
      data: {
        message: error.message,
        stack: error.stack,
        name: error.name,
        ...context
      },
      userId: context.userId
    });
  }
  
  // 배치 전송 메서드들
  private async flushMetrics(): Promise<void> {
    if (this.metricBuffer.length === 0) return;
    
    const metrics = [...this.metricBuffer];
    this.metricBuffer = [];
    
    try {
      await this.client.post('/metrics', { metrics });
      this.logger.debug(`Flushed ${metrics.length} metrics to Agno`);
    } catch (error) {
      this.logger.error('Failed to flush metrics to Agno', { error });
      // 실패한 메트릭은 버퍼에 다시 추가
      this.metricBuffer.unshift(...metrics);
    }
  }
  
  private async flushEvents(): Promise<void> {
    if (this.eventBuffer.length === 0) return;
    
    const events = [...this.eventBuffer];
    this.eventBuffer = [];
    
    try {
      await this.client.post('/events', { events });
      this.logger.debug(`Flushed ${events.length} events to Agno`);
    } catch (error) {
      this.logger.error('Failed to flush events to Agno', { error });
      this.eventBuffer.unshift(...events);
    }
  }
  
  private async flushTraces(): Promise<void> {
    if (this.traceBuffer.length === 0) return;
    
    const traces = [...this.traceBuffer];
    this.traceBuffer = [];
    
    try {
      await this.client.post('/traces', { traces });
      this.logger.debug(`Flushed ${traces.length} traces to Agno`);
    } catch (error) {
      this.logger.error('Failed to flush traces to Agno', { error });
      this.traceBuffer.unshift(...traces);
    }
  }
  
  // 타이머 관리
  private startFlushTimer(): void {
    this.flushTimer = setInterval(async () => {
      await Promise.all([
        this.flushMetrics(),
        this.flushEvents(),
        this.flushTraces()
      ]);
    }, this.config.flushInterval!);
  }
  
  async shutdown(): Promise<void> {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    
    // 남은 데이터 모두 전송
    await Promise.all([
      this.flushMetrics(),
      this.flushEvents(),
      this.flushTraces()
    ]);
  }
}

// Agno 데코레이터 (메서드 자동 추적)
export function AgnoTrace(
  operationName?: string
): MethodDecorator {
  return function (
    target: any,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const operation = operationName || String(propertyKey);
      const traceId = `trace-${Date.now()}-${Math.random()}`;
      const spanId = `span-${Date.now()}-${Math.random()}`;
      const startTime = Date.now();
      
      const agnoClient = (this as any).agnoClient;
      
      try {
        const result = await originalMethod.apply(this, args);
        
        if (agnoClient) {
          await agnoClient.sendTrace({
            traceId,
            spanId,
            operation,
            startTime: new Date(startTime),
            endTime: new Date(),
            duration: Date.now() - startTime,
            status: 'success',
            metadata: {
              class: target.constructor.name,
              method: String(propertyKey)
            }
          });
        }
        
        return result;
        
      } catch (error) {
        if (agnoClient) {
          await agnoClient.sendTrace({
            traceId,
            spanId,
            operation,
            startTime: new Date(startTime),
            endTime: new Date(),
            duration: Date.now() - startTime,
            status: 'error',
            metadata: {
              class: target.constructor.name,
              method: String(propertyKey),
              error: error.message
            }
          });
        }
        
        throw error;
      }
    };
    
    return descriptor;
  };
}
```

---

## Task 0.14: 개발 워크플로우 자동화

### SubTask 0.14.1: Git 훅 및 커밋 규칙 설정
**목표**: 일관된 코드 품질을 위한 Git 훅 설정

**구현 내용**:
```bash
#!/bin/bash
# scripts/setup-git-hooks.sh

echo "🔧 Git 훅 설정 시작..."

# Husky 설치 및 초기화
npm install --save-dev husky
npx husky install

# commit-msg 훅 추가
npx husky add .husky/commit-msg 'npx --no -- commitlint --edit $1'

# pre-commit 훅 추가
npx husky add .husky/pre-commit 'npm run pre-commit'

# pre-push 훅 추가
npx husky add .husky/pre-push 'npm run pre-push'

echo "✅ Git 훅 설정 완료!"
```

```typescript
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat',     // 새로운 기능
        'fix',      // 버그 수정
        'docs',     // 문서 수정
        'style',    // 코드 포맷팅
        'refactor', // 코드 리팩토링
        'test',     // 테스트 추가/수정
        'chore',    // 빌드 프로세스 또는 보조 도구 변경
        'perf',     // 성능 개선
        'ci',       // CI 설정 변경
        'revert',   // 이전 커밋 되돌리기
        'agent'     // 에이전트 관련 변경 (T-Developer 전용)
      ]
    ],
    'subject-case': [2, 'never', ['upper-case']],
    'header-max-length': [2, 'always', 72],
    'body-max-line-length': [2, 'always', 100],
    'scope-enum': [
      2,
      'always',
      [
        'core',
        'agents',
        'api',
        'frontend',
        'infra',
        'docs',
        'tests',
        'deps'
      ]
    ]
  }
};
```

```json
// .gitmessage
# <type>(<scope>): <subject>
#
# <body>
#
# <footer>
#
# Type: feat, fix, docs, style, refactor, test, chore, perf, ci, revert, agent
# Scope: core, agents, api, frontend, infra, docs, tests, deps
#
# Subject: 첫 글자 소문자, 명령형, 마침표 없음, 50자 이내
#
# Body: 72자마다 줄바꿈, 무엇을 왜 했는지 설명
#
# Footer: Breaking changes, 이슈 번호 참조
#
# 예시:
# feat(agents): add natural language input processing
#
# Implement NL input agent with following capabilities:
# - Parse user requirements from natural language
# - Extract technical specifications
# - Generate structured project metadata
#
# Closes #123
```
### SubTask 0.14.2: 개발 환경 최종 검증
**목표**: 모든 개발 환경 구성요소의 정상 작동 확인

**구현 내용**:
```typescript
// scripts/verify-environment.ts
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import axios from 'axios';
import { DynamoDBClient, ListTablesCommand } from '@aws-sdk/client-dynamodb';
import Redis from 'ioredis';
import chalk from 'chalk';

const execAsync = promisify(exec);

interface VerificationResult {
  component: string;
  status: 'pass' | 'fail' | 'warning';
  message: string;
  details?: any;
}

class EnvironmentVerifier {
  private results: VerificationResult[] = [];
  
  async verify(): Promise<void> {
    console.log(chalk.blue('🔍 T-Developer 환경 검증 시작...\n'));
    
    // 1. Node.js 환경
    await this.verifyNodeEnvironment();
    
    // 2. AWS 설정
    await this.verifyAWSConfiguration();
    
    // 3. 데이터베이스
    await this.verifyDatabases();
    
    // 4. 외부 서비스
    await this.verifyExternalServices();
    
    // 5. 개발 도구
    await this.verifyDevelopmentTools();
    
    // 6. 보안 설정
    await this.verifySecuritySettings();
    
    // 결과 출력
    this.printResults();
  }
  
  private async verifyNodeEnvironment(): Promise<void> {
    try {
      const { stdout: nodeVersion } = await execAsync('node --version');
      const { stdout: npmVersion } = await execAsync('npm --version');
      
      const nodeMatch = nodeVersion.match(/v(\d+)\.(\d+)/);
      if (nodeMatch) {
        const majorVersion = parseInt(nodeMatch[1]);
        if (majorVersion >= 18) {
          this.addResult('Node.js', 'pass', `버전 ${nodeVersion.trim()} 확인`);
        } else {
          this.addResult('Node.js', 'fail', `버전 18 이상 필요 (현재: ${nodeVersion.trim()})`);
        }
      }
      
      this.addResult('npm', 'pass', `버전 ${npmVersion.trim()} 확인`);
      
      // 필수 패키지 확인
      const packageJson = JSON.parse(await fs.readFile('package.json', 'utf-8'));
      const requiredPackages = [
        '@aws-sdk/client-bedrock-runtime',
        '@aws-sdk/client-dynamodb',
        'express',
        'typescript',
        'jest'
      ];
      
      const missingPackages = requiredPackages.filter(
        pkg => !packageJson.dependencies?.[pkg] && !packageJson.devDependencies?.[pkg]
      );
      
      if (missingPackages.length === 0) {
        this.addResult('필수 패키지', 'pass', '모든 필수 패키지 설치됨');
      } else {
        this.addResult('필수 패키지', 'fail', `누락된 패키지: ${missingPackages.join(', ')}`);
      }
      
    } catch (error) {
      this.addResult('Node.js 환경', 'fail', '확인 실패', error);
    }
  }
  
  private async verifyAWSConfiguration(): Promise<void> {
    try {
      // AWS 자격 증명 확인
      const { stdout: awsIdentity } = await execAsync('aws sts get-caller-identity');
      const identity = JSON.parse(awsIdentity);
      
      this.addResult('AWS 자격 증명', 'pass', `계정 ID: ${identity.Account}`);
      
      // DynamoDB 연결 테스트
      const dynamoClient = new DynamoDBClient({
        region: process.env.AWS_REGION || 'us-east-1',
        endpoint: process.env.DYNAMODB_ENDPOINT
      });
      
      const tables = await dynamoClient.send(new ListTablesCommand({}));
      this.addResult('DynamoDB', 'pass', `테이블 수: ${tables.TableNames?.length || 0}`);
      
      // S3 버킷 확인
      const { stdout: s3Buckets } = await execAsync('aws s3 ls');
      const bucketCount = s3Buckets.split('\n').filter(line => line.trim()).length;
      this.addResult('S3', 'pass', `버킷 수: ${bucketCount}`);
      
    } catch (error) {
      this.addResult('AWS 설정', 'fail', 'AWS 서비스 연결 실패', error);
    }
  }
  
  private async verifyDatabases(): Promise<void> {
    // Redis 연결 테스트
    try {
      const redis = new Redis({
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
        retryStrategy: () => null
      });
      
      await redis.ping();
      this.addResult('Redis', 'pass', 'Redis 서버 연결 성공');
      await redis.disconnect();
      
    } catch (error) {
      this.addResult('Redis', 'warning', 'Redis 서버 연결 실패 (선택사항)');
    }
    
    // DynamoDB Local 확인
    if (process.env.NODE_ENV === 'development') {
      try {
        const response = await axios.get('http://localhost:8000');
        this.addResult('DynamoDB Local', 'pass', '로컬 DynamoDB 실행 중');
      } catch {
        this.addResult('DynamoDB Local', 'warning', '로컬 DynamoDB 미실행 (개발용)');
      }
    }
  }
  
  private async verifyExternalServices(): Promise<void> {
    // GitHub API
    if (process.env.GITHUB_TOKEN) {
      try {
        await axios.get('https://api.github.com/user', {
          headers: { Authorization: `token ${process.env.GITHUB_TOKEN}` }
        });
        this.addResult('GitHub API', 'pass', 'GitHub 토큰 유효');
      } catch {
        this.addResult('GitHub API', 'fail', 'GitHub 토큰 무효');
      }
    } else {
      this.addResult('GitHub API', 'warning', 'GitHub 토큰 미설정');
    }
    
    // AI 서비스
    const aiServices = [
      { name: 'OpenAI', envVar: 'OPENAI_API_KEY' },
      { name: 'Anthropic', envVar: 'ANTHROPIC_API_KEY' },
      { name: 'Bedrock', envVar: 'BEDROCK_AGENTCORE_RUNTIME_ID' }
    ];
    
    for (const service of aiServices) {
      if (process.env[service.envVar]) {
        this.addResult(service.name, 'pass', `${service.envVar} 설정됨`);
      } else {
        this.addResult(service.name, 'warning', `${service.envVar} 미설정`);
      }
    }
  }
  
  private async verifyDevelopmentTools(): Promise<void> {
    const tools = [
      { cmd: 'docker --version', name: 'Docker' },
      { cmd: 'git --version', name: 'Git' },
      { cmd: 'code --version', name: 'VS Code', optional: true }
    ];
    
    for (const tool of tools) {
      try {
        const { stdout } = await execAsync(tool.cmd);
        this.addResult(tool.name, 'pass', stdout.trim().split('\n')[0]);
      } catch {
        if (tool.optional) {
          this.addResult(tool.name, 'warning', '설치되지 않음 (선택사항)');
        } else {
          this.addResult(tool.name, 'fail', '설치되지 않음');
        }
      }
    }
  }
  
  private async verifySecuritySettings(): Promise<void> {
    // 환경 변수 보안
    const sensitiveVars = ['JWT_SECRET', 'ENCRYPTION_KEY'];
    const weakValues = ['secret', 'password', '123456', 'admin'];
    
    for (const varName of sensitiveVars) {
      const value = process.env[varName];
      if (!value) {
        this.addResult(`보안: ${varName}`, 'fail', '설정되지 않음');
      } else if (weakValues.includes(value.toLowerCase())) {
        this.addResult(`보안: ${varName}`, 'fail', '약한 값 사용');
      } else if (value.length < 16) {
        this.addResult(`보안: ${varName}`, 'warning', '16자 이상 권장');
      } else {
        this.addResult(`보안: ${varName}`, 'pass', '적절한 값 설정됨');
      }
    }
    
    // .env 파일 권한 확인
    try {
      const stats = await fs.stat('.env');
      const mode = (stats.mode & parseInt('777', 8)).toString(8);
      if (mode === '600') {
        this.addResult('.env 파일 권한', 'pass', '안전한 권한 설정 (600)');
      } else {
        this.addResult('.env 파일 권한', 'warning', `현재 권한: ${mode} (600 권장)`);
      }
    } catch {
      this.addResult('.env 파일', 'fail', '.env 파일이 없습니다');
    }
  }
  
  private addResult(component: string, status: VerificationResult['status'], message: string, details?: any): void {
    this.results.push({ component, status, message, details });
  }
  
  private printResults(): void {
    console.log('\n' + chalk.blue('='.repeat(60)));
    console.log(chalk.blue.bold('검증 결과 요약'));
    console.log(chalk.blue('='.repeat(60)) + '\n');
    
    const statusIcons = {
      pass: chalk.green('✅'),
      fail: chalk.red('❌'),
      warning: chalk.yellow('⚠️')
    };
    
    const maxComponentLength = Math.max(...this.results.map(r => r.component.length));
    
    for (const result of this.results) {
      const icon = statusIcons[result.status];
      const component = result.component.padEnd(maxComponentLength + 2);
      const statusColor = result.status === 'pass' ? chalk.green :
                         result.status === 'fail' ? chalk.red : chalk.yellow;
      
      console.log(`${icon} ${chalk.white(component)} ${statusColor(result.message)}`);
      
      if (result.details && process.env.VERBOSE) {
        console.log(chalk.gray(`   상세: ${JSON.stringify(result.details, null, 2)}`));
      }
    }
    
    // 통계
    const stats = {
      pass: this.results.filter(r => r.status === 'pass').length,
      fail: this.results.filter(r => r.status === 'fail').length,
      warning: this.results.filter(r => r.status === 'warning').length
    };
    
    console.log('\n' + chalk.blue('-'.repeat(60)));
    console.log(chalk.white('통계:'), 
      chalk.green(`성공: ${stats.pass}`),
      chalk.red(`실패: ${stats.fail}`),
      chalk.yellow(`경고: ${stats.warning}`)
    );
    
    if (stats.fail > 0) {
      console.log('\n' + chalk.red.bold('⚠️  일부 검증이 실패했습니다. 위의 실패 항목을 확인하세요.'));
      process.exit(1);
    } else if (stats.warning > 0) {
      console.log('\n' + chalk.yellow.bold('ℹ️  일부 경고가 있지만 개발을 시작할 수 있습니다.'));
    } else {
      console.log('\n' + chalk.green.bold('🎉 모든 검증을 통과했습니다! 개발 환경이 준비되었습니다.'));
    }
  }
}

// 실행
if (require.main === module) {
  const verifier = new EnvironmentVerifier();
  verifier.verify().catch(console.error);
}

export { EnvironmentVerifier };
```

### SubTask 0.14.3: 개발 환경 설정 문서화
**목표**: 완성된 개발 환경 설정을 문서로 정리

**구현 내용**:
```markdown
<!-- docs/setup/development-environment.md -->
# T-Developer 개발 환경 설정 가이드

## 📋 목차
1. [시스템 요구사항](#시스템-요구사항)
2. [필수 도구 설치](#필수-도구-설치)
3. [프로젝트 설정](#프로젝트-설정)
4. [환경 변수 구성](#환경-변수-구성)
5. [AWS 서비스 설정](#aws-서비스-설정)
6. [로컬 개발 환경](#로컬-개발-환경)
7. [검증 및 테스트](#검증-및-테스트)
8. [문제 해결](#문제-해결)

## 시스템 요구사항

### 하드웨어
- **CPU**: 4코어 이상 권장
- **RAM**: 16GB 이상 권장
- **디스크**: 50GB 이상 여유 공간

### 운영체제
- macOS 12.0+
- Ubuntu 20.04+
- Windows 10/11 (WSL2 필수)

## 필수 도구 설치

### 1. Node.js (v18+)
```bash
# NVM 사용 (권장)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18
nvm use 18

# 직접 설치
# https://nodejs.org/en/download/
```

### 2. Python (v3.9+)
```bash
# macOS
brew install python@3.9

# Ubuntu
sudo apt update
sudo apt install python3.9 python3.9-venv

# Windows
# https://www.python.org/downloads/
```

### 3. AWS CLI
```bash
# macOS
brew install awscli

# Linux/WSL
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install

# 설정
aws configure
```

### 4. Docker
```bash
# macOS
brew install --cask docker

# Ubuntu
sudo apt install docker.io docker-compose
sudo usermod -aG docker $USER

# Windows
# Docker Desktop 설치: https://www.docker.com/products/docker-desktop
```

### 5. Git
```bash
# macOS
brew install git

# Ubuntu
sudo apt install git
```

## 프로젝트 설정

### 1. 저장소 클론
```bash
git clone https://github.com/your-org/t-developer.git
cd t-developer
```

### 2. 의존성 설치
```bash
# 루트 디렉토리에서
npm install

# Backend 의존성
cd backend
npm install

# Frontend 의존성
cd ../frontend
npm install
```

### 3. Git Hooks 설정
```bash
# 루트 디렉토리에서
npm run prepare
```

## 환경 변수 구성

### 1. 환경 변수 파일 생성
```bash
# 루트 디렉토리에서
cp .env.example .env

# 보안 설정
chmod 600 .env
```

### 2. 필수 환경 변수 설정
```bash
# .env 파일 편집
nano .env  # 또는 원하는 에디터 사용
```

#### 필수 설정 항목:
```env
# Node 환경
NODE_ENV=development
PORT=3000

# AWS 설정
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_REGION=us-east-1

# AI 서비스 (최소 하나 필수)
OPENAI_API_KEY=sk-...
# 또는
ANTHROPIC_API_KEY=sk-ant-...

# 보안 (강력한 값으로 변경 필수!)
JWT_SECRET=your-super-secure-jwt-secret-min-32-chars
ENCRYPTION_KEY=your-32-character-encryption-key!!

# GitHub (선택사항)
GITHUB_TOKEN=ghp_...
```

## AWS 서비스 설정

### 1. DynamoDB 테이블 생성
```bash
# 스크립트 실행
npm run setup:aws:dynamodb
```

### 2. S3 버킷 생성
```bash
# 스크립트 실행
npm run setup:aws:s3
```

### 3. Bedrock 설정 (선택사항)
```bash
# Bedrock 액세스 활성화
aws bedrock get-foundation-model-availability \
  --region us-east-1 \
  --model-id anthropic.claude-v2
```

## 로컬 개발 환경

### 1. 로컬 서비스 시작
```bash
# Docker Compose로 모든 서비스 시작
docker-compose up -d

# 개별 서비스 시작
docker-compose up -d dynamodb-local
docker-compose up -d redis
```

### 2. 데이터베이스 초기화
```bash
# DynamoDB 로컬 테이블 생성
npm run db:init:local
```

### 3. 개발 서버 시작
```bash
# Backend (터미널 1)
cd backend
npm run dev

# Frontend (터미널 2)
cd frontend
npm run dev
```

### 4. 서비스 접속
- **Frontend**: http://localhost:5173
- **Backend API**: http://localhost:3000
- **API 문서**: http://localhost:3000/api-docs
- **Grafana**: http://localhost:3001 (admin/admin)

## 검증 및 테스트

### 1. 환경 검증
```bash
# 전체 환경 검증
npm run verify:env

# 상세 정보 포함
VERBOSE=true npm run verify:env
```

### 2. 테스트 실행
```bash
# 단위 테스트
npm test

# 통합 테스트
npm run test:integration

# E2E 테스트
npm run test:e2e
```

### 3. 린트 및 포맷팅
```bash
# 린트 검사
npm run lint

# 자동 수정
npm run lint:fix

# 코드 포맷팅
npm run format
```

## 문제 해결

### 포트 충돌
```bash
# 사용 중인 포트 확인
lsof -i :3000
lsof -i :5173

# 프로세스 종료
kill -9 <PID>
```

### Docker 문제
```bash
# Docker 재시작
docker-compose down
docker-compose up -d

# 볼륨 정리
docker system prune -a --volumes
```

### 권한 문제
```bash
# node_modules 권한 수정
sudo chown -R $(whoami) node_modules

# npm 캐시 정리
npm cache clean --force
```

### AWS 연결 문제
```bash
# 자격 증명 확인
aws sts get-caller-identity

# 리전 확인
echo $AWS_REGION
```

## 다음 단계

개발 환경 설정이 완료되었다면:

1. [아키텍처 문서](../architecture/overview.md) 읽기
2. [개발 가이드](../development/getting-started.md) 확인
3. [첫 번째 에이전트 만들기](../tutorials/first-agent.md)

---

문제가 있거나 도움이 필요하면 [이슈 트래커](https://github.com/your-org/t-developer/issues)에 문의하세요.
```

### SubTask 0.14.4: Phase 0 완료 체크리스트
**목표**: Phase 0의 모든 작업이 완료되었는지 최종 확인

**구현 내용**:
```typescript
// scripts/phase0-checklist.ts
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

interface ChecklistItem {
  task: string;
  description: string;
  check: () => Promise<boolean>;
  critical: boolean;
}

class Phase0Checklist {
  private items: ChecklistItem[] = [
    // Task 0.1: 개발 환경 초기 설정
    {
      task: '0.1.1',
      description: '필수 도구 설치 확인',
      check: async () => {
        try {
          await execAsync('node --version');
          await execAsync('npm --version');
          await execAsync('aws --version');
          await execAsync('docker --version');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    {
      task: '0.1.2',
      description: '프로젝트 구조 생성',
      check: async () => {
        const dirs = ['backend', 'frontend', 'infrastructure', 'docs'];
        for (const dir of dirs) {
          try {
            await fs.access(dir);
          } catch {
            return false;
          }
        }
        return true;
      },
      critical: true
    },
    {
      task: '0.1.3',
      description: 'Git 저장소 초기화',
      check: async () => {
        try {
          await fs.access('.git');
          await fs.access('.gitignore');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    {
      task: '0.1.4',
      description: '환경 변수 템플릿',
      check: async () => {
        try {
          await fs.access('.env.example');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    
    // Task 0.2: AWS 기본 설정
    {
      task: '0.2.1',
      description: 'AWS 계정 및 권한 설정',
      check: async () => {
        try {
          const { stdout } = await execAsync('aws sts get-caller-identity');
          return stdout.includes('UserId');
        } catch {
          return false;
        }
      },
      critical: true
    },
    {
      task: '0.2.3',
      description: 'DynamoDB 테이블 설계',
      check: async () => {
        try {
          await fs.access('infrastructure/dynamodb/schemas');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.3: 프로젝트 의존성 설정
    {
      task: '0.3.1',
      description: 'Backend 패키지 설정',
      check: async () => {
        try {
          await fs.access('backend/package.json');
          await fs.access('backend/tsconfig.json');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    {
      task: '0.3.2',
      description: 'Frontend 패키지 설정',
      check: async () => {
        try {
          await fs.access('frontend/package.json');
          await fs.access('frontend/vite.config.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    
    // Task 0.4: 보안 및 인증 기초 설정
    {
      task: '0.4.1',
      description: '환경 변수 암호화',
      check: async () => {
        try {
          await fs.access('backend/src/utils/crypto.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.5: 개발 도구 설정
    {
      task: '0.5.1',
      description: 'ESLint 설정',
      check: async () => {
        try {
          await fs.access('.eslintrc.js');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    {
      task: '0.5.2',
      description: 'Prettier 설정',
      check: async () => {
        try {
          await fs.access('.prettierrc');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.6: 테스트 환경 설정
    {
      task: '0.6.1',
      description: 'Jest 설정',
      check: async () => {
        try {
          await fs.access('backend/jest.config.js');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.7: CI/CD 파이프라인 기초
    {
      task: '0.7.1',
      description: 'GitHub Actions 워크플로우',
      check: async () => {
        try {
          await fs.access('.github/workflows');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.8: 문서화 기반
    {
      task: '0.8.1',
      description: '문서 구조',
      check: async () => {
        try {
          await fs.access('docs');
          const files = await fs.readdir('docs');
          return files.length > 0;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.9: 로컬 개발 환경
    {
      task: '0.9.1',
      description: 'Docker Compose 설정',
      check: async () => {
        try {
          await fs.access('docker-compose.yml');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.10: 보안 강화
    {
      task: '0.10.1',
      description: '보안 미들웨어',
      check: async () => {
        try {
          await fs.access('backend/src/middleware/security.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.11: 모니터링 기초
    {
      task: '0.11.1',
      description: '로깅 시스템',
      check: async () => {
        try {
          await fs.access('backend/src/config/logger.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.12: 개발 효율성 도구
    {
      task: '0.12.1',
      description: '코드 생성기',
      check: async () => {
        try {
          await fs.access('scripts/generators');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.13: 에이전트 개발 환경
    {
      task: '0.13.1',
      description: '에이전트 프레임워크',
      check: async () => {
        try {
          await fs.access('backend/src/agents/framework/base-agent.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    
    // Task 0.14: Phase 0 마무리
    {
      task: '0.14.1',
      description: '통합 테스트',
      check: async () => {
        try {
          const { stdout } = await execAsync('npm test -- --passWithNoTests');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    }
  ];
  
  async run(): Promise<void> {
    console.log(chalk.blue.bold('\n🔍 Phase 0 완료 체크리스트\n'));
    console.log(chalk.gray('='.repeat(60)) + '\n');
    
    let passCount = 0;
    let criticalFailCount = 0;
    
    for (const item of this.items) {
      const result = await item.check();
      const icon = result ? chalk.green('✅') : chalk.red('❌');
      const taskColor = result ? chalk.green : chalk.red;
      
      console.log(
        `${icon} ${chalk.gray(`[${item.task}]`)} ${taskColor(item.description)}` +
        (item.critical && !result ? chalk.red(' (필수)') : '')
      );
      
      if (result) {
        passCount++;
      } else if (item.critical) {
        criticalFailCount++;
      }
    }
    
    // 결과 요약
    console.log('\n' + chalk.gray('='.repeat(60)));
    console.log(chalk.blue.bold('\n📊 결과 요약\n'));
    
    const totalItems = this.items.length;
    const completionRate = Math.round((passCount / totalItems) * 100);
    
    console.log(`완료: ${chalk.green(passCount)}/${totalItems} (${completionRate}%)`);
    console.log(`필수 항목 실패: ${chalk.red(criticalFailCount)}`);
    
    if (criticalFailCount > 0) {
      console.log('\n' + chalk.red.bold('❌ Phase 0를 완료하기 전에 필수 항목을 해결해야 합니다.'));
    } else if (passCount === totalItems) {
      console.log('\n' + chalk.green.bold('🎉 축하합니다! Phase 0가 완벽하게 완료되었습니다!'));
      console.log(chalk.green('이제 Phase 1로 진행할 수 있습니다.'));
    } else {
      console.log('\n' + chalk.yellow.bold('⚠️  Phase 0의 필수 항목은 완료되었지만 일부 선택 항목이 남아있습니다.'));
      console.log(chalk.yellow('Phase 1로 진행할 수 있지만, 나중에 완료하는 것을 권장합니다.'));
    }
    
    // 다음 단계 안내
    console.log('\n' + chalk.blue.bold('📌 다음 단계:'));
    console.log(chalk.gray('1. 남은 항목 완료 (선택사항)'));
    console.log(chalk.gray('2. Phase 1: 코어 인프라 구축 시작'));
    console.log(chalk.gray('   - npm run phase1:start'));
  }
}

// 실행
if (require.main === module) {
  const checklist = new Phase0Checklist();
  checklist.run().catch(console.error);
}

export { Phase0Checklist };
```

## Task 0.15: Phase 0 완료 및 Phase 1 준비

### SubTask 0.15.1: Phase 0 학습 정리
**목표**: Phase 0에서 얻은 교훈과 개선점 정리

**구현 내용**:
```markdown
<!-- docs/phases/phase0-retrospective.md -->
# Phase 0 회고 및 학습 정리

## 📊 Phase 0 개요
- **기간**: [시작일] ~ [종료일]
- **목표**: T-Developer 개발을 위한 기반 환경 구축
- **주요 성과**: 15개 Tasks, 60+ SubTasks 완료

## ✅ 완료된 주요 작업

### 1. 개발 환경
- ✅ Node.js 18+ 기반 TypeScript 환경 구축
- ✅ 모노레포 구조 설정 (backend/frontend/infrastructure)
- ✅ Git 워크플로우 및 hooks 설정
- ✅ 환경 변수 관리 체계 구축

### 2. AWS 인프라
- ✅ AWS 계정 및 IAM 권한 설정
- ✅ DynamoDB 스키마 설계
- ✅ S3 버킷 구조 설계
- ✅ 로컬 개발용 AWS 서비스 에뮬레이션

### 3. 개발 도구
- ✅ ESLint/Prettier 코드 품질 도구
- ✅ Jest 기반 테스트 환경
- ✅ Docker Compose 로컬 환경
- ✅ CI/CD 파이프라인 기초

### 4. 보안 및 모니터링
- ✅ 보안 미들웨어 구현
- ✅ 환경 변수 암호화
- ✅ 로깅 및 메트릭 수집 기반
- ✅ 입력 검증 및 살균

### 5. 에이전트 프레임워크
- ✅ BaseAgent 추상 클래스
- ✅ 에이전트 간 통신 프로토콜
- ✅ AWS Bedrock/Agent Squad 통합 준비
- ✅ Agno 모니터링 통합 준비

## 📚 주요 학습 사항

### 1. 아키텍처 결정
- **모노레포 접근**: Nx 없이도 npm workspaces로 충분
- **TypeScript 설정**: strict 모드가 초기엔 번거롭지만 장기적으로 유리
- **Docker 활용**: 로컬 개발 환경 일관성 확보에 필수

### 2. AWS 서비스
- **DynamoDB**: 단일 테이블 설계가 복잡하지만 성능상 이점
- **로컬 에뮬레이션**: LocalStack보다 개별 서비스 컨테이너가 안정적
- **IAM 권한**: 최소 권한 원칙 준수의 중요성

### 3. 개발 프로세스
- **자동화의 가치**: 반복 작업은 즉시 스크립트화
- **문서화**: 코드와 함께 문서도 동시 작성이 효율적
- **테스트 우선**: TDD는 아니더라도 테스트 가능한 구조 설계 필수

## 🔧 개선 필요 사항

### 1. 성능 최적화
- [ ] 빌드 시간 단축 (현재 3분 → 목표 1분)
- [ ] 테스트 병렬화로 실행 시간 개선
- [ ] Docker 이미지 크기 최적화

### 2. 개발자 경험
- [ ] 더 나은 에러 메시지
- [ ] 자동 완성 및 IntelliSense 개선
- [ ] 디버깅 환경 강화

### 3. 문서화
- [ ] API 문서 자동 생성 개선
- [ ] 인터랙티브 튜토리얼 추가
- [ ] 비디오 가이드 제작

## 💡 Phase 1을 위한 제안

### 1. 우선순위
1. **코어 에이전트 시스템**: BaseAgent를 기반으로 한 실제 구현
2. **데이터 레이어**: DynamoDB 통합 및 캐싱 전략
3. **API Gateway**: RESTful API 및 WebSocket 구현

### 2. 위험 요소
- **Bedrock 통합**: API 제한 및 비용 관리 필요
- **멀티 에이전트 조정**: 복잡도 관리 전략 필요
- **실시간 통신**: WebSocket 연결 안정성

### 3. 성공 지표
- 첫 번째 에이전트 동작 확인
- 기본 API 엔드포인트 구현
- 에이전트 간 통신 검증

## 🎯 다음 단계

### Phase 1 시작 준비
```bash
# Phase 1 브랜치 생성
git checkout -b phase1-core-infrastructure

# Phase 1 작업 디렉토리 준비
mkdir -p backend/src/core
mkdir -p backend/src/data
mkdir -p backend/src/api

# Phase 1 체크리스트 생성
npm run phase1:init
```

### 팀 준비 사항
1. Phase 0 코드 리뷰 완료
2. AWS 권한 및 리소스 확인
3. Phase 1 작업 분담 회의

---

**작성일**: 2024-XX-XX  
**작성자**: T-Developer Team
```

### SubTask 0.15.2: Phase 1 초기 설정
**목표**: Phase 1 작업을 위한 기초 설정

**구현 내용**:
```typescript
// scripts/init-phase1.ts
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';

class Phase1Initializer {
  async initialize(): Promise<void> {
    console.log(chalk.blue.bold('\n🚀 Phase 1: 코어 인프라 구축 초기화\n'));
    
    // 1. 디렉토리 구조 생성
    await this.createDirectoryStructure();
    
    // 2. 기본 파일 생성
    await this.createBaseFiles();
    
    // 3. Phase 1 체크리스트 생성
    await this.createChecklist();
    
    console.log(chalk.green.bold('\n✅ Phase 1 초기화 완료!\n'));
    console.log(chalk.gray('다음 명령으로 시작하세요:'));
    console.log(chalk.cyan('  cd backend/src/core'));
    console.log(chalk.cyan('  npm run dev'));
  }
  
  private async createDirectoryStructure(): Promise<void> {
    const directories = [
      // 코어 시스템
      'backend/src/core/config',
      'backend/src/core/errors',
      'backend/src/core/interfaces',
      'backend/src/core/utils',
      
      // 데이터 레이어
      'backend/src/data/repositories',
      'backend/src/data/models',
      'backend/src/data/migrations',
      'backend/src/data/cache',
      
      // API 레이어
      'backend/src/api/controllers',
      'backend/src/api/routes',
      'backend/src/api/middleware',
      'backend/src/api/validators',
      
      // 에이전트 시스템
      'backend/src/agents/implementations',
      'backend/src/agents/orchestrator',
      'backend/src/agents/registry',
      
      // 테스트
      'backend/tests/core',
      'backend/tests/data',
      'backend/tests/api',
      'backend/tests/agents'
    ];
    
    for (const dir of directories) {
      await fs.mkdir(dir, { recursive: true });
      console.log(chalk.green(`✓ Created: ${dir}`));
    }
  }
  
  private async createBaseFiles(): Promise<void> {
    // 코어 설정 파일
    const coreConfig = `// backend/src/core/config/index.ts
export interface CoreConfig {
  app: {
    name: string;
    version: string;
    env: string;
  };
  server: {
    port: number;
    host: string;
  };
  database: {
    dynamodb: {
      region: string;
      endpoint?: string;
    };
  };
  cache: {
    redis: {
      host: string;
      port: number;
    };
  };
  agents: {
    maxConcurrent: number;
    timeout: number;
  };
}

export const config: CoreConfig = {
  app: {
    name: 'T-Developer',
    version: process.env.npm_package_version || '1.0.0',
    env: process.env.NODE_ENV || 'development'
  },
  server: {
    port: parseInt(process.env.PORT || '3000'),
    host: process.env.HOST || '0.0.0.0'
  },
  database: {
    dynamodb: {
      region: process.env.AWS_REGION || 'us-east-1',
      endpoint: process.env.DYNAMODB_ENDPOINT
    }
  },
  cache: {
    redis: {
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379')
    }
  },
  agents: {
    maxConcurrent: parseInt(process.env.MAX_CONCURRENT_AGENTS || '50'),
    timeout: parseInt(process.env.AGENT_TIMEOUT || '300000')
  }
};
`;
    
    await fs.writeFile(
      'backend/src/core/config/index.ts',
      coreConfig
    );
    
    // 에러 클래스
    const baseError = `// backend/src/core/errors/base-error.ts
export abstract class BaseError extends Error {
  abstract statusCode: number;
  abstract code: string;
  
  constructor(message: string) {
    super(message);
    Object.setPrototypeOf(this, BaseError.prototype);
  }
  
  abstract serializeErrors(): { message: string; field?: string }[];
}

export class NotFoundError extends BaseError {
  statusCode = 404;
  code = 'NOT_FOUND';
  
  constructor(public resource: string) {
    super(\`Resource not found: \${resource}\`);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
  
  serializeErrors() {
    return [{ message: this.message }];
  }
}
`;
    
    await fs.writeFile(
      'backend/src/core/errors/base-error.ts',
      baseError
    );
    
    console.log(chalk.green('✓ Created base files'));
  }
  
  private async createChecklist(): Promise<void> {
    const checklist = `# Phase 1: 코어 인프라 구축 체크리스트

## Task 1.1: 핵심 설정 시스템
- [ ] 중앙 설정 관리자 구현
- [ ] 환경별 설정 로더
- [ ] 설정 검증 시스템
- [ ] 동적 설정 리로드

## Task 1.2: 에러 처리 시스템
- [ ] 커스텀 에러 클래스 계층구조
- [ ] 전역 에러 핸들러
- [ ] 에러 로깅 및 추적
- [ ] 에러 복구 전략

## Task 1.3: 로깅 인프라
- [ ] 구조화된 로깅 시스템
- [ ] 로그 레벨 관리
- [ ] 로그 집계 및 전송
- [ ] 성능 메트릭 로깅

## Task 1.4: 데이터베이스 연결
- [ ] DynamoDB 클라이언트 설정
- [ ] 연결 풀 관리
- [ ] 재시도 로직
- [ ] 연결 모니터링

## Task 1.5: 캐싱 시스템
- [ ] Redis 클라이언트 설정
- [ ] 캐시 전략 구현
- [ ] 캐시 무효화 로직
- [ ] 캐시 히트율 모니터링

... (추가 Tasks)
`;
    
    await fs.writeFile(
      'docs/phases/phase1-checklist.md',
      checklist
    );
    
    console.log(chalk.green('✓ Created Phase 1 checklist'));
  }
}

// 실행
if (require.main === module) {
  const initializer = new Phase1Initializer();
  initializer.initialize().catch(console.error);
}
```

### SubTask 0.15.3: Phase 0 아카이브 및 문서 정리
**목표**: Phase 0의 모든 작업물을 체계적으로 정리하고 보관

**구현 내용**:
```bash
#!/bin/bash
# scripts/archive-phase0.sh

echo "📦 Phase 0 아카이브 시작..."

# 1. Phase 0 태그 생성
git tag -a "phase0-complete" -m "Phase 0: 사전 준비 및 환경 설정 완료"

# 2. 문서 정리
mkdir -p docs/archive/phase0
cp -r docs/setup docs/archive/phase0/
cp -r docs/phases/phase0-* docs/archive/phase0/

# 3. 설정 파일 백업
mkdir -p backups/phase0
cp .env.example backups/phase0/
cp package.json backups/phase0/
cp -r .github backups/phase0/

# 4. 체크리스트 저장
npm run phase0:checklist > docs/archive/phase0/final-checklist.txt

# 5. 통계 생성
echo "📊 Phase 0 통계 생성 중..."
cat > docs/archive/phase0/statistics.md << EOF
# Phase 0 통계

## 코드 통계
- 총 파일 수: $(find . -type f -name "*.ts" -o -name "*.js" | wc -l)
- TypeScript 라인 수: $(find . -name "*.ts" -exec wc -l {} + | tail -1 | awk '{print $1}')
- 테스트 파일 수: $(find . -name "*.test.ts" -o -name "*.spec.ts" | wc -l)

## Git 통계
- 총 커밋 수: $(git rev-list --count HEAD)
- 기여자 수: $(git shortlog -sn | wc -l)

## 의존성
- Backend 패키지: $(cd backend && npm ls --depth=0 | wc -l)
- Frontend 패키지: $(cd frontend && npm ls --depth=0 | wc -l)

생성일: $(date)
EOF

echo "✅ Phase 0 아카이브 완료!"
echo "📁 아카이브 위치: docs/archive/phase0/"
```

---

이제 Phase 0의 모든 작업이 완료되었습니다! 

Phase 0에서는 T-Developer 프로젝트의 기반이 되는 다음과 같은 핵심 요소들을 구축했습니다:

1. **개발 환경**: Node.js, TypeScript, AWS CLI, Docker 등 필수 도구 설정
2. **프로젝트 구조**: 모노레포 구조와 체계적인 디렉토리 구성
3. **AWS 인프라**: DynamoDB, S3, Bedrock 통합 준비
4. **개발 도구**: ESLint, Prettier, Jest, Git hooks
5. **보안**: 환경 변수 암호화, 입력 검증, 보안 미들웨어
6. **CI/CD**: GitHub Actions 워크플로우
7. **문서화**: 포괄적인 개발 가이드 및 API 문서
8. **모니터링**: 로깅, 메트릭, 에러 추적
9. **에이전트 프레임워크**: BaseAgent 및 통신 프로토콜
10. **통합 준비**: AWS Agent Squad, Bedrock AgentCore, Agno