## Task 0.12: ê°œë°œ ì›Œí¬í”Œë¡œìš° ìµœì í™”

### SubTask 0.12.1: ìë™í™”ëœ ì½”ë“œ ìƒì„± ë„êµ¬
**ëª©í‘œ**: ë°˜ë³µì ì¸ ì½”ë“œ ì‘ì„±ì„ ìœ„í•œ ìë™í™” ë„êµ¬ êµ¬ì¶•

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// scripts/code-generator/generator.ts
import { Command } from 'commander';
import inquirer from 'inquirer';
import { promises as fs } from 'fs';
import path from 'path';
import Handlebars from 'handlebars';
import chalk from 'chalk';

// í…œí”Œë¦¿ ë§¤ë‹ˆì €
class TemplateManager {
  private templatesDir = path.join(__dirname, 'templates');
  private templates: Map<string, HandlebarsTemplateDelegate> = new Map();
  
  async loadTemplates(): Promise<void> {
    const templateFiles = await fs.readdir(this.templatesDir);
    
    for (const file of templateFiles) {
      if (file.endsWith('.hbs')) {
        const name = path.basename(file, '.hbs');
        const content = await fs.readFile(
          path.join(this.templatesDir, file),
          'utf-8'
        );
        this.templates.set(name, Handlebars.compile(content));
      }
    }
    
    this.registerHelpers();
  }
  
  private registerHelpers(): void {
    // ì¼€ì´ìŠ¤ ë³€í™˜ í—¬í¼
    Handlebars.registerHelper('camelCase', (str: string) => 
      str.replace(/-./g, x => x[1].toUpperCase())
    );
    
    Handlebars.registerHelper('pascalCase', (str: string) => {
      const camel = str.replace(/-./g, x => x[1].toUpperCase());
      return camel.charAt(0).toUpperCase() + camel.slice(1);
    });
    
    Handlebars.registerHelper('kebabCase', (str: string) =>
      str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`).replace(/^-/, '')
    );
    
    // ì¡°ê±´ë¶€ í—¬í¼
    Handlebars.registerHelper('if_eq', function(a, b, options) {
      if (a === b) {
        return options.fn(this);
      }
      return options.inverse(this);
    });
  }
  
  render(templateName: string, data: any): string {
    const template = this.templates.get(templateName);
    if (!template) {
      throw new Error(`Template '${templateName}' not found`);
    }
    return template(data);
  }
}

// ì½”ë“œ ìƒì„±ê¸°
class CodeGenerator {
  private templateManager = new TemplateManager();
  
  async initialize(): Promise<void> {
    await this.templateManager.loadTemplates();
  }
  
  // ì—ì´ì „íŠ¸ ìƒì„±
  async generateAgent(name: string): Promise<void> {
    const answers = await inquirer.prompt([
      {
        type: 'list',
        name: 'type',
        message: 'Select agent type:',
        choices: [
          'processing',
          'analysis',
          'generation',
          'integration'
        ]
      },
      {
        type: 'checkbox',
        name: 'capabilities',
        message: 'Select agent capabilities:',
        choices: [
          'database-access',
          'file-operations',
          'api-calls',
          'llm-integration',
          'caching'
        ]
      },
      {
        type: 'input',
        name: 'description',
        message: 'Agent description:'
      }
    ]);
    
    const data = {
      name,
      className: this.toPascalCase(name),
      ...answers
    };
    
    // ì—ì´ì „íŠ¸ íŒŒì¼ ìƒì„±
    const agentCode = this.templateManager.render('agent', data);
    const agentPath = path.join(
      process.cwd(),
      'backend/src/agents',
      `${name}-agent.ts`
    );
    
    await fs.writeFile(agentPath, agentCode);
    
    // í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
    const testCode = this.templateManager.render('agent-test', data);
    const testPath = path.join(
      process.cwd(),
      'backend/tests/agents',
      `${name}-agent.test.ts`
    );
    
    await fs.writeFile(testPath, testCode);
    
    // ë¬¸ì„œ ìƒì„±
    const docCode = this.templateManager.render('agent-doc', data);
    const docPath = path.join(
      process.cwd(),
      'docs/agents',
      `${name}-agent.md`
    );
    
    await fs.writeFile(docPath, docCode);
    
    console.log(chalk.green(`âœ… Agent '${name}' generated successfully!`));
    console.log(chalk.blue('Generated files:'));
    console.log(`  - ${agentPath}`);
    console.log(`  - ${testPath}`);
    console.log(`  - ${docPath}`);
  }
  
  // API ì—”ë“œí¬ì¸íŠ¸ ìƒì„±
  async generateEndpoint(resource: string): Promise<void> {
    const answers = await inquirer.prompt([
      {
        type: 'checkbox',
        name: 'methods',
        message: 'Select HTTP methods:',
        choices: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
        default: ['GET', 'POST', 'PUT', 'DELETE']
      },
      {
        type: 'confirm',
        name: 'authentication',
        message: 'Require authentication?',
        default: true
      },
      {
        type: 'confirm',
        name: 'validation',
        message: 'Include validation?',
        default: true
      },
      {
        type: 'confirm',
        name: 'pagination',
        message: 'Include pagination?',
        default: true
      }
    ]);
    
    const data = {
      resource,
      resourceName: this.toPascalCase(resource),
      ...answers
    };
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±
    const controllerCode = this.templateManager.render('controller', data);
    const controllerPath = path.join(
      process.cwd(),
      'backend/src/controllers',
      `${resource}.controller.ts`
    );
    
    await fs.writeFile(controllerPath, controllerCode);
    
    // ì„œë¹„ìŠ¤ ìƒì„±
    const serviceCode = this.templateManager.render('service', data);
    const servicePath = path.join(
      process.cwd(),
      'backend/src/services',
      `${resource}.service.ts`
    );
    
    await fs.writeFile(servicePath, serviceCode);
    
    // ë¼ìš°íŠ¸ ìƒì„±
    const routeCode = this.templateManager.render('route', data);
    const routePath = path.join(
      process.cwd(),
      'backend/src/routes',
      `${resource}.routes.ts`
    );
    
    await fs.writeFile(routePath, routeCode);
    
    // ê²€ì¦ ìŠ¤í‚¤ë§ˆ ìƒì„±
    if (answers.validation) {
      const validationCode = this.templateManager.render('validation', data);
      const validationPath = path.join(
        process.cwd(),
        'backend/src/validations',
        `${resource}.validation.ts`
      );
      
      await fs.writeFile(validationPath, validationCode);
    }
    
    console.log(chalk.green(`âœ… API endpoint '${resource}' generated successfully!`));
  }
  
  // React ì»´í¬ë„ŒíŠ¸ ìƒì„±
  async generateComponent(name: string): Promise<void> {
    const answers = await inquirer.prompt([
      {
        type: 'list',
        name: 'type',
        message: 'Component type:',
        choices: ['functional', 'class']
      },
      {
        type: 'confirm',
        name: 'typescript',
        message: 'Use TypeScript?',
        default: true
      },
      {
        type: 'confirm',
        name: 'styles',
        message: 'Include styles?',
        default: true
      },
      {
        type: 'confirm',
        name: 'tests',
        message: 'Include tests?',
        default: true
      },
      {
        type: 'checkbox',
        name: 'hooks',
        message: 'Select hooks to use:',
        choices: ['useState', 'useEffect', 'useContext', 'useReducer', 'useMemo', 'useCallback']
      }
    ]);
    
    const data = {
      name,
      componentName: this.toPascalCase(name),
      ...answers
    };
    
    const ext = answers.typescript ? 'tsx' : 'jsx';
    const styleExt = 'module.css';
    
    // ì»´í¬ë„ŒíŠ¸ ë””ë ‰í† ë¦¬ ìƒì„±
    const componentDir = path.join(
      process.cwd(),
      'frontend/src/components',
      name
    );
    await fs.mkdir(componentDir, { recursive: true });
    
    // ì»´í¬ë„ŒíŠ¸ íŒŒì¼ ìƒì„±
    const componentCode = this.templateManager.render('react-component', data);
    const componentPath = path.join(componentDir, `index.${ext}`);
    await fs.writeFile(componentPath, componentCode);
    
    // ìŠ¤íƒ€ì¼ íŒŒì¼ ìƒì„±
    if (answers.styles) {
      const styleCode = this.templateManager.render('component-styles', data);
      const stylePath = path.join(componentDir, `styles.${styleExt}`);
      await fs.writeFile(stylePath, styleCode);
    }
    
    // í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
    if (answers.tests) {
      const testCode = this.templateManager.render('component-test', data);
      const testPath = path.join(componentDir, `${name}.test.${ext}`);
      await fs.writeFile(testPath, testCode);
    }
    
    // ìŠ¤í† ë¦¬ë¶ íŒŒì¼ ìƒì„±
    const storyCode = this.templateManager.render('component-story', data);
    const storyPath = path.join(componentDir, `${name}.stories.${ext}`);
    await fs.writeFile(storyPath, storyCode);
    
    console.log(chalk.green(`âœ… Component '${name}' generated successfully!`));
  }
  
  // ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ
  private toPascalCase(str: string): string {
    return str
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
  }
}

// CLI ì„¤ì •
const program = new Command();
const generator = new CodeGenerator();

program
  .name('t-dev-gen')
  .description('T-Developer code generator')
  .version('1.0.0');

program
  .command('agent <name>')
  .description('Generate a new agent')
  .action(async (name) => {
    await generator.initialize();
    await generator.generateAgent(name);
  });

program
  .command('api <resource>')
  .description('Generate API endpoint')
  .action(async (resource) => {
    await generator.initialize();
    await generator.generateEndpoint(resource);
  });

program
  .command('component <name>')
  .description('Generate React component')
  .action(async (name) => {
    await generator.initialize();
    await generator.generateComponent(name);
  });

program.parse();
```

```handlebars
<!-- scripts/code-generator/templates/agent.hbs -->
import { Agent } from '@/core/agent';
import { logger } from '@/config/logger';
{{#if (includes capabilities 'database-access')}}
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
{{/if}}
{{#if (includes capabilities 'llm-integration')}}
import { BedrockClient } from '@aws-sdk/client-bedrock';
{{/if}}

/**
 * {{description}}
 */
export class {{className}}Agent extends Agent {
  static readonly AGENT_NAME = '{{name}}';
  static readonly AGENT_TYPE = '{{type}}';
  
  {{#if (includes capabilities 'database-access')}}
  private docClient: DynamoDBDocumentClient;
  {{/if}}
  {{#if (includes capabilities 'llm-integration')}}
  private bedrockClient: BedrockClient;
  {{/if}}
  
  constructor() {
    super({
      name: {{className}}Agent.AGENT_NAME,
      type: {{className}}Agent.AGENT_TYPE,
      capabilities: [
        {{#each capabilities}}
        '{{this}}',
        {{/each}}
      ]
    });
    
    this.initialize();
  }
  
  private initialize(): void {
    {{#if (includes capabilities 'database-access')}}
    this.docClient = this.createDynamoDBClient();
    {{/if}}
    {{#if (includes capabilities 'llm-integration')}}
    this.bedrockClient = this.createBedrockClient();
    {{/if}}
  }
  
  async execute(input: any): Promise<any> {
    logger.info(`Executing ${this.name} agent`, { input });
    
    try {
      // Validate input
      this.validateInput(input);
      
      // Process input
      const result = await this.process(input);
      
      // Return result
      return {
        success: true,
        data: result,
        metadata: {
          agentName: this.name,
          executionTime: Date.now(),
          version: '1.0.0'
        }
      };
      
    } catch (error) {
      logger.error(`Error in ${this.name} agent`, error);
      throw error;
    }
  }
  
  private validateInput(input: any): void {
    // TODO: Implement input validation
    if (!input) {
      throw new Error('Input is required');
    }
  }
  
  private async process(input: any): Promise<any> {
    // TODO: Implement processing logic
    {{#if_eq type 'processing'}}
    // Processing agent logic
    return this.processData(input);
    {{/if_eq}}
    {{#if_eq type 'analysis'}}
    // Analysis agent logic
    return this.analyzeData(input);
    {{/if_eq}}
    {{#if_eq type 'generation'}}
    // Generation agent logic
    return this.generateOutput(input);
    {{/if_eq}}
    {{#if_eq type 'integration'}}
    // Integration agent logic
    return this.integrateServices(input);
    {{/if_eq}}
  }
  
  {{#if_eq type 'processing'}}
  private async processData(data: any): Promise<any> {
    // TODO: Implement data processing
    return data;
  }
  {{/if_eq}}
  
  {{#if_eq type 'analysis'}}
  private async analyzeData(data: any): Promise<any> {
    // TODO: Implement data analysis
    return { analyzed: true };
  }
  {{/if_eq}}
  
  {{#if_eq type 'generation'}}
  private async generateOutput(input: any): Promise<any> {
    // TODO: Implement output generation
    return { generated: true };
  }
  {{/if_eq}}
  
  {{#if_eq type 'integration'}}
  private async integrateServices(input: any): Promise<any> {
    // TODO: Implement service integration
    return { integrated: true };
  }
  {{/if_eq}}
}
```
---

### SubTask 0.12.2: Hot Module Replacement (HMR) ì„¤ì •
**ëª©í‘œ**: ê°œë°œ ì¤‘ ë¹ ë¥¸ í”¼ë“œë°±ì„ ìœ„í•œ HMR êµ¬ì„±

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// backend/src/dev/hot-reload.ts
import { spawn, ChildProcess } from 'child_process';
import chokidar from 'chokidar';
import { EventEmitter } from 'events';
import path from 'path';
import { logger } from '../config/logger';
import WebSocket from 'ws';

// HMR ë§¤ë‹ˆì €
export class HotModuleReplacementManager extends EventEmitter {
  private watcher?: chokidar.FSWatcher;
  private process?: ChildProcess;
  private wsServer?: WebSocket.Server;
  private reloadTimer?: NodeJS.Timeout;
  private isRestarting = false;
  
  constructor(private config: HMRConfig) {
    super();
  }
  
  // HMR ì‹œì‘
  async start(): Promise<void> {
    logger.info('Starting Hot Module Replacement...');
    
    // WebSocket ì„œë²„ ì‹œì‘ (ë¸Œë¼ìš°ì € ìƒˆë¡œê³ ì¹¨ìš©)
    this.startWebSocketServer();
    
    // ì´ˆê¸° í”„ë¡œì„¸ìŠ¤ ì‹œì‘
    await this.startProcess();
    
    // íŒŒì¼ ê°ì‹œ ì‹œì‘
    this.startWatching();
  }
  
  // WebSocket ì„œë²„
  private startWebSocketServer(): void {
    this.wsServer = new WebSocket.Server({ port: this.config.wsPort || 3001 });
    
    this.wsServer.on('connection', (ws) => {
      logger.debug('HMR client connected');
      
      ws.on('close', () => {
        logger.debug('HMR client disconnected');
      });
    });
  }
  
  // íŒŒì¼ ê°ì‹œ
  private startWatching(): void {
    const watchPaths = this.config.watchPaths || ['src'];
    const ignorePaths = this.config.ignorePaths || [
      'node_modules',
      'dist',
      'coverage',
      '.git',
      '**/*.test.ts',
      '**/*.spec.ts'
    ];
    
    this.watcher = chokidar.watch(watchPaths, {
      ignored: ignorePaths,
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 300,
        pollInterval: 100
      }
    });
    
    // íŒŒì¼ ë³€ê²½ ì´ë²¤íŠ¸
    this.watcher.on('change', (filePath) => this.handleFileChange(filePath));
    this.watcher.on('add', (filePath) => this.handleFileChange(filePath));
    this.watcher.on('unlink', (filePath) => this.handleFileChange(filePath));
  }
  
  // íŒŒì¼ ë³€ê²½ ì²˜ë¦¬
  private handleFileChange(filePath: string): void {
    logger.info(`File changed: ${filePath}`);
    
    // ë””ë°”ìš´ì‹±
    if (this.reloadTimer) {
      clearTimeout(this.reloadTimer);
    }
    
    this.reloadTimer = setTimeout(() => {
      const ext = path.extname(filePath);
      
      if (this.config.hotReloadableExtensions?.includes(ext)) {
        // Hot reload ê°€ëŠ¥í•œ íŒŒì¼
        this.hotReload(filePath);
      } else {
        // ì „ì²´ ì¬ì‹œì‘ í•„ìš”
        this.restartProcess();
      }
    }, this.config.debounceDelay || 100);
  }
  
  // Hot reload ìˆ˜í–‰
  private async hotReload(filePath: string): Promise<void> {
    try {
      // ìºì‹œì—ì„œ ëª¨ë“ˆ ì œê±°
      this.clearModuleCache(filePath);
      
      // ëª¨ë“ˆ íŠ¹ì • í•« ë¦¬ë¡œë“œ ë¡œì§
      if (filePath.includes('/agents/')) {
        await this.reloadAgent(filePath);
      } else if (filePath.includes('/routes/')) {
        await this.reloadRoute(filePath);
      } else if (filePath.includes('/services/')) {
        await this.reloadService(filePath);
      } else {
        // ê¸°ë³¸ í•« ë¦¬ë¡œë“œ
        this.emit('module:reload', filePath);
      }
      
      // ë¸Œë¼ìš°ì € ìƒˆë¡œê³ ì¹¨
      this.notifyClients('reload');
      
      logger.info(`Hot reloaded: ${filePath}`);
      
    } catch (error) {
      logger.error('Hot reload failed:', error);
      // ì‹¤íŒ¨ ì‹œ ì „ì²´ ì¬ì‹œì‘
      this.restartProcess();
    }
  }
  
  // ì—ì´ì „íŠ¸ ë¦¬ë¡œë“œ
  private async reloadAgent(filePath: string): Promise<void> {
    const agentName = path.basename(filePath, '.ts').replace('-agent', '');
    
    // ì—ì´ì „íŠ¸ ë§¤ë‹ˆì €ì— ë¦¬ë¡œë“œ ìš”ì²­
    if (global.agentManager) {
      await global.agentManager.reloadAgent(agentName);
    }
  }
  
  // ë¼ìš°íŠ¸ ë¦¬ë¡œë“œ
  private async reloadRoute(filePath: string): Promise<void> {
    // Express ë¼ìš°í„° ì¬ë“±ë¡
    if (global.app) {
      const routeName = path.basename(filePath, '.ts');
      delete require.cache[require.resolve(filePath)];
      const newRouter = require(filePath).default;
      
      // ê¸°ì¡´ ë¼ìš°íŠ¸ ì œê±° ë° ìƒˆ ë¼ìš°íŠ¸ ë“±ë¡
      global.app._router.stack = global.app._router.stack.filter(
        (layer: any) => !layer.regexp.test(`/${routeName}`)
      );
      global.app.use(`/api/${routeName}`, newRouter);
    }
  }
  
  // ì„œë¹„ìŠ¤ ë¦¬ë¡œë“œ
  private async reloadService(filePath: string): Promise<void> {
    const serviceName = path.basename(filePath, '.ts');
    
    // ì„œë¹„ìŠ¤ ì»¨í…Œì´ë„ˆì—ì„œ ì¬ë“±ë¡
    if (global.serviceContainer) {
      delete require.cache[require.resolve(filePath)];
      const ServiceClass = require(filePath).default;
      global.serviceContainer.register(serviceName, new ServiceClass());
    }
  }
  
  // ëª¨ë“ˆ ìºì‹œ ì œê±°
  private clearModuleCache(filePath: string): void {
    const resolvedPath = require.resolve(filePath);
    delete require.cache[resolvedPath];
    
    // ì˜ì¡´ì„±ë„ í•¨ê»˜ ì œê±°
    Object.keys(require.cache).forEach((key) => {
      if (require.cache[key]?.children.some(child => child.id === resolvedPath)) {
        delete require.cache[key];
      }
    });
  }
  
  // í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘
  private async restartProcess(): Promise<void> {
    if (this.isRestarting) return;
    
    this.isRestarting = true;
    logger.info('Restarting application...');
    
    // ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
    if (this.process) {
      await this.stopProcess();
    }
    
    // ìƒˆ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
    await this.startProcess();
    
    this.isRestarting = false;
    this.notifyClients('restart');
  }
  
  // í”„ë¡œì„¸ìŠ¤ ì‹œì‘
  private async startProcess(): Promise<void> {
    const command = this.config.command || 'npm';
    const args = this.config.args || ['run', 'dev'];
    
    this.process = spawn(command, args, {
      stdio: 'inherit',
      env: {
        ...process.env,
        NODE_ENV: 'development',
        HMR_ENABLED: 'true'
      }
    });
    
    this.process.on('exit', (code) => {
      if (code !== 0 && !this.isRestarting) {
        logger.error(`Process exited with code ${code}`);
        setTimeout(() => this.restartProcess(), 1000);
      }
    });
    
    // í”„ë¡œì„¸ìŠ¤ ì¤€ë¹„ ëŒ€ê¸°
    await this.waitForProcessReady();
  }
  
  // í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
  private async stopProcess(): Promise<void> {
    if (!this.process) return;
    
    return new Promise((resolve) => {
      this.process!.once('exit', resolve);
      this.process!.kill('SIGTERM');
      
      // ê°•ì œ ì¢…ë£Œ íƒ€ì´ë¨¸
      setTimeout(() => {
        if (this.process) {
          this.process.kill('SIGKILL');
        }
        resolve(undefined);
      }, 5000);
    });
  }
  
  // í”„ë¡œì„¸ìŠ¤ ì¤€ë¹„ ëŒ€ê¸°
  private async waitForProcessReady(): Promise<void> {
    const maxAttempts = 30;
    const checkInterval = 1000;
    
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const response = await fetch(`http://localhost:${this.config.appPort || 3000}/health`);
        if (response.ok) {
          logger.info('Application is ready');
          return;
        }
      } catch (error) {
        // ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•ŠìŒ
      }
      
      await new Promise(resolve => setTimeout(resolve, checkInterval));
    }
    
    throw new Error('Application failed to start');
  }
  
  // í´ë¼ì´ì–¸íŠ¸ì— ì•Œë¦¼
  private notifyClients(action: string): void {
    if (!this.wsServer) return;
    
    const message = JSON.stringify({ action, timestamp: Date.now() });
    
    this.wsServer.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  }
  
  // HMR ì¤‘ì§€
  async stop(): Promise<void> {
    logger.info('Stopping Hot Module Replacement...');
    
    if (this.watcher) {
      await this.watcher.close();
    }
    
    if (this.process) {
      await this.stopProcess();
    }
    
    if (this.wsServer) {
      this.wsServer.close();
    }
  }
}

// TypeScript ë³€í™˜ê¸°
export class TypeScriptTranspiler {
  private tsNode: any;
  
  constructor() {
    this.tsNode = require('ts-node').register({
      transpileOnly: true,
      compilerOptions: {
        module: 'commonjs',
        target: 'es2020',
        lib: ['es2020'],
        allowJs: true,
        esModuleInterop: true,
        skipLibCheck: true
      }
    });
  }
  
  // ëŸ°íƒ€ì„ ë³€í™˜
  transpile(code: string, fileName: string): string {
    const ts = require('typescript');
    
    const result = ts.transpileModule(code, {
      compilerOptions: {
        module: ts.ModuleKind.CommonJS,
        target: ts.ScriptTarget.ES2020,
        esModuleInterop: true
      },
      fileName
    });
    
    return result.outputText;
  }
  
  // require í›… ì„¤ì¹˜
  installRequireHook(): void {
    const Module = require('module');
    const originalRequire = Module.prototype.require;
    
    Module.prototype.require = function(id: string) {
      // HMRì´ í™œì„±í™”ëœ ëª¨ë“ˆì¸ì§€ í™•ì¸
      if (global.HMR_MODULES?.has(id)) {
        logger.debug(`HMR: Loading module ${id}`);
        
        // ìºì‹œ ë¬´íš¨í™”
        delete require.cache[require.resolve(id)];
      }
      
      return originalRequire.apply(this, arguments);
    };
  }
}

// í”„ë¡ íŠ¸ì—”ë“œ HMR í´ë¼ì´ì–¸íŠ¸
export const hmrClient = `
(function() {
  const ws = new WebSocket('ws://localhost:3001');
  
  ws.onopen = () => {
    console.log('[HMR] Connected');
  };
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    switch (data.action) {
      case 'reload':
        console.log('[HMR] Reloading page...');
        window.location.reload();
        break;
        
      case 'restart':
        console.log('[HMR] Server restarted');
        // ì¬ì—°ê²° ì‹œë„
        setTimeout(() => {
          window.location.reload();
        }, 1000);
        break;
        
      case 'css':
        console.log('[HMR] Updating CSS...');
        updateCSS(data.file);
        break;
    }
  };
  
  ws.onclose = () => {
    console.log('[HMR] Disconnected. Retrying...');
    setTimeout(() => {
      window.location.reload();
    }, 2000);
  };
  
  function updateCSS(file) {
    const links = document.querySelectorAll('link[rel="stylesheet"]');
    const link = Array.from(links).find(l => l.href.includes(file));
    
    if (link) {
      const newLink = link.cloneNode();
      newLink.href = link.href.split('?')[0] + '?t=' + Date.now();
      link.parentNode.replaceChild(newLink, link);
    }
  }
})();
`;

// HMR ì„¤ì • íƒ€ì…
interface HMRConfig {
  watchPaths?: string[];
  ignorePaths?: string[];
  hotReloadableExtensions?: string[];
  debounceDelay?: number;
  command?: string;
  args?: string[];
  appPort?: number;
  wsPort?: number;
}

// Express ì•±ì— HMR ë¯¸ë“¤ì›¨ì–´ ì¶”ê°€
export function setupHMRMiddleware(app: any): void {
  if (process.env.NODE_ENV !== 'development') return;
  
  // HMR í´ë¼ì´ì–¸íŠ¸ ì£¼ì…
  app.use((req: any, res: any, next: any) => {
    if (req.path.endsWith('.html')) {
      const originalSend = res.send;
      res.send = function(html: string) {
        if (typeof html === 'string' && html.includes('</body>')) {
          html = html.replace('</body>', `<script>${hmrClient}</script></body>`);
        }
        originalSend.call(this, html);
      };
    }
    next();
  });
  
  // ì „ì—­ ê°ì²´ ì„¤ì •
  global.app = app;
  global.HMR_MODULES = new Set();
}
```

### SubTask 0.12.3: ê°œë°œìš© ë°ì´í„° ëª¨í‚¹ ì‹œìŠ¤í…œ
**ëª©í‘œ**: ì™¸ë¶€ ì˜ì¡´ì„± ì—†ì´ ê°œë°œí•  ìˆ˜ ìˆëŠ” ëª¨í‚¹ ì‹œìŠ¤í…œ

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// backend/src/dev/mock-system.ts
import { faker } from '@faker-js/faker';
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';

// ëª¨í‚¹ ì„œë¹„ìŠ¤ ë§¤ë‹ˆì €
export class MockServiceManager {
  private mockServers: Map<string, any> = new Map();
  private mockData: Map<string, any> = new Map();
  
  // ëª¨ë“  ëª¨í‚¹ ì„œë¹„ìŠ¤ ì‹œì‘
  async startAll(): Promise<void> {
    await Promise.all([
      this.startBedrockMock(),
      this.startDynamoDBMock(),
      this.startS3Mock(),
      this.startExternalAPIMocks()
    ]);
    
    console.log('âœ… All mock services started');
  }
  
  // Bedrock API ëª¨í‚¹
  private async startBedrockMock(): Promise<void> {
    const app = express();
    app.use(express.json());
    
    // Claude ëª¨ë¸ ì‘ë‹µ ëª¨í‚¹
    app.post('/model/anthropic.claude-*/invoke', async (req, res) => {
      const { prompt } = req.body;
      
      // ì§€ì—° ì‹œë®¬ë ˆì´ì…˜
      await this.simulateLatency(500, 2000);
      
      // ëª¨ì˜ ì‘ë‹µ ìƒì„±
      const response = this.generateMockLLMResponse(prompt);
      
      res.json({
        completion: response,
        stop_reason: 'stop_sequence',
        model: req.params[0],
        usage: {
          input_tokens: prompt.split(' ').length * 1.3,
          output_tokens: response.split(' ').length * 1.3
        }
      });
    });
    
    const server = app.listen(4567, () => {
      console.log('ğŸ¤– Bedrock mock server running on port 4567');
    });
    
    this.mockServers.set('bedrock', server);
  }
  
  // DynamoDB ëª¨í‚¹
  private async startDynamoDBMock(): Promise<void> {
    const app = express();
    app.use(express.json());
    
    // í…Œì´ë¸”ë³„ ë°ì´í„° ì €ì¥ì†Œ
    const tables: Map<string, any[]> = new Map();
    
    // PutItem
    app.post('/tables/:tableName/items', (req, res) => {
      const { tableName } = req.params;
      const item = req.body.Item;
      
      if (!tables.has(tableName)) {
        tables.set(tableName, []);
      }
      
      const tableData = tables.get(tableName)!;
      const existingIndex = tableData.findIndex(i => i.id === item.id);
      
      if (existingIndex >= 0) {
        tableData[existingIndex] = item;
      } else {
        tableData.push(item);
      }
      
      res.json({ Attributes: item });
    });
    
    // GetItem
    app.get('/tables/:tableName/items/:id', (req, res) => {
      const { tableName, id } = req.params;
      const tableData = tables.get(tableName) || [];
      const item = tableData.find(i => i.id === id);
      
      if (item) {
        res.json({ Item: item });
      } else {
        res.status(404).json({ message: 'Item not found' });
      }
    });
    
    // Query
    app.post('/tables/:tableName/query', (req, res) => {
      const { tableName } = req.params;
      const { KeyConditionExpression, ExpressionAttributeValues } = req.body;
      
      const tableData = tables.get(tableName) || [];
      
      // ê°„ë‹¨í•œ ì¿¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
      const results = tableData.filter(item => {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” KeyConditionExpression íŒŒì‹± í•„ìš”
        return true;
      });
      
      res.json({
        Items: results,
        Count: results.length,
        ScannedCount: results.length
      });
    });
    
    const server = app.listen(8000, () => {
      console.log('ğŸ—ƒï¸  DynamoDB mock server running on port 8000');
    });
    
    this.mockServers.set('dynamodb', server);
    
    // ì´ˆê¸° ë°ì´í„° ì‹œë”©
    await this.seedDynamoDBData(tables);
  }
  
  // S3 ëª¨í‚¹
  private async startS3Mock(): Promise<void> {
    const app = express();
    app.use(express.json());
    app.use(express.raw({ type: '*/*', limit: '100mb' }));
    
    const buckets: Map<string, Map<string, any>> = new Map();
    
    // CreateBucket
    app.put('/:bucket', (req, res) => {
      const { bucket } = req.params;
      
      if (!buckets.has(bucket)) {
        buckets.set(bucket, new Map());
        res.status(200).send();
      } else {
        res.status(409).json({ 
          Code: 'BucketAlreadyExists',
          Message: 'The requested bucket name is not available'
        });
      }
    });
    
    // PutObject
    app.put('/:bucket/:key(*)', (req, res) => {
      const { bucket, key } = req.params;
      
      if (!buckets.has(bucket)) {
        return res.status(404).json({ Code: 'NoSuchBucket' });
      }
      
      const bucketData = buckets.get(bucket)!;
      bucketData.set(key, {
        Body: req.body,
        ContentType: req.headers['content-type'],
        ContentLength: req.body.length,
        ETag: `"${faker.string.alphanumeric(32)}"`,
        LastModified: new Date().toISOString()
      });
      
      res.json({ ETag: bucketData.get(key).ETag });
    });
    
    // GetObject
    app.get('/:bucket/:key(*)', (req, res) => {
      const { bucket, key } = req.params;
      
      if (!buckets.has(bucket)) {
        return res.status(404).json({ Code: 'NoSuchBucket' });
      }
      
      const bucketData = buckets.get(bucket)!;
      const object = bucketData.get(key);
      
      if (!object) {
        return res.status(404).json({ Code: 'NoSuchKey' });
      }
      
      res.set({
        'Content-Type': object.ContentType,
        'Content-Length': object.ContentLength,
        'ETag': object.ETag,
        'Last-Modified': object.LastModified
      });
      
      res.send(object.Body);
    });
    
    const server = app.listen(4568, () => {
      console.log('â˜ï¸  S3 mock server running on port 4568');
    });
    
    this.mockServers.set('s3', server);
  }
  
  // ì™¸ë¶€ API ëª¨í‚¹
  private async startExternalAPIMocks(): Promise<void> {
    const app = express();
    app.use(express.json());
    
    // NPM Registry ëª¨í‚¹
    app.get('/npm/:package', (req, res) => {
      const packageInfo = this.generateMockNPMPackage(req.params.package);
      res.json(packageInfo);
    });
    
    // GitHub API ëª¨í‚¹
    app.get('/github/repos/:owner/:repo', (req, res) => {
      const repoInfo = this.generateMockGitHubRepo(req.params.owner, req.params.repo);
      res.json(repoInfo);
    });
    
    // PyPI ëª¨í‚¹
    app.get('/pypi/:package', (req, res) => {
      const packageInfo = this.generateMockPyPIPackage(req.params.package);
      res.json(packageInfo);
    });
    
    const server = app.listen(4569, () => {
      console.log('ğŸŒ External API mock server running on port 4569');
    });
    
    this.mockServers.set('external', server);
  }
  
  // ëª¨ì˜ LLM ì‘ë‹µ ìƒì„±
  private generateMockLLMResponse(prompt: string): string {
    const responses: Record<string, string> = {
      'analyze': 'Based on my analysis, this appears to be a web application project that requires user authentication, data storage, and a RESTful API.',
      'generate': 'Here\'s the generated code:\n\n```javascript\nclass ExampleService {\n  async getData() {\n    return { success: true, data: [] };\n  }\n}\n```',
      'default': faker.lorem.paragraphs(2)
    };
    
    const keyword = Object.keys(responses).find(k => prompt.toLowerCase().includes(k));
    return responses[keyword || 'default'];
  }
  
  // NPM íŒ¨í‚¤ì§€ ì •ë³´ ìƒì„±
  private generateMockNPMPackage(packageName: string): any {
    return {
      name: packageName,
      version: faker.system.semver(),
      description: faker.lorem.sentence(),
      keywords: faker.lorem.words(5).split(' '),
      author: faker.person.fullName(),
      license: faker.helpers.arrayElement(['MIT', 'Apache-2.0', 'GPL-3.0']),
      repository: {
        type: 'git',
        url: `https://github.com/${faker.internet.userName()}/${packageName}`
      },
      dependencies: this.generateMockDependencies(),
      devDependencies: this.generateMockDependencies(),
      downloads: {
        weekly: faker.number.int({ min: 1000, max: 1000000 })
      }
    };
  }
  
  // GitHub ë¦¬í¬ì§€í† ë¦¬ ì •ë³´ ìƒì„±
  private generateMockGitHubRepo(owner: string, repo: string): any {
    return {
      id: faker.number.int({ min: 1000000, max: 9999999 }),
      name: repo,
      full_name: `${owner}/${repo}`,
      owner: {
        login: owner,
        avatar_url: faker.image.avatar()
      },
      description: faker.lorem.sentence(),
      fork: false,
      created_at: faker.date.past().toISOString(),
      updated_at: faker.date.recent().toISOString(),
      pushed_at: faker.date.recent().toISOString(),
      stargazers_count: faker.number.int({ min: 0, max: 50000 }),
      watchers_count: faker.number.int({ min: 0, max: 5000 }),
      forks_count: faker.number.int({ min: 0, max: 10000 }),
      language: faker.helpers.arrayElement(['JavaScript', 'TypeScript', 'Python', 'Java', 'Go']),
      license: {
        key: 'mit',
        name: 'MIT License'
      }
    };
  }
  
  // PyPI íŒ¨í‚¤ì§€ ì •ë³´ ìƒì„±
  private generateMockPyPIPackage(packageName: string): any {
    return {
      info: {
        name: packageName,
        version: faker.system.semver(),
        summary: faker.lorem.sentence(),
        author: faker.person.fullName(),
        author_email: faker.internet.email(),
        license: faker.helpers.arrayElement(['MIT', 'Apache-2.0', 'GPL-3.0']),
        keywords: faker.lorem.words(5),
        classifiers: [
          'Development Status :: 4 - Beta',
          'Intended Audience :: Developers',
          'Programming Language :: Python :: 3'
        ]
      },
      releases: this.generateMockReleases()
    };
  }
  
  // ì˜ì¡´ì„± ìƒì„±
  private generateMockDependencies(): Record<string, string> {
    const deps: Record<string, string> = {};
    const count = faker.number.int({ min: 3, max: 10 });
    
    for (let i = 0; i < count; i++) {
      const packageName = faker.helpers.arrayElement([
        'express', 'react', 'vue', 'lodash', 'axios',
        'moment', 'uuid', 'bcrypt', 'jsonwebtoken', 'dotenv'
      ]);
      deps[packageName] = `^${faker.system.semver()}`;
    }
    
    return deps;
  }
  
  // ë¦´ë¦¬ìŠ¤ ì •ë³´ ìƒì„±
  private generateMockReleases(): Record<string, any[]> {
    const releases: Record<string, any[]> = {};
    const versionCount = faker.number.int({ min: 3, max: 10 });
    
    for (let i = 0; i < versionCount; i++) {
      const version = faker.system.semver();
      releases[version] = [{
        filename: `package-${version}.tar.gz`,
        size: faker.number.int({ min: 10000, max: 1000000 }),
        upload_time: faker.date.past().toISOString()
      }];
    }
    
    return releases;
  }
  
  // DynamoDB ì´ˆê¸° ë°ì´í„° ì‹œë”©
  private async seedDynamoDBData(tables: Map<string, any[]>): Promise<void> {
    // Projects í…Œì´ë¸”
    const projects = [];
    for (let i = 0; i < 20; i++) {
      projects.push({
        id: `proj_${faker.string.uuid()}`,
        name: faker.commerce.productName(),
        description: faker.lorem.paragraph(),
        status: faker.helpers.arrayElement(['analyzing', 'building', 'completed']),
        createdAt: faker.date.past().toISOString()
      });
    }
    tables.set('T-Developer-Projects', projects);
    
    // Components í…Œì´ë¸”
    const components = [];
    for (let i = 0; i < 50; i++) {
      components.push({
        id: `comp_${faker.string.uuid()}`,
        name: faker.hacker.noun(),
        version: faker.system.semver(),
        language: faker.helpers.arrayElement(['javascript', 'typescript', 'python']),
        downloads: faker.number.int({ min: 100, max: 100000 })
      });
    }
    tables.set('T-Developer-Components', components);
  }
  
  // ì§€ì—° ì‹œë®¬ë ˆì´ì…˜
  private async simulateLatency(min: number, max: number): Promise<void> {
    const delay = faker.number.int({ min, max });
    await new Promise(resolve => setTimeout(resolve, delay));
  }
  
  // ëª¨ë“  ëª¨í‚¹ ì„œë¹„ìŠ¤ ì¤‘ì§€
  async stopAll(): Promise<void> {
    for (const [name, server] of this.mockServers) {
      server.close();
      console.log(`ğŸ›‘ ${name} mock server stopped`);
    }
    
    this.mockServers.clear();
    this.mockData.clear();
  }
}

// WebSocket ëª¨í‚¹
export class WebSocketMockServer {
  private io: Server;
  
  constructor(httpServer: any) {
    this.io = new Server(httpServer, {
      cors: {
        origin: '*',
        methods: ['GET', 'POST']
      }
    });
    
    this.setupHandlers();
  }
  
  private setupHandlers(): void {
    this.io.on('connection', (socket) => {
      console.log('Mock WebSocket client connected');
      
      // í”„ë¡œì íŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹œë®¬ë ˆì´ì…˜
      this.simulateProjectUpdates(socket);
      
      // ì—ì´ì „íŠ¸ ì‹¤í–‰ ìƒíƒœ ì‹œë®¬ë ˆì´ì…˜
      this.simulateAgentExecutions(socket);
      
      socket.on('disconnect', () => {
        console.log('Mock WebSocket client disconnected');
      });
    });
  }
  
  private simulateProjectUpdates(socket: any): void {
    const projectId = `proj_${faker.string.uuid()}`;
    const statuses = ['analyzing', 'designing', 'building', 'testing', 'completed'];
    let currentIndex = 0;
    
    const interval = setInterval(() => {
      if (currentIndex >= statuses.length) {
        clearInterval(interval);
        return;
      }
      
      socket.emit('project:update', {
        projectId,
        status: statuses[currentIndex],
        progress: (currentIndex + 1) / statuses.length * 100,
        timestamp: new Date().toISOString()
      });
      
      currentIndex++;
    }, 3000);
  }
  
  private simulateAgentExecutions(socket: any): void {
    const agents = [
      'nl-input', 'ui-selection', 'parsing', 'component-decision',
      'matching-rate', 'search', 'generation', 'assembly', 'download'
    ];
    
    agents.forEach((agent, index) => {
      setTimeout(() => {
        socket.emit('agent:start', {
          agentName: agent,
          timestamp: new Date().toISOString()
        });
        
        setTimeout(() => {
          socket.emit('agent:complete', {
            agentName: agent,
            result: 'success',
            duration: faker.number.int({ min: 1000, max: 5000 }),
            timestamp: new Date().toISOString()
          });
        }, faker.number.int({ min: 2000, max: 8000 }));
      }, index * 2000);
    });
  }
}

// ëª¨í‚¹ ì„¤ì •
export const mockConfig = {
  enabled: process.env.USE_MOCKS === 'true',
  services: {
    bedrock: process.env.MOCK_BEDROCK === 'true',
    dynamodb: process.env.MOCK_DYNAMODB === 'true',
    s3: process.env.MOCK_S3 === 'true',
    external: process.env.MOCK_EXTERNAL_APIS === 'true'
  },
  endpoints: {
    bedrock: 'http://localhost:4567',
    dynamodb: 'http://localhost:8000',
    s3: 'http://localhost:4568',
    npm: 'http://localhost:4569/npm',
    github: 'http://localhost:4569/github',
    pypi: 'http://localhost:4569/pypi'
  }
};
```
---

### SubTask 0.12.4: ë””ë²„ê¹… ë„êµ¬ í†µí•©
**ëª©í‘œ**: íš¨ìœ¨ì ì¸ ë””ë²„ê¹…ì„ ìœ„í•œ ë„êµ¬ ë° ì„¤ì •

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// backend/src/dev/debugging-tools.ts
import { InspectorSession } from 'inspector';
import { performance } from 'perf_hooks';
import { AsyncLocalStorage } from 'async_hooks';
import util from 'util';
import chalk from 'chalk';

// íŠ¸ë ˆì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
export const traceContext = new AsyncLocalStorage<TraceContext>();

interface TraceContext {
  traceId: string;
  spanId: string;
  parentSpanId?: string;
  startTime: number;
  metadata: Record<string, any>;
}

// ê³ ê¸‰ ë””ë²„ê±°
export class AdvancedDebugger {
  private session: InspectorSession;
  private breakpoints: Map<string, Breakpoint> = new Map();
  private profiles: Map<string, any> = new Map();
  
  constructor() {
    this.session = new InspectorSession();
    this.session.connect();
  }
  
  // ì¡°ê±´ë¶€ ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì„¤ì •
  async setConditionalBreakpoint(
    file: string,
    line: number,
    condition: string,
    logMessage?: string
  ): Promise<void> {
    const scriptId = await this.getScriptId(file);
    
    await this.post('Debugger.setBreakpoint', {
      location: {
        scriptId,
        lineNumber: line - 1
      },
      condition
    });
    
    this.breakpoints.set(`${file}:${line}`, {
      file,
      line,
      condition,
      logMessage,
      hitCount: 0
    });
    
    if (logMessage) {
      // ë¡œê·¸ ë¸Œë ˆì´í¬í¬ì¸íŠ¸
      await this.post('Runtime.addBinding', {
        name: 'logpoint',
        executionContextId: 1
      });
    }
  }
  
  // ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ì‹œì‘
  async startProfiling(profileName: string): Promise<void> {
    await this.post('Profiler.enable');
    await this.post('Profiler.start');
    
    this.profiles.set(profileName, {
      startTime: Date.now(),
      name: profileName
    });
  }
  
  // ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ì¤‘ì§€
  async stopProfiling(profileName: string): Promise<CPUProfile> {
    const result = await this.post('Profiler.stop');
    await this.post('Profiler.disable');
    
    const profile = this.profiles.get(profileName);
    if (profile) {
      profile.endTime = Date.now();
      profile.data = result.profile;
    }
    
    return this.analyzeCPUProfile(result.profile);
  }
  
  // ë©”ëª¨ë¦¬ ìŠ¤ëƒ…ìƒ·
  async takeHeapSnapshot(tag?: string): Promise<string> {
    await this.post('HeapProfiler.enable');
    
    const chunks: string[] = [];
    
    this.session.on('HeapProfiler.addHeapSnapshotChunk', (message) => {
      chunks.push(message.params.chunk);
    });
    
    await this.post('HeapProfiler.takeHeapSnapshot', {
      reportProgress: true,
      treatGlobalObjectsAsRoots: true
    });
    
    await this.post('HeapProfiler.disable');
    
    const snapshot = chunks.join('');
    const filename = `heapsnapshot-${tag || Date.now()}.json`;
    
    await fs.writeFile(filename, snapshot);
    
    return filename;
  }
  
  // ë¹„ë™ê¸° ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ í™œì„±í™”
  async enableAsyncStackTraces(): Promise<void> {
    await this.post('Debugger.enable');
    await this.post('Debugger.setAsyncCallStackDepth', { maxDepth: 32 });
  }
  
  // ëŸ°íƒ€ì„ í‰ê°€
  async evaluate(expression: string, contextId?: number): Promise<any> {
    const result = await this.post('Runtime.evaluate', {
      expression,
      generatePreview: true,
      includeCommandLineAPI: true,
      contextId
    });
    
    if (result.exceptionDetails) {
      throw new Error(result.exceptionDetails.text);
    }
    
    return result.result.value;
  }
  
  // CPU í”„ë¡œíŒŒì¼ ë¶„ì„
  private analyzeCPUProfile(profile: any): CPUProfile {
    const nodes = new Map<number, any>();
    let totalTime = 0;
    
    // ë…¸ë“œ ë§µ ìƒì„±
    profile.nodes.forEach((node: any) => {
      nodes.set(node.id, {
        ...node,
        selfTime: 0,
        totalTime: 0,
        children: []
      });
    });
    
    // ë¶€ëª¨-ìì‹ ê´€ê³„ ì„¤ì •
    profile.nodes.forEach((node: any) => {
      if (node.parent) {
        const parent = nodes.get(node.parent);
        if (parent) {
          parent.children.push(node.id);
        }
      }
    });
    
    // ì‹œê°„ ê³„ì‚°
    if (profile.samples && profile.timeDeltas) {
      let currentTime = profile.startTime;
      
      profile.samples.forEach((sample: number, index: number) => {
        const node = nodes.get(sample);
        if (node) {
          const delta = profile.timeDeltas[index];
          node.selfTime += delta;
          totalTime += delta;
          
          // ë¶€ëª¨ ë…¸ë“œë“¤ì˜ totalTime ì—…ë°ì´íŠ¸
          let current = node;
          while (current) {
            current.totalTime += delta;
            current = nodes.get(current.parent);
          }
        }
        
        currentTime += profile.timeDeltas[index];
      });
    }
    
    // í•«ìŠ¤íŒŸ ì°¾ê¸°
    const hotspots = Array.from(nodes.values())
      .filter(node => node.selfTime > 0)
      .sort((a, b) => b.selfTime - a.selfTime)
      .slice(0, 10)
      .map(node => ({
        functionName: node.callFrame.functionName || '(anonymous)',
        url: node.callFrame.url,
        lineNumber: node.callFrame.lineNumber,
        selfTime: node.selfTime,
        totalTime: node.totalTime,
        percentage: (node.selfTime / totalTime) * 100
      }));
    
    return {
      totalTime,
      hotspots,
      profile
    };
  }
  
  // Inspector ì„¸ì…˜ ëª…ë ¹ ì‹¤í–‰
  private post(method: string, params?: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.session.post(method, params, (err, result) => {
        if (err) reject(err);
        else resolve(result);
      });
    });
  }
  
  // ìŠ¤í¬ë¦½íŠ¸ ID ê°€ì ¸ì˜¤ê¸°
  private async getScriptId(filename: string): Promise<string> {
    const result = await this.post('Debugger.enable');
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ìŠ¤í¬ë¦½íŠ¸ ëª©ë¡ì—ì„œ íŒŒì¼ëª…ìœ¼ë¡œ ê²€ìƒ‰
    return '1'; // ì„ì‹œ
  }
}

// ì‹¤í–‰ ì¶”ì ê¸°
export class ExecutionTracer {
  private traces: Map<string, Trace[]> = new Map();
  
  // í•¨ìˆ˜ ì¶”ì  ë°ì½”ë ˆì´í„°
  trace(options: TraceOptions = {}) {
    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
      const originalMethod = descriptor.value;
      
      descriptor.value = async function(...args: any[]) {
        const traceId = traceContext.getStore()?.traceId || generateTraceId();
        const spanId = generateSpanId();
        const startTime = performance.now();
        
        const trace: Trace = {
          traceId,
          spanId,
          method: `${target.constructor.name}.${propertyKey}`,
          args: options.logArgs ? args : undefined,
          startTime,
          metadata: {}
        };
        
        // ì¶”ì  ì‹œì‘
        if (options.log) {
          console.log(chalk.blue(`â†’ ${trace.method}`), {
            traceId,
            spanId,
            args: options.logArgs ? args : '[hidden]'
          });
        }
        
        try {
          // ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
          const result = await traceContext.run(
            {
              traceId,
              spanId,
              parentSpanId: traceContext.getStore()?.spanId,
              startTime,
              metadata: {}
            },
            async () => await originalMethod.apply(this, args)
          );
          
          trace.endTime = performance.now();
          trace.duration = trace.endTime - trace.startTime;
          trace.result = options.logResult ? result : undefined;
          trace.success = true;
          
          // ì¶”ì  ì™„ë£Œ
          if (options.log) {
            console.log(
              chalk.green(`â† ${trace.method}`),
              chalk.gray(`(${trace.duration.toFixed(2)}ms)`),
              {
                traceId,
                spanId,
                result: options.logResult ? result : '[hidden]'
              }
            );
          }
          
          return result;
          
        } catch (error) {
          trace.endTime = performance.now();
          trace.duration = trace.endTime - trace.startTime;
          trace.error = error;
          trace.success = false;
          
          // ì—ëŸ¬ ì¶”ì 
          if (options.log) {
            console.log(
              chalk.red(`âœ— ${trace.method}`),
              chalk.gray(`(${trace.duration.toFixed(2)}ms)`),
              {
                traceId,
                spanId,
                error: error.message
              }
            );
          }
          
          throw error;
          
        } finally {
          // ì¶”ì  ì €ì¥
          this.saveTrace(trace);
        }
      };
      
      return descriptor;
    };
  }
  
  // ìˆ˜ë™ ì¶”ì 
  async traceExecution<T>(
    name: string,
    fn: () => Promise<T>,
    metadata?: Record<string, any>
  ): Promise<T> {
    const traceId = traceContext.getStore()?.traceId || generateTraceId();
    const spanId = generateSpanId();
    const startTime = performance.now();
    
    console.log(chalk.blue(`â†’ ${name}`), { traceId, spanId });
    
    try {
      const result = await traceContext.run(
        {
          traceId,
          spanId,
          parentSpanId: traceContext.getStore()?.spanId,
          startTime,
          metadata: metadata || {}
        },
        fn
      );
      
      const duration = performance.now() - startTime;
      console.log(
        chalk.green(`â† ${name}`),
        chalk.gray(`(${duration.toFixed(2)}ms)`)
      );
      
      return result;
      
    } catch (error) {
      const duration = performance.now() - startTime;
      console.log(
        chalk.red(`âœ— ${name}`),
        chalk.gray(`(${duration.toFixed(2)}ms)`),
        error
      );
      throw error;
    }
  }
  
  // ì¶”ì  ì €ì¥
  private saveTrace(trace: Trace): void {
    if (!this.traces.has(trace.traceId)) {
      this.traces.set(trace.traceId, []);
    }
    
    this.traces.get(trace.traceId)!.push(trace);
  }
  
  // ì¶”ì  ì¡°íšŒ
  getTrace(traceId: string): Trace[] | undefined {
    return this.traces.get(traceId);
  }
  
  // ì¶”ì  ì‹œê°í™”
  visualizeTrace(traceId: string): string {
    const traces = this.getTrace(traceId);
    if (!traces) return 'Trace not found';
    
    const sorted = traces.sort((a, b) => a.startTime - b.startTime);
    const lines: string[] = [''];
    
    sorted.forEach((trace, index) => {
      const indent = '  '.repeat(trace.metadata.depth || 0);
      const duration = trace.duration?.toFixed(2) || '?';
      const status = trace.success ? 'âœ“' : 'âœ—';
      
      lines.push(
        `${indent}${status} ${trace.method} (${duration}ms)`
      );
    });
    
    return lines.join('\n');
  }
}

// í–¥ìƒëœ ì½˜ì†” ë¡œê¹…
export class EnhancedConsole {
  private originalConsole = { ...console };
  
  install(): void {
    // console.log ì˜¤ë²„ë¼ì´ë“œ
    console.log = (...args: any[]) => {
      const enhanced = this.enhance(args);
      this.originalConsole.log(...enhanced);
    };
    
    // console.error ì˜¤ë²„ë¼ì´ë“œ
    console.error = (...args: any[]) => {
      const enhanced = this.enhance(args, 'error');
      this.originalConsole.error(...enhanced);
    };
    
    // console.table ê°œì„ 
    const originalTable = console.table;
    console.table = (data: any, columns?: string[]) => {
      if (typeof data === 'object' && data !== null) {
        // ë” ë‚˜ì€ í¬ë§·íŒ…
        this.originalConsole.log(chalk.cyan('â”Œâ”€ Table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”'));
        originalTable.call(console, data, columns);
        this.originalConsole.log(chalk.cyan('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜'));
      } else {
        originalTable.call(console, data, columns);
      }
    };
  }
  
  private enhance(args: any[], type: string = 'log'): any[] {
    const ctx = traceContext.getStore();
    const timestamp = new Date().toISOString();
    
    // ì»¬ëŸ¬ ë° í¬ë§·íŒ…
    const prefix = type === 'error' 
      ? chalk.red(`[${timestamp}]`)
      : chalk.gray(`[${timestamp}]`);
    
    // íŠ¸ë ˆì´ìŠ¤ ì •ë³´ ì¶”ê°€
    const traceInfo = ctx 
      ? chalk.dim(`[${ctx.traceId.slice(0, 8)}/${ctx.spanId.slice(0, 8)}]`)
      : '';
    
    // ê°ì²´ ê¹Šì€ ê²€ì‚¬
    const enhanced = args.map(arg => {
      if (typeof arg === 'object' && arg !== null) {
        return util.inspect(arg, {
          colors: true,
          depth: 4,
          maxArrayLength: 100,
          breakLength: 80,
          compact: false
        });
      }
      return arg;
    });
    
    return [prefix, traceInfo, ...enhanced];
  }
}

// ë””ë²„ê·¸ í”„ë¡ì‹œ
export function createDebugProxy<T extends object>(
  target: T,
  name: string = 'Object'
): T {
  return new Proxy(target, {
    get(obj, prop, receiver) {
      const value = Reflect.get(obj, prop, receiver);
      console.log(chalk.yellow(`[Proxy:${name}] GET`), prop, 'â†’', value);
      return value;
    },
    
    set(obj, prop, value, receiver) {
      console.log(chalk.yellow(`[Proxy:${name}] SET`), prop, 'â†', value);
      return Reflect.set(obj, prop, value, receiver);
    },
    
    deleteProperty(obj, prop) {
      console.log(chalk.yellow(`[Proxy:${name}] DELETE`), prop);
      return Reflect.deleteProperty(obj, prop);
    },
    
    has(obj, prop) {
      const exists = Reflect.has(obj, prop);
      console.log(chalk.yellow(`[Proxy:${name}] HAS`), prop, 'â†’', exists);
      return exists;
    }
  });
}

// íƒ€ì… ì •ì˜
interface Breakpoint {
  file: string;
  line: number;
  condition?: string;
  logMessage?: string;
  hitCount: number;
}

interface CPUProfile {
  totalTime: number;
  hotspots: Array<{
    functionName: string;
    url: string;
    lineNumber: number;
    selfTime: number;
    totalTime: number;
    percentage: number;
  }>;
  profile: any;
}

interface TraceOptions {
  log?: boolean;
  logArgs?: boolean;
  logResult?: boolean;
}

interface Trace {
  traceId: string;
  spanId: string;
  method: string;
  args?: any[];
  result?: any;
  error?: any;
  startTime: number;
  endTime?: number;
  duration?: number;
  success?: boolean;
  metadata: Record<string, any>;
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
function generateTraceId(): string {
  return crypto.randomBytes(16).toString('hex');
}

function generateSpanId(): string {
  return crypto.randomBytes(8).toString('hex');
}

// ë””ë²„ê¹… ë¯¸ë“¤ì›¨ì–´
export function debuggingMiddleware() {
  return (req: Request, res: Response, next: NextFunction) => {
    const traceId = req.headers['x-trace-id'] as string || generateTraceId();
    const spanId = generateSpanId();
    
    // ìš”ì²­ ë¡œê¹…
    console.log(chalk.blue('â†’ HTTP Request'), {
      method: req.method,
      path: req.path,
      traceId,
      spanId,
      headers: req.headers,
      body: req.body
    });
    
    // íŠ¸ë ˆì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
    traceContext.run(
      {
        traceId,
        spanId,
        startTime: Date.now(),
        metadata: {
          method: req.method,
          path: req.path
        }
      },
      () => {
        // ì‘ë‹µ ë¡œê¹…
        const originalSend = res.send;
        res.send = function(data: any) {
          console.log(chalk.green('â† HTTP Response'), {
            traceId,
            spanId,
            statusCode: res.statusCode,
            body: data
          });
          
          return originalSend.call(this, data);
        };
        
        next();
      }
    );
  };
}
```

### SubTask 0.12.5: ê°œë°œ í™˜ê²½ í”„ë¦¬ì…‹ ê´€ë¦¬
**ëª©í‘œ**: ë‹¤ì–‘í•œ ê°œë°œ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ìœ„í•œ í™˜ê²½ í”„ë¦¬ì…‹

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// backend/src/dev/environment-presets.ts
import { promises as fs } from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import dotenv from 'dotenv';

// í™˜ê²½ í”„ë¦¬ì…‹ ë§¤ë‹ˆì €
export class EnvironmentPresetManager {
  private presets: Map<string, EnvironmentPreset> = new Map();
  private currentPreset?: string;
  
  constructor(private presetsDir: string = './config/presets') {}
  
  // í”„ë¦¬ì…‹ ë¡œë“œ
  async loadPresets(): Promise<void> {
    const files = await fs.readdir(this.presetsDir);
    
    for (const file of files) {
      if (file.endsWith('.yaml') || file.endsWith('.yml')) {
        const content = await fs.readFile(
          path.join(this.presetsDir, file),
          'utf-8'
        );
        
        const preset = yaml.load(content) as EnvironmentPreset;
        const name = path.basename(file, path.extname(file));
        
        this.presets.set(name, preset);
        console.log(`ğŸ“¦ Loaded preset: ${name}`);
      }
    }
  }
  
  // í”„ë¦¬ì…‹ í™œì„±í™”
  async activatePreset(name: string): Promise<void> {
    const preset = this.presets.get(name);
    if (!preset) {
      throw new Error(`Preset '${name}' not found`);
    }
    
    console.log(`ğŸš€ Activating preset: ${name}`);
    
    // í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
    await this.applyEnvironmentVariables(preset.env);
    
    // ì„œë¹„ìŠ¤ ì‹œì‘
    await this.startServices(preset.services);
    
    // Mock ì„¤ì •
    await this.configureMocks(preset.mocks);
    
    // ì´ˆê¸° ë°ì´í„° ì„¤ì •
    await this.loadInitialData(preset.data);
    
    // ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
    await this.runScripts(preset.scripts?.setup);
    
    this.currentPreset = name;
    console.log(`âœ… Preset '${name}' activated`);
  }
  
  // í”„ë¦¬ì…‹ ë¹„í™œì„±í™”
  async deactivatePreset(): Promise<void> {
    if (!this.currentPreset) return;
    
    const preset = this.presets.get(this.currentPreset);
    if (!preset) return;
    
    console.log(`ğŸ›‘ Deactivating preset: ${this.currentPreset}`);
    
    // ì •ë¦¬ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
    await this.runScripts(preset.scripts?.teardown);
    
    // ì„œë¹„ìŠ¤ ì¤‘ì§€
    await this.stopServices(preset.services);
    
    this.currentPreset = undefined;
  }
  
  // í™˜ê²½ ë³€ìˆ˜ ì ìš©
  private async applyEnvironmentVariables(
    env?: Record<string, string | number | boolean>
  ): Promise<void> {
    if (!env) return;
    
    // í˜„ì¬ í™˜ê²½ ë³€ìˆ˜ ë°±ì—…
    const backup = { ...process.env };
    
    // ìƒˆ í™˜ê²½ ë³€ìˆ˜ ì ìš©
    Object.entries(env).forEach(([key, value]) => {
      process.env[key] = String(value);
    });
    
    // .env íŒŒì¼ ì—…ë°ì´íŠ¸
    const envPath = path.join(process.cwd(), '.env.preset');
    const envContent = Object.entries(env)
      .map(([key, value]) => `${key}=${value}`)
      .join('\n');
    
    await fs.writeFile(envPath, envContent);
    dotenv.config({ path: envPath, override: true });
  }
  
  // ì„œë¹„ìŠ¤ ì‹œì‘
  private async startServices(services?: ServiceConfig[]): Promise<void> {
    if (!services) return;
    
    for (const service of services) {
      console.log(`ğŸ”§ Starting service: ${service.name}`);
      
      switch (service.type) {
        case 'docker':
          await this.startDockerService(service);
          break;
        case 'process':
          await this.startProcessService(service);
          break;
        case 'mock':
          await this.startMockService(service);
          break;
      }
    }
  }
  
  // Docker ì„œë¹„ìŠ¤ ì‹œì‘
  private async startDockerService(service: ServiceConfig): Promise<void> {
    const { spawn } = require('child_process');
    
    const args = ['run', '--rm', '-d'];
    
    // í¬íŠ¸ ë§¤í•‘
    if (service.ports) {
      service.ports.forEach(port => {
        args.push('-p', port);
      });
    }
    
    // í™˜ê²½ ë³€ìˆ˜
    if (service.env) {
      Object.entries(service.env).forEach(([key, value]) => {
        args.push('-e', `${key}=${value}`);
      });
    }
    
    // ì»¨í…Œì´ë„ˆ ì´ë¦„
    args.push('--name', `t-dev-${service.name}`);
    
    // ì´ë¯¸ì§€
    args.push(service.image!);
    
    const docker = spawn('docker', args);
    
    docker.on('error', (error) => {
      console.error(`Failed to start ${service.name}:`, error);
    });
  }
  
  // í”„ë¡œì„¸ìŠ¤ ì„œë¹„ìŠ¤ ì‹œì‘
  private async startProcessService(service: ServiceConfig): Promise<void> {
    const { spawn } = require('child_process');
    
    const [command, ...args] = service.command!.split(' ');
    
    const process = spawn(command, args, {
      env: { ...process.env, ...service.env },
      cwd: service.cwd,
      detached: true
    });
    
    process.unref();
  }
  
  // Mock ì„œë¹„ìŠ¤ ì‹œì‘
  private async startMockService(service: ServiceConfig): Promise<void> {
    const { MockServiceManager } = await import('./mock-system');
    const mockManager = new MockServiceManager();
    
    if (service.name === 'all') {
      await mockManager.startAll();
    } else {
      // íŠ¹ì • ì„œë¹„ìŠ¤ë§Œ ì‹œì‘
      await mockManager[`start${service.name}Mock`]();
    }
  }
  
  // ì„œë¹„ìŠ¤ ì¤‘ì§€
  private async stopServices(services?: ServiceConfig[]): Promise<void> {
    if (!services) return;
    
    for (const service of services) {
      console.log(`ğŸ›‘ Stopping service: ${service.name}`);
      
      if (service.type === 'docker') {
        const { exec } = require('child_process');
        exec(`docker stop t-dev-${service.name}`);
      }
    }
  }
  
  // Mock ì„¤ì •
  private async configureMocks(mocks?: MockConfig): Promise<void> {
    if (!mocks) return;
    
    // Mock ì‘ë‹µ ì„¤ì •
    if (mocks.responses) {
      // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Mock ì‹œìŠ¤í…œì— ì‘ë‹µ ì„¤ì •
    }
    
    // ì§€ì—° ì„¤ì •
    if (mocks.latency) {
      process.env.MOCK_LATENCY_MIN = String(mocks.latency.min);
      process.env.MOCK_LATENCY_MAX = String(mocks.latency.max);
    }
    
    // ì—ëŸ¬ ì‹œë®¬ë ˆì´ì…˜
    if (mocks.errors) {
      process.env.MOCK_ERROR_RATE = String(mocks.errors.rate);
    }
  }
  
  // ì´ˆê¸° ë°ì´í„° ë¡œë“œ
  private async loadInitialData(data?: DataConfig): Promise<void> {
    if (!data) return;
    
    console.log('ğŸ“Š Loading initial data...');
    
    // íŒŒì¼ì—ì„œ ë¡œë“œ
    if (data.files) {
      for (const file of data.files) {
        const content = await fs.readFile(file, 'utf-8');
        const items = JSON.parse(content);
        
        // ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…
        await this.insertData(data.target, items);
      }
    }
    
    // ìƒì„±ê¸°ë¡œ ìƒì„±
    if (data.generators) {
      for (const generator of data.generators) {
        const { generateTestData } = await import('./test-data-generator');
        const items = await generateTestData(generator.type, generator.count);
        
        await this.insertData(data.target, items);
      }
    }
  }
  
  // ë°ì´í„° ì‚½ì…
  private async insertData(target: string, items: any[]): Promise<void> {
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” DynamoDB ë˜ëŠ” ë‹¤ë¥¸ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…
    console.log(`ğŸ’¾ Inserted ${items.length} items into ${target}`);
  }
  
  // ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
  private async runScripts(scripts?: string[]): Promise<void> {
    if (!scripts) return;
    
    for (const script of scripts) {
      console.log(`ğŸ“œ Running script: ${script}`);
      
      const { exec } = require('child_process');
      const { promisify } = require('util');
      const execAsync = promisify(exec);
      
      try {
        const { stdout, stderr } = await execAsync(script);
        if (stdout) console.log(stdout);
        if (stderr) console.error(stderr);
      } catch (error) {
        console.error(`Script failed: ${script}`, error);
      }
    }
  }
  
  // í”„ë¦¬ì…‹ ëª©ë¡
  listPresets(): PresetInfo[] {
    return Array.from(this.presets.entries()).map(([name, preset]) => ({
      name,
      description: preset.description,
      active: name === this.currentPreset
    }));
  }
  
  // í”„ë¦¬ì…‹ ìƒì„±
  async createPreset(name: string, config: EnvironmentPreset): Promise<void> {
    const filePath = path.join(this.presetsDir, `${name}.yaml`);
    const content = yaml.dump(config);
    
    await fs.writeFile(filePath, content);
    this.presets.set(name, config);
    
    console.log(`âœ… Created preset: ${name}`);
  }
}

// í”„ë¦¬ì…‹ íƒ€ì… ì •ì˜
interface EnvironmentPreset {
  name: string;
  description: string;
  env?: Record<string, string | number | boolean>;
  services?: ServiceConfig[];
  mocks?: MockConfig;
  data?: DataConfig;
  scripts?: {
    setup?: string[];
    teardown?: string[];
  };
}

interface ServiceConfig {
  name: string;
  type: 'docker' | 'process' | 'mock';
  image?: string;
  command?: string;
  ports?: string[];
  env?: Record<string, string>;
  cwd?: string;
}

interface MockConfig {
  enabled: boolean;
  services?: string[];
  responses?: Record<string, any>;
  latency?: {
    min: number;
    max: number;
  };
  errors?: {
    rate: number;
    types?: string[];
  };
}

interface DataConfig {
  target: string;
  files?: string[];
  generators?: Array<{
    type: string;
    count: number;
    options?: any;
  }>;
}

interface PresetInfo {
  name: string;
  description: string;
  active: boolean;
}

// í”„ë¦¬ì…‹ ì˜ˆì‹œ
const examplePresets = {
  'minimal': {
    name: 'minimal',
    description: 'Minimal setup for quick development',
    env: {
      NODE_ENV: 'development',
      USE_MOCKS: false,
      LOG_LEVEL: 'debug'
    },
    services: [
      {
        name: 'dynamodb',
        type: 'docker',
        image: 'amazon/dynamodb-local',
        ports: ['8000:8000']
      }
    ]
  },
  
  'full-mocks': {
    name: 'full-mocks',
    description: 'All services mocked for offline development',
    env: {
      NODE_ENV: 'development',
      USE_MOCKS: true,
      MOCK_LATENCY: true
    },
    mocks: {
      enabled: true,
      services: ['bedrock', 'dynamodb', 's3', 'external'],
      latency: {
        min: 100,
        max: 500
      }
    },
    data: {
      target: 'dynamodb',
      generators: [
        { type: 'projects', count: 50 },
        { type: 'components', count: 200 }
      ]
    }
  },
  
  'integration-test': {
    name: 'integration-test',
    description: 'Environment for integration testing',
    env: {
      NODE_ENV: 'test',
      USE_MOCKS: true,
      LOG_LEVEL: 'error'
    },
    services: [
      {
        name: 'dynamodb',
        type: 'docker',
        image: 'amazon/dynamodb-local',
        ports: ['8000:8000']
      },
      {
        name: 'redis',
        type: 'docker',
        image: 'redis:7-alpine',
        ports: ['6379:6379']
      }
    ],
    scripts: {
      setup: [
        'npm run db:migrate:test',
        'npm run seed:test'
      ],
      teardown: [
        'npm run db:clean:test'
      ]
    }
  },
  
  'performance-test': {
    name: 'performance-test',
    description: 'Environment for performance testing',
    env: {
      NODE_ENV: 'production',
      USE_MOCKS: false,
      ENABLE_PROFILING: true,
      LOG_LEVEL: 'warn'
    },
    services: [
      {
        name: 'dynamodb',
        type: 'docker',
        image: 'amazon/dynamodb-local',
        ports: ['8000:8000'],
        env: {
          JAVA_OPTS: '-Xmx2048m'
        }
      }
    ],
    data: {
      target: 'dynamodb',
      generators: [
        { type: 'projects', count: 1000 },
        { type: 'components', count: 5000 }
      ]
    },
    scripts: {
      setup: [
        'npm run build',
        'npm run optimize'
      ]
    }
  }
};

// CLI ëª…ë ¹ì–´
export function setupPresetCLI(program: any): void {
  const presetCmd = program
    .command('preset')
    .description('Manage development environment presets');
  
  presetCmd
    .command('list')
    .description('List available presets')
    .action(async () => {
      const manager = new EnvironmentPresetManager();
      await manager.loadPresets();
      
      const presets = manager.listPresets();
      console.table(presets);
    });
  
  presetCmd
    .command('activate <name>')
    .description('Activate a preset')
    .action(async (name: string) => {
      const manager = new EnvironmentPresetManager();
      await manager.loadPresets();
      await manager.activatePreset(name);
    });
  
  presetCmd
    .command('deactivate')
    .description('Deactivate current preset')
    .action(async () => {
      const manager = new EnvironmentPresetManager();
      await manager.deactivatePreset();
    });
  
  presetCmd
    .command('create <name>')
    .description('Create a new preset')
    .action(async (name: string) => {
      // ëŒ€í™”í˜• í”„ë¦¬ì…‹ ìƒì„±
      const inquirer = require('inquirer');
      
      const answers = await inquirer.prompt([
        {
          type: 'input',
          name: 'description',
          message: 'Preset description:'
        },
        {
          type: 'checkbox',
          name: 'services',
          message: 'Select services:',
          choices: ['dynamodb', 'redis', 'elasticsearch', 'mocks']
        },
        {
          type: 'confirm',
          name: 'useMocks',
          message: 'Enable mocking?'
        }
      ]);
      
      const preset: EnvironmentPreset = {
        name,
        description: answers.description,
        env: {
          NODE_ENV: 'development',
          USE_MOCKS: answers.useMocks
        },
        services: answers.services.map((s: string) => ({
          name: s,
          type: s === 'mocks' ? 'mock' : 'docker',
          image: s === 'dynamodb' ? 'amazon/dynamodb-local' :
                 s === 'redis' ? 'redis:7-alpine' :
                 s === 'elasticsearch' ? 'elasticsearch:8.11.0' : undefined
        }))
      };
      
      const manager = new EnvironmentPresetManager();
      await manager.createPreset(name, preset);
    });
}
```

**ğŸ”§ ì‚¬ìš©ì ì‘ì—…**:
- í”„ë¦¬ì…‹ ë””ë ‰í† ë¦¬ ìƒì„±: `mkdir -p config/presets`
- ê¸°ë³¸ í”„ë¦¬ì…‹ YAML íŒŒì¼ ìƒì„±
- ê°œë°œ ì‹œë‚˜ë¦¬ì˜¤ë³„ í”„ë¦¬ì…‹ êµ¬ì„±
- `npm run dev:preset minimal` ê°™ì€ ìŠ¤í¬ë¦½íŠ¸ ì¶”ê°€

---

## Task 0.13: ì—ì´ì „íŠ¸ ê°œë°œ í™˜ê²½ ì„¤ì •

### SubTask 0.13.1: ì—ì´ì „íŠ¸ í”„ë ˆì„ì›Œí¬ ê¸°ì´ˆ ì„¤ì •
**ëª©í‘œ**: 9ê°œ í•µì‹¬ ì—ì´ì „íŠ¸ ê°œë°œì„ ìœ„í•œ ê¸°ë³¸ í”„ë ˆì„ì›Œí¬ êµ¬ì„±

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// backend/src/agents/framework/base-agent.ts
import { EventEmitter } from 'events';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from 'winston';
import { metrics } from '../../utils/monitoring';

export interface AgentContext {
  projectId: string;
  userId: string;
  sessionId: string;
  parentAgent?: string;
  metadata: Record<string, any>;
}

export interface AgentMessage {
  id: string;
  type: 'request' | 'response' | 'event' | 'error';
  source: string;
  target: string;
  payload: any;
  timestamp: Date;
  correlationId?: string;
}

export interface AgentCapability {
  name: string;
  description: string;
  inputSchema: any;
  outputSchema: any;
  version: string;
}

export abstract class BaseAgent extends EventEmitter {
  protected readonly id: string;
  protected readonly name: string;
  protected readonly version: string;
  protected readonly logger: Logger;
  protected context?: AgentContext;
  protected capabilities: Map<string, AgentCapability> = new Map();
  protected status: 'idle' | 'busy' | 'error' = 'idle';
  protected metrics: any;
  
  constructor(
    name: string,
    version: string,
    logger: Logger
  ) {
    super();
    this.id = `${name}-${uuidv4()}`;
    this.name = name;
    this.version = version;
    this.logger = logger;
    this.metrics = metrics;
    
    this.initialize();
  }
  
  protected abstract initialize(): void;
  protected abstract process(message: AgentMessage): Promise<any>;
  
  // ì—ì´ì „íŠ¸ ìƒëª…ì£¼ê¸° ë©”ì„œë“œ
  async start(context: AgentContext): Promise<void> {
    this.context = context;
    this.status = 'idle';
    
    this.logger.info(`Agent ${this.name} started`, {
      agentId: this.id,
      context
    });
    
    this.metrics.increment('agent.started', 1, [`agent:${this.name}`]);
    this.emit('started', { agentId: this.id, context });
    
    await this.onStart();
  }
  
  async stop(): Promise<void> {
    this.status = 'idle';
    
    this.logger.info(`Agent ${this.name} stopped`, {
      agentId: this.id
    });
    
    this.metrics.increment('agent.stopped', 1, [`agent:${this.name}`]);
    this.emit('stopped', { agentId: this.id });
    
    await this.onStop();
  }
  
  // ë©”ì‹œì§€ ì²˜ë¦¬
  async handleMessage(message: AgentMessage): Promise<AgentMessage> {
    const startTime = Date.now();
    this.status = 'busy';
    
    try {
      this.logger.debug(`Agent ${this.name} processing message`, {
        agentId: this.id,
        messageId: message.id,
        type: message.type
      });
      
      const result = await this.process(message);
      
      const response: AgentMessage = {
        id: uuidv4(),
        type: 'response',
        source: this.id,
        target: message.source,
        payload: result,
        timestamp: new Date(),
        correlationId: message.id
      };
      
      this.metrics.timing('agent.processing_time', Date.now() - startTime, [
        `agent:${this.name}`,
        `message_type:${message.type}`
      ]);
      
      this.status = 'idle';
      return response;
      
    } catch (error) {
      this.status = 'error';
      this.logger.error(`Agent ${this.name} error`, {
        agentId: this.id,
        messageId: message.id,
        error
      });
      
      this.metrics.increment('agent.errors', 1, [`agent:${this.name}`]);
      
      return {
        id: uuidv4(),
        type: 'error',
        source: this.id,
        target: message.source,
        payload: { error: error.message },
        timestamp: new Date(),
        correlationId: message.id
      };
    }
  }
  
  // ëŠ¥ë ¥(Capability) ê´€ë¦¬
  registerCapability(capability: AgentCapability): void {
    this.capabilities.set(capability.name, capability);
    this.logger.info(`Capability registered: ${capability.name}`, {
      agentId: this.id,
      capability
    });
  }
  
  getCapabilities(): AgentCapability[] {
    return Array.from(this.capabilities.values());
  }
  
  // ìƒíƒœ ê´€ë¦¬
  getStatus(): string {
    return this.status;
  }
  
  getMetrics(): any {
    return {
      agentId: this.id,
      name: this.name,
      status: this.status,
      capabilities: this.getCapabilities().length
    };
  }
  
  // Hook ë©”ì„œë“œë“¤ (í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„)
  protected async onStart(): Promise<void> {}
  protected async onStop(): Promise<void> {}
}
```

### SubTask 0.13.2: ì—ì´ì „íŠ¸ í†µì‹  í”„ë¡œí† ì½œ ì„¤ì •
**ëª©í‘œ**: ì—ì´ì „íŠ¸ ê°„ íš¨ìœ¨ì ì¸ í†µì‹ ì„ ìœ„í•œ í”„ë¡œí† ì½œ ì •ì˜

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// backend/src/agents/framework/communication.ts
import { EventEmitter } from 'events';
import Redis from 'ioredis';
import { AgentMessage } from './base-agent';

export interface MessageBus {
  publish(channel: string, message: AgentMessage): Promise<void>;
  subscribe(channel: string, handler: (message: AgentMessage) => void): void;
  unsubscribe(channel: string): void;
}

// Redis ê¸°ë°˜ ë©”ì‹œì§€ ë²„ìŠ¤
export class RedisMessageBus implements MessageBus {
  private publisher: Redis;
  private subscriber: Redis;
  private handlers: Map<string, Set<(message: AgentMessage) => void>> = new Map();
  
  constructor(redisUrl: string) {
    this.publisher = new Redis(redisUrl);
    this.subscriber = new Redis(redisUrl);
    
    this.subscriber.on('message', (channel, data) => {
      const message = JSON.parse(data) as AgentMessage;
      const channelHandlers = this.handlers.get(channel);
      
      if (channelHandlers) {
        channelHandlers.forEach(handler => handler(message));
      }
    });
  }
  
  async publish(channel: string, message: AgentMessage): Promise<void> {
    await this.publisher.publish(channel, JSON.stringify(message));
  }
  
  subscribe(channel: string, handler: (message: AgentMessage) => void): void {
    if (!this.handlers.has(channel)) {
      this.handlers.set(channel, new Set());
      this.subscriber.subscribe(channel);
    }
    
    this.handlers.get(channel)!.add(handler);
  }
  
  unsubscribe(channel: string): void {
    this.handlers.delete(channel);
    this.subscriber.unsubscribe(channel);
  }
}

// ì—ì´ì „íŠ¸ í†µì‹  ë§¤ë‹ˆì €
export class AgentCommunicationManager {
  private messageBus: MessageBus;
  private agents: Map<string, any> = new Map();
  private routingTable: Map<string, string[]> = new Map();
  
  constructor(messageBus: MessageBus) {
    this.messageBus = messageBus;
  }
  
  // ì—ì´ì „íŠ¸ ë“±ë¡
  registerAgent(agentId: string, agent: any, channels: string[]): void {
    this.agents.set(agentId, agent);
    
    channels.forEach(channel => {
      if (!this.routingTable.has(channel)) {
        this.routingTable.set(channel, []);
      }
      this.routingTable.get(channel)!.push(agentId);
      
      // ì±„ë„ êµ¬ë…
      this.messageBus.subscribe(channel, async (message) => {
        if (message.target === agentId || message.target === 'broadcast') {
          const response = await agent.handleMessage(message);
          
          if (response && response.type === 'response') {
            await this.sendMessage(response);
          }
        }
      });
    });
  }
  
  // ë©”ì‹œì§€ ì „ì†¡
  async sendMessage(message: AgentMessage): Promise<void> {
    // Direct ë©”ì‹œì§•
    if (message.target && message.target !== 'broadcast') {
      await this.messageBus.publish(`agent:${message.target}`, message);
      return;
    }
    
    // Broadcast ë©”ì‹œì§•
    if (message.target === 'broadcast') {
      await this.messageBus.publish('agent:broadcast', message);
    }
  }
  
  // ë¼ìš°íŒ… ì •ë³´ ì¡°íšŒ
  getRoutingInfo(): Map<string, string[]> {
    return new Map(this.routingTable);
  }
  
  // ì—ì´ì „íŠ¸ ìƒíƒœ ì¡°íšŒ
  getAgentStatus(agentId: string): any {
    const agent = this.agents.get(agentId);
    return agent ? agent.getStatus() : null;
  }
}

// ì—ì´ì „íŠ¸ ê°„ RPC ì§€ì›
export class AgentRPC {
  private communicationManager: AgentCommunicationManager;
  private pendingCalls: Map<string, {
    resolve: (value: any) => void;
    reject: (error: any) => void;
    timeout: NodeJS.Timeout;
  }> = new Map();
  
  constructor(communicationManager: AgentCommunicationManager) {
    this.communicationManager = communicationManager;
  }
  
  // RPC í˜¸ì¶œ
  async call(
    targetAgent: string,
    method: string,
    params: any,
    timeout: number = 30000
  ): Promise<any> {
    const callId = `rpc-${Date.now()}-${Math.random()}`;
    
    const message: AgentMessage = {
      id: callId,
      type: 'request',
      source: 'rpc-client',
      target: targetAgent,
      payload: {
        method,
        params
      },
      timestamp: new Date()
    };
    
    return new Promise((resolve, reject) => {
      // íƒ€ì„ì•„ì›ƒ ì„¤ì •
      const timeoutHandle = setTimeout(() => {
        this.pendingCalls.delete(callId);
        reject(new Error(`RPC call timeout: ${method}`));
      }, timeout);
      
      // ëŒ€ê¸° ì¤‘ì¸ í˜¸ì¶œ ë“±ë¡
      this.pendingCalls.set(callId, {
        resolve,
        reject,
        timeout: timeoutHandle
      });
      
      // ë©”ì‹œì§€ ì „ì†¡
      this.communicationManager.sendMessage(message);
    });
  }
  
  // RPC ì‘ë‹µ ì²˜ë¦¬
  handleResponse(message: AgentMessage): void {
    if (message.correlationId && this.pendingCalls.has(message.correlationId)) {
      const call = this.pendingCalls.get(message.correlationId)!;
      clearTimeout(call.timeout);
      
      if (message.type === 'response') {
        call.resolve(message.payload);
      } else if (message.type === 'error') {
        call.reject(new Error(message.payload.error));
      }
      
      this.pendingCalls.delete(message.correlationId);
    }
  }
}
```

### SubTask 0.13.3: AWS Bedrock AgentCore í†µí•© ì¤€ë¹„
**ëª©í‘œ**: Bedrock AgentCoreì™€ì˜ í†µí•©ì„ ìœ„í•œ ê¸°ì´ˆ ì„¤ì •

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// backend/src/integrations/bedrock/agentcore-config.ts
import { 
  BedrockAgentRuntimeClient,
  InvokeAgentCommand,
  RetrieveCommand
} from '@aws-sdk/client-bedrock-agent-runtime';
import { Logger } from 'winston';

export interface AgentCoreConfig {
  agentId: string;
  agentAliasId: string;
  region: string;
  knowledgeBaseId?: string;
  instructionTemplate?: string;
}

export class BedrockAgentCoreManager {
  private client: BedrockAgentRuntimeClient;
  private logger: Logger;
  private config: AgentCoreConfig;
  
  constructor(
    config: AgentCoreConfig,
    logger: Logger
  ) {
    this.config = config;
    this.logger = logger;
    
    this.client = new BedrockAgentRuntimeClient({
      region: config.region
    });
  }
  
  // ì—ì´ì „íŠ¸ í˜¸ì¶œ
  async invokeAgent(
    sessionId: string,
    inputText: string,
    sessionAttributes?: Record<string, string>
  ): Promise<any> {
    try {
      const command = new InvokeAgentCommand({
        agentId: this.config.agentId,
        agentAliasId: this.config.agentAliasId,
        sessionId,
        inputText,
        sessionState: {
          sessionAttributes
        }
      });
      
      const response = await this.client.send(command);
      
      // ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ì²˜ë¦¬
      const chunks: any[] = [];
      
      if (response.completion) {
        for await (const chunk of response.completion) {
          chunks.push(chunk);
          
          // ì²­í¬ íƒ€ì…ë³„ ì²˜ë¦¬
          if (chunk.chunk) {
            this.handleChunk(chunk.chunk);
          }
        }
      }
      
      return {
        sessionId,
        response: chunks,
        metadata: {
          agentId: this.config.agentId,
          timestamp: new Date()
        }
      };
      
    } catch (error) {
      this.logger.error('Bedrock AgentCore invocation failed', {
        error,
        sessionId,
        inputText
      });
      throw error;
    }
  }
  
  // Knowledge Base ê²€ìƒ‰
  async retrieveFromKnowledgeBase(
    query: string,
    numberOfResults: number = 5
  ): Promise<any> {
    if (!this.config.knowledgeBaseId) {
      throw new Error('Knowledge base ID not configured');
    }
    
    try {
      const command = new RetrieveCommand({
        knowledgeBaseId: this.config.knowledgeBaseId,
        retrievalQuery: {
          text: query
        },
        retrievalConfiguration: {
          vectorSearchConfiguration: {
            numberOfResults
          }
        }
      });
      
      const response = await this.client.send(command);
      
      return {
        results: response.retrievalResults || [],
        metadata: {
          knowledgeBaseId: this.config.knowledgeBaseId,
          query,
          timestamp: new Date()
        }
      };
      
    } catch (error) {
      this.logger.error('Knowledge base retrieval failed', {
        error,
        query,
        knowledgeBaseId: this.config.knowledgeBaseId
      });
      throw error;
    }
  }
  
  // ì²­í¬ ì²˜ë¦¬
  private handleChunk(chunk: any): void {
    if (chunk.bytes) {
      // ë°”ì´ë„ˆë¦¬ ë°ì´í„° ì²˜ë¦¬
      const text = Buffer.from(chunk.bytes).toString('utf-8');
      this.logger.debug('Received text chunk', { text });
    }
    
    if (chunk.attribution) {
      // ì†ì„± ì •ë³´ ì²˜ë¦¬
      this.logger.debug('Received attribution', {
        attribution: chunk.attribution
      });
    }
  }
  
  // ì„¸ì…˜ ê´€ë¦¬
  async createSession(userId: string, metadata?: any): Promise<string> {
    const sessionId = `${userId}-${Date.now()}`;
    
    this.logger.info('Created Bedrock session', {
      sessionId,
      userId,
      metadata
    });
    
    return sessionId;
  }
}

// Bedrock ì—ì´ì „íŠ¸ ë˜í¼
export abstract class BedrockAgent extends BaseAgent {
  protected bedrockManager: BedrockAgentCoreManager;
  
  constructor(
    name: string,
    version: string,
    logger: Logger,
    bedrockConfig: AgentCoreConfig
  ) {
    super(name, version, logger);
    
    this.bedrockManager = new BedrockAgentCoreManager(
      bedrockConfig,
      logger
    );
  }
  
  // Bedrock ê¸°ëŠ¥ì„ í™œìš©í•œ ì²˜ë¦¬
  protected async processWithBedrock(
    input: string,
    sessionId?: string
  ): Promise<any> {
    const session = sessionId || await this.bedrockManager.createSession(
      this.context?.userId || 'anonymous'
    );
    
    return this.bedrockManager.invokeAgent(session, input);
  }
  
  // Knowledge Base í™œìš©
  protected async searchKnowledgeBase(query: string): Promise<any> {
    return this.bedrockManager.retrieveFromKnowledgeBase(query);
  }
}
```

### SubTask 0.13.4: Agent Squad í†µí•© ì¤€ë¹„
**ëª©í‘œ**: AWS Agent Squadì™€ì˜ í†µí•©ì„ ìœ„í•œ ê¸°ì´ˆ ì„¤ì •

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// backend/src/integrations/agent-squad/squad-config.ts
import { EventEmitter } from 'events';
import { Logger } from 'winston';

export interface SquadConfig {
  supervisorConfig: {
    name: string;
    role: 'orchestrator' | 'coordinator' | 'monitor';
    capabilities: string[];
  };
  workers: Array<{
    name: string;
    type: string;
    count: number;
    capabilities: string[];
  }>;
  communication: {
    protocol: 'redis' | 'sqs' | 'eventbridge';
    endpoint: string;
  };
}

// Supervisor Agent êµ¬í˜„
export class SupervisorAgent extends EventEmitter {
  private config: SquadConfig['supervisorConfig'];
  private logger: Logger;
  private workers: Map<string, WorkerAgent[]> = new Map();
  private taskQueue: TaskQueue;
  
  constructor(
    config: SquadConfig['supervisorConfig'],
    logger: Logger
  ) {
    super();
    this.config = config;
    this.logger = logger;
    this.taskQueue = new TaskQueue();
    
    this.initialize();
  }
  
  private initialize(): void {
    this.logger.info('Supervisor Agent initialized', {
      name: this.config.name,
      role: this.config.role,
      capabilities: this.config.capabilities
    });
  }
  
  // Worker ê´€ë¦¬
  async addWorker(worker: WorkerAgent): Promise<void> {
    const type = worker.getType();
    
    if (!this.workers.has(type)) {
      this.workers.set(type, []);
    }
    
    this.workers.get(type)!.push(worker);
    
    this.logger.info('Worker added to squad', {
      supervisorName: this.config.name,
      workerType: type,
      workerId: worker.getId()
    });
    
    // Worker ì´ë²¤íŠ¸ êµ¬ë…
    worker.on('taskCompleted', (result) => {
      this.handleWorkerTaskCompletion(worker, result);
    });
    
    worker.on('error', (error) => {
      this.handleWorkerError(worker, error);
    });
  }
  
  // ì‘ì—… ë¶„ë°°
  async distributeTask(task: Task): Promise<void> {
    const workerType = this.selectWorkerType(task);
    const workers = this.workers.get(workerType);
    
    if (!workers || workers.length === 0) {
      throw new Error(`No workers available for type: ${workerType}`);
    }
    
    // ë¡œë“œ ë°¸ëŸ°ì‹±: ê°€ì¥ idleí•œ worker ì„ íƒ
    const selectedWorker = this.selectIdleWorker(workers);
    
    if (!selectedWorker) {
      // ëª¨ë“  workerê°€ busyí•˜ë©´ íì— ì¶”ê°€
      await this.taskQueue.enqueue(task);
      return;
    }
    
    await selectedWorker.executeTask(task);
  }
  
  // Worker ì„ íƒ ë¡œì§
  private selectWorkerType(task: Task): string {
    // ì‘ì—… íƒ€ì…ê³¼ capability ë§¤ì¹­
    for (const [type, workers] of this.workers) {
      if (workers.some(w => w.canHandle(task))) {
        return type;
      }
    }
    
    throw new Error(`No suitable worker for task: ${task.type}`);
  }
  
  private selectIdleWorker(workers: WorkerAgent[]): WorkerAgent | null {
    return workers.find(w => w.getStatus() === 'idle') || null;
  }
  
  // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  private handleWorkerTaskCompletion(
    worker: WorkerAgent,
    result: any
  ): void {
    this.logger.info('Worker task completed', {
      workerId: worker.getId(),
      result
    });
    
    this.emit('taskCompleted', {
      worker: worker.getId(),
      result
    });
    
    // íì—ì„œ ë‹¤ìŒ ì‘ì—… í• ë‹¹
    this.assignNextTask(worker);
  }
  
  private handleWorkerError(
    worker: WorkerAgent,
    error: Error
  ): void {
    this.logger.error('Worker error', {
      workerId: worker.getId(),
      error
    });
    
    this.emit('workerError', {
      worker: worker.getId(),
      error
    });
  }
  
  private async assignNextTask(worker: WorkerAgent): Promise<void> {
    const nextTask = await this.taskQueue.dequeue(worker.getType());
    
    if (nextTask) {
      await worker.executeTask(nextTask);
    }
  }
  
  // ìƒíƒœ ëª¨ë‹ˆí„°ë§
  getSquadStatus(): any {
    const status = {
      supervisor: {
        name: this.config.name,
        role: this.config.role
      },
      workers: {} as any,
      queueSize: this.taskQueue.size()
    };
    
    for (const [type, workers] of this.workers) {
      status.workers[type] = {
        count: workers.length,
        idle: workers.filter(w => w.getStatus() === 'idle').length,
        busy: workers.filter(w => w.getStatus() === 'busy').length
      };
    }
    
    return status;
  }
}

// Worker Agent ê¸°ë³¸ í´ë˜ìŠ¤
export abstract class WorkerAgent extends EventEmitter {
  protected id: string;
  protected type: string;
  protected status: 'idle' | 'busy' | 'error' = 'idle';
  protected capabilities: string[];
  protected logger: Logger;
  
  constructor(
    type: string,
    capabilities: string[],
    logger: Logger
  ) {
    super();
    this.id = `worker-${type}-${Date.now()}`;
    this.type = type;
    this.capabilities = capabilities;
    this.logger = logger;
  }
  
  getId(): string {
    return this.id;
  }
  
  getType(): string {
    return this.type;
  }
  
  getStatus(): string {
    return this.status;
  }
  
  canHandle(task: Task): boolean {
    return this.capabilities.includes(task.capability);
  }
  
  async executeTask(task: Task): Promise<void> {
    this.status = 'busy';
    
    try {
      const result = await this.process(task);
      
      this.emit('taskCompleted', result);
      this.status = 'idle';
      
    } catch (error) {
      this.status = 'error';
      this.emit('error', error);
      
      setTimeout(() => {
        this.status = 'idle';
      }, 5000); // 5ì´ˆ í›„ ë³µêµ¬
    }
  }
  
  protected abstract process(task: Task): Promise<any>;
}

// ì‘ì—… í êµ¬í˜„
class TaskQueue {
  private queues: Map<string, Task[]> = new Map();
  
  async enqueue(task: Task): Promise<void> {
    const type = task.workerType || 'default';
    
    if (!this.queues.has(type)) {
      this.queues.set(type, []);
    }
    
    this.queues.get(type)!.push(task);
  }
  
  async dequeue(type: string): Promise<Task | null> {
    const queue = this.queues.get(type);
    
    if (!queue || queue.length === 0) {
      return null;
    }
    
    return queue.shift() || null;
  }
  
  size(): number {
    let total = 0;
    for (const queue of this.queues.values()) {
      total += queue.length;
    }
    return total;
  }
}

// íƒ€ì… ì •ì˜
interface Task {
  id: string;
  type: string;
  capability: string;
  workerType?: string;
  payload: any;
  priority?: number;
  timeout?: number;
}
```

### SubTask 0.13.5: Agno ëª¨ë‹ˆí„°ë§ í†µí•© ì¤€ë¹„
**ëª©í‘œ**: Agno í”Œë«í¼ê³¼ì˜ ëª¨ë‹ˆí„°ë§ í†µí•© ì„¤ì •

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// backend/src/integrations/agno/monitoring-config.ts
import axios, { AxiosInstance } from 'axios';
import { Logger } from 'winston';

export interface AgnoConfig {
  apiKey: string;
  endpoint: string;
  projectId: string;
  environment: string;
  batchSize?: number;
  flushInterval?: number;
}

export interface AgnoMetric {
  name: string;
  value: number;
  tags?: Record<string, string>;
  timestamp?: Date;
}

export interface AgnoEvent {
  type: string;
  data: any;
  userId?: string;
  sessionId?: string;
  timestamp?: Date;
  metadata?: Record<string, any>;
}

export interface AgnoTrace {
  traceId: string;
  spanId: string;
  parentSpanId?: string;
  operation: string;
  startTime: Date;
  endTime?: Date;
  duration?: number;
  status: 'success' | 'error';
  metadata?: Record<string, any>;
}

export class AgnoMonitoringClient {
  private config: AgnoConfig;
  private client: AxiosInstance;
  private logger: Logger;
  private metricBuffer: AgnoMetric[] = [];
  private eventBuffer: AgnoEvent[] = [];
  private traceBuffer: AgnoTrace[] = [];
  private flushTimer?: NodeJS.Timer;
  
  constructor(config: AgnoConfig, logger: Logger) {
    this.config = {
      batchSize: 100,
      flushInterval: 10000, // 10ì´ˆ
      ...config
    };
    this.logger = logger;
    
    this.client = axios.create({
      baseURL: config.endpoint,
      headers: {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json',
        'X-Project-ID': config.projectId,
        'X-Environment': config.environment
      }
    });
    
    this.startFlushTimer();
  }
  
  // ë©”íŠ¸ë¦­ ì „ì†¡
  async sendMetric(metric: AgnoMetric): Promise<void> {
    this.metricBuffer.push({
      ...metric,
      timestamp: metric.timestamp || new Date()
    });
    
    if (this.metricBuffer.length >= this.config.batchSize!) {
      await this.flushMetrics();
    }
  }
  
  // ì´ë²¤íŠ¸ ì „ì†¡
  async sendEvent(event: AgnoEvent): Promise<void> {
    this.eventBuffer.push({
      ...event,
      timestamp: event.timestamp || new Date()
    });
    
    if (this.eventBuffer.length >= this.config.batchSize!) {
      await this.flushEvents();
    }
  }
  
  // íŠ¸ë ˆì´ìŠ¤ ì „ì†¡
  async sendTrace(trace: AgnoTrace): Promise<void> {
    this.traceBuffer.push(trace);
    
    if (this.traceBuffer.length >= this.config.batchSize!) {
      await this.flushTraces();
    }
  }
  
  // ì—ì´ì „íŠ¸ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  async monitorAgentPerformance(
    agentName: string,
    operation: string,
    duration: number,
    success: boolean,
    metadata?: any
  ): Promise<void> {
    // ë©”íŠ¸ë¦­ ì „ì†¡
    await this.sendMetric({
      name: `agent.${agentName}.duration`,
      value: duration,
      tags: {
        agent: agentName,
        operation,
        status: success ? 'success' : 'failure'
      }
    });
    
    // ì´ë²¤íŠ¸ ì „ì†¡
    await this.sendEvent({
      type: 'agent_operation',
      data: {
        agent: agentName,
        operation,
        duration,
        success,
        ...metadata
      }
    });
  }
  
  // í”„ë¡œì íŠ¸ ì§„í–‰ìƒí™© ëª¨ë‹ˆí„°ë§
  async monitorProjectProgress(
    projectId: string,
    phase: string,
    progress: number,
    metadata?: any
  ): Promise<void> {
    await this.sendEvent({
      type: 'project_progress',
      data: {
        projectId,
        phase,
        progress,
        ...metadata
      }
    });
    
    await this.sendMetric({
      name: 'project.progress',
      value: progress,
      tags: {
        project: projectId,
        phase
      }
    });
  }
  
  // ì—ëŸ¬ ì¶”ì 
  async trackError(
    error: Error,
    context: {
      agent?: string;
      operation?: string;
      userId?: string;
      projectId?: string;
    }
  ): Promise<void> {
    await this.sendEvent({
      type: 'error',
      data: {
        message: error.message,
        stack: error.stack,
        name: error.name,
        ...context
      },
      userId: context.userId
    });
  }
  
  // ë°°ì¹˜ ì „ì†¡ ë©”ì„œë“œë“¤
  private async flushMetrics(): Promise<void> {
    if (this.metricBuffer.length === 0) return;
    
    const metrics = [...this.metricBuffer];
    this.metricBuffer = [];
    
    try {
      await this.client.post('/metrics', { metrics });
      this.logger.debug(`Flushed ${metrics.length} metrics to Agno`);
    } catch (error) {
      this.logger.error('Failed to flush metrics to Agno', { error });
      // ì‹¤íŒ¨í•œ ë©”íŠ¸ë¦­ì€ ë²„í¼ì— ë‹¤ì‹œ ì¶”ê°€
      this.metricBuffer.unshift(...metrics);
    }
  }
  
  private async flushEvents(): Promise<void> {
    if (this.eventBuffer.length === 0) return;
    
    const events = [...this.eventBuffer];
    this.eventBuffer = [];
    
    try {
      await this.client.post('/events', { events });
      this.logger.debug(`Flushed ${events.length} events to Agno`);
    } catch (error) {
      this.logger.error('Failed to flush events to Agno', { error });
      this.eventBuffer.unshift(...events);
    }
  }
  
  private async flushTraces(): Promise<void> {
    if (this.traceBuffer.length === 0) return;
    
    const traces = [...this.traceBuffer];
    this.traceBuffer = [];
    
    try {
      await this.client.post('/traces', { traces });
      this.logger.debug(`Flushed ${traces.length} traces to Agno`);
    } catch (error) {
      this.logger.error('Failed to flush traces to Agno', { error });
      this.traceBuffer.unshift(...traces);
    }
  }
  
  // íƒ€ì´ë¨¸ ê´€ë¦¬
  private startFlushTimer(): void {
    this.flushTimer = setInterval(async () => {
      await Promise.all([
        this.flushMetrics(),
        this.flushEvents(),
        this.flushTraces()
      ]);
    }, this.config.flushInterval!);
  }
  
  async shutdown(): Promise<void> {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    
    // ë‚¨ì€ ë°ì´í„° ëª¨ë‘ ì „ì†¡
    await Promise.all([
      this.flushMetrics(),
      this.flushEvents(),
      this.flushTraces()
    ]);
  }
}

// Agno ë°ì½”ë ˆì´í„° (ë©”ì„œë“œ ìë™ ì¶”ì )
export function AgnoTrace(
  operationName?: string
): MethodDecorator {
  return function (
    target: any,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const operation = operationName || String(propertyKey);
      const traceId = `trace-${Date.now()}-${Math.random()}`;
      const spanId = `span-${Date.now()}-${Math.random()}`;
      const startTime = Date.now();
      
      const agnoClient = (this as any).agnoClient;
      
      try {
        const result = await originalMethod.apply(this, args);
        
        if (agnoClient) {
          await agnoClient.sendTrace({
            traceId,
            spanId,
            operation,
            startTime: new Date(startTime),
            endTime: new Date(),
            duration: Date.now() - startTime,
            status: 'success',
            metadata: {
              class: target.constructor.name,
              method: String(propertyKey)
            }
          });
        }
        
        return result;
        
      } catch (error) {
        if (agnoClient) {
          await agnoClient.sendTrace({
            traceId,
            spanId,
            operation,
            startTime: new Date(startTime),
            endTime: new Date(),
            duration: Date.now() - startTime,
            status: 'error',
            metadata: {
              class: target.constructor.name,
              method: String(propertyKey),
              error: error.message
            }
          });
        }
        
        throw error;
      }
    };
    
    return descriptor;
  };
}
```

---

## Task 0.14: ê°œë°œ ì›Œí¬í”Œë¡œìš° ìë™í™”

### SubTask 0.14.1: Git í›… ë° ì»¤ë°‹ ê·œì¹™ ì„¤ì •
**ëª©í‘œ**: ì¼ê´€ëœ ì½”ë“œ í’ˆì§ˆì„ ìœ„í•œ Git í›… ì„¤ì •

**êµ¬í˜„ ë‚´ìš©**:
```bash
#!/bin/bash
# scripts/setup-git-hooks.sh

echo "ğŸ”§ Git í›… ì„¤ì • ì‹œì‘..."

# Husky ì„¤ì¹˜ ë° ì´ˆê¸°í™”
npm install --save-dev husky
npx husky install

# commit-msg í›… ì¶”ê°€
npx husky add .husky/commit-msg 'npx --no -- commitlint --edit $1'

# pre-commit í›… ì¶”ê°€
npx husky add .husky/pre-commit 'npm run pre-commit'

# pre-push í›… ì¶”ê°€
npx husky add .husky/pre-push 'npm run pre-push'

echo "âœ… Git í›… ì„¤ì • ì™„ë£Œ!"
```

```typescript
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat',     // ìƒˆë¡œìš´ ê¸°ëŠ¥
        'fix',      // ë²„ê·¸ ìˆ˜ì •
        'docs',     // ë¬¸ì„œ ìˆ˜ì •
        'style',    // ì½”ë“œ í¬ë§·íŒ…
        'refactor', // ì½”ë“œ ë¦¬íŒ©í† ë§
        'test',     // í…ŒìŠ¤íŠ¸ ì¶”ê°€/ìˆ˜ì •
        'chore',    // ë¹Œë“œ í”„ë¡œì„¸ìŠ¤ ë˜ëŠ” ë³´ì¡° ë„êµ¬ ë³€ê²½
        'perf',     // ì„±ëŠ¥ ê°œì„ 
        'ci',       // CI ì„¤ì • ë³€ê²½
        'revert',   // ì´ì „ ì»¤ë°‹ ë˜ëŒë¦¬ê¸°
        'agent'     // ì—ì´ì „íŠ¸ ê´€ë ¨ ë³€ê²½ (T-Developer ì „ìš©)
      ]
    ],
    'subject-case': [2, 'never', ['upper-case']],
    'header-max-length': [2, 'always', 72],
    'body-max-line-length': [2, 'always', 100],
    'scope-enum': [
      2,
      'always',
      [
        'core',
        'agents',
        'api',
        'frontend',
        'infra',
        'docs',
        'tests',
        'deps'
      ]
    ]
  }
};
```

```json
// .gitmessage
# <type>(<scope>): <subject>
#
# <body>
#
# <footer>
#
# Type: feat, fix, docs, style, refactor, test, chore, perf, ci, revert, agent
# Scope: core, agents, api, frontend, infra, docs, tests, deps
#
# Subject: ì²« ê¸€ì ì†Œë¬¸ì, ëª…ë ¹í˜•, ë§ˆì¹¨í‘œ ì—†ìŒ, 50ì ì´ë‚´
#
# Body: 72ìë§ˆë‹¤ ì¤„ë°”ê¿ˆ, ë¬´ì—‡ì„ ì™œ í–ˆëŠ”ì§€ ì„¤ëª…
#
# Footer: Breaking changes, ì´ìŠˆ ë²ˆí˜¸ ì°¸ì¡°
#
# ì˜ˆì‹œ:
# feat(agents): add natural language input processing
#
# Implement NL input agent with following capabilities:
# - Parse user requirements from natural language
# - Extract technical specifications
# - Generate structured project metadata
#
# Closes #123
```
### SubTask 0.14.2: ê°œë°œ í™˜ê²½ ìµœì¢… ê²€ì¦
**ëª©í‘œ**: ëª¨ë“  ê°œë°œ í™˜ê²½ êµ¬ì„±ìš”ì†Œì˜ ì •ìƒ ì‘ë™ í™•ì¸

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// scripts/verify-environment.ts
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import axios from 'axios';
import { DynamoDBClient, ListTablesCommand } from '@aws-sdk/client-dynamodb';
import Redis from 'ioredis';
import chalk from 'chalk';

const execAsync = promisify(exec);

interface VerificationResult {
  component: string;
  status: 'pass' | 'fail' | 'warning';
  message: string;
  details?: any;
}

class EnvironmentVerifier {
  private results: VerificationResult[] = [];
  
  async verify(): Promise<void> {
    console.log(chalk.blue('ğŸ” T-Developer í™˜ê²½ ê²€ì¦ ì‹œì‘...\n'));
    
    // 1. Node.js í™˜ê²½
    await this.verifyNodeEnvironment();
    
    // 2. AWS ì„¤ì •
    await this.verifyAWSConfiguration();
    
    // 3. ë°ì´í„°ë² ì´ìŠ¤
    await this.verifyDatabases();
    
    // 4. ì™¸ë¶€ ì„œë¹„ìŠ¤
    await this.verifyExternalServices();
    
    // 5. ê°œë°œ ë„êµ¬
    await this.verifyDevelopmentTools();
    
    // 6. ë³´ì•ˆ ì„¤ì •
    await this.verifySecuritySettings();
    
    // ê²°ê³¼ ì¶œë ¥
    this.printResults();
  }
  
  private async verifyNodeEnvironment(): Promise<void> {
    try {
      const { stdout: nodeVersion } = await execAsync('node --version');
      const { stdout: npmVersion } = await execAsync('npm --version');
      
      const nodeMatch = nodeVersion.match(/v(\d+)\.(\d+)/);
      if (nodeMatch) {
        const majorVersion = parseInt(nodeMatch[1]);
        if (majorVersion >= 18) {
          this.addResult('Node.js', 'pass', `ë²„ì „ ${nodeVersion.trim()} í™•ì¸`);
        } else {
          this.addResult('Node.js', 'fail', `ë²„ì „ 18 ì´ìƒ í•„ìš” (í˜„ì¬: ${nodeVersion.trim()})`);
        }
      }
      
      this.addResult('npm', 'pass', `ë²„ì „ ${npmVersion.trim()} í™•ì¸`);
      
      // í•„ìˆ˜ íŒ¨í‚¤ì§€ í™•ì¸
      const packageJson = JSON.parse(await fs.readFile('package.json', 'utf-8'));
      const requiredPackages = [
        '@aws-sdk/client-bedrock-runtime',
        '@aws-sdk/client-dynamodb',
        'express',
        'typescript',
        'jest'
      ];
      
      const missingPackages = requiredPackages.filter(
        pkg => !packageJson.dependencies?.[pkg] && !packageJson.devDependencies?.[pkg]
      );
      
      if (missingPackages.length === 0) {
        this.addResult('í•„ìˆ˜ íŒ¨í‚¤ì§€', 'pass', 'ëª¨ë“  í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜ë¨');
      } else {
        this.addResult('í•„ìˆ˜ íŒ¨í‚¤ì§€', 'fail', `ëˆ„ë½ëœ íŒ¨í‚¤ì§€: ${missingPackages.join(', ')}`);
      }
      
    } catch (error) {
      this.addResult('Node.js í™˜ê²½', 'fail', 'í™•ì¸ ì‹¤íŒ¨', error);
    }
  }
  
  private async verifyAWSConfiguration(): Promise<void> {
    try {
      // AWS ìê²© ì¦ëª… í™•ì¸
      const { stdout: awsIdentity } = await execAsync('aws sts get-caller-identity');
      const identity = JSON.parse(awsIdentity);
      
      this.addResult('AWS ìê²© ì¦ëª…', 'pass', `ê³„ì • ID: ${identity.Account}`);
      
      // DynamoDB ì—°ê²° í…ŒìŠ¤íŠ¸
      const dynamoClient = new DynamoDBClient({
        region: process.env.AWS_REGION || 'us-east-1',
        endpoint: process.env.DYNAMODB_ENDPOINT
      });
      
      const tables = await dynamoClient.send(new ListTablesCommand({}));
      this.addResult('DynamoDB', 'pass', `í…Œì´ë¸” ìˆ˜: ${tables.TableNames?.length || 0}`);
      
      // S3 ë²„í‚· í™•ì¸
      const { stdout: s3Buckets } = await execAsync('aws s3 ls');
      const bucketCount = s3Buckets.split('\n').filter(line => line.trim()).length;
      this.addResult('S3', 'pass', `ë²„í‚· ìˆ˜: ${bucketCount}`);
      
    } catch (error) {
      this.addResult('AWS ì„¤ì •', 'fail', 'AWS ì„œë¹„ìŠ¤ ì—°ê²° ì‹¤íŒ¨', error);
    }
  }
  
  private async verifyDatabases(): Promise<void> {
    // Redis ì—°ê²° í…ŒìŠ¤íŠ¸
    try {
      const redis = new Redis({
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
        retryStrategy: () => null
      });
      
      await redis.ping();
      this.addResult('Redis', 'pass', 'Redis ì„œë²„ ì—°ê²° ì„±ê³µ');
      await redis.disconnect();
      
    } catch (error) {
      this.addResult('Redis', 'warning', 'Redis ì„œë²„ ì—°ê²° ì‹¤íŒ¨ (ì„ íƒì‚¬í•­)');
    }
    
    // DynamoDB Local í™•ì¸
    if (process.env.NODE_ENV === 'development') {
      try {
        const response = await axios.get('http://localhost:8000');
        this.addResult('DynamoDB Local', 'pass', 'ë¡œì»¬ DynamoDB ì‹¤í–‰ ì¤‘');
      } catch {
        this.addResult('DynamoDB Local', 'warning', 'ë¡œì»¬ DynamoDB ë¯¸ì‹¤í–‰ (ê°œë°œìš©)');
      }
    }
  }
  
  private async verifyExternalServices(): Promise<void> {
    // GitHub API
    if (process.env.GITHUB_TOKEN) {
      try {
        await axios.get('https://api.github.com/user', {
          headers: { Authorization: `token ${process.env.GITHUB_TOKEN}` }
        });
        this.addResult('GitHub API', 'pass', 'GitHub í† í° ìœ íš¨');
      } catch {
        this.addResult('GitHub API', 'fail', 'GitHub í† í° ë¬´íš¨');
      }
    } else {
      this.addResult('GitHub API', 'warning', 'GitHub í† í° ë¯¸ì„¤ì •');
    }
    
    // AI ì„œë¹„ìŠ¤
    const aiServices = [
      { name: 'OpenAI', envVar: 'OPENAI_API_KEY' },
      { name: 'Anthropic', envVar: 'ANTHROPIC_API_KEY' },
      { name: 'Bedrock', envVar: 'BEDROCK_AGENTCORE_RUNTIME_ID' }
    ];
    
    for (const service of aiServices) {
      if (process.env[service.envVar]) {
        this.addResult(service.name, 'pass', `${service.envVar} ì„¤ì •ë¨`);
      } else {
        this.addResult(service.name, 'warning', `${service.envVar} ë¯¸ì„¤ì •`);
      }
    }
  }
  
  private async verifyDevelopmentTools(): Promise<void> {
    const tools = [
      { cmd: 'docker --version', name: 'Docker' },
      { cmd: 'git --version', name: 'Git' },
      { cmd: 'code --version', name: 'VS Code', optional: true }
    ];
    
    for (const tool of tools) {
      try {
        const { stdout } = await execAsync(tool.cmd);
        this.addResult(tool.name, 'pass', stdout.trim().split('\n')[0]);
      } catch {
        if (tool.optional) {
          this.addResult(tool.name, 'warning', 'ì„¤ì¹˜ë˜ì§€ ì•ŠìŒ (ì„ íƒì‚¬í•­)');
        } else {
          this.addResult(tool.name, 'fail', 'ì„¤ì¹˜ë˜ì§€ ì•ŠìŒ');
        }
      }
    }
  }
  
  private async verifySecuritySettings(): Promise<void> {
    // í™˜ê²½ ë³€ìˆ˜ ë³´ì•ˆ
    const sensitiveVars = ['JWT_SECRET', 'ENCRYPTION_KEY'];
    const weakValues = ['secret', 'password', '123456', 'admin'];
    
    for (const varName of sensitiveVars) {
      const value = process.env[varName];
      if (!value) {
        this.addResult(`ë³´ì•ˆ: ${varName}`, 'fail', 'ì„¤ì •ë˜ì§€ ì•ŠìŒ');
      } else if (weakValues.includes(value.toLowerCase())) {
        this.addResult(`ë³´ì•ˆ: ${varName}`, 'fail', 'ì•½í•œ ê°’ ì‚¬ìš©');
      } else if (value.length < 16) {
        this.addResult(`ë³´ì•ˆ: ${varName}`, 'warning', '16ì ì´ìƒ ê¶Œì¥');
      } else {
        this.addResult(`ë³´ì•ˆ: ${varName}`, 'pass', 'ì ì ˆí•œ ê°’ ì„¤ì •ë¨');
      }
    }
    
    // .env íŒŒì¼ ê¶Œí•œ í™•ì¸
    try {
      const stats = await fs.stat('.env');
      const mode = (stats.mode & parseInt('777', 8)).toString(8);
      if (mode === '600') {
        this.addResult('.env íŒŒì¼ ê¶Œí•œ', 'pass', 'ì•ˆì „í•œ ê¶Œí•œ ì„¤ì • (600)');
      } else {
        this.addResult('.env íŒŒì¼ ê¶Œí•œ', 'warning', `í˜„ì¬ ê¶Œí•œ: ${mode} (600 ê¶Œì¥)`);
      }
    } catch {
      this.addResult('.env íŒŒì¼', 'fail', '.env íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤');
    }
  }
  
  private addResult(component: string, status: VerificationResult['status'], message: string, details?: any): void {
    this.results.push({ component, status, message, details });
  }
  
  private printResults(): void {
    console.log('\n' + chalk.blue('='.repeat(60)));
    console.log(chalk.blue.bold('ê²€ì¦ ê²°ê³¼ ìš”ì•½'));
    console.log(chalk.blue('='.repeat(60)) + '\n');
    
    const statusIcons = {
      pass: chalk.green('âœ…'),
      fail: chalk.red('âŒ'),
      warning: chalk.yellow('âš ï¸')
    };
    
    const maxComponentLength = Math.max(...this.results.map(r => r.component.length));
    
    for (const result of this.results) {
      const icon = statusIcons[result.status];
      const component = result.component.padEnd(maxComponentLength + 2);
      const statusColor = result.status === 'pass' ? chalk.green :
                         result.status === 'fail' ? chalk.red : chalk.yellow;
      
      console.log(`${icon} ${chalk.white(component)} ${statusColor(result.message)}`);
      
      if (result.details && process.env.VERBOSE) {
        console.log(chalk.gray(`   ìƒì„¸: ${JSON.stringify(result.details, null, 2)}`));
      }
    }
    
    // í†µê³„
    const stats = {
      pass: this.results.filter(r => r.status === 'pass').length,
      fail: this.results.filter(r => r.status === 'fail').length,
      warning: this.results.filter(r => r.status === 'warning').length
    };
    
    console.log('\n' + chalk.blue('-'.repeat(60)));
    console.log(chalk.white('í†µê³„:'), 
      chalk.green(`ì„±ê³µ: ${stats.pass}`),
      chalk.red(`ì‹¤íŒ¨: ${stats.fail}`),
      chalk.yellow(`ê²½ê³ : ${stats.warning}`)
    );
    
    if (stats.fail > 0) {
      console.log('\n' + chalk.red.bold('âš ï¸  ì¼ë¶€ ê²€ì¦ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìœ„ì˜ ì‹¤íŒ¨ í•­ëª©ì„ í™•ì¸í•˜ì„¸ìš”.'));
      process.exit(1);
    } else if (stats.warning > 0) {
      console.log('\n' + chalk.yellow.bold('â„¹ï¸  ì¼ë¶€ ê²½ê³ ê°€ ìˆì§€ë§Œ ê°œë°œì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'));
    } else {
      console.log('\n' + chalk.green.bold('ğŸ‰ ëª¨ë“  ê²€ì¦ì„ í†µê³¼í–ˆìŠµë‹ˆë‹¤! ê°œë°œ í™˜ê²½ì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.'));
    }
  }
}

// ì‹¤í–‰
if (require.main === module) {
  const verifier = new EnvironmentVerifier();
  verifier.verify().catch(console.error);
}

export { EnvironmentVerifier };
```

### SubTask 0.14.3: ê°œë°œ í™˜ê²½ ì„¤ì • ë¬¸ì„œí™”
**ëª©í‘œ**: ì™„ì„±ëœ ê°œë°œ í™˜ê²½ ì„¤ì •ì„ ë¬¸ì„œë¡œ ì •ë¦¬

**êµ¬í˜„ ë‚´ìš©**:
```markdown
<!-- docs/setup/development-environment.md -->
# T-Developer ê°œë°œ í™˜ê²½ ì„¤ì • ê°€ì´ë“œ

## ğŸ“‹ ëª©ì°¨
1. [ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­](#ì‹œìŠ¤í…œ-ìš”êµ¬ì‚¬í•­)
2. [í•„ìˆ˜ ë„êµ¬ ì„¤ì¹˜](#í•„ìˆ˜-ë„êµ¬-ì„¤ì¹˜)
3. [í”„ë¡œì íŠ¸ ì„¤ì •](#í”„ë¡œì íŠ¸-ì„¤ì •)
4. [í™˜ê²½ ë³€ìˆ˜ êµ¬ì„±](#í™˜ê²½-ë³€ìˆ˜-êµ¬ì„±)
5. [AWS ì„œë¹„ìŠ¤ ì„¤ì •](#aws-ì„œë¹„ìŠ¤-ì„¤ì •)
6. [ë¡œì»¬ ê°œë°œ í™˜ê²½](#ë¡œì»¬-ê°œë°œ-í™˜ê²½)
7. [ê²€ì¦ ë° í…ŒìŠ¤íŠ¸](#ê²€ì¦-ë°-í…ŒìŠ¤íŠ¸)
8. [ë¬¸ì œ í•´ê²°](#ë¬¸ì œ-í•´ê²°)

## ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­

### í•˜ë“œì›¨ì–´
- **CPU**: 4ì½”ì–´ ì´ìƒ ê¶Œì¥
- **RAM**: 16GB ì´ìƒ ê¶Œì¥
- **ë””ìŠ¤í¬**: 50GB ì´ìƒ ì—¬ìœ  ê³µê°„

### ìš´ì˜ì²´ì œ
- macOS 12.0+
- Ubuntu 20.04+
- Windows 10/11 (WSL2 í•„ìˆ˜)

## í•„ìˆ˜ ë„êµ¬ ì„¤ì¹˜

### 1. Node.js (v18+)
```bash
# NVM ì‚¬ìš© (ê¶Œì¥)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18
nvm use 18

# ì§ì ‘ ì„¤ì¹˜
# https://nodejs.org/en/download/
```

### 2. Python (v3.9+)
```bash
# macOS
brew install python@3.9

# Ubuntu
sudo apt update
sudo apt install python3.9 python3.9-venv

# Windows
# https://www.python.org/downloads/
```

### 3. AWS CLI
```bash
# macOS
brew install awscli

# Linux/WSL
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install

# ì„¤ì •
aws configure
```

### 4. Docker
```bash
# macOS
brew install --cask docker

# Ubuntu
sudo apt install docker.io docker-compose
sudo usermod -aG docker $USER

# Windows
# Docker Desktop ì„¤ì¹˜: https://www.docker.com/products/docker-desktop
```

### 5. Git
```bash
# macOS
brew install git

# Ubuntu
sudo apt install git
```

## í”„ë¡œì íŠ¸ ì„¤ì •

### 1. ì €ì¥ì†Œ í´ë¡ 
```bash
git clone https://github.com/your-org/t-developer.git
cd t-developer
```

### 2. ì˜ì¡´ì„± ì„¤ì¹˜
```bash
# ë£¨íŠ¸ ë””ë ‰í† ë¦¬ì—ì„œ
npm install

# Backend ì˜ì¡´ì„±
cd backend
npm install

# Frontend ì˜ì¡´ì„±
cd ../frontend
npm install
```

### 3. Git Hooks ì„¤ì •
```bash
# ë£¨íŠ¸ ë””ë ‰í† ë¦¬ì—ì„œ
npm run prepare
```

## í™˜ê²½ ë³€ìˆ˜ êµ¬ì„±

### 1. í™˜ê²½ ë³€ìˆ˜ íŒŒì¼ ìƒì„±
```bash
# ë£¨íŠ¸ ë””ë ‰í† ë¦¬ì—ì„œ
cp .env.example .env

# ë³´ì•ˆ ì„¤ì •
chmod 600 .env
```

### 2. í•„ìˆ˜ í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
```bash
# .env íŒŒì¼ í¸ì§‘
nano .env  # ë˜ëŠ” ì›í•˜ëŠ” ì—ë””í„° ì‚¬ìš©
```

#### í•„ìˆ˜ ì„¤ì • í•­ëª©:
```env
# Node í™˜ê²½
NODE_ENV=development
PORT=3000

# AWS ì„¤ì •
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_REGION=us-east-1

# AI ì„œë¹„ìŠ¤ (ìµœì†Œ í•˜ë‚˜ í•„ìˆ˜)
OPENAI_API_KEY=sk-...
# ë˜ëŠ”
ANTHROPIC_API_KEY=sk-ant-...

# ë³´ì•ˆ (ê°•ë ¥í•œ ê°’ìœ¼ë¡œ ë³€ê²½ í•„ìˆ˜!)
JWT_SECRET=your-super-secure-jwt-secret-min-32-chars
ENCRYPTION_KEY=your-32-character-encryption-key!!

# GitHub (ì„ íƒì‚¬í•­)
GITHUB_TOKEN=ghp_...
```

## AWS ì„œë¹„ìŠ¤ ì„¤ì •

### 1. DynamoDB í…Œì´ë¸” ìƒì„±
```bash
# ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
npm run setup:aws:dynamodb
```

### 2. S3 ë²„í‚· ìƒì„±
```bash
# ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
npm run setup:aws:s3
```

### 3. Bedrock ì„¤ì • (ì„ íƒì‚¬í•­)
```bash
# Bedrock ì•¡ì„¸ìŠ¤ í™œì„±í™”
aws bedrock get-foundation-model-availability \
  --region us-east-1 \
  --model-id anthropic.claude-v2
```

## ë¡œì»¬ ê°œë°œ í™˜ê²½

### 1. ë¡œì»¬ ì„œë¹„ìŠ¤ ì‹œì‘
```bash
# Docker Composeë¡œ ëª¨ë“  ì„œë¹„ìŠ¤ ì‹œì‘
docker-compose up -d

# ê°œë³„ ì„œë¹„ìŠ¤ ì‹œì‘
docker-compose up -d dynamodb-local
docker-compose up -d redis
```

### 2. ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
```bash
# DynamoDB ë¡œì»¬ í…Œì´ë¸” ìƒì„±
npm run db:init:local
```

### 3. ê°œë°œ ì„œë²„ ì‹œì‘
```bash
# Backend (í„°ë¯¸ë„ 1)
cd backend
npm run dev

# Frontend (í„°ë¯¸ë„ 2)
cd frontend
npm run dev
```

### 4. ì„œë¹„ìŠ¤ ì ‘ì†
- **Frontend**: http://localhost:5173
- **Backend API**: http://localhost:3000
- **API ë¬¸ì„œ**: http://localhost:3000/api-docs
- **Grafana**: http://localhost:3001 (admin/admin)

## ê²€ì¦ ë° í…ŒìŠ¤íŠ¸

### 1. í™˜ê²½ ê²€ì¦
```bash
# ì „ì²´ í™˜ê²½ ê²€ì¦
npm run verify:env

# ìƒì„¸ ì •ë³´ í¬í•¨
VERBOSE=true npm run verify:env
```

### 2. í…ŒìŠ¤íŠ¸ ì‹¤í–‰
```bash
# ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
npm test

# í†µí•© í…ŒìŠ¤íŠ¸
npm run test:integration

# E2E í…ŒìŠ¤íŠ¸
npm run test:e2e
```

### 3. ë¦°íŠ¸ ë° í¬ë§·íŒ…
```bash
# ë¦°íŠ¸ ê²€ì‚¬
npm run lint

# ìë™ ìˆ˜ì •
npm run lint:fix

# ì½”ë“œ í¬ë§·íŒ…
npm run format
```

## ë¬¸ì œ í•´ê²°

### í¬íŠ¸ ì¶©ëŒ
```bash
# ì‚¬ìš© ì¤‘ì¸ í¬íŠ¸ í™•ì¸
lsof -i :3000
lsof -i :5173

# í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
kill -9 <PID>
```

### Docker ë¬¸ì œ
```bash
# Docker ì¬ì‹œì‘
docker-compose down
docker-compose up -d

# ë³¼ë¥¨ ì •ë¦¬
docker system prune -a --volumes
```

### ê¶Œí•œ ë¬¸ì œ
```bash
# node_modules ê¶Œí•œ ìˆ˜ì •
sudo chown -R $(whoami) node_modules

# npm ìºì‹œ ì •ë¦¬
npm cache clean --force
```

### AWS ì—°ê²° ë¬¸ì œ
```bash
# ìê²© ì¦ëª… í™•ì¸
aws sts get-caller-identity

# ë¦¬ì „ í™•ì¸
echo $AWS_REGION
```

## ë‹¤ìŒ ë‹¨ê³„

ê°œë°œ í™˜ê²½ ì„¤ì •ì´ ì™„ë£Œë˜ì—ˆë‹¤ë©´:

1. [ì•„í‚¤í…ì²˜ ë¬¸ì„œ](../architecture/overview.md) ì½ê¸°
2. [ê°œë°œ ê°€ì´ë“œ](../development/getting-started.md) í™•ì¸
3. [ì²« ë²ˆì§¸ ì—ì´ì „íŠ¸ ë§Œë“¤ê¸°](../tutorials/first-agent.md)

---

ë¬¸ì œê°€ ìˆê±°ë‚˜ ë„ì›€ì´ í•„ìš”í•˜ë©´ [ì´ìŠˆ íŠ¸ë˜ì»¤](https://github.com/your-org/t-developer/issues)ì— ë¬¸ì˜í•˜ì„¸ìš”.
```

### SubTask 0.14.4: Phase 0 ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸
**ëª©í‘œ**: Phase 0ì˜ ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ ìµœì¢… í™•ì¸

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// scripts/phase0-checklist.ts
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

interface ChecklistItem {
  task: string;
  description: string;
  check: () => Promise<boolean>;
  critical: boolean;
}

class Phase0Checklist {
  private items: ChecklistItem[] = [
    // Task 0.1: ê°œë°œ í™˜ê²½ ì´ˆê¸° ì„¤ì •
    {
      task: '0.1.1',
      description: 'í•„ìˆ˜ ë„êµ¬ ì„¤ì¹˜ í™•ì¸',
      check: async () => {
        try {
          await execAsync('node --version');
          await execAsync('npm --version');
          await execAsync('aws --version');
          await execAsync('docker --version');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    {
      task: '0.1.2',
      description: 'í”„ë¡œì íŠ¸ êµ¬ì¡° ìƒì„±',
      check: async () => {
        const dirs = ['backend', 'frontend', 'infrastructure', 'docs'];
        for (const dir of dirs) {
          try {
            await fs.access(dir);
          } catch {
            return false;
          }
        }
        return true;
      },
      critical: true
    },
    {
      task: '0.1.3',
      description: 'Git ì €ì¥ì†Œ ì´ˆê¸°í™”',
      check: async () => {
        try {
          await fs.access('.git');
          await fs.access('.gitignore');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    {
      task: '0.1.4',
      description: 'í™˜ê²½ ë³€ìˆ˜ í…œí”Œë¦¿',
      check: async () => {
        try {
          await fs.access('.env.example');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    
    // Task 0.2: AWS ê¸°ë³¸ ì„¤ì •
    {
      task: '0.2.1',
      description: 'AWS ê³„ì • ë° ê¶Œí•œ ì„¤ì •',
      check: async () => {
        try {
          const { stdout } = await execAsync('aws sts get-caller-identity');
          return stdout.includes('UserId');
        } catch {
          return false;
        }
      },
      critical: true
    },
    {
      task: '0.2.3',
      description: 'DynamoDB í…Œì´ë¸” ì„¤ê³„',
      check: async () => {
        try {
          await fs.access('infrastructure/dynamodb/schemas');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.3: í”„ë¡œì íŠ¸ ì˜ì¡´ì„± ì„¤ì •
    {
      task: '0.3.1',
      description: 'Backend íŒ¨í‚¤ì§€ ì„¤ì •',
      check: async () => {
        try {
          await fs.access('backend/package.json');
          await fs.access('backend/tsconfig.json');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    {
      task: '0.3.2',
      description: 'Frontend íŒ¨í‚¤ì§€ ì„¤ì •',
      check: async () => {
        try {
          await fs.access('frontend/package.json');
          await fs.access('frontend/vite.config.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    
    // Task 0.4: ë³´ì•ˆ ë° ì¸ì¦ ê¸°ì´ˆ ì„¤ì •
    {
      task: '0.4.1',
      description: 'í™˜ê²½ ë³€ìˆ˜ ì•”í˜¸í™”',
      check: async () => {
        try {
          await fs.access('backend/src/utils/crypto.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.5: ê°œë°œ ë„êµ¬ ì„¤ì •
    {
      task: '0.5.1',
      description: 'ESLint ì„¤ì •',
      check: async () => {
        try {
          await fs.access('.eslintrc.js');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    {
      task: '0.5.2',
      description: 'Prettier ì„¤ì •',
      check: async () => {
        try {
          await fs.access('.prettierrc');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.6: í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì •
    {
      task: '0.6.1',
      description: 'Jest ì„¤ì •',
      check: async () => {
        try {
          await fs.access('backend/jest.config.js');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.7: CI/CD íŒŒì´í”„ë¼ì¸ ê¸°ì´ˆ
    {
      task: '0.7.1',
      description: 'GitHub Actions ì›Œí¬í”Œë¡œìš°',
      check: async () => {
        try {
          await fs.access('.github/workflows');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.8: ë¬¸ì„œí™” ê¸°ë°˜
    {
      task: '0.8.1',
      description: 'ë¬¸ì„œ êµ¬ì¡°',
      check: async () => {
        try {
          await fs.access('docs');
          const files = await fs.readdir('docs');
          return files.length > 0;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.9: ë¡œì»¬ ê°œë°œ í™˜ê²½
    {
      task: '0.9.1',
      description: 'Docker Compose ì„¤ì •',
      check: async () => {
        try {
          await fs.access('docker-compose.yml');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.10: ë³´ì•ˆ ê°•í™”
    {
      task: '0.10.1',
      description: 'ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´',
      check: async () => {
        try {
          await fs.access('backend/src/middleware/security.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.11: ëª¨ë‹ˆí„°ë§ ê¸°ì´ˆ
    {
      task: '0.11.1',
      description: 'ë¡œê¹… ì‹œìŠ¤í…œ',
      check: async () => {
        try {
          await fs.access('backend/src/config/logger.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.12: ê°œë°œ íš¨ìœ¨ì„± ë„êµ¬
    {
      task: '0.12.1',
      description: 'ì½”ë“œ ìƒì„±ê¸°',
      check: async () => {
        try {
          await fs.access('scripts/generators');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    },
    
    // Task 0.13: ì—ì´ì „íŠ¸ ê°œë°œ í™˜ê²½
    {
      task: '0.13.1',
      description: 'ì—ì´ì „íŠ¸ í”„ë ˆì„ì›Œí¬',
      check: async () => {
        try {
          await fs.access('backend/src/agents/framework/base-agent.ts');
          return true;
        } catch {
          return false;
        }
      },
      critical: true
    },
    
    // Task 0.14: Phase 0 ë§ˆë¬´ë¦¬
    {
      task: '0.14.1',
      description: 'í†µí•© í…ŒìŠ¤íŠ¸',
      check: async () => {
        try {
          const { stdout } = await execAsync('npm test -- --passWithNoTests');
          return true;
        } catch {
          return false;
        }
      },
      critical: false
    }
  ];
  
  async run(): Promise<void> {
    console.log(chalk.blue.bold('\nğŸ” Phase 0 ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸\n'));
    console.log(chalk.gray('='.repeat(60)) + '\n');
    
    let passCount = 0;
    let criticalFailCount = 0;
    
    for (const item of this.items) {
      const result = await item.check();
      const icon = result ? chalk.green('âœ…') : chalk.red('âŒ');
      const taskColor = result ? chalk.green : chalk.red;
      
      console.log(
        `${icon} ${chalk.gray(`[${item.task}]`)} ${taskColor(item.description)}` +
        (item.critical && !result ? chalk.red(' (í•„ìˆ˜)') : '')
      );
      
      if (result) {
        passCount++;
      } else if (item.critical) {
        criticalFailCount++;
      }
    }
    
    // ê²°ê³¼ ìš”ì•½
    console.log('\n' + chalk.gray('='.repeat(60)));
    console.log(chalk.blue.bold('\nğŸ“Š ê²°ê³¼ ìš”ì•½\n'));
    
    const totalItems = this.items.length;
    const completionRate = Math.round((passCount / totalItems) * 100);
    
    console.log(`ì™„ë£Œ: ${chalk.green(passCount)}/${totalItems} (${completionRate}%)`);
    console.log(`í•„ìˆ˜ í•­ëª© ì‹¤íŒ¨: ${chalk.red(criticalFailCount)}`);
    
    if (criticalFailCount > 0) {
      console.log('\n' + chalk.red.bold('âŒ Phase 0ë¥¼ ì™„ë£Œí•˜ê¸° ì „ì— í•„ìˆ˜ í•­ëª©ì„ í•´ê²°í•´ì•¼ í•©ë‹ˆë‹¤.'));
    } else if (passCount === totalItems) {
      console.log('\n' + chalk.green.bold('ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! Phase 0ê°€ ì™„ë²½í•˜ê²Œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!'));
      console.log(chalk.green('ì´ì œ Phase 1ë¡œ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'));
    } else {
      console.log('\n' + chalk.yellow.bold('âš ï¸  Phase 0ì˜ í•„ìˆ˜ í•­ëª©ì€ ì™„ë£Œë˜ì—ˆì§€ë§Œ ì¼ë¶€ ì„ íƒ í•­ëª©ì´ ë‚¨ì•„ìˆìŠµë‹ˆë‹¤.'));
      console.log(chalk.yellow('Phase 1ë¡œ ì§„í–‰í•  ìˆ˜ ìˆì§€ë§Œ, ë‚˜ì¤‘ì— ì™„ë£Œí•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.'));
    }
    
    // ë‹¤ìŒ ë‹¨ê³„ ì•ˆë‚´
    console.log('\n' + chalk.blue.bold('ğŸ“Œ ë‹¤ìŒ ë‹¨ê³„:'));
    console.log(chalk.gray('1. ë‚¨ì€ í•­ëª© ì™„ë£Œ (ì„ íƒì‚¬í•­)'));
    console.log(chalk.gray('2. Phase 1: ì½”ì–´ ì¸í”„ë¼ êµ¬ì¶• ì‹œì‘'));
    console.log(chalk.gray('   - npm run phase1:start'));
  }
}

// ì‹¤í–‰
if (require.main === module) {
  const checklist = new Phase0Checklist();
  checklist.run().catch(console.error);
}

export { Phase0Checklist };
```

## Task 0.15: Phase 0 ì™„ë£Œ ë° Phase 1 ì¤€ë¹„

### SubTask 0.15.1: Phase 0 í•™ìŠµ ì •ë¦¬
**ëª©í‘œ**: Phase 0ì—ì„œ ì–»ì€ êµí›ˆê³¼ ê°œì„ ì  ì •ë¦¬

**êµ¬í˜„ ë‚´ìš©**:
```markdown
<!-- docs/phases/phase0-retrospective.md -->
# Phase 0 íšŒê³  ë° í•™ìŠµ ì •ë¦¬

## ğŸ“Š Phase 0 ê°œìš”
- **ê¸°ê°„**: [ì‹œì‘ì¼] ~ [ì¢…ë£Œì¼]
- **ëª©í‘œ**: T-Developer ê°œë°œì„ ìœ„í•œ ê¸°ë°˜ í™˜ê²½ êµ¬ì¶•
- **ì£¼ìš” ì„±ê³¼**: 15ê°œ Tasks, 60+ SubTasks ì™„ë£Œ

## âœ… ì™„ë£Œëœ ì£¼ìš” ì‘ì—…

### 1. ê°œë°œ í™˜ê²½
- âœ… Node.js 18+ ê¸°ë°˜ TypeScript í™˜ê²½ êµ¬ì¶•
- âœ… ëª¨ë…¸ë ˆí¬ êµ¬ì¡° ì„¤ì • (backend/frontend/infrastructure)
- âœ… Git ì›Œí¬í”Œë¡œìš° ë° hooks ì„¤ì •
- âœ… í™˜ê²½ ë³€ìˆ˜ ê´€ë¦¬ ì²´ê³„ êµ¬ì¶•

### 2. AWS ì¸í”„ë¼
- âœ… AWS ê³„ì • ë° IAM ê¶Œí•œ ì„¤ì •
- âœ… DynamoDB ìŠ¤í‚¤ë§ˆ ì„¤ê³„
- âœ… S3 ë²„í‚· êµ¬ì¡° ì„¤ê³„
- âœ… ë¡œì»¬ ê°œë°œìš© AWS ì„œë¹„ìŠ¤ ì—ë®¬ë ˆì´ì…˜

### 3. ê°œë°œ ë„êµ¬
- âœ… ESLint/Prettier ì½”ë“œ í’ˆì§ˆ ë„êµ¬
- âœ… Jest ê¸°ë°˜ í…ŒìŠ¤íŠ¸ í™˜ê²½
- âœ… Docker Compose ë¡œì»¬ í™˜ê²½
- âœ… CI/CD íŒŒì´í”„ë¼ì¸ ê¸°ì´ˆ

### 4. ë³´ì•ˆ ë° ëª¨ë‹ˆí„°ë§
- âœ… ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´ êµ¬í˜„
- âœ… í™˜ê²½ ë³€ìˆ˜ ì•”í˜¸í™”
- âœ… ë¡œê¹… ë° ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ê¸°ë°˜
- âœ… ì…ë ¥ ê²€ì¦ ë° ì‚´ê· 

### 5. ì—ì´ì „íŠ¸ í”„ë ˆì„ì›Œí¬
- âœ… BaseAgent ì¶”ìƒ í´ë˜ìŠ¤
- âœ… ì—ì´ì „íŠ¸ ê°„ í†µì‹  í”„ë¡œí† ì½œ
- âœ… AWS Bedrock/Agent Squad í†µí•© ì¤€ë¹„
- âœ… Agno ëª¨ë‹ˆí„°ë§ í†µí•© ì¤€ë¹„

## ğŸ“š ì£¼ìš” í•™ìŠµ ì‚¬í•­

### 1. ì•„í‚¤í…ì²˜ ê²°ì •
- **ëª¨ë…¸ë ˆí¬ ì ‘ê·¼**: Nx ì—†ì´ë„ npm workspacesë¡œ ì¶©ë¶„
- **TypeScript ì„¤ì •**: strict ëª¨ë“œê°€ ì´ˆê¸°ì—” ë²ˆê±°ë¡­ì§€ë§Œ ì¥ê¸°ì ìœ¼ë¡œ ìœ ë¦¬
- **Docker í™œìš©**: ë¡œì»¬ ê°œë°œ í™˜ê²½ ì¼ê´€ì„± í™•ë³´ì— í•„ìˆ˜

### 2. AWS ì„œë¹„ìŠ¤
- **DynamoDB**: ë‹¨ì¼ í…Œì´ë¸” ì„¤ê³„ê°€ ë³µì¡í•˜ì§€ë§Œ ì„±ëŠ¥ìƒ ì´ì 
- **ë¡œì»¬ ì—ë®¬ë ˆì´ì…˜**: LocalStackë³´ë‹¤ ê°œë³„ ì„œë¹„ìŠ¤ ì»¨í…Œì´ë„ˆê°€ ì•ˆì •ì 
- **IAM ê¶Œí•œ**: ìµœì†Œ ê¶Œí•œ ì›ì¹™ ì¤€ìˆ˜ì˜ ì¤‘ìš”ì„±

### 3. ê°œë°œ í”„ë¡œì„¸ìŠ¤
- **ìë™í™”ì˜ ê°€ì¹˜**: ë°˜ë³µ ì‘ì—…ì€ ì¦‰ì‹œ ìŠ¤í¬ë¦½íŠ¸í™”
- **ë¬¸ì„œí™”**: ì½”ë“œì™€ í•¨ê»˜ ë¬¸ì„œë„ ë™ì‹œ ì‘ì„±ì´ íš¨ìœ¨ì 
- **í…ŒìŠ¤íŠ¸ ìš°ì„ **: TDDëŠ” ì•„ë‹ˆë”ë¼ë„ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ êµ¬ì¡° ì„¤ê³„ í•„ìˆ˜

## ğŸ”§ ê°œì„  í•„ìš” ì‚¬í•­

### 1. ì„±ëŠ¥ ìµœì í™”
- [ ] ë¹Œë“œ ì‹œê°„ ë‹¨ì¶• (í˜„ì¬ 3ë¶„ â†’ ëª©í‘œ 1ë¶„)
- [ ] í…ŒìŠ¤íŠ¸ ë³‘ë ¬í™”ë¡œ ì‹¤í–‰ ì‹œê°„ ê°œì„ 
- [ ] Docker ì´ë¯¸ì§€ í¬ê¸° ìµœì í™”

### 2. ê°œë°œì ê²½í—˜
- [ ] ë” ë‚˜ì€ ì—ëŸ¬ ë©”ì‹œì§€
- [ ] ìë™ ì™„ì„± ë° IntelliSense ê°œì„ 
- [ ] ë””ë²„ê¹… í™˜ê²½ ê°•í™”

### 3. ë¬¸ì„œí™”
- [ ] API ë¬¸ì„œ ìë™ ìƒì„± ê°œì„ 
- [ ] ì¸í„°ë™í‹°ë¸Œ íŠœí† ë¦¬ì–¼ ì¶”ê°€
- [ ] ë¹„ë””ì˜¤ ê°€ì´ë“œ ì œì‘

## ğŸ’¡ Phase 1ì„ ìœ„í•œ ì œì•ˆ

### 1. ìš°ì„ ìˆœìœ„
1. **ì½”ì–´ ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ**: BaseAgentë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ì‹¤ì œ êµ¬í˜„
2. **ë°ì´í„° ë ˆì´ì–´**: DynamoDB í†µí•© ë° ìºì‹± ì „ëµ
3. **API Gateway**: RESTful API ë° WebSocket êµ¬í˜„

### 2. ìœ„í—˜ ìš”ì†Œ
- **Bedrock í†µí•©**: API ì œí•œ ë° ë¹„ìš© ê´€ë¦¬ í•„ìš”
- **ë©€í‹° ì—ì´ì „íŠ¸ ì¡°ì •**: ë³µì¡ë„ ê´€ë¦¬ ì „ëµ í•„ìš”
- **ì‹¤ì‹œê°„ í†µì‹ **: WebSocket ì—°ê²° ì•ˆì •ì„±

### 3. ì„±ê³µ ì§€í‘œ
- ì²« ë²ˆì§¸ ì—ì´ì „íŠ¸ ë™ì‘ í™•ì¸
- ê¸°ë³¸ API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„
- ì—ì´ì „íŠ¸ ê°„ í†µì‹  ê²€ì¦

## ğŸ¯ ë‹¤ìŒ ë‹¨ê³„

### Phase 1 ì‹œì‘ ì¤€ë¹„
```bash
# Phase 1 ë¸Œëœì¹˜ ìƒì„±
git checkout -b phase1-core-infrastructure

# Phase 1 ì‘ì—… ë””ë ‰í† ë¦¬ ì¤€ë¹„
mkdir -p backend/src/core
mkdir -p backend/src/data
mkdir -p backend/src/api

# Phase 1 ì²´í¬ë¦¬ìŠ¤íŠ¸ ìƒì„±
npm run phase1:init
```

### íŒ€ ì¤€ë¹„ ì‚¬í•­
1. Phase 0 ì½”ë“œ ë¦¬ë·° ì™„ë£Œ
2. AWS ê¶Œí•œ ë° ë¦¬ì†ŒìŠ¤ í™•ì¸
3. Phase 1 ì‘ì—… ë¶„ë‹´ íšŒì˜

---

**ì‘ì„±ì¼**: 2024-XX-XX  
**ì‘ì„±ì**: T-Developer Team
```

### SubTask 0.15.2: Phase 1 ì´ˆê¸° ì„¤ì •
**ëª©í‘œ**: Phase 1 ì‘ì—…ì„ ìœ„í•œ ê¸°ì´ˆ ì„¤ì •

**êµ¬í˜„ ë‚´ìš©**:
```typescript
// scripts/init-phase1.ts
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';

class Phase1Initializer {
  async initialize(): Promise<void> {
    console.log(chalk.blue.bold('\nğŸš€ Phase 1: ì½”ì–´ ì¸í”„ë¼ êµ¬ì¶• ì´ˆê¸°í™”\n'));
    
    // 1. ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„±
    await this.createDirectoryStructure();
    
    // 2. ê¸°ë³¸ íŒŒì¼ ìƒì„±
    await this.createBaseFiles();
    
    // 3. Phase 1 ì²´í¬ë¦¬ìŠ¤íŠ¸ ìƒì„±
    await this.createChecklist();
    
    console.log(chalk.green.bold('\nâœ… Phase 1 ì´ˆê¸°í™” ì™„ë£Œ!\n'));
    console.log(chalk.gray('ë‹¤ìŒ ëª…ë ¹ìœ¼ë¡œ ì‹œì‘í•˜ì„¸ìš”:'));
    console.log(chalk.cyan('  cd backend/src/core'));
    console.log(chalk.cyan('  npm run dev'));
  }
  
  private async createDirectoryStructure(): Promise<void> {
    const directories = [
      // ì½”ì–´ ì‹œìŠ¤í…œ
      'backend/src/core/config',
      'backend/src/core/errors',
      'backend/src/core/interfaces',
      'backend/src/core/utils',
      
      // ë°ì´í„° ë ˆì´ì–´
      'backend/src/data/repositories',
      'backend/src/data/models',
      'backend/src/data/migrations',
      'backend/src/data/cache',
      
      // API ë ˆì´ì–´
      'backend/src/api/controllers',
      'backend/src/api/routes',
      'backend/src/api/middleware',
      'backend/src/api/validators',
      
      // ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ
      'backend/src/agents/implementations',
      'backend/src/agents/orchestrator',
      'backend/src/agents/registry',
      
      // í…ŒìŠ¤íŠ¸
      'backend/tests/core',
      'backend/tests/data',
      'backend/tests/api',
      'backend/tests/agents'
    ];
    
    for (const dir of directories) {
      await fs.mkdir(dir, { recursive: true });
      console.log(chalk.green(`âœ“ Created: ${dir}`));
    }
  }
  
  private async createBaseFiles(): Promise<void> {
    // ì½”ì–´ ì„¤ì • íŒŒì¼
    const coreConfig = `// backend/src/core/config/index.ts
export interface CoreConfig {
  app: {
    name: string;
    version: string;
    env: string;
  };
  server: {
    port: number;
    host: string;
  };
  database: {
    dynamodb: {
      region: string;
      endpoint?: string;
    };
  };
  cache: {
    redis: {
      host: string;
      port: number;
    };
  };
  agents: {
    maxConcurrent: number;
    timeout: number;
  };
}

export const config: CoreConfig = {
  app: {
    name: 'T-Developer',
    version: process.env.npm_package_version || '1.0.0',
    env: process.env.NODE_ENV || 'development'
  },
  server: {
    port: parseInt(process.env.PORT || '3000'),
    host: process.env.HOST || '0.0.0.0'
  },
  database: {
    dynamodb: {
      region: process.env.AWS_REGION || 'us-east-1',
      endpoint: process.env.DYNAMODB_ENDPOINT
    }
  },
  cache: {
    redis: {
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379')
    }
  },
  agents: {
    maxConcurrent: parseInt(process.env.MAX_CONCURRENT_AGENTS || '50'),
    timeout: parseInt(process.env.AGENT_TIMEOUT || '300000')
  }
};
`;
    
    await fs.writeFile(
      'backend/src/core/config/index.ts',
      coreConfig
    );
    
    // ì—ëŸ¬ í´ë˜ìŠ¤
    const baseError = `// backend/src/core/errors/base-error.ts
export abstract class BaseError extends Error {
  abstract statusCode: number;
  abstract code: string;
  
  constructor(message: string) {
    super(message);
    Object.setPrototypeOf(this, BaseError.prototype);
  }
  
  abstract serializeErrors(): { message: string; field?: string }[];
}

export class NotFoundError extends BaseError {
  statusCode = 404;
  code = 'NOT_FOUND';
  
  constructor(public resource: string) {
    super(\`Resource not found: \${resource}\`);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
  
  serializeErrors() {
    return [{ message: this.message }];
  }
}
`;
    
    await fs.writeFile(
      'backend/src/core/errors/base-error.ts',
      baseError
    );
    
    console.log(chalk.green('âœ“ Created base files'));
  }
  
  private async createChecklist(): Promise<void> {
    const checklist = `# Phase 1: ì½”ì–´ ì¸í”„ë¼ êµ¬ì¶• ì²´í¬ë¦¬ìŠ¤íŠ¸

## Task 1.1: í•µì‹¬ ì„¤ì • ì‹œìŠ¤í…œ
- [ ] ì¤‘ì•™ ì„¤ì • ê´€ë¦¬ì êµ¬í˜„
- [ ] í™˜ê²½ë³„ ì„¤ì • ë¡œë”
- [ ] ì„¤ì • ê²€ì¦ ì‹œìŠ¤í…œ
- [ ] ë™ì  ì„¤ì • ë¦¬ë¡œë“œ

## Task 1.2: ì—ëŸ¬ ì²˜ë¦¬ ì‹œìŠ¤í…œ
- [ ] ì»¤ìŠ¤í…€ ì—ëŸ¬ í´ë˜ìŠ¤ ê³„ì¸µêµ¬ì¡°
- [ ] ì „ì—­ ì—ëŸ¬ í•¸ë“¤ëŸ¬
- [ ] ì—ëŸ¬ ë¡œê¹… ë° ì¶”ì 
- [ ] ì—ëŸ¬ ë³µêµ¬ ì „ëµ

## Task 1.3: ë¡œê¹… ì¸í”„ë¼
- [ ] êµ¬ì¡°í™”ëœ ë¡œê¹… ì‹œìŠ¤í…œ
- [ ] ë¡œê·¸ ë ˆë²¨ ê´€ë¦¬
- [ ] ë¡œê·¸ ì§‘ê³„ ë° ì „ì†¡
- [ ] ì„±ëŠ¥ ë©”íŠ¸ë¦­ ë¡œê¹…

## Task 1.4: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
- [ ] DynamoDB í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
- [ ] ì—°ê²° í’€ ê´€ë¦¬
- [ ] ì¬ì‹œë„ ë¡œì§
- [ ] ì—°ê²° ëª¨ë‹ˆí„°ë§

## Task 1.5: ìºì‹± ì‹œìŠ¤í…œ
- [ ] Redis í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
- [ ] ìºì‹œ ì „ëµ êµ¬í˜„
- [ ] ìºì‹œ ë¬´íš¨í™” ë¡œì§
- [ ] ìºì‹œ íˆíŠ¸ìœ¨ ëª¨ë‹ˆí„°ë§

... (ì¶”ê°€ Tasks)
`;
    
    await fs.writeFile(
      'docs/phases/phase1-checklist.md',
      checklist
    );
    
    console.log(chalk.green('âœ“ Created Phase 1 checklist'));
  }
}

// ì‹¤í–‰
if (require.main === module) {
  const initializer = new Phase1Initializer();
  initializer.initialize().catch(console.error);
}
```

### SubTask 0.15.3: Phase 0 ì•„ì¹´ì´ë¸Œ ë° ë¬¸ì„œ ì •ë¦¬
**ëª©í‘œ**: Phase 0ì˜ ëª¨ë“  ì‘ì—…ë¬¼ì„ ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬í•˜ê³  ë³´ê´€

**êµ¬í˜„ ë‚´ìš©**:
```bash
#!/bin/bash
# scripts/archive-phase0.sh

echo "ğŸ“¦ Phase 0 ì•„ì¹´ì´ë¸Œ ì‹œì‘..."

# 1. Phase 0 íƒœê·¸ ìƒì„±
git tag -a "phase0-complete" -m "Phase 0: ì‚¬ì „ ì¤€ë¹„ ë° í™˜ê²½ ì„¤ì • ì™„ë£Œ"

# 2. ë¬¸ì„œ ì •ë¦¬
mkdir -p docs/archive/phase0
cp -r docs/setup docs/archive/phase0/
cp -r docs/phases/phase0-* docs/archive/phase0/

# 3. ì„¤ì • íŒŒì¼ ë°±ì—…
mkdir -p backups/phase0
cp .env.example backups/phase0/
cp package.json backups/phase0/
cp -r .github backups/phase0/

# 4. ì²´í¬ë¦¬ìŠ¤íŠ¸ ì €ì¥
npm run phase0:checklist > docs/archive/phase0/final-checklist.txt

# 5. í†µê³„ ìƒì„±
echo "ğŸ“Š Phase 0 í†µê³„ ìƒì„± ì¤‘..."
cat > docs/archive/phase0/statistics.md << EOF
# Phase 0 í†µê³„

## ì½”ë“œ í†µê³„
- ì´ íŒŒì¼ ìˆ˜: $(find . -type f -name "*.ts" -o -name "*.js" | wc -l)
- TypeScript ë¼ì¸ ìˆ˜: $(find . -name "*.ts" -exec wc -l {} + | tail -1 | awk '{print $1}')
- í…ŒìŠ¤íŠ¸ íŒŒì¼ ìˆ˜: $(find . -name "*.test.ts" -o -name "*.spec.ts" | wc -l)

## Git í†µê³„
- ì´ ì»¤ë°‹ ìˆ˜: $(git rev-list --count HEAD)
- ê¸°ì—¬ì ìˆ˜: $(git shortlog -sn | wc -l)

## ì˜ì¡´ì„±
- Backend íŒ¨í‚¤ì§€: $(cd backend && npm ls --depth=0 | wc -l)
- Frontend íŒ¨í‚¤ì§€: $(cd frontend && npm ls --depth=0 | wc -l)

ìƒì„±ì¼: $(date)
EOF

echo "âœ… Phase 0 ì•„ì¹´ì´ë¸Œ ì™„ë£Œ!"
echo "ğŸ“ ì•„ì¹´ì´ë¸Œ ìœ„ì¹˜: docs/archive/phase0/"
```

---

ì´ì œ Phase 0ì˜ ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! 

Phase 0ì—ì„œëŠ” T-Developer í”„ë¡œì íŠ¸ì˜ ê¸°ë°˜ì´ ë˜ëŠ” ë‹¤ìŒê³¼ ê°™ì€ í•µì‹¬ ìš”ì†Œë“¤ì„ êµ¬ì¶•í–ˆìŠµë‹ˆë‹¤:

1. **ê°œë°œ í™˜ê²½**: Node.js, TypeScript, AWS CLI, Docker ë“± í•„ìˆ˜ ë„êµ¬ ì„¤ì •
2. **í”„ë¡œì íŠ¸ êµ¬ì¡°**: ëª¨ë…¸ë ˆí¬ êµ¬ì¡°ì™€ ì²´ê³„ì ì¸ ë””ë ‰í† ë¦¬ êµ¬ì„±
3. **AWS ì¸í”„ë¼**: DynamoDB, S3, Bedrock í†µí•© ì¤€ë¹„
4. **ê°œë°œ ë„êµ¬**: ESLint, Prettier, Jest, Git hooks
5. **ë³´ì•ˆ**: í™˜ê²½ ë³€ìˆ˜ ì•”í˜¸í™”, ì…ë ¥ ê²€ì¦, ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´
6. **CI/CD**: GitHub Actions ì›Œí¬í”Œë¡œìš°
7. **ë¬¸ì„œí™”**: í¬ê´„ì ì¸ ê°œë°œ ê°€ì´ë“œ ë° API ë¬¸ì„œ
8. **ëª¨ë‹ˆí„°ë§**: ë¡œê¹…, ë©”íŠ¸ë¦­, ì—ëŸ¬ ì¶”ì 
9. **ì—ì´ì „íŠ¸ í”„ë ˆì„ì›Œí¬**: BaseAgent ë° í†µì‹  í”„ë¡œí† ì½œ
10. **í†µí•© ì¤€ë¹„**: AWS Agent Squad, Bedrock AgentCore, Agno