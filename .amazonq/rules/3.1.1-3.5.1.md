# Phase 3: 에이전트 프레임워크 구축 - 전체 SubTask 작업지시 문서

## 📋 Phase 3 개요
- **목표**: T-Developer의 9개 핵심 에이전트를 위한 포괄적인 프레임워크 구축
- **범위**: 20개 Tasks × 4 SubTasks = 80개 작업 단위
- **기간**: 예상 10-12주
- **전제조건**: Phase 1 코어 인프라 완료, Phase 2 데이터 레이어 완료

---

## 🏗️ Phase 3 전체 Task 구조

### 에이전트 기본 프레임워크 (Tasks 3.1-3.4)
- Task 3.1: 에이전트 베이스 클래스 설계
- Task 3.2: 에이전트 생명주기 관리
- Task 3.3: 에이전트 통신 프로토콜
- Task 3.4: 에이전트 상태 관리

### 9개 핵심 에이전트 구현 (Tasks 3.5-3.13)
- Task 3.5: Business Analyst Agent 구현
- Task 3.6: System Design Agent 구현
- Task 3.7: Frontend Agent 구현
- Task 3.8: Backend Agent 구현
- Task 3.9: Data Agent 구현
- Task 3.10: Test Agent 구현
- Task 3.11: Security Agent 구현
- Task 3.12: DevOps Agent 구현
- Task 3.13: Document Agent 구현

### 에이전트 협업 시스템 (Tasks 3.14-3.16)
- Task 3.14: 에이전트 간 협업 프로토콜
- Task 3.15: 워크플로우 오케스트레이션
- Task 3.16: 에이전트 체인 관리

### 에이전트 관리 시스템 (Tasks 3.17-3.20)
- Task 3.17: 에이전트 레지스트리 시스템
- Task 3.18: 에이전트 모니터링 및 분석
- Task 3.19: 에이전트 버전 관리
- Task 3.20: 에이전트 성능 최적화

---

## 📝 세부 작업지시서

### Task 3.1: 에이전트 베이스 클래스 설계

#### SubTask 3.1.1: 추상 베이스 에이전트 클래스 구현
**담당자**: 시니어 백엔드 아키텍트  
**예상 소요시간**: 16시간

**작업 내용**:
```python
# backend/src/agents/framework/base_agent.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
import asyncio
from dataclasses import dataclass
from enum import Enum
import uuid
from datetime import datetime

class AgentStatus(Enum):
    IDLE = "idle"
    PROCESSING = "processing"
    WAITING = "waiting"
    ERROR = "error"
    COMPLETED = "completed"

@dataclass
class AgentContext:
    project_id: str
    session_id: str
    user_id: str
    workspace_path: str
    metadata: Dict[str, Any]

@dataclass
class AgentMessage:
    id: str
    type: str
    sender: str
    recipient: str
    payload: Dict[str, Any]
    timestamp: datetime
    correlation_id: Optional[str] = None

class BaseAgent(ABC):
    """Base class for all T-Developer agents"""
    
    def __init__(self, name: str, version: str = "1.0.0"):
        self.id = str(uuid.uuid4())
        self.name = name
        self.version = version
        self.status = AgentStatus.IDLE
        self.context: Optional[AgentContext] = None
        self.capabilities: List[str] = []
        self.dependencies: List[str] = []
        self._message_queue: asyncio.Queue = asyncio.Queue()
        self._tasks: List[asyncio.Task] = []
        
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize agent resources and connections"""
        pass
    
    @abstractmethod
    async def process_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Process a specific task"""
        pass
    
    @abstractmethod
    def get_capabilities(self) -> List[Dict[str, Any]]:
        """Return agent capabilities"""
        pass
    
    async def start(self, context: AgentContext) -> None:
        """Start the agent with given context"""
        self.context = context
        await self.initialize()
        self.status = AgentStatus.IDLE
        
        # Start message processing loop
        task = asyncio.create_task(self._process_messages())
        self._tasks.append(task)
    
    async def stop(self) -> None:
        """Stop the agent gracefully"""
        self.status = AgentStatus.IDLE
        
        # Cancel all tasks
        for task in self._tasks:
            task.cancel()
        
        await asyncio.gather(*self._tasks, return_exceptions=True)
        self._tasks.clear()
    
    async def send_message(self, message: AgentMessage) -> None:
        """Send message to message queue"""
        await self._message_queue.put(message)
    
    async def _process_messages(self) -> None:
        """Process messages from queue"""
        while True:
            try:
                message = await self._message_queue.get()
                await self._handle_message(message)
            except asyncio.CancelledError:
                break
            except Exception as e:
                await self._handle_error(e)
    
    @abstractmethod
    async def _handle_message(self, message: AgentMessage) -> None:
        """Handle incoming message"""
        pass
    
    async def _handle_error(self, error: Exception) -> None:
        """Handle errors"""
        self.status = AgentStatus.ERROR
        # Log error and emit event
```

**검증 기준**:
- [ ] 모든 에이전트가 상속할 수 있는 완전한 베이스 클래스
- [ ] 비동기 메시지 처리 지원
- [ ] 상태 관리 및 생명주기 메서드 구현
- [ ] 확장 가능한 구조

#### SubTask 3.1.2: Agno Framework 통합 레이어
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**작업 내용**:
```typescript
// backend/src/agents/framework/agno-integration.ts
import { Agent as AgnoAgent } from 'agno';
import { AwsBedrock } from 'agno/models/aws';
import { BaseAgent } from './base-agent';

export interface AgnoConfig {
  modelId: string;
  temperature?: number;
  maxTokens?: number;
  tools?: any[];
  memory?: any;
}

export class AgnoEnabledAgent extends BaseAgent {
  protected agnoAgent: AgnoAgent;
  protected agnoConfig: AgnoConfig;
  
  constructor(name: string, agnoConfig: AgnoConfig) {
    super(name);
    this.agnoConfig = agnoConfig;
  }
  
  async initialize(): Promise<void> {
    // Initialize Agno agent
    this.agnoAgent = new AgnoAgent({
      name: this.name,
      model: new AwsBedrock({ id: this.agnoConfig.modelId }),
      temperature: this.agnoConfig.temperature || 0.7,
      maxTokens: this.agnoConfig.maxTokens || 4000,
      tools: this.agnoConfig.tools || [],
      memory: this.agnoConfig.memory
    });
    
    // Set up Agno event handlers
    this.agnoAgent.on('thinking', (thought) => {
      this.emit('agent:thinking', { agent: this.name, thought });
    });
    
    this.agnoAgent.on('tool_use', (tool) => {
      this.emit('agent:tool_use', { agent: this.name, tool });
    });
  }
  
  async processWithAgno(prompt: string, context?: any): Promise<any> {
    try {
      const response = await this.agnoAgent.run(prompt, {
        context,
        stream: false
      });
      
      return response;
    } catch (error) {
      this.handleAgnoError(error);
      throw error;
    }
  }
  
  protected handleAgnoError(error: any): void {
    // Specific error handling for Agno
    if (error.code === 'TOKEN_LIMIT_EXCEEDED') {
      this.emit('agent:error', {
        type: 'token_limit',
        message: 'Token limit exceeded, splitting task'
      });
    }
  }
}
```

#### SubTask 3.1.3: Agent Squad 통합 컴포넌트
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**작업 내용**:
```python
# backend/src/agents/framework/squad_integration.py
from agent_squad import SupervisorAgent, SupervisorAgentOptions
from agent_squad.agents import BedrockLLMAgent, BedrockLLMAgentOptions
from typing import List, Dict, Any, Optional
from .base_agent import BaseAgent, AgentMessage

class SquadEnabledAgent(BaseAgent):
    """Base class for agents that use Agent Squad"""
    
    def __init__(self, name: str, team_size: int = 3):
        super().__init__(name)
        self.team_size = team_size
        self.supervisor: Optional[SupervisorAgent] = None
        self.team_agents: List[BedrockLLMAgent] = []
        
    async def initialize(self) -> None:
        """Initialize Agent Squad supervisor and team"""
        await super().initialize()
        
        # Create team agents
        self.team_agents = await self._create_team_agents()
        
        # Create supervisor
        self.supervisor = SupervisorAgent(SupervisorAgentOptions(
            name=f"{self.name}_Supervisor",
            description=f"Supervisor for {self.name}",
            lead_agent=self._create_lead_agent(),
            team=self.team_agents,
            supervise_style="collaborative",
            planning_mode="step_by_step",
            output_format="structured"
        ))
        
        await self.supervisor.initialize()
    
    def _create_lead_agent(self) -> BedrockLLMAgent:
        """Create lead agent for the squad"""
        return BedrockLLMAgent(BedrockLLMAgentOptions(
            name=f"{self.name}_Lead",
            description=f"Lead agent for {self.name}",
            model_id="anthropic.claude-3-opus-v1:0",
            temperature=0.3,
            system_prompt=self._get_lead_system_prompt()
        ))
    
    async def _create_team_agents(self) -> List[BedrockLLMAgent]:
        """Create specialized team agents"""
        agents = []
        
        for i in range(self.team_size):
            agent = BedrockLLMAgent(BedrockLLMAgentOptions(
                name=f"{self.name}_TeamMember_{i}",
                description=f"Team member {i} for {self.name}",
                model_id="anthropic.claude-3-sonnet-v2:0",
                temperature=0.5,
                system_prompt=self._get_team_member_prompt(i)
            ))
            agents.append(agent)
        
        return agents
    
    async def execute_with_squad(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Execute task using Agent Squad"""
        if not self.supervisor:
            raise RuntimeError("Squad not initialized")
        
        # Prepare task for supervisor
        squad_task = {
            "objective": task.get("objective"),
            "context": task.get("context"),
            "requirements": task.get("requirements"),
            "constraints": task.get("constraints")
        }
        
        # Execute with supervisor
        result = await self.supervisor.execute(squad_task)
        
        return {
            "status": "completed",
            "result": result.output,
            "reasoning": result.reasoning,
            "team_contributions": result.team_contributions
        }
    
    @abstractmethod
    def _get_lead_system_prompt(self) -> str:
        """Get system prompt for lead agent"""
        pass
    
    @abstractmethod
    def _get_team_member_prompt(self, index: int) -> str:
        """Get system prompt for team member"""
        pass
```

#### SubTask 3.1.4: Bedrock AgentCore 런타임 통합
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**작업 내용**:
```typescript
// backend/src/agents/framework/bedrock-runtime.ts
import { BedrockAgentRuntime } from '@aws-sdk/client-bedrock-agent-runtime';
import { BaseAgent } from './base-agent';

export interface BedrockRuntimeConfig {
  region: string;
  agentId: string;
  agentAliasId: string;
  knowledgeBaseId?: string;
  sessionId?: string;
}

export class BedrockEnabledAgent extends BaseAgent {
  private runtime: BedrockAgentRuntime;
  private config: BedrockRuntimeConfig;
  
  constructor(name: string, config: BedrockRuntimeConfig) {
    super(name);
    this.config = config;
    this.runtime = new BedrockAgentRuntime({
      region: config.region
    });
  }
  
  async initialize(): Promise<void> {
    await super.initialize();
    
    // Verify agent exists
    try {
      const agent = await this.runtime.getAgent({
        agentId: this.config.agentId
      });
      
      console.log(`Bedrock agent ${agent.agentName} initialized`);
    } catch (error) {
      throw new Error(`Failed to initialize Bedrock agent: ${error}`);
    }
  }
  
  async invokeAgent(input: string, sessionAttributes?: Record<string, string>): Promise<any> {
    const sessionId = this.config.sessionId || this.generateSessionId();
    
    try {
      const response = await this.runtime.invokeAgent({
        agentId: this.config.agentId,
        agentAliasId: this.config.agentAliasId,
        sessionId,
        inputText: input,
        sessionState: {
          sessionAttributes
        }
      });
      
      // Process streaming response
      const chunks: any[] = [];
      if (response.completion) {
        for await (const chunk of response.completion) {
          chunks.push(chunk);
          
          // Emit progress events
          if (chunk.chunk?.bytes) {
            const text = new TextDecoder().decode(chunk.chunk.bytes);
            this.emit('agent:streaming', { text });
          }
        }
      }
      
      return this.processAgentResponse(chunks);
    } catch (error) {
      this.handleBedrockError(error);
      throw error;
    }
  }
  
  async queryKnowledgeBase(query: string): Promise<any> {
    if (!this.config.knowledgeBaseId) {
      throw new Error('Knowledge base ID not configured');
    }
    
    const response = await this.runtime.retrieveAndGenerate({
      input: { text: query },
      retrieveAndGenerateConfiguration: {
        type: 'KNOWLEDGE_BASE',
        knowledgeBaseConfiguration: {
          knowledgeBaseId: this.config.knowledgeBaseId,
          modelArn: `arn:aws:bedrock:${this.config.region}::foundation-model/anthropic.claude-3-sonnet-v2:0`
        }
      }
    });
    
    return response;
  }
  
  private processAgentResponse(chunks: any[]): any {
    // Process and combine chunks
    const fullResponse = chunks
      .map(chunk => {
        if (chunk.chunk?.bytes) {
          return new TextDecoder().decode(chunk.chunk.bytes);
        }
        return '';
      })
      .join('');
    
    return {
      text: fullResponse,
      metadata: chunks[chunks.length - 1]?.metadata || {}
    };
  }
  
  private handleBedrockError(error: any): void {
    if (error.name === 'ThrottlingException') {
      this.emit('agent:throttled', { retryAfter: 5000 });
    } else if (error.name === 'ValidationException') {
      this.emit('agent:validation_error', { message: error.message });
    }
  }
  
  private generateSessionId(): string {
    return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

---

### Task 3.2: 에이전트 생명주기 관리

#### SubTask 3.2.1: 에이전트 초기화 시스템
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**작업 내용**:
```python
# backend/src/agents/lifecycle/initializer.py
from typing import Dict, Any, List, Optional
import asyncio
from dataclasses import dataclass
import yaml
import json

@dataclass
class AgentConfiguration:
    name: str
    type: str
    version: str
    model_config: Dict[str, Any]
    dependencies: List[str]
    resources: Dict[str, Any]
    environment: Dict[str, str]

class AgentInitializer:
    """Manages agent initialization and bootstrapping"""
    
    def __init__(self, config_path: str):
        self.config_path = config_path
        self.configurations: Dict[str, AgentConfiguration] = {}
        self.initialized_agents: Dict[str, Any] = {}
        self._load_configurations()
    
    def _load_configurations(self) -> None:
        """Load agent configurations from file"""
        with open(self.config_path, 'r') as f:
            if self.config_path.endswith('.yaml'):
                configs = yaml.safe_load(f)
            else:
                configs = json.load(f)
        
        for agent_config in configs['agents']:
            config = AgentConfiguration(**agent_config)
            self.configurations[config.name] = config
    
    async def initialize_agent(self, agent_name: str) -> Any:
        """Initialize a single agent"""
        if agent_name in self.initialized_agents:
            return self.initialized_agents[agent_name]
        
        config = self.configurations.get(agent_name)
        if not config:
            raise ValueError(f"No configuration found for agent: {agent_name}")
        
        # Check dependencies first
        await self._initialize_dependencies(config.dependencies)
        
        # Create agent instance
        agent_class = self._get_agent_class(config.type)
        agent = agent_class(
            name=config.name,
            version=config.version,
            **config.model_config
        )
        
        # Initialize resources
        await self._initialize_resources(agent, config.resources)
        
        # Set environment
        await self._set_environment(agent, config.environment)
        
        # Initialize agent
        await agent.initialize()
        
        self.initialized_agents[agent_name] = agent
        return agent
    
    async def _initialize_dependencies(self, dependencies: List[str]) -> None:
        """Initialize agent dependencies"""
        for dep in dependencies:
            if dep not in self.initialized_agents:
                await self.initialize_agent(dep)
    
    async def _initialize_resources(self, agent: Any, resources: Dict[str, Any]) -> None:
        """Initialize agent resources (DB connections, file systems, etc.)"""
        for resource_type, resource_config in resources.items():
            if resource_type == 'database':
                await self._setup_database(agent, resource_config)
            elif resource_type == 'storage':
                await self._setup_storage(agent, resource_config)
            elif resource_type == 'cache':
                await self._setup_cache(agent, resource_config)
            elif resource_type == 'knowledge_base':
                await self._setup_knowledge_base(agent, resource_config)
    
    async def _setup_database(self, agent: Any, config: Dict[str, Any]) -> None:
        """Setup database connections for agent"""
        from ...data.connection_pool import get_connection
        
        connection = await get_connection(
            db_type=config['type'],
            connection_string=config['connection_string']
        )
        agent.set_database(connection)
    
    async def _setup_storage(self, agent: Any, config: Dict[str, Any]) -> None:
        """Setup storage access for agent"""
        from ...storage.s3_client import S3Client
        
        storage_client = S3Client(
            bucket=config['bucket'],
            prefix=f"agents/{agent.name}"
        )
        agent.set_storage(storage_client)
    
    async def _setup_cache(self, agent: Any, config: Dict[str, Any]) -> None:
        """Setup caching for agent"""
        from ...cache.redis_client import RedisCache
        
        cache = RedisCache(
            host=config['host'],
            port=config['port'],
            ttl=config.get('ttl', 3600)
        )
        agent.set_cache(cache)
    
    async def _setup_knowledge_base(self, agent: Any, config: Dict[str, Any]) -> None:
        """Setup knowledge base access for agent"""
        if config['type'] == 'bedrock':
            agent.set_knowledge_base_id(config['knowledge_base_id'])
    
    async def _set_environment(self, agent: Any, environment: Dict[str, str]) -> None:
        """Set agent environment variables"""
        for key, value in environment.items():
            agent.set_env(key, value)
    
    def _get_agent_class(self, agent_type: str):
        """Get agent class by type"""
        from ..implementations import (
            BusinessAnalystAgent,
            SystemDesignAgent,
            FrontendAgent,
            BackendAgent,
            DataAgent,
            TestAgent,
            SecurityAgent,
            DevOpsAgent,
            DocumentAgent
        )
        
        agent_map = {
            'business_analyst': BusinessAnalystAgent,
            'system_design': SystemDesignAgent,
            'frontend': FrontendAgent,
            'backend': BackendAgent,
            'data': DataAgent,
            'test': TestAgent,
            'security': SecurityAgent,
            'devops': DevOpsAgent,
            'document': DocumentAgent
        }
        
        return agent_map.get(agent_type)
    
    async def initialize_all_agents(self) -> Dict[str, Any]:
        """Initialize all configured agents"""
        tasks = []
        for agent_name in self.configurations:
            task = asyncio.create_task(self.initialize_agent(agent_name))
            tasks.append((agent_name, task))
        
        results = {}
        for agent_name, task in tasks:
            try:
                agent = await task
                results[agent_name] = agent
            except Exception as e:
                print(f"Failed to initialize {agent_name}: {e}")
                results[agent_name] = None
        
        return results
```

#### SubTask 3.2.2: 에이전트 상태 모니터링
**담당자**: 백엔드 개발자  
**예상 소요시간**: 10시간

**작업 내용**:
```typescript
// backend/src/agents/lifecycle/monitor.ts
import { EventEmitter } from 'events';
import { BaseAgent, AgentStatus } from '../framework/base-agent';
import { MetricsCollector } from '../../monitoring/metrics';

interface AgentMetrics {
  agentId: string;
  agentName: string;
  status: AgentStatus;
  uptime: number;
  taskCount: number;
  successRate: number;
  avgResponseTime: number;
  lastError?: string;
  resourceUsage: {
    cpu: number;
    memory: number;
    tokenUsage: number;
  };
}

interface HealthCheck {
  isHealthy: boolean;
  checks: {
    connectivity: boolean;
    responseTime: boolean;
    errorRate: boolean;
    resourceUsage: boolean;
  };
  message?: string;
}

export class AgentMonitor extends EventEmitter {
  private agents: Map<string, BaseAgent> = new Map();
  private metrics: Map<string, AgentMetrics> = new Map();
  private metricsCollector: MetricsCollector;
  private healthCheckInterval: NodeJS.Timeout;
  
  constructor(metricsCollector: MetricsCollector) {
    super();
    this.metricsCollector = metricsCollector;
  }
  
  registerAgent(agent: BaseAgent): void {
    this.agents.set(agent.id, agent);
    
    // Initialize metrics
    this.metrics.set(agent.id, {
      agentId: agent.id,
      agentName: agent.name,
      status: agent.status,
      uptime: 0,
      taskCount: 0,
      successRate: 100,
      avgResponseTime: 0,
      resourceUsage: {
        cpu: 0,
        memory: 0,
        tokenUsage: 0
      }
    });
    
    // Attach event listeners
    this.attachAgentListeners(agent);
  }
  
  private attachAgentListeners(agent: BaseAgent): void {
    agent.on('status_change', (status: AgentStatus) => {
      this.updateAgentStatus(agent.id, status);
    });
    
    agent.on('task_completed', (task: any) => {
      this.recordTaskCompletion(agent.id, task);
    });
    
    agent.on('error', (error: any) => {
      this.recordError(agent.id, error);
    });
    
    agent.on('resource_usage', (usage: any) => {
      this.updateResourceUsage(agent.id, usage);
    });
  }
  
  startMonitoring(intervalMs: number = 30000): void {
    this.healthCheckInterval = setInterval(() => {
      this.performHealthChecks();
    }, intervalMs);
  }
  
  stopMonitoring(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
  }
  
  private async performHealthChecks(): Promise<void> {
    for (const [agentId, agent] of this.agents) {
      const health = await this.checkAgentHealth(agent);
      
      if (!health.isHealthy) {
        this.emit('agent_unhealthy', {
          agentId,
          agentName: agent.name,
          health
        });
        
        // Attempt recovery
        await this.attemptRecovery(agent);
      }
    }
  }
  
  private async checkAgentHealth(agent: BaseAgent): Promise<HealthCheck> {
    const metrics = this.metrics.get(agent.id);
    if (!metrics) {
      return { isHealthy: false, checks: {} as any };
    }
    
    const checks = {
      connectivity: await this.checkConnectivity(agent),
      responseTime: metrics.avgResponseTime < 5000, // 5 second threshold
      errorRate: metrics.successRate > 90, // 90% success rate threshold
      resourceUsage: this.checkResourceLimits(metrics.resourceUsage)
    };
    
    const isHealthy = Object.values(checks).every(check => check);
    
    return {
      isHealthy,
      checks,
      message: isHealthy ? 'Agent is healthy' : 'Agent health check failed'
    };
  }
  
  private async checkConnectivity(agent: BaseAgent): Promise<boolean> {
    try {
      // Send ping message
      const response = await agent.ping();
      return response.status === 'ok';
    } catch {
      return false;
    }
  }
  
  private checkResourceLimits(usage: any): boolean {
    return usage.cpu < 80 && usage.memory < 80; // 80% threshold
  }
  
  private async attemptRecovery(agent: BaseAgent): Promise<void> {
    console.log(`Attempting recovery for agent ${agent.name}`);
    
    try {
      // Try restart
      await agent.stop();
      await agent.start(agent.context!);
      
      this.emit('agent_recovered', {
        agentId: agent.id,
        agentName: agent.name
      });
    } catch (error) {
      this.emit('agent_recovery_failed', {
        agentId: agent.id,
        agentName: agent.name,
        error
      });
    }
  }
  
  getAgentMetrics(agentId: string): AgentMetrics | undefined {
    return this.metrics.get(agentId);
  }
  
  getAllMetrics(): AgentMetrics[] {
    return Array.from(this.metrics.values());
  }
  
  private updateAgentStatus(agentId: string, status: AgentStatus): void {
    const metrics = this.metrics.get(agentId);
    if (metrics) {
      metrics.status = status;
      this.metricsCollector.recordGauge(
        'agent.status',
        status === AgentStatus.IDLE ? 0 : 1,
        { agent: metrics.agentName }
      );
    }
  }
  
  private recordTaskCompletion(agentId: string, task: any): void {
    const metrics = this.metrics.get(agentId);
    if (metrics) {
      metrics.taskCount++;
      
      // Update success rate
      const successCount = Math.floor(metrics.taskCount * metrics.successRate / 100);
      metrics.successRate = ((successCount + 1) / (metrics.taskCount)) * 100;
      
      // Update average response time
      const totalTime = metrics.avgResponseTime * (metrics.taskCount - 1);
      metrics.avgResponseTime = (totalTime + task.duration) / metrics.taskCount;
      
      // Record metrics
      this.metricsCollector.recordCounter(
        'agent.task.completed',
        1,
        { agent: metrics.agentName }
      );
      
      this.metricsCollector.recordHistogram(
        'agent.task.duration',
        task.duration,
        { agent: metrics.agentName }
      );
    }
  }
  
  private recordError(agentId: string, error: any): void {
    const metrics = this.metrics.get(agentId);
    if (metrics) {
      metrics.lastError = error.message;
      
      // Update success rate
      const successCount = Math.floor(metrics.taskCount * metrics.successRate / 100);
      metrics.successRate = (successCount / (metrics.taskCount + 1)) * 100;
      
      this.metricsCollector.recordCounter(
        'agent.error',
        1,
        { agent: metrics.agentName, error_type: error.type }
      );
    }
  }
  
  private updateResourceUsage(agentId: string, usage: any): void {
    const metrics = this.metrics.get(agentId);
    if (metrics) {
      metrics.resourceUsage = usage;
      
      this.metricsCollector.recordGauge(
        'agent.resource.cpu',
        usage.cpu,
        { agent: metrics.agentName }
      );
      
      this.metricsCollector.recordGauge(
        'agent.resource.memory',
        usage.memory,
        { agent: metrics.agentName }
      );
      
      this.metricsCollector.recordGauge(
        'agent.resource.tokens',
        usage.tokenUsage,
        { agent: metrics.agentName }
      );
    }
  }
}
```

#### SubTask 3.2.3: 에이전트 종료 및 정리
**담당자**: 백엔드 개발자  
**예상 소요시간**: 8시간

**작업 내용**:
```python
# backend/src/agents/lifecycle/shutdown.py
import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime
import signal
import sys

class AgentShutdownManager:
    """Manages graceful shutdown of agents"""
    
    def __init__(self):
        self.agents: Dict[str, Any] = {}
        self.shutdown_timeout: int = 30  # seconds
        self.is_shutting_down: bool = False
        self._shutdown_tasks: List[asyncio.Task] = []
        self._register_signal_handlers()
    
    def register_agent(self, agent: Any) -> None:
        """Register an agent for shutdown management"""
        self.agents[agent.id] = agent
    
    def _register_signal_handlers(self) -> None:
        """Register system signal handlers for graceful shutdown"""
        for sig in [signal.SIGTERM, signal.SIGINT]:
            signal.signal(sig, self._signal_handler)
    
    def _signal_handler(self, signum: int, frame: Any) -> None:
        """Handle shutdown signals"""
        print(f"Received signal {signum}, initiating graceful shutdown...")
        asyncio.create_task(self.shutdown_all())
    
    async def shutdown_agent(self, agent_id: str, force: bool = False) -> bool:
        """Shutdown a single agent"""
        agent = self.agents.get(agent_id)
        if not agent:
            return False
        
        try:
            # Notify agent of impending shutdown
            await agent.prepare_shutdown()
            
            # Wait for current tasks to complete
            if not force:
                await agent.wait_for_tasks(timeout=self.shutdown_timeout)
            
            # Save agent state
            await self._save_agent_state(agent)
            
            # Clean up resources
            await self._cleanup_agent_resources(agent)
            
            # Stop agent
            await agent.stop()
            
            # Remove from registry
            del self.agents[agent_id]
            
            return True
            
        except Exception as e:
            print(f"Error shutting down agent {agent_id}: {e}")
            if force:
                # Force cleanup
                await self._force_cleanup(agent)
            return False
    
    async def shutdown_all(self) -> None:
        """Shutdown all registered agents"""
        if self.is_shutting_down:
            return
        
        self.is_shutting_down = True
        print("Starting graceful shutdown of all agents...")
        
        # Create shutdown tasks for all agents
        shutdown_tasks = []
        for agent_id in list(self.agents.keys()):
            task = asyncio.create_task(self.shutdown_agent(agent_id))
            shutdown_tasks.append(task)
        
        # Wait for all shutdowns to complete
        results = await asyncio.gather(*shutdown_tasks, return_exceptions=True)
        
        # Check results
        failed_agents = []
        for agent_id, result in zip(list(self.agents.keys()), results):
            if isinstance(result, Exception) or not result:
                failed_agents.append(agent_id)
        
        # Force shutdown failed agents
        if failed_agents:
            print(f"Force shutting down {len(failed_agents)} agents...")
            force_tasks = []
            for agent_id in failed_agents:
                task = asyncio.create_task(
                    self.shutdown_agent(agent_id, force=True)
                )
                force_tasks.append(task)
            
            await asyncio.gather(*force_tasks, return_exceptions=True)
        
        print("All agents shut down successfully")
        
        # Exit the process
        sys.exit(0)
    
    async def _save_agent_state(self, agent: Any) -> None:
        """Save agent state before shutdown"""
        state = {
            'agent_id': agent.id,
            'agent_name': agent.name,
            'status': agent.status,
            'shutdown_time': datetime.utcnow().isoformat(),
            'pending_tasks': await agent.get_pending_tasks(),
            'context': agent.context
        }
        
        # Save to persistent storage
        await self._persist_state(agent.id, state)
    
    async def _persist_state(self, agent_id: str, state: Dict[str, Any]) -> None:
        """Persist agent state to storage"""
        from ...storage.state_manager import StateManager
        
        state_manager = StateManager()
        await state_manager.save_agent_state(agent_id, state)
    
    async def _cleanup_agent_resources(self, agent: Any) -> None:
        """Clean up agent resources"""
        cleanup_tasks = []
        
        # Close database connections
        if hasattr(agent, 'database'):
            cleanup_tasks.append(agent.database.close())
        
        # Clear cache
        if hasattr(agent, 'cache'):
            cleanup_tasks.append(agent.cache.clear())
        
        # Close file handles
        if hasattr(agent, 'files'):
            for file_handle in agent.files:
                cleanup_tasks.append(file_handle.close())
        
        # Close network connections
        if hasattr(agent, 'connections'):
            for conn in agent.connections:
                cleanup_tasks.append(conn.close())
        
        await asyncio.gather(*cleanup_tasks, return_exceptions=True)
    
    async def _force_cleanup(self, agent: Any) -> None:
        """Force cleanup of agent resources"""
        try:
            # Cancel all running tasks
            if hasattr(agent, '_tasks'):
                for task in agent._tasks:
                    task.cancel()
            
            # Force close all resources
            await self._cleanup_agent_resources(agent)
            
            # Force stop
            agent.status = 'stopped'
            
        except Exception as e:
            print(f"Error during force cleanup: {e}")
    
    async def recover_agents(self) -> List[str]:
        """Recover agents from saved state after restart"""
        from ...storage.state_manager import StateManager
        
        state_manager = StateManager()
        saved_states = await state_manager.get_all_agent_states()
        
        recovered_agents = []
        for state in saved_states:
            try:
                # Recreate agent from state
                agent = await self._recreate_agent(state)
                
                # Resume pending tasks
                if state.get('pending_tasks'):
                    await agent.resume_tasks(state['pending_tasks'])
                
                recovered_agents.append(agent.id)
                
            except Exception as e:
                print(f"Failed to recover agent {state['agent_id']}: {e}")
        
        return recovered_agents
    
    async def _recreate_agent(self, state: Dict[str, Any]) -> Any:
        """Recreate agent from saved state"""
        from ..framework.agent_factory import AgentFactory
        
        factory = AgentFactory()
        agent = await factory.create_agent(
            agent_type=state['agent_name'],
            context=state['context']
        )
        
        return agent
```

#### SubTask 3.2.4: 에이전트 생명주기 이벤트 시스템
**담당자**: 백엔드 개발자  
**예상 소요시간**: 8시간

**작업 내용**:
```typescript
// backend/src/agents/lifecycle/events.ts
import { EventEmitter } from 'events';
import { BaseAgent } from '../framework/base-agent';

export enum LifecycleEvent {
  // Initialization events
  INITIALIZING = 'agent:initializing',
  INITIALIZED = 'agent:initialized',
  INITIALIZATION_FAILED = 'agent:initialization_failed',
  
  // Start events
  STARTING = 'agent:starting',
  STARTED = 'agent:started',
  START_FAILED = 'agent:start_failed',
  
  // Runtime events
  TASK_RECEIVED = 'agent:task_received',
  TASK_STARTED = 'agent:task_started',
  TASK_COMPLETED = 'agent:task_completed',
  TASK_FAILED = 'agent:task_failed',
  
  // State events
  STATE_CHANGED = 'agent:state_changed',
  SUSPENDED = 'agent:suspended',
  RESUMED = 'agent:resumed',
  
  // Shutdown events
  SHUTTING_DOWN = 'agent:shutting_down',
  SHUTDOWN_COMPLETE = 'agent:shutdown_complete',
  SHUTDOWN_FAILED = 'agent:shutdown_failed',
  
  // Error events
  ERROR = 'agent:error',
  WARNING = 'agent:warning',
  CRITICAL_ERROR = 'agent:critical_error',
  
  // Health events
  HEALTH_CHECK = 'agent:health_check',
  UNHEALTHY = 'agent:unhealthy',
  RECOVERED = 'agent:recovered'
}

export interface LifecycleEventData {
  agentId: string;
  agentName: string;
  timestamp: Date;
  event: LifecycleEvent;
  data?: any;
  error?: Error;
}

export class LifecycleEventManager extends EventEmitter {
  private eventHistory: Map<string, LifecycleEventData[]> = new Map();
  private subscribers: Map<string, Set<(event: LifecycleEventData) => void>> = new Map();
  
  attachToAgent(agent: BaseAgent): void {
    // Initialize event history for agent
    this.eventHistory.set(agent.id, []);
    
    // Attach lifecycle event listeners
    this.attachInitializationEvents(agent);
    this.attachRuntimeEvents(agent);
    this.attachStateEvents(agent);
    this.attachErrorEvents(agent);
  }
  
  private attachInitializationEvents(agent: BaseAgent): void {
    agent.on('initializing', () => {
      this.recordEvent(agent, LifecycleEvent.INITIALIZING);
    });
    
    agent.on('initialized', () => {
      this.recordEvent(agent, LifecycleEvent.INITIALIZED);
    });
    
    agent.on('initialization_failed', (error) => {
      this.recordEvent(agent, LifecycleEvent.INITIALIZATION_FAILED, { error });
    });
  }
  
  private attachRuntimeEvents(agent: BaseAgent): void {
    agent.on('task_received', (task) => {
      this.recordEvent(agent, LifecycleEvent.TASK_RECEIVED, { taskId: task.id });
    });
    
    agent.on('task_started', (task) => {
      this.recordEvent(agent, LifecycleEvent.TASK_STARTED, { taskId: task.id });
    });
    
    agent.on('task_completed', (result) => {
      this.recordEvent(agent, LifecycleEvent.TASK_COMPLETED, { result });
    });
    
    agent.on('task_failed', (error) => {
      this.recordEvent(agent, LifecycleEvent.TASK_FAILED, { error });
    });
  }
  
  private attachStateEvents(agent: BaseAgent): void {
    agent.on('state_changed', (oldState, newState) => {
      this.recordEvent(agent, LifecycleEvent.STATE_CHANGED, { oldState, newState });
    });
    
    agent.on('suspended', (reason) => {
      this.recordEvent(agent, LifecycleEvent.SUSPENDED, { reason });
    });
    
    agent.on('resumed', () => {
      this.recordEvent(agent, LifecycleEvent.RESUMED);
    });
  }
  
  private attachErrorEvents(agent: BaseAgent): void {
    agent.on('error', (error) => {
      this.recordEvent(agent, LifecycleEvent.ERROR, { error });
    });
    
    agent.on('warning', (warning) => {
      this.recordEvent(agent, LifecycleEvent.WARNING, { warning });
    });
    
    agent.on('critical_error', (error) => {
      this.recordEvent(agent, LifecycleEvent.CRITICAL_ERROR, { error });
    });
  }
  
  private recordEvent(
    agent: BaseAgent, 
    event: LifecycleEvent, 
    data?: any
  ): void {
    const eventData: LifecycleEventData = {
      agentId: agent.id,
      agentName: agent.name,
      timestamp: new Date(),
      event,
      data
    };
    
    // Store in history
    const history = this.eventHistory.get(agent.id) || [];
    history.push(eventData);
    
    // Limit history size
    if (history.length > 1000) {
      history.shift();
    }
    
    // Emit to subscribers
    this.notifySubscribers(eventData);
    
    // Emit global event
    this.emit('lifecycle_event', eventData);
  }
  
  subscribe(
    agentId: string, 
    callback: (event: LifecycleEventData) => void
  ): () => void {
    if (!this.subscribers.has(agentId)) {
      this.subscribers.set(agentId, new Set());
    }
    
    this.subscribers.get(agentId)!.add(callback);
    
    // Return unsubscribe function
    return () => {
      this.subscribers.get(agentId)?.delete(callback);
    };
  }
  
  private notifySubscribers(event: LifecycleEventData): void {
    const subscribers = this.subscribers.get(event.agentId);
    if (subscribers) {
      subscribers.forEach(callback => {
        try {
          callback(event);
        } catch (error) {
          console.error('Error in lifecycle event subscriber:', error);
        }
      });
    }
  }
  
  getEventHistory(agentId: string): LifecycleEventData[] {
    return this.eventHistory.get(agentId) || [];
  }
  
  getEventsByType(agentId: string, eventType: LifecycleEvent): LifecycleEventData[] {
    const history = this.getEventHistory(agentId);
    return history.filter(event => event.event === eventType);
  }
  
  getRecentEvents(agentId: string, count: number = 10): LifecycleEventData[] {
    const history = this.getEventHistory(agentId);
    return history.slice(-count);
  }
  
  clearHistory(agentId: string): void {
    this.eventHistory.delete(agentId);
  }
}

// Lifecycle hooks decorator
export function LifecycleHook(event: LifecycleEvent) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      // Emit event before method execution
      this.emit(event, ...args);
      
      try {
        // Execute original method
        const result = await originalMethod.apply(this, args);
        
        // Emit success event if applicable
        if (event.includes('starting')) {
          this.emit(event.replace('starting', 'started'), result);
        }
        
        return result;
      } catch (error) {
        // Emit failure event
        if (event.includes('starting')) {
          this.emit(event.replace('starting', 'start_failed'), error);
        }
        throw error;
      }
    };
    
    return descriptor;
  };
}
```

---

### Task 3.3: 에이전트 통신 프로토콜

#### SubTask 3.3.1: 메시지 프로토콜 정의
**담당자**: 백엔드 아키텍트  
**예상 소요시간**: 10시간

**작업 내용**:
```python
# backend/src/agents/communication/protocol.py
from enum import Enum
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from datetime import datetime
import uuid
import json

class MessageType(Enum):
    # Task messages
    TASK_REQUEST = "task_request"
    TASK_RESPONSE = "task_response"
    TASK_STATUS = "task_status"
    
    # Control messages
    COMMAND = "command"
    QUERY = "query"
    EVENT = "event"
    
    # Collaboration messages
    COLLABORATION_REQUEST = "collaboration_request"
    COLLABORATION_RESPONSE = "collaboration_response"
    DELEGATION = "delegation"
    
    # System messages
    PING = "ping"
    PONG = "pong"
    HEARTBEAT = "heartbeat"
    ERROR = "error"

class MessagePriority(Enum):
    LOW = 0
    NORMAL = 1
    HIGH = 2
    CRITICAL = 3

@dataclass
class MessageHeader:
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    type: MessageType = MessageType.TASK_REQUEST
    sender: str = ""
    recipient: str = ""
    timestamp: datetime = field(default_factory=datetime.utcnow)
    priority: MessagePriority = MessagePriority.NORMAL
    correlation_id: Optional[str] = None
    reply_to: Optional[str] = None
    ttl: Optional[int] = None  # Time to live in seconds
    routing_key: Optional[str] = None

@dataclass
class Message:
    header: MessageHeader
    payload: Dict[str, Any]
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_json(self) -> str:
        """Serialize message to JSON"""
        return json.dumps({
            'header': {
                'id': self.header.id,
                'type': self.header.type.value,
                'sender': self.header.sender,
                'recipient': self.header.recipient,
                'timestamp': self.header.timestamp.isoformat(),
                'priority': self.header.priority.value,
                'correlation_id': self.header.correlation_id,
                'reply_to': self.header.reply_to,
                'ttl': self.header.ttl,
                'routing_key': self.header.routing_key
            },
            'payload': self.payload,
            'metadata': self.metadata
        })
    
    @classmethod
    def from_json(cls, json_str: str) -> 'Message':
        """Deserialize message from JSON"""
        data = json.loads(json_str)
        header_data = data['header']
        
        header = MessageHeader(
            id=header_data['id'],
            type=MessageType(header_data['type']),
            sender=header_data['sender'],
            recipient=header_data['recipient'],
            timestamp=datetime.fromisoformat(header_data['timestamp']),
            priority=MessagePriority(header_data['priority']),
            correlation_id=header_data.get('correlation_id'),
            reply_to=header_data.get('reply_to'),
            ttl=header_data.get('ttl'),
            routing_key=header_data.get('routing_key')
        )
        
        return cls(
            header=header,
            payload=data['payload'],
            metadata=data.get('metadata', {})
        )

class MessageBuilder:
    """Fluent interface for building messages"""
    
    def __init__(self):
        self.header = MessageHeader()
        self.payload = {}
        self.metadata = {}
    
    def with_type(self, message_type: MessageType) -> 'MessageBuilder':
        self.header.type = message_type
        return self
    
    def from_agent(self, sender: str) -> 'MessageBuilder':
        self.header.sender = sender
        return self
    
    def to_agent(self, recipient: str) -> 'MessageBuilder':
        self.header.recipient = recipient
        return self
    
    def with_priority(self, priority: MessagePriority) -> 'MessageBuilder':
        self.header.priority = priority
        return self
    
    def with_correlation_id(self, correlation_id: str) -> 'MessageBuilder':
        self.header.correlation_id = correlation_id
        return self
    
    def reply_to(self, message_id: str) -> 'MessageBuilder':
        self.header.reply_to = message_id
        return self
    
    def with_ttl(self, seconds: int) -> 'MessageBuilder':
        self.header.ttl = seconds
        return self
    
    def with_routing_key(self, key: str) -> 'MessageBuilder':
        self.header.routing_key = key
        return self
    
    def with_payload(self, payload: Dict[str, Any]) -> 'MessageBuilder':
        self.payload = payload
        return self
    
    def with_metadata(self, metadata: Dict[str, Any]) -> 'MessageBuilder':
        self.metadata = metadata
        return self
    
    def build(self) -> Message:
        return Message(
            header=self.header,
            payload=self.payload,
            metadata=self.metadata
        )

# Standard message schemas
class MessageSchemas:
    TASK_REQUEST = {
        "type": "object",
        "properties": {
            "task_id": {"type": "string"},
            "task_type": {"type": "string"},
            "description": {"type": "string"},
            "requirements": {
                "type": "object",
                "additionalProperties": True
            },
            "context": {
                "type": "object",
                "additionalProperties": True
            },
            "constraints": {
                "type": "object",
                "properties": {
                    "timeout": {"type": "integer"},
                    "max_retries": {"type": "integer"},
                    "resources": {"type": "object"}
                }
            }
        },
        "required": ["task_id", "task_type", "description"]
    }
    
    TASK_RESPONSE = {
        "type": "object",
        "properties": {
            "task_id": {"type": "string"},
            "status": {
                "type": "string",
                "enum": ["success", "failure", "partial"]
            },
            "result": {
                "type": "object",
                "additionalProperties": True
            },
            "errors": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "code": {"type": "string"},
                        "message": {"type": "string"}
                    }
                }
            },
            "metrics": {
                "type": "object",
                "properties": {
                    "execution_time": {"type": "number"},
                    "tokens_used": {"type": "integer"},
                    "cost": {"type": "number"}
                }
            }
        },
        "required": ["task_id", "status"]
    }
    
    COLLABORATION_REQUEST = {
        "type": "object",
        "properties": {
            "collaboration_id": {"type": "string"},
            "type": {
                "type": "string",
                "enum": ["assistance", "review", "validation", "joint_task"]
            },
            "description": {"type": "string"},
            "input_data": {
                "type": "object",
                "additionalProperties": True
            },
            "expected_output": {
                "type": "object",
                "properties": {
                    "format": {"type": "string"},
                    "schema": {"type": "object"}
                }
            },
            "deadline": {"type": "string", "format": "date-time"}
        },
        "required": ["collaboration_id", "type", "description"]
    }
```

#### SubTask 3.3.2: 비동기 메시징 시스템
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**작업 내용**:
```typescript
// backend/src/agents/communication/messaging.ts
import { EventEmitter } from 'events';
import { Message, MessageType, MessagePriority } from './protocol';
import { Queue, Worker } from 'bullmq';
import Redis from 'ioredis';

interface MessageBrokerConfig {
  redis: {
    host: string;
    port: number;
    password?: string;
  };
  queues: {
    maxConcurrency: number;
    defaultTimeout: number;
  };
}

export class MessageBroker extends EventEmitter {
  private redis: Redis;
  private pubClient: Redis;
  private subClient: Redis;
  private queues: Map<string, Queue> = new Map();
  private workers: Map<string, Worker> = new Map();
  private handlers: Map<string, (message: Message) => Promise<any>> = new Map();
  
  constructor(private config: MessageBrokerConfig) {
    super();
    this.redis = new Redis(config.redis);
    this.pubClient = new Redis(config.redis);
    this.subClient = new Redis(config.redis);
  }
  
  async initialize(): Promise<void> {
    // Set up pub/sub for real-time messaging
    this.subClient.on('message', this.handlePubSubMessage.bind(this));
    
    // Initialize default queues
    await this.createQueue('high_priority', { priority: MessagePriority.HIGH });
    await this.createQueue('normal_priority', { priority: MessagePriority.NORMAL });
    await this.createQueue('low_priority', { priority: MessagePriority.LOW });
  }
  
  async createQueue(name: string, options: any = {}): Promise<void> {
    const queue = new Queue(name, {
      connection: this.redis,
      defaultJobOptions: {
        removeOnComplete: true,
        removeOnFail: false,
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000
        }
      }
    });
    
    this.queues.set(name, queue);
    
    // Create worker for the queue
    const worker = new Worker(
      name,
      async (job) => {
        const message = Message.fromJson(job.data.message);
        return await this.processMessage(message);
      },
      {
        connection: this.redis,
        concurrency: options.concurrency || this.config.queues.maxConcurrency
      }
    );
    
    worker.on('completed', (job) => {
      this.emit('message:processed', job.data);
    });
    
    worker.on('failed', (job, err) => {
      this.emit('message:failed', { job: job?.data, error: err });
    });
    
    this.workers.set(name, worker);
  }
  
  async send(message: Message): Promise<void> {
    // Route based on priority
    const queueName = this.getQueueForPriority(message.header.priority);
    const queue = this.queues.get(queueName);
    
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    // Add TTL if specified
    const jobOptions: any = {};
    if (message.header.ttl) {
      jobOptions.delay = message.header.ttl * 1000;
    }
    
    // Add to queue
    await queue.add('message', {
      message: message.toJson()
    }, jobOptions);
    
    // Also publish for real-time subscribers if high priority
    if (message.header.priority === MessagePriority.HIGH ||
        message.header.priority === MessagePriority.CRITICAL) {
      await this.publish(message);
    }
  }
  
  async publish(message: Message): Promise<void> {
    const channel = `agent:${message.header.recipient}`;
    await this.pubClient.publish(channel, message.toJson());
  }
  
  async subscribe(agentId: string): Promise<void> {
    const channel = `agent:${agentId}`;
    await this.subClient.subscribe(channel);
  }
  
  registerHandler(
    agentId: string, 
    handler: (message: Message) => Promise<any>
  ): void {
    this.handlers.set(agentId, handler);
  }
  
  private async handlePubSubMessage(channel: string, data: string): Promise<void> {
    try {
      const message = Message.fromJson(data);
      const agentId = channel.split(':')[1];
      
      const handler = this.handlers.get(agentId);
      if (handler) {
        await handler(message);
      }
    } catch (error) {
      this.emit('error', error);
    }
  }
  
  private async processMessage(message: Message): Promise<any> {
    const handler = this.handlers.get(message.header.recipient);
    
    if (!handler) {
      throw new Error(`No handler registered for ${message.header.recipient}`);
    }
    
    try {
      const result = await handler(message);
      
      // Send response if reply_to is specified
      if (message.header.reply_to) {
        const response = new MessageBuilder()
          .with_type(MessageType.TASK_RESPONSE)
          .from_agent(message.header.recipient)
          .to_agent(message.header.sender)
          .with_correlation_id(message.header.correlation_id || message.header.id)
          .with_payload(result)
          .build();
        
        await this.send(response);
      }
      
      return result;
    } catch (error) {
      // Send error response
      if (message.header.reply_to) {
        const errorResponse = new MessageBuilder()
          .with_type(MessageType.ERROR)
          .from_agent(message.header.recipient)
          .to_agent(message.header.sender)
          .with_correlation_id(message.header.correlation_id || message.header.id)
          .with_payload({
            error: error.message,
            original_message_id: message.header.id
          })
          .build();
        
        await this.send(errorResponse);
      }
      
      throw error;
    }
  }
  
  private getQueueForPriority(priority: MessagePriority): string {
    switch (priority) {
      case MessagePriority.CRITICAL:
      case MessagePriority.HIGH:
        return 'high_priority';
      case MessagePriority.NORMAL:
        return 'normal_priority';
      case MessagePriority.LOW:
        return 'low_priority';
      default:
        return 'normal_priority';
    }
  }
  
  async getQueueStatus(queueName: string): Promise<any> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }
    
    const [waiting, active, delayed, completed, failed] = await Promise.all([
      queue.getWaitingCount(),
      queue.getActiveCount(),
      queue.getDelayedCount(),
      queue.getCompletedCount(),
      queue.getFailedCount()
    ]);
    
    return {
      name: queueName,
      waiting,
      active,
      delayed,
      completed,
      failed
    };
  }
  
  async shutdown(): Promise<void> {
    // Close all workers
    for (const worker of this.workers.values()) {
      await worker.close();
    }
    
    // Close all queues
    for (const queue of this.queues.values()) {
      await queue.close();
    }
    
    // Close Redis connections
    await this.redis.quit();
    await this.pubClient.quit();
    await this.subClient.quit();
  }
}

// Message routing
export class MessageRouter {
  private routes: Map<string, string[]> = new Map();
  private broker: MessageBroker;
  
  constructor(broker: MessageBroker) {
    this.broker = broker;
  }
  
  addRoute(pattern: string, agents: string[]): void {
    this.routes.set(pattern, agents);
  }
  
  async route(message: Message): Promise<void> {
    // Direct routing
    if (message.header.recipient) {
      await this.broker.send(message);
      return;
    }
    
    // Pattern-based routing
    if (message.header.routing_key) {
      const agents = this.findAgentsForRoute(message.header.routing_key);
      
      for (const agent of agents) {
        const routedMessage = {
          ...message,
          header: {
            ...message.header,
            recipient: agent
          }
        };
        
        await this.broker.send(routedMessage);
      }
    }
  }
  
  private findAgentsForRoute(routingKey: string): string[] {
    const agents: string[] = [];
    
    for (const [pattern, routeAgents] of this.routes) {
      if (this.matchPattern(routingKey, pattern)) {
        agents.push(...routeAgents);
      }
    }
    
    return [...new Set(agents)]; // Remove duplicates
  }
  
  private matchPattern(key: string, pattern: string): boolean {
    // Simple wildcard matching
    const regex = new RegExp(
      '^' + pattern.replace('*', '.*').replace('#', '.*') + '$'
    );
    return regex.test(key);
  }
}
```

#### SubTask 3.3.3: 에이전트 간 RPC 시스템
**담당자**: 백엔드 개발자  
**예상 소요시간**: 10시간

**작업 내용**:
```python
# backend/src/agents/communication/rpc.py
import asyncio
from typing import Dict, Any, Optional, Callable, TypeVar, Generic
from datetime import datetime, timedelta
import json
from functools import wraps

T = TypeVar('T')

class RPCTimeout(Exception):
    """RPC timeout exception"""
    pass

class RPCError(Exception):
    """RPC error exception"""
    def __init__(self, code: str, message: str, data: Any = None):
        super().__init__(message)
        self.code = code
        self.data = data

class RPCRequest:
    def __init__(
        self,
        method: str,
        params: Dict[str, Any],
        id: Optional[str] = None,
        timeout: int = 30
    ):
        self.method = method
        self.params = params
        self.id = id or str(uuid.uuid4())
        self.timeout = timeout
        self.timestamp = datetime.utcnow()

class RPCResponse(Generic[T]):
    def __init__(
        self,
        id: str,
        result: Optional[T] = None,
        error: Optional[Dict[str, Any]] = None
    ):
        self.id = id
        self.result = result
        self.error = error
        self.timestamp = datetime.utcnow()

class RPCClient:
    """RPC client for agent-to-agent communication"""
    
    def __init__(self, agent_id: str, message_broker: Any):
        self.agent_id = agent_id
        self.message_broker = message_broker
        self.pending_requests: Dict[str, asyncio.Future] = {}
        self._setup_response_handler()
    
    def _setup_response_handler(self):
        """Setup handler for RPC responses"""
        self.message_broker.registerHandler(
            self.agent_id,
            self._handle_rpc_response
        )
    
    async def _handle_rpc_response(self, message: Message) -> None:
        """Handle incoming RPC responses"""
        if message.header.type != MessageType.TASK_RESPONSE:
            return
        
        correlation_id = message.header.correlation_id
        if correlation_id in self.pending_requests:
            future = self.pending_requests[correlation_id]
            
            if 'error' in message.payload:
                error = RPCError(**message.payload['error'])
                future.set_exception(error)
            else:
                future.set_result(message.payload.get('result'))
            
            del self.pending_requests[correlation_id]
    
    async def call(
        self,
        target_agent: str,
        method: str,
        params: Dict[str, Any] = None,
        timeout: int = 30
    ) -> Any:
        """Make RPC call to another agent"""
        request = RPCRequest(
            method=method,
            params=params or {},
            timeout=timeout
        )
        
        # Create future for response
        future = asyncio.Future()
        self.pending_requests[request.id] = future
        
        # Build and send message
        message = MessageBuilder() \
            .with_type(MessageType.TASK_REQUEST) \
            .from_agent(self.agent_id) \
            .to_agent(target_agent) \
            .with_correlation_id(request.id) \
            .with_payload({
                'method': request.method,
                'params': request.params
            }) \
            .with_ttl(timeout) \
            .build()
        
        await self.message_broker.send(message)
        
        # Wait for response with timeout
        try:
            result = await asyncio.wait_for(future, timeout=timeout)
            return result
        except asyncio.TimeoutError:
            del self.pending_requests[request.id]
            raise RPCTimeout(f"RPC call to {target_agent}.{method} timed out")
    
    async def call_batch(
        self,
        calls: List[Dict[str, Any]],
        parallel: bool = True
    ) -> List[Any]:
        """Make multiple RPC calls"""
        if parallel:
            tasks = [
                self.call(
                    call['agent'],
                    call['method'],
                    call.get('params', {}),
                    call.get('timeout', 30)
                )
                for call in calls
            ]
            return await asyncio.gather(*tasks, return_exceptions=True)
        else:
            results = []
            for call in calls:
                try:
                    result = await self.call(
                        call['agent'],
                        call['method'],
                        call.get('params', {}),
                        call.get('timeout', 30)
                    )
                    results.append(result)
                except Exception as e:
                    results.append(e)
            return results

class RPCServer:
    """RPC server for handling incoming calls"""
    
    def __init__(self, agent_id: str, message_broker: Any):
        self.agent_id = agent_id
        self.message_broker = message_broker
        self.methods: Dict[str, Callable] = {}
        self._setup_request_handler()
    
    def _setup_request_handler(self):
        """Setup handler for RPC requests"""
        self.message_broker.registerHandler(
            self.agent_id,
            self._handle_rpc_request
        )
    
    def register_method(self, name: str, handler: Callable) -> None:
        """Register RPC method"""
        self.methods[name] = handler
    
    def method(self, name: Optional[str] = None):
        """Decorator to register RPC method"""
        def decorator(func: Callable) -> Callable:
            method_name = name or func.__name__
            self.register_method(method_name, func)
            return func
        return decorator
    
    async def _handle_rpc_request(self, message: Message) -> None:
        """Handle incoming RPC requests"""
        if message.header.type != MessageType.TASK_REQUEST:
            return
        
        method = message.payload.get('method')
        params = message.payload.get('params', {})
        
        try:
            if method not in self.methods:
                raise RPCError(
                    'METHOD_NOT_FOUND',
                    f"Method '{method}' not found"
                )
            
            # Call method
            handler = self.methods[method]
            if asyncio.iscoroutinefunction(handler):
                result = await handler(**params)
            else:
                result = handler(**params)
            
            # Send response
            response_message = MessageBuilder() \
                .with_type(MessageType.TASK_RESPONSE) \
                .from_agent(self.agent_id) \
                .to_agent(message.header.sender) \
                .with_correlation_id(message.header.correlation_id) \
                .with_payload({'result': result}) \
                .build()
            
            await self.message_broker.send(response_message)
            
        except RPCError as e:
            # Send error response
            error_message = MessageBuilder() \
                .with_type(MessageType.TASK_RESPONSE) \
                .from_agent(self.agent_id) \
                .to_agent(message.header.sender) \
                .with_correlation_id(message.header.correlation_id) \
                .with_payload({
                    'error': {
                        'code': e.code,
                        'message': str(e),
                        'data': e.data
                    }
                }) \
                .build()
            
            await self.message_broker.send(error_message)
            
        except Exception as e:
            # Send generic error response
            error_message = MessageBuilder() \
                .with_type(MessageType.TASK_RESPONSE) \
                .from_agent(self.agent_id) \
                .to_agent(message.header.sender) \
                .with_correlation_id(message.header.correlation_id) \
                .with_payload({
                    'error': {
                        'code': 'INTERNAL_ERROR',
                        'message': str(e)
                    }
                }) \
                .build()
            
            await self.message_broker.send(error_message)

# Agent RPC mixin
class RPCMixin:
    """Mixin to add RPC capabilities to agents"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.rpc_client: Optional[RPCClient] = None
        self.rpc_server: Optional[RPCServer] = None
    
    async def setup_rpc(self, message_broker: Any):
        """Setup RPC client and server"""
        self.rpc_client = RPCClient(self.id, message_broker)
        self.rpc_server = RPCServer(self.id, message_broker)
        
        # Register default methods
        self.rpc_server.register_method('ping', self._rpc_ping)
        self.rpc_server.register_method('get_status', self._rpc_get_status)
        self.rpc_server.register_method('get_capabilities', self._rpc_get_capabilities)
    
    async def _rpc_ping(self) -> Dict[str, Any]:
        """RPC ping method"""
        return {
            'agent_id': self.id,
            'agent_name': self.name,
            'timestamp': datetime.utcnow().isoformat(),
            'status': 'ok'
        }
    
    async def _rpc_get_status(self) -> Dict[str, Any]:
        """RPC get status method"""
        return {
            'agent_id': self.id,
            'status': self.status.value,
            'uptime': self.get_uptime(),
            'tasks_completed': self.get_task_count()
        }
    
    async def _rpc_get_capabilities(self) -> List[Dict[str, Any]]:
        """RPC get capabilities method"""
        return self.get_capabilities()
    
    # Convenience methods for making RPC calls
    async def call_agent(
        self,
        agent: str,
        method: str,
        **params
    ) -> Any:
        """Call method on another agent"""
        if not self.rpc_client:
            raise RuntimeError("RPC not initialized")
        
        return await self.rpc_client.call(agent, method, params)
    
    async def broadcast(
        self,
        agents: List[str],
        method: str,
        **params
    ) -> List[Any]:
        """Broadcast call to multiple agents"""
        if not self.rpc_client:
            raise RuntimeError("RPC not initialized")
        
        calls = [
            {
                'agent': agent,
                'method': method,
                'params': params
            }
            for agent in agents
        ]
        
        return await self.rpc_client.call_batch(calls, parallel=True)
```

#### SubTask 3.3.4: 브로드캐스트 및 멀티캐스트 시스템
**담당자**: 백엔드 개발자  
**예상 소요시간**: 8시간

**작업 내용**:
```typescript
// backend/src/agents/communication/broadcast.ts
import { EventEmitter } from 'events';
import { Message, MessageBuilder, MessageType } from './protocol';
import { MessageBroker } from './messaging';

interface BroadcastGroup {
  id: string;
  name: string;
  members: Set<string>;
  created: Date;
  metadata: Record<string, any>;
}

interface BroadcastOptions {
  excludeSender?: boolean;
  reliable?: boolean;
  ordered?: boolean;
  timeout?: number;
  acknowledgment?: boolean;
}

export class BroadcastManager extends EventEmitter {
  private groups: Map<string, BroadcastGroup> = new Map();
  private broker: MessageBroker;
  private subscriptions: Map<string, Set<string>> = new Map();
  
  constructor(broker: MessageBroker) {
    super();
    this.broker = broker;
  }
  
  createGroup(name: string, members: string[] = []): BroadcastGroup {
    const group: BroadcastGroup = {
      id: `group-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name,
      members: new Set(members),
      created: new Date(),
      metadata: {}
    };
    
    this.groups.set(group.id, group);
    
    // Update subscriptions
    members.forEach(member => this.addToSubscriptions(member, group.id));
    
    this.emit('group:created', group);
    return group;
  }
  
  joinGroup(groupId: string, agentId: string): void {
    const group = this.groups.get(groupId);
    if (!group) {
      throw new Error(`Group ${groupId} not found`);
    }
    
    group.members.add(agentId);
    this.addToSubscriptions(agentId, groupId);
    
    this.emit('group:member_joined', { groupId, agentId });
  }
  
  leaveGroup(groupId: string, agentId: string): void {
    const group = this.groups.get(groupId);
    if (!group) {
      throw new Error(`Group ${groupId} not found`);
    }
    
    group.members.delete(agentId);
    this.removeFromSubscriptions(agentId, groupId);
    
    this.emit('group:member_left', { groupId, agentId });
  }
  
  async broadcast(
    senderId: string,
    groupId: string,
    payload: any,
    options: BroadcastOptions = {}
  ): Promise<void> {
    const group = this.groups.get(groupId);
    if (!group) {
      throw new Error(`Group ${groupId} not found`);
    }
    
    const members = Array.from(group.members);
    const recipients = options.excludeSender 
      ? members.filter(m => m !== senderId)
      : members;
    
    if (options.reliable) {
      // Use reliable messaging with acknowledgments
      await this.reliableBroadcast(senderId, recipients, payload, options);
    } else {
      // Use fast broadcast
      await this.fastBroadcast(senderId, recipients, payload);
    }
  }
  
  private async fastBroadcast(
    senderId: string,
    recipients: string[],
    payload: any
  ): Promise<void> {
    const messages = recipients.map(recipient => 
      new MessageBuilder()
        .with_type(MessageType.EVENT)
        .from_agent(senderId)
        .to_agent(recipient)
        .with_payload(payload)
        .build()
    );
    
    // Send all messages in parallel
    await Promise.all(messages.map(msg => this.broker.publish(msg)));
  }
  
  private async reliableBroadcast(
    senderId: string,
    recipients: string[],
    payload: any,
    options: BroadcastOptions
  ): Promise<void> {
    const broadcastId = `broadcast-${Date.now()}`;
    const acknowledgments: Map<string, boolean> = new Map();
    
    // Initialize acknowledgments
    recipients.forEach(r => acknowledgments.set(r, false));
    
    // Create messages with acknowledgment request
    const messages = recipients.map(recipient => 
      new MessageBuilder()
        .with_type(MessageType.EVENT)
        .from_agent(senderId)
        .to_agent(recipient)
        .with_correlation_id(broadcastId)
        .with_payload({
          ...payload,
          _broadcast: {
            id: broadcastId,
            requiresAck: options.acknowledgment
          }
        })
        .build()
    );
    
    // Send messages
    await Promise.all(messages.map(msg => this.broker.send(msg)));
    
    if (options.acknowledgment) {
      // Wait for acknowledgments
      await this.waitForAcknowledgments(
        broadcastId,
        acknowledgments,
        options.timeout || 5000
      );
    }
  }
  
  private async waitForAcknowledgments(
    broadcastId: string,
    acknowledgments: Map<string, boolean>,
    timeout: number
  ): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const allAcked = Array.from(acknowledgments.values()).every(ack => ack);
      if (allAcked) {
        return;
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // Emit timeout event with missing acknowledgments
    const missing = Array.from(acknowledgments.entries())
      .filter(([_, acked]) => !acked)
      .map(([agent, _]) => agent);
    
    this.emit('broadcast:timeout', { broadcastId, missing });
  }
  
  async multicast(
    senderId: string,
    recipients: string[],
    payload: any,
    options: BroadcastOptions = {}
  ): Promise<void> {
    // Similar to broadcast but without group requirement
    if (options.reliable) {
      await this.reliableBroadcast(senderId, recipients, payload, options);
    } else {
      await this.fastBroadcast(senderId, recipients, payload);
    }
  }
  
  // Topic-based broadcasting
  async publish(topic: string, payload: any, senderId: string): Promise<void> {
    const subscribers = this.getTopicSubscribers(topic);
    
    if (subscribers.length === 0) {
      return;
    }
    
    await this.multicast(senderId, subscribers, {
      topic,
      ...payload
    });
  }
  
  subscribe(agentId: string, topic: string): void {
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.set(topic, new Set());
    }
    
    this.subscriptions.get(topic)!.add(agentId);
  }
  
  unsubscribe(agentId: string, topic: string): void {
    this.subscriptions.get(topic)?.delete(agentId);
  }
  
  private getTopicSubscribers(topic: string): string[] {
    // Support wildcard topics
    const subscribers = new Set<string>();
    
    for (const [subTopic, agents] of this.subscriptions) {
      if (this.matchTopic(topic, subTopic)) {
        agents.forEach(agent => subscribers.add(agent));
      }
    }
    
    return Array.from(subscribers);
  }
  
  private matchTopic(topic: string, pattern: string): boolean {
    const topicParts = topic.split('.');
    const patternParts = pattern.split('.');
    
    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i] === '#') {
        return true; // # matches everything after
      }
      
      if (patternParts[i] === '*') {
        continue; // * matches single level
      }
      
      if (i >= topicParts.length || patternParts[i] !== topicParts[i]) {
        return false;
      }
    }
    
    return topicParts.length === patternParts.length;
  }
  
  private addToSubscriptions(agentId: string, groupId: string): void {
    const topic = `group.${groupId}`;
    this.subscribe(agentId, topic);
  }
  
  private removeFromSubscriptions(agentId: string, groupId: string): void {
    const topic = `group.${groupId}`;
    this.unsubscribe(agentId, topic);
  }
  
  getGroups(): BroadcastGroup[] {
    return Array.from(this.groups.values());
  }
  
  getGroupMembers(groupId: string): string[] {
    const group = this.groups.get(groupId);
    return group ? Array.from(group.members) : [];
  }
  
  getAgentGroups(agentId: string): string[] {
    const groups: string[] = [];
    
    for (const [groupId, group] of this.groups) {
      if (group.members.has(agentId)) {
        groups.push(groupId);
      }
    }
    
    return groups;
  }
}

// Broadcast patterns
export class BroadcastPatterns {
  static fanOut(
    manager: BroadcastManager,
    senderId: string,
    recipients: string[],
    payload: any
  ): Promise<void> {
    return manager.multicast(senderId, recipients, payload, {
      reliable: false,
      excludeSender: true
    });
  }
  
  static reliableFanOut(
    manager: BroadcastManager,
    senderId: string,
    recipients: string[],
    payload: any
  ): Promise<void> {
    return manager.multicast(senderId, recipients, payload, {
      reliable: true,
      acknowledgment: true,
      excludeSender: true
    });
  }
  
  static gossip(
    manager: BroadcastManager,
    senderId: string,
    groupId: string,
    payload: any,
    fanout: number = 3
  ): Promise<void> {
    // Gossip protocol - send to random subset
    const members = manager.getGroupMembers(groupId)
      .filter(m => m !== senderId);
    
    const selected = this.selectRandom(members, fanout);
    
    return manager.multicast(senderId, selected, {
      ...payload,
      _gossip: {
        hops: 0,
        maxHops: Math.log2(members.length) * 2
      }
    });
  }
  
  private static selectRandom<T>(array: T[], count: number): T[] {
    const shuffled = [...array].sort(() => 0.5 - Math.random());
    return shuffled.slice(0, count);
  }
}
```
### Task 3.4: 에이전트 상태 관리

#### SubTask 3.4.1: 상태 머신 구현
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**작업 내용**:
```python
# backend/src/agents/state/state_machine.py
from enum import Enum
from typing import Dict, List, Optional, Callable, Any, Set
from dataclasses import dataclass
import asyncio
from datetime import datetime

class StateTransitionError(Exception):
    """Exception raised when invalid state transition is attempted"""
    pass

@dataclass
class StateTransition:
    from_state: str
    to_state: str
    condition: Optional[Callable[[], bool]] = None
    action: Optional[Callable[[], None]] = None
    metadata: Dict[str, Any] = None

@dataclass
class StateDefinition:
    name: str
    on_enter: Optional[Callable[[], None]] = None
    on_exit: Optional[Callable[[], None]] = None
    timeout: Optional[int] = None  # seconds
    allowed_transitions: List[str] = None

class StateMachine:
    """Finite state machine for agent state management"""
    
    def __init__(self, initial_state: str):
        self.states: Dict[str, StateDefinition] = {}
        self.transitions: Dict[str, List[StateTransition]] = {}
        self.current_state: str = initial_state
        self.previous_state: Optional[str] = None
        self.state_history: List[Dict[str, Any]] = []
        self.transition_callbacks: List[Callable] = []
        self._state_timers: Dict[str, asyncio.Task] = {}
        self._lock = asyncio.Lock()
        
    def add_state(self, state: StateDefinition) -> None:
        """Add a state to the machine"""
        self.states[state.name] = state
        self.transitions[state.name] = []
        
    def add_transition(
        self,
        from_state: str,
        to_state: str,
        condition: Optional[Callable] = None,
        action: Optional[Callable] = None
    ) -> None:
        """Add a transition between states"""
        if from_state not in self.states:
            raise ValueError(f"State {from_state} not defined")
        if to_state not in self.states:
            raise ValueError(f"State {to_state} not defined")
            
        transition = StateTransition(
            from_state=from_state,
            to_state=to_state,
            condition=condition,
            action=action
        )
        
        self.transitions[from_state].append(transition)
        
    async def transition_to(self, new_state: str, context: Dict[str, Any] = None) -> bool:
        """Attempt to transition to a new state"""
        async with self._lock:
            # Check if transition is valid
            if not self._can_transition_to(new_state):
                raise StateTransitionError(
                    f"Cannot transition from {self.current_state} to {new_state}"
                )
            
            # Find the transition
            transition = self._find_transition(self.current_state, new_state)
            if not transition:
                raise StateTransitionError(
                    f"No transition defined from {self.current_state} to {new_state}"
                )
            
            # Check condition if specified
            if transition.condition and not await self._check_condition(transition.condition):
                return False
            
            # Execute exit action for current state
            current_state_def = self.states[self.current_state]
            if current_state_def.on_exit:
                await self._execute_callback(current_state_def.on_exit)
            
            # Cancel current state timer if exists
            if self.current_state in self._state_timers:
                self._state_timers[self.current_state].cancel()
                del self._state_timers[self.current_state]
            
            # Record transition
            self._record_transition(self.current_state, new_state, context)
            
            # Update state
            self.previous_state = self.current_state
            self.current_state = new_state
            
            # Execute transition action
            if transition.action:
                await self._execute_callback(transition.action)
            
            # Execute enter action for new state
            new_state_def = self.states[new_state]
            if new_state_def.on_enter:
                await self._execute_callback(new_state_def.on_enter)
            
            # Set timeout for new state if specified
            if new_state_def.timeout:
                self._set_state_timeout(new_state, new_state_def.timeout)
            
            # Notify callbacks
            await self._notify_transition_callbacks(
                self.previous_state,
                self.current_state,
                context
            )
            
            return True
    
    def _can_transition_to(self, state: str) -> bool:
        """Check if transition to state is allowed"""
        current_state_def = self.states.get(self.current_state)
        if not current_state_def:
            return False
            
        if current_state_def.allowed_transitions:
            return state in current_state_def.allowed_transitions
            
        # Check if any transition exists
        return any(t.to_state == state for t in self.transitions.get(self.current_state, []))
    
    def _find_transition(self, from_state: str, to_state: str) -> Optional[StateTransition]:
        """Find transition between states"""
        for transition in self.transitions.get(from_state, []):
            if transition.to_state == to_state:
                return transition
        return None
    
    async def _check_condition(self, condition: Callable) -> bool:
        """Check transition condition"""
        if asyncio.iscoroutinefunction(condition):
            return await condition()
        return condition()
    
    async def _execute_callback(self, callback: Callable) -> None:
        """Execute callback function"""
        if asyncio.iscoroutinefunction(callback):
            await callback()
        else:
            callback()
    
    def _set_state_timeout(self, state: str, timeout: int) -> None:
        """Set timeout for state"""
        async def timeout_handler():
            await asyncio.sleep(timeout)
            # Transition to timeout state or default
            try:
                await self.transition_to(f"{state}_timeout")
            except StateTransitionError:
                # Fallback to error state
                await self.transition_to("error")
        
        self._state_timers[state] = asyncio.create_task(timeout_handler())
    
    def _record_transition(self, from_state: str, to_state: str, context: Any) -> None:
        """Record state transition in history"""
        self.state_history.append({
            'from_state': from_state,
            'to_state': to_state,
            'timestamp': datetime.utcnow(),
            'context': context
        })
        
        # Limit history size
        if len(self.state_history) > 1000:
            self.state_history = self.state_history[-1000:]
    
    async def _notify_transition_callbacks(
        self,
        from_state: str,
        to_state: str,
        context: Any
    ) -> None:
        """Notify registered callbacks of state transition"""
        for callback in self.transition_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    await callback(from_state, to_state, context)
                else:
                    callback(from_state, to_state, context)
            except Exception as e:
                # Log error but don't fail transition
                print(f"Error in transition callback: {e}")
    
    def on_transition(self, callback: Callable) -> None:
        """Register callback for state transitions"""
        self.transition_callbacks.append(callback)
    
    def get_available_transitions(self) -> List[str]:
        """Get list of available transitions from current state"""
        return [t.to_state for t in self.transitions.get(self.current_state, [])]
    
    def get_state_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get recent state history"""
        return self.state_history[-limit:]
    
    def is_in_state(self, state: str) -> bool:
        """Check if currently in given state"""
        return self.current_state == state
    
    def get_time_in_current_state(self) -> Optional[float]:
        """Get time spent in current state"""
        if self.state_history:
            last_transition = self.state_history[-1]
            if last_transition['to_state'] == self.current_state:
                elapsed = datetime.utcnow() - last_transition['timestamp']
                return elapsed.total_seconds()
        return None

# Agent-specific state machine
class AgentStateMachine(StateMachine):
    """State machine specifically for agents"""
    
    def __init__(self):
        super().__init__("uninitialized")
        self._setup_states()
        self._setup_transitions()
    
    def _setup_states(self):
        """Setup standard agent states"""
        # Basic states
        self.add_state(StateDefinition(
            name="uninitialized",
            allowed_transitions=["initializing", "error"]
        ))
        
        self.add_state(StateDefinition(
            name="initializing",
            timeout=60,  # 1 minute timeout
            allowed_transitions=["idle", "error", "initializing_timeout"]
        ))
        
        self.add_state(StateDefinition(
            name="idle",
            allowed_transitions=["processing", "suspended", "shutting_down", "error"]
        ))
        
        self.add_state(StateDefinition(
            name="processing",
            allowed_transitions=["idle", "waiting", "error", "shutting_down"]
        ))
        
        self.add_state(StateDefinition(
            name="waiting",
            allowed_transitions=["processing", "idle", "error", "timeout"]
        ))
        
        self.add_state(StateDefinition(
            name="suspended",
            allowed_transitions=["idle", "shutting_down"]
        ))
        
        self.add_state(StateDefinition(
            name="shutting_down",
            timeout=30,
            allowed_transitions=["shutdown", "error"]
        ))
        
        self.add_state(StateDefinition(
            name="shutdown",
            allowed_transitions=[]  # Terminal state
        ))
        
        self.add_state(StateDefinition(
            name="error",
            allowed_transitions=["idle", "shutting_down"]
        ))
        
        # Timeout states
        self.add_state(StateDefinition(
            name="initializing_timeout",
            allowed_transitions=["error", "shutting_down"]
        ))
        
        self.add_state(StateDefinition(
            name="timeout",
            allowed_transitions=["idle", "error"]
        ))
    
    def _setup_transitions(self):
        """Setup standard transitions"""
        # Initialization flow
        self.add_transition("uninitialized", "initializing")
        self.add_transition("initializing", "idle")
        self.add_transition("initializing", "error")
        
        # Normal operation
        self.add_transition("idle", "processing")
        self.add_transition("processing", "idle")
        self.add_transition("processing", "waiting")
        self.add_transition("waiting", "processing")
        self.add_transition("waiting", "idle")
        
        # Suspension
        self.add_transition("idle", "suspended")
        self.add_transition("suspended", "idle")
        
        # Error handling
        self.add_transition("idle", "error")
        self.add_transition("processing", "error")
        self.add_transition("waiting", "error")
        self.add_transition("error", "idle")
        
        # Shutdown
        self.add_transition("idle", "shutting_down")
        self.add_transition("processing", "shutting_down")
        self.add_transition("suspended", "shutting_down")
        self.add_transition("error", "shutting_down")
        self.add_transition("shutting_down", "shutdown")
```

#### SubTask 3.4.2: 상태 지속성 관리
**담당자**: 백엔드 개발자  
**예상 소요시간**: 10시간

**작업 내용**:
```typescript
// backend/src/agents/state/persistence.ts
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, GetCommand, PutCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { BaseAgent } from '../framework/base-agent';

interface AgentState {
  agentId: string;
  agentName: string;
  currentState: string;
  previousState?: string;
  stateData: Record<string, any>;
  context: Record<string, any>;
  checkpoints: Checkpoint[];
  lastUpdated: Date;
  version: number;
}

interface Checkpoint {
  id: string;
  timestamp: Date;
  state: string;
  data: Record<string, any>;
  metadata: Record<string, any>;
}

export class StatePersistenceManager {
  private dynamoClient: DynamoDBDocumentClient;
  private s3Client: S3Client;
  private tableName: string;
  private bucketName: string;
  
  constructor(config: {
    region: string;
    tableName: string;
    bucketName: string;
  }) {
    const dynamodb = new DynamoDBClient({ region: config.region });
    this.dynamoClient = DynamoDBDocumentClient.from(dynamodb);
    this.s3Client = new S3Client({ region: config.region });
    this.tableName = config.tableName;
    this.bucketName = config.bucketName;
  }
  
  async saveState(agent: BaseAgent, stateData: any = {}): Promise<void> {
    const state: AgentState = {
      agentId: agent.id,
      agentName: agent.name,
      currentState: agent.status,
      stateData: {
        ...stateData,
        taskCount: agent.getTaskCount(),
        metrics: agent.getMetrics()
      },
      context: agent.context || {},
      checkpoints: [],
      lastUpdated: new Date(),
      version: 1
    };
    
    // Save to DynamoDB
    await this.dynamoClient.send(new PutCommand({
      TableName: this.tableName,
      Item: {
        PK: `AGENT#${agent.id}`,
        SK: 'STATE#CURRENT',
        ...state,
        TTL: Math.floor(Date.now() / 1000) + (30 * 24 * 60 * 60) // 30 days
      },
      ConditionExpression: 'attribute_not_exists(PK) OR version < :version',
      ExpressionAttributeValues: {
        ':version': state.version
      }
    }));
    
    // Save state history
    await this.saveStateHistory(agent.id, state);
  }
  
  async loadState(agentId: string): Promise<AgentState | null> {
    try {
      const response = await this.dynamoClient.send(new GetCommand({
        TableName: this.tableName,
        Key: {
          PK: `AGENT#${agentId}`,
          SK: 'STATE#CURRENT'
        }
      }));
      
      if (!response.Item) {
        return null;
      }
      
      return response.Item as AgentState;
    } catch (error) {
      console.error(`Failed to load state for agent ${agentId}:`, error);
      return null;
    }
  }
  
  async createCheckpoint(
    agent: BaseAgent,
    metadata: Record<string, any> = {}
  ): Promise<string> {
    const checkpointId = `checkpoint-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    const checkpoint: Checkpoint = {
      id: checkpointId,
      timestamp: new Date(),
      state: agent.status,
      data: await this.serializeAgentData(agent),
      metadata
    };
    
    // For large checkpoints, store in S3
    if (JSON.stringify(checkpoint.data).length > 400 * 1024) { // 400KB
      await this.saveCheckpointToS3(agent.id, checkpoint);
      
      // Store reference in DynamoDB
      await this.dynamoClient.send(new UpdateCommand({
        TableName: this.tableName,
        Key: {
          PK: `AGENT#${agent.id}`,
          SK: 'STATE#CURRENT'
        },
        UpdateExpression: 'SET checkpoints = list_append(if_not_exists(checkpoints, :empty), :checkpoint)',
        ExpressionAttributeValues: {
          ':empty': [],
          ':checkpoint': [{
            id: checkpointId,
            timestamp: checkpoint.timestamp,
            location: 's3',
            metadata
          }]
        }
      }));
    } else {
      // Store directly in DynamoDB
      await this.dynamoClient.send(new UpdateCommand({
        TableName: this.tableName,
        Key: {
          PK: `AGENT#${agent.id}`,
          SK: 'STATE#CURRENT'
        },
        UpdateExpression: 'SET checkpoints = list_append(if_not_exists(checkpoints, :empty), :checkpoint)',
        ExpressionAttributeValues: {
          ':empty': [],
          ':checkpoint': [checkpoint]
        }
      }));
    }
    
    return checkpointId;
  }
  
  async restoreFromCheckpoint(
    agent: BaseAgent,
    checkpointId: string
  ): Promise<void> {
    // Load current state to find checkpoint
    const state = await this.loadState(agent.id);
    if (!state) {
      throw new Error('No state found for agent');
    }
    
    // Find checkpoint
    const checkpointRef = state.checkpoints.find(cp => cp.id === checkpointId);
    if (!checkpointRef) {
      throw new Error(`Checkpoint ${checkpointId} not found`);
    }
    
    let checkpoint: Checkpoint;
    
    if ((checkpointRef as any).location === 's3') {
      checkpoint = await this.loadCheckpointFromS3(agent.id, checkpointId);
    } else {
      checkpoint = checkpointRef;
    }
    
    // Restore agent state
    await this.restoreAgentData(agent, checkpoint.data);
    
    // Update current state
    await this.saveState(agent, {
      restoredFrom: checkpointId,
      restoreTimestamp: new Date()
    });
  }
  
  private async saveCheckpointToS3(
    agentId: string,
    checkpoint: Checkpoint
  ): Promise<void> {
    const key = `agent-checkpoints/${agentId}/${checkpoint.id}.json`;
    
    await this.s3Client.send(new PutObjectCommand({
      Bucket: this.bucketName,
      Key: key,
      Body: JSON.stringify(checkpoint),
      ContentType: 'application/json',
      Metadata: {
        agentId,
        checkpointId: checkpoint.id,
        timestamp: checkpoint.timestamp.toISOString()
      }
    }));
  }
  
  private async loadCheckpointFromS3(
    agentId: string,
    checkpointId: string
  ): Promise<Checkpoint> {
    const key = `agent-checkpoints/${agentId}/${checkpointId}.json`;
    
    const response = await this.s3Client.send(new GetObjectCommand({
      Bucket: this.bucketName,
      Key: key
    }));
    
    const data = await response.Body!.transformToString();
    return JSON.parse(data);
  }
  
  private async saveStateHistory(
    agentId: string,
    state: AgentState
  ): Promise<void> {
    // Save state transition to history
    await this.dynamoClient.send(new PutCommand({
      TableName: this.tableName,
      Item: {
        PK: `AGENT#${agentId}`,
        SK: `HISTORY#${new Date().toISOString()}`,
        ...state,
        TTL: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60) // 7 days
      }
    }));
  }
  
  async getStateHistory(
    agentId: string,
    limit: number = 100
  ): Promise<AgentState[]> {
    const response = await this.dynamoClient.send(new QueryCommand({
      TableName: this.tableName,
      KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk)',
      ExpressionAttributeValues: {
        ':pk': `AGENT#${agentId}`,
        ':sk': 'HISTORY#'
      },
      ScanIndexForward: false, // Newest first
      Limit: limit
    }));
    
    return (response.Items || []) as AgentState[];
  }
  
  private async serializeAgentData(agent: BaseAgent): Promise<any> {
    // Serialize agent-specific data
    return {
      status: agent.status,
      context: agent.context,
      metrics: agent.getMetrics(),
      capabilities: agent.getCapabilities(),
      customData: await agent.getCustomStateData()
    };
  }
  
  private async restoreAgentData(agent: BaseAgent, data: any): Promise<void> {
    // Restore agent-specific data
    agent.status = data.status;
    agent.context = data.context;
    
    if (data.customData) {
      await agent.restoreCustomStateData(data.customData);
    }
  }
  
  async cleanupOldStates(olderThanDays: number = 30): Promise<number> {
    // Cleanup old state history entries
    const cutoffTime = new Date();
    cutoffTime.setDate(cutoffTime.getDate() - olderThanDays);
    
    // This would typically be done via DynamoDB TTL
    // Here we return the count of items that would be cleaned
    const response = await this.dynamoClient.send(new QueryCommand({
      TableName: this.tableName,
      IndexName: 'TTLIndex',
      KeyConditionExpression: 'TTL < :ttl',
      ExpressionAttributeValues: {
        ':ttl': Math.floor(cutoffTime.getTime() / 1000)
      },
      Select: 'COUNT'
    }));
    
    return response.Count || 0;
  }
}

// State recovery service
export class StateRecoveryService {
  constructor(
    private persistenceManager: StatePersistenceManager,
    private agentRegistry: any
  ) {}
  
  async recoverAgent(agentId: string): Promise<BaseAgent | null> {
    // Load persisted state
    const state = await this.persistenceManager.loadState(agentId);
    if (!state) {
      return null;
    }
    
    // Create agent instance
    const AgentClass = this.agentRegistry.getAgentClass(state.agentName);
    if (!AgentClass) {
      throw new Error(`Unknown agent type: ${state.agentName}`);
    }
    
    const agent = new AgentClass();
    agent.id = agentId;
    
    // Restore state
    agent.status = state.currentState;
    agent.context = state.context;
    
    // Initialize agent
    await agent.initialize();
    
    // Restore custom data
    if (state.stateData.customData) {
      await agent.restoreCustomStateData(state.stateData.customData);
    }
    
    return agent;
  }
  
  async recoverAllAgents(): Promise<BaseAgent[]> {
    // This would query for all agents that need recovery
    // For now, return empty array
    return [];
  }
}
```

#### SubTask 3.4.3: 분산 상태 동기화
**담당자**: 백엔드 개발자  
**예상 소요시간**: 12시간

**작업 내용**:
```python
# backend/src/agents/state/distributed_sync.py
import asyncio
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass
from datetime import datetime
import json
import hashlib
from enum import Enum

class SyncStrategy(Enum):
    LEADER_FOLLOWER = "leader_follower"
    PEER_TO_PEER = "peer_to_peer"
    EVENTUAL_CONSISTENCY = "eventual_consistency"
    STRONG_CONSISTENCY = "strong_consistency"

@dataclass
class StateVersion:
    version: int
    timestamp: datetime
    hash: str
    node_id: str

@dataclass
class StateDelta:
    from_version: int
    to_version: int
    operations: List[Dict[str, Any]]
    timestamp: datetime

class DistributedStateSync:
    """Distributed state synchronization for agents"""
    
    def __init__(
        self,
        node_id: str,
        strategy: SyncStrategy = SyncStrategy.EVENTUAL_CONSISTENCY
    ):
        self.node_id = node_id
        self.strategy = strategy
        self.state_store: Dict[str, Any] = {}
        self.version_history: List[StateVersion] = []
        self.pending_syncs: asyncio.Queue = asyncio.Queue()
        self.peer_nodes: Set[str] = set()
        self.is_leader = False
        self.sync_interval = 1.0  # seconds
        self._sync_task: Optional[asyncio.Task] = None
        
    async def start(self):
        """Start synchronization process"""
        self._sync_task = asyncio.create_task(self._sync_loop())
        
        if self.strategy == SyncStrategy.LEADER_FOLLOWER:
            await self._participate_in_leader_election()
    
    async def stop(self):
        """Stop synchronization process"""
        if self._sync_task:
            self._sync_task.cancel()
            await asyncio.gather(self._sync_task, return_exceptions=True)
    
    async def update_state(
        self,
        key: str,
        value: Any,
        metadata: Dict[str, Any] = None
    ) -> StateVersion:
        """Update local state and propagate to peers"""
        # Update local state
        self.state_store[key] = value
        
        # Create new version
        version = self._create_version()
        self.version_history.append(version)
        
        # Create delta
        delta = StateDelta(
            from_version=version.version - 1 if version.version > 1 else 0,
            to_version=version.version,
            operations=[{
                'type': 'update',
                'key': key,
                'value': value,
                'metadata': metadata
            }],
            timestamp=datetime.utcnow()
        )
        
        # Queue for synchronization
        await self.pending_syncs.put(delta)
        
        # Immediate sync for strong consistency
        if self.strategy == SyncStrategy.STRONG_CONSISTENCY:
            await self._sync_immediately(delta)
        
        return version
    
    async def get_state(self, key: str) -> Any:
        """Get state value"""
        if self.strategy == SyncStrategy.STRONG_CONSISTENCY:
            # Ensure we have latest state
            await self._fetch_latest_state(key)
        
        return self.state_store.get(key)
    
    async def _sync_loop(self):
        """Main synchronization loop"""
        while True:
            try:
                # Process pending syncs
                if not self.pending_syncs.empty():
                    await self._process_pending_syncs()
                
                # Periodic sync based on strategy
                if self.strategy == SyncStrategy.PEER_TO_PEER:
                    await self._peer_sync()
                elif self.strategy == SyncStrategy.LEADER_FOLLOWER:
                    await self._leader_follower_sync()
                
                await asyncio.sleep(self.sync_interval)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Sync error: {e}")
                await asyncio.sleep(self.sync_interval * 2)
    
    async def _process_pending_syncs(self):
        """Process pending synchronization deltas"""
        batch = []
        
        # Batch multiple updates
        while not self.pending_syncs.empty() and len(batch) < 100:
            delta = await self.pending_syncs.get()
            batch.append(delta)
        
        if batch:
            await self._broadcast_deltas(batch)
    
    async def _broadcast_deltas(self, deltas: List[StateDelta]):
        """Broadcast state deltas to peer nodes"""
        message = {
            'type': 'state_sync',
            'node_id': self.node_id,
            'deltas': [self._serialize_delta(d) for d in deltas]
        }
        
        # Send to all peers
        tasks = []
        for peer in self.peer_nodes:
            task = asyncio.create_task(
                self._send_to_peer(peer, message)
            )
            tasks.append(task)
        
        # Wait for acknowledgments based on strategy
        if self.strategy == SyncStrategy.STRONG_CONSISTENCY:
            # Wait for all peers
            results = await asyncio.gather(*tasks, return_exceptions=True)
            failures = [r for r in results if isinstance(r, Exception)]
            if failures:
                raise Exception(f"Failed to sync to {len(failures)} peers")
        else:
            # Fire and forget for eventual consistency
            asyncio.gather(*tasks, return_exceptions=True)
    
    async def _peer_sync(self):
        """Peer-to-peer synchronization"""
        # Select random peer for anti-entropy
        if not self.peer_nodes:
            return
        
        peer = random.choice(list(self.peer_nodes))
        
        # Exchange version vectors
        our_vector = self._get_version_vector()
        peer_vector = await self._get_peer_version_vector(peer)
        
        # Determine what we need from peer
        needed_versions = self._compute_needed_versions(our_vector, peer_vector)
        if needed_versions:
            await self._request_states(peer, needed_versions)
        
        # Determine what peer needs from us
        peer_needs = self._compute_needed_versions(peer_vector, our_vector)
        if peer_needs:
            await self._send_states(peer, peer_needs)
    
    async def _leader_follower_sync(self):
        """Leader-follower synchronization"""
        if self.is_leader:
            # Leader broadcasts state to followers
            current_state = self._get_full_state()
            message = {
                'type': 'leader_state_push',
                'state': current_state,
                'version': self._get_current_version()
            }
            
            await self._broadcast_to_followers(message)
        else:
            # Follower requests state from leader
            leader = await self._get_current_leader()
            if leader:
                await self._request_state_from_leader(leader)
    
    def _create_version(self) -> StateVersion:
        """Create new state version"""
        version_num = len(self.version_history) + 1
        state_hash = self._compute_state_hash()
        
        return StateVersion(
            version=version_num,
            timestamp=datetime.utcnow(),
            hash=state_hash,
            node_id=self.node_id
        )
    
    def _compute_state_hash(self) -> str:
        """Compute hash of current state"""
        state_json = json.dumps(self.state_store, sort_keys=True)
        return hashlib.sha256(state_json.encode()).hexdigest()
    
    def _serialize_delta(self, delta: StateDelta) -> Dict[str, Any]:
        """Serialize state delta for transmission"""
        return {
            'from_version': delta.from_version,
            'to_version': delta.to_version,
            'operations': delta.operations,
            'timestamp': delta.timestamp.isoformat()
        }
    
    async def handle_sync_message(self, message: Dict[str, Any]):
        """Handle incoming sync message from peer"""
        msg_type = message.get('type')
        
        if msg_type == 'state_sync':
            await self._handle_state_sync(message)
        elif msg_type == 'version_vector_request':
            await self._handle_version_vector_request(message)
        elif msg_type == 'state_request':
            await self._handle_state_request(message)
        elif msg_type == 'leader_state_push':
            await self._handle_leader_push(message)
    
    async def _handle_state_sync(self, message: Dict[str, Any]):
        """Handle state synchronization message"""
        deltas = message.get('deltas', [])
        
        for delta_data in deltas:
            delta = self._deserialize_delta(delta_data)
            await self._apply_delta(delta)
    
    async def _apply_delta(self, delta: StateDelta):
        """Apply state delta to local state"""
        for operation in delta.operations:
            op_type = operation['type']
            
            if op_type == 'update':
                self.state_store[operation['key']] = operation['value']
            elif op_type == 'delete':
                self.state_store.pop(operation['key'], None)
            elif op_type == 'merge':
                await self._merge_state(
                    operation['key'],
                    operation['value']
                )
    
    async def _merge_state(self, key: str, remote_value: Any):
        """Merge remote state with local state"""
        local_value = self.state_store.get(key)
        
        if local_value is None:
            self.state_store[key] = remote_value
        elif isinstance(local_value, dict) and isinstance(remote_value, dict):
            # Deep merge for dictionaries
            merged = self._deep_merge(local_value, remote_value)
            self.state_store[key] = merged
        elif isinstance(local_value, list) and isinstance(remote_value, list):
            # CRDT-style merge for lists
            merged = list(set(local_value + remote_value))
            self.state_store[key] = merged
        else:
            # Last-write-wins for other types
            self.state_store[key] = remote_value
    
    def _deep_merge(self, dict1: Dict, dict2: Dict) -> Dict:
        """Deep merge two dictionaries"""
        result = dict1.copy()
        
        for key, value in dict2.items():
            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                result[key] = self._deep_merge(result[key], value)
            else:
                result[key] = value
        
        return result
    
    # Conflict resolution strategies
    async def resolve_conflict(
        self,
        key: str,
        local_value: Any,
        remote_value: Any,
        local_version: StateVersion,
        remote_version: StateVersion
    ) -> Any:
        """Resolve conflicts between local and remote state"""
        
        # Strategy 1: Last-write-wins based on timestamp
        if local_version.timestamp > remote_version.timestamp:
            return local_value
        elif remote_version.timestamp > local_version.timestamp:
            return remote_value
        
        # Strategy 2: Higher node ID wins for same timestamp
        elif local_version.node_id > remote_version.node_id:
            return local_value
        else:
            return remote_value
```

#### SubTask 3.4.4: 상태 모니터링 대시보드
**담당자**: 풀스택 개발자  
**예상 소요시간**: 10시간

**작업 내용**:
```typescript
// backend/src/agents/state/monitoring.ts
import { EventEmitter } from 'events';
import WebSocket from 'ws';
import { BaseAgent } from '../framework/base-agent';

interface StateMetrics {
  totalTransitions: number;
  transitionsPerMinute: number;
  averageTimeInState: Record<string, number>;
  stateDistribution: Record<string, number>;
  errorRate: number;
  lastError?: {
    timestamp: Date;
    message: string;
    state: string;
  };
}

interface StateMonitorConfig {
  metricsInterval: number;
  historySize: number;
  alertThresholds: {
    errorRate: number;
    stuckInStateMinutes: number;
  };
}

export class StateMonitor extends EventEmitter {
  private agents: Map<string, BaseAgent> = new Map();
  private metrics: Map<string, StateMetrics> = new Map();
  private stateHistory: Map<string, any[]> = new Map();
  private config: StateMonitorConfig;
  private metricsInterval?: NodeJS.Timeout;
  private wsServer?: WebSocket.Server;
  
  constructor(config: StateMonitorConfig) {
    super();
    this.config = config;
  }
  
  startMonitoring(port: number = 8080): void {
    // Start metrics collection
    this.metricsInterval = setInterval(() => {
      this.collectMetrics();
    }, this.config.metricsInterval);
    
    // Start WebSocket server for real-time updates
    this.wsServer = new WebSocket.Server({ port });
    
    this.wsServer.on('connection', (ws) => {
      // Send initial state
      ws.send(JSON.stringify({
        type: 'initial',
        data: this.getMonitoringData()
      }));
      
      // Setup real-time updates
      const updateHandler = (data: any) => {
        ws.send(JSON.stringify({
          type: 'update',
          data
        }));
      };
      
      this.on('metrics:update', updateHandler);
      
      ws.on('close', () => {
        this.off('metrics:update', updateHandler);
      });
    });
  }
  
  stopMonitoring(): void {
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval);
    }
    
    if (this.wsServer) {
      this.wsServer.close();
    }
  }
  
  monitorAgent(agent: BaseAgent): void {
    this.agents.set(agent.id, agent);
    
    // Initialize metrics
    this.metrics.set(agent.id, {
      totalTransitions: 0,
      transitionsPerMinute: 0,
      averageTimeInState: {},
      stateDistribution: {},
      errorRate: 0
    });
    
    // Initialize history
    this.stateHistory.set(agent.id, []);
    
    // Attach listeners
    this.attachStateListeners(agent);
  }
  
  private attachStateListeners(agent: BaseAgent): void {
    agent.on('state:transition', (data) => {
      this.recordTransition(agent.id, data);
    });
    
    agent.on('state:error', (error) => {
      this.recordError(agent.id, error);
    });
  }
  
  private recordTransition(agentId: string, data: any): void {
    const history = this.stateHistory.get(agentId) || [];
    
    history.push({
      timestamp: new Date(),
      from: data.from,
      to: data.to,
      duration: data.duration
    });
    
    // Limit history size
    if (history.length > this.config.historySize) {
      history.shift();
    }
    
    // Update metrics
    const metrics = this.metrics.get(agentId);
    if (metrics) {
      metrics.totalTransitions++;
      
      // Update state distribution
      metrics.stateDistribution[data.to] = 
        (metrics.stateDistribution[data.to] || 0) + 1;
      
      // Update average time in state
      const currentAvg = metrics.averageTimeInState[data.from] || 0;
      const count = metrics.stateDistribution[data.from] || 1;
      metrics.averageTimeInState[data.from] = 
        (currentAvg * (count - 1) + data.duration) / count;
    }
    
    // Check for alerts
    this.checkAlerts(agentId);
    
    // Emit update
    this.emit('metrics:update', {
      agentId,
      type: 'transition',
      data
    });
  }
  
  private recordError(agentId: string, error: any): void {
    const metrics = this.metrics.get(agentId);
    if (metrics) {
      metrics.lastError = {
        timestamp: new Date(),
        message: error.message,
        state: error.state
      };
      
      // Update error rate
      const history = this.stateHistory.get(agentId) || [];
      const recentErrors = history.filter(h => 
        h.error && 
        new Date().getTime() - h.timestamp.getTime() < 60000
      ).length;
      
      metrics.errorRate = recentErrors / Math.max(history.length, 1);
    }
    
    // Emit update
    this.emit('metrics:update', {
      agentId,
      type: 'error',
      error
    });
  }
  
  private collectMetrics(): void {
    for (const [agentId, agent] of this.agents) {
      const metrics = this.metrics.get(agentId);
      if (!metrics) continue;
      
      // Calculate transitions per minute
      const history = this.stateHistory.get(agentId) || [];
      const oneMinuteAgo = new Date().getTime() - 60000;
      const recentTransitions = history.filter(h => 
        h.timestamp.getTime() > oneMinuteAgo
      ).length;
      
      metrics.transitionsPerMinute = recentTransitions;
    }
  }
  
  private checkAlerts(agentId: string): void {
    const metrics = this.metrics.get(agentId);
    const agent = this.agents.get(agentId);
    
    if (!metrics || !agent) return;
    
    // Check error rate threshold
    if (metrics.errorRate > this.config.alertThresholds.errorRate) {
      this.emit('alert', {
        agentId,
        type: 'high_error_rate',
        message: `Error rate ${metrics.errorRate} exceeds threshold`,
        severity: 'warning'
      });
    }
    
    // Check stuck in state
    const currentStateTime = agent.getTimeInCurrentState();
    if (currentStateTime && 
        currentStateTime > this.config.alertThresholds.stuckInStateMinutes * 60) {
      this.emit('alert', {
        agentId,
        type: 'stuck_in_state',
        message: `Agent stuck in ${agent.status} for ${currentStateTime}s`,
        severity: 'warning'
      });
    }
  }
  
  getMonitoringData(): any {
    const agentsData = [];
    
    for (const [agentId, agent] of this.agents) {
      const metrics = this.metrics.get(agentId);
      const history = this.stateHistory.get(agentId);
      
      agentsData.push({
        id: agentId,
        name: agent.name,
        currentState: agent.status,
        metrics,
        recentHistory: history?.slice(-10) || []
      });
    }
    
    return {
      agents: agentsData,
      summary: this.calculateSummary()
    };
  }
  
  private calculateSummary(): any {
    let totalAgents = 0;
    let activeAgents = 0;
    let errorAgents = 0;
    let totalTransitions = 0;
    
    for (const [agentId, agent] of this.agents) {
      totalAgents++;
      
      if (agent.status === 'processing' || agent.status === 'waiting') {
        activeAgents++;
      }
      
      if (agent.status === 'error') {
        errorAgents++;
      }
      
      const metrics = this.metrics.get(agentId);
      if (metrics) {
        totalTransitions += metrics.totalTransitions;
      }
    }
    
    return {
      totalAgents,
      activeAgents,
      errorAgents,
      totalTransitions,
      timestamp: new Date()
    };
  }
  
  // Dashboard API endpoints
  getAgentStateHistory(agentId: string, limit: number = 100): any[] {
    const history = this.stateHistory.get(agentId) || [];
    return history.slice(-limit);
  }
  
  getAgentMetrics(agentId: string): StateMetrics | undefined {
    return this.metrics.get(agentId);
  }
  
  getAllAgentsStatus(): any[] {
    const status = [];
    
    for (const [agentId, agent] of this.agents) {
      status.push({
        id: agentId,
        name: agent.name,
        status: agent.status,
        uptime: agent.getUptime(),
        lastActivity: agent.getLastActivity()
      });
    }
    
    return status;
  }
}

// State visualization component
export class StateVisualization {
  generateStateDiagram(transitions: any[]): string {
    // Generate Mermaid diagram for state transitions
    const lines = ['stateDiagram-v2'];
    const states = new Set<string>();
    const transitionMap = new Map<string, Set<string>>();
    
    // Collect states and transitions
    for (const t of transitions) {
      states.add(t.from);
      states.add(t.to);
      
      if (!transitionMap.has(t.from)) {
        transitionMap.set(t.from, new Set());
      }
      transitionMap.get(t.from)!.add(t.to);
    }
    
    // Add state definitions
    for (const state of states) {
      if (state === 'error') {
        lines.push(`    ${state}: Error State`);
        lines.push(`    ${state} --> [*]`);
      } else if (state === 'shutdown') {
        lines.push(`    ${state}: Shutdown`);
        lines.push(`    ${state} --> [*]`);
      }
    }
    
    // Add transitions
    for (const [from, tos] of transitionMap) {
      for (const to of tos) {
        lines.push(`    ${from} --> ${to}`);
      }
    }
    
    return lines.join('\n');
  }
  
  generateMetricsChart(metrics: StateMetrics): any {
    // Generate chart data for state metrics
    return {
      stateDistribution: {
        type: 'pie',
        data: {
          labels: Object.keys(metrics.stateDistribution),
          datasets: [{
            data: Object.values(metrics.stateDistribution),
            backgroundColor: [
              '#4CAF50', '#2196F3', '#FF9800', 
              '#F44336', '#9C27B0', '#00BCD4'
            ]
          }]
        }
      },
      averageTimeInState: {
        type: 'bar',
        data: {
          labels: Object.keys(metrics.averageTimeInState),
          datasets: [{
            label: 'Average Time (seconds)',
            data: Object.values(metrics.averageTimeInState),
            backgroundColor: '#2196F3'
          }]
        }
      },
      transitionsOverTime: {
        type: 'line',
        data: {
          labels: [], // Time labels
          datasets: [{
            label: 'Transitions per Minute',
            data: [], // Transition counts
            borderColor: '#4CAF50',
            tension: 0.1
          }]
        }
      }
    };
  }
}
```

---

### Task 3.5: Business Analyst Agent 구현

#### SubTask 3.5.1: 요구사항 분석 엔진
**담당자**: AI/ML 엔지니어  
**예상 소요시간**: 16시간

**작업 내용**:
```python
# backend/src/agents/implementations/business_analyst_agent.py
from typing import Dict, List, Any, Optional
import json
from dataclasses import dataclass
from enum import Enum

from ..framework.base_agent import BaseAgent
from ..framework.agno_integration import AgnoEnabledAgent
from ..framework.squad_integration import SquadEnabledAgent

class RequirementType(Enum):
    FUNCTIONAL = "functional"
    NON_FUNCTIONAL = "non_functional"
    TECHNICAL = "technical"
    BUSINESS = "business"
    USER_EXPERIENCE = "user_experience"

@dataclass
class Requirement:
    id: str
    type: RequirementType
    description: str
    priority: str  # high, medium, low
    acceptance_criteria: List[str]
    dependencies: List[str]
    estimated_effort: Optional[str]
    metadata: Dict[str, Any]

@dataclass
class ProjectScope:
    objectives: List[str]
    deliverables: List[str]
    constraints: List[str]
    assumptions: List[str]
    risks: List[Dict[str, Any]]
    timeline: Dict[str, Any]

class BusinessAnalystAgent(AgnoEnabledAgent, SquadEnabledAgent):
    """Business Analyst Agent for requirements analysis and project scoping"""
    
    def __init__(self):
        AgnoEnabledAgent.__init__(
            self,
            name="BusinessAnalystAgent",
            agno_config={
                'modelId': 'anthropic.claude-3-opus-v1:0',
                'temperature': 0.3,
                'maxTokens': 8000,
                'tools': [
                    self._create_requirement_analyzer_tool(),
                    self._create_scope_definition_tool(),
                    self._create_stakeholder_analysis_tool()
                ]
            }
        )
        SquadEnabledAgent.__init__(self, name="BusinessAnalystAgent", team_size=3)
        
        self.requirements: List[Requirement] = []
        self.project_scope: Optional[ProjectScope] = None
        self.domain_knowledge_base = {}
        
    async def initialize(self) -> None:
        await AgnoEnabledAgent.initialize(self)
        await SquadEnabledAgent.initialize(self)
        
        # Load domain knowledge
        await self._load_domain_knowledge()
        
        # Register capabilities
        self.capabilities = [
            {
                'name': 'analyze_requirements',
                'description': 'Extract and analyze project requirements from description',
                'input_schema': {
                    'type': 'object',
                    'properties': {
                        'description': {'type': 'string'},
                        'context': {'type': 'object'}
                    }
                }
            },
            {
                'name': 'define_scope',
                'description': 'Define project scope and boundaries',
                'input_schema': {
                    'type': 'object',
                    'properties': {
                        'requirements': {'type': 'array'},
                        'constraints': {'type': 'array'}
                    }
                }
            },
            {
                'name': 'create_user_stories',
                'description': 'Generate user stories from requirements',
                'input_schema': {
                    'type': 'object',
                    'properties': {
                        'requirements': {'type': 'array'},
                        'user_personas': {'type': 'array'}
                    }
                }
            }
        ]
    
    async def process_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Process business analysis task"""
        task_type = task.get('task_type')
        
        if task_type == 'analyze_project':
            return await self.analyze_project(task['data'])
        elif task_type == 'extract_requirements':
            return await self.extract_requirements(task['data'])
        elif task_type == 'define_scope':
            return await self.define_project_scope(task['data'])
        elif task_type == 'create_user_stories':
            return await self.create_user_stories(task['data'])
        else:
            raise ValueError(f"Unknown task type: {task_type}")
    
    async def analyze_project(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Comprehensive project analysis"""
        description = data.get('description', '')
        context = data.get('context', {})
        
        # Use Agno for initial analysis
        analysis_prompt = f"""
        Analyze this project description and extract:
        1. Business objectives and goals
        2. Target users and stakeholders
        3. Key features and functionalities
        4. Technical requirements and constraints
        5. Success criteria and KPIs
        6. Potential risks and challenges
        
        Project Description: {description}
        
        Context: {json.dumps(context, indent=2)}
        
        Provide a comprehensive analysis in structured format.
        """
        
        initial_analysis = await self.processWithAgno(
            analysis_prompt,
            context={'analysis_type': 'comprehensive'}
        )
        
        # Use Squad for detailed analysis
        squad_task = {
            'objective': 'Perform detailed business analysis',
            'context': {
                'description': description,
                'initial_analysis': initial_analysis
            },
            'requirements': [
                'Identify all stakeholders',
                'Extract functional requirements',
                'Define non-functional requirements',
                'Assess technical feasibility',
                'Estimate project complexity'
            ]
        }
        
        detailed_analysis = await self.execute_with_squad(squad_task)
        
        # Process and structure results
        return await self._process_analysis_results(
            initial_analysis,
            detailed_analysis
        )
    
    async def extract_requirements(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract detailed requirements from project description"""
        
        # Extract functional requirements
        functional_reqs = await self._extract_functional_requirements(data)
        
        # Extract non-functional requirements
        non_functional_reqs = await self._extract_non_functional_requirements(data)
        
        # Extract technical requirements
        technical_reqs = await self._extract_technical_requirements(data)
        
        # Prioritize requirements
        prioritized_reqs = await self._prioritize_requirements(
            functional_reqs + non_functional_reqs + technical_reqs
        )
        
        # Identify dependencies
        dependencies = await self._identify_dependencies(prioritized_reqs)
        
        # Store requirements
        self.requirements = prioritized_reqs
        
        return {
            'requirements': [req.__dict__ for req in prioritized_reqs],
            'dependencies': dependencies,
            'summary': {
                'total': len(prioritized_reqs),
                'functional': len(functional_reqs),
                'non_functional': len(non_functional_reqs),
                'technical': len(technical_reqs),
                'high_priority': len([r for r in prioritized_reqs if r.priority == 'high'])
            }
        }
    
    async def _extract_functional_requirements(
        self, 
        data: Dict[str, Any]
    ) -> List[Requirement]:
        """Extract functional requirements"""
        prompt = f"""
        Extract all functional requirements from this project description.
        For each requirement, provide:
        - Clear description
        - Acceptance criteria
        - User impact
        - Implementation complexity
        
        Project: {data.get('description')}
        
        Format as structured list.
        """
        
        response = await self.processWithAgno(prompt)
        
        requirements = []
        for idx, req_data in enumerate(response.get('requirements', [])):
            requirement = Requirement(
                id=f"FR-{idx+1:03d}",
                type=RequirementType.FUNCTIONAL,
                description=req_data['description'],
                priority=req_data.get('priority', 'medium'),
                acceptance_criteria=req_data.get('acceptance_criteria', []),
                dependencies=[],
                estimated_effort=req_data.get('complexity'),
                metadata={
                    'user_impact': req_data.get('user_impact'),
                    'business_value': req_data.get('business_value')
                }
            )
            requirements.append(requirement)
        
        return requirements
    
    async def _extract_non_functional_requirements(
        self, 
        data: Dict[str, Any]
    ) -> List[Requirement]:
        """Extract non-functional requirements"""
        categories = [
            'performance',
            'security',
            'scalability',
            'reliability',
            'usability',
            'maintainability',
            'compatibility',
            'compliance'
        ]
        
        requirements = []
        for category in categories:
            category_reqs = await self._extract_category_requirements(
                data, 
                category
            )
            requirements.extend(category_reqs)
        
        return requirements
    
    async def _prioritize_requirements(
        self, 
        requirements: List[Requirement]
    ) -> List[Requirement]:
        """Prioritize requirements using multiple criteria"""
        
        prioritization_criteria = {
            'business_value': 0.3,
            'user_impact': 0.25,
            'technical_risk': 0.2,
            'implementation_effort': 0.15,
            'dependencies': 0.1
        }
        
        # Score each requirement
        for req in requirements:
            score = await self._calculate_requirement_score(
                req, 
                prioritization_criteria
            )
            req.metadata['priority_score'] = score
            
            # Assign priority based on score
            if score >= 0.7:
                req.priority = 'high'
            elif score >= 0.4:
                req.priority = 'medium'
            else:
                req.priority = 'low'
        
        # Sort by priority score
        return sorted(
            requirements, 
            key=lambda r: r.metadata.get('priority_score', 0),
            reverse=True
        )
    
    async def define_project_scope(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Define comprehensive project scope"""
        
        requirements = data.get('requirements', self.requirements)
        constraints = data.get('constraints', [])
        
        # Define objectives based on requirements
        objectives = await self._define_objectives(requirements)
        
        # Define deliverables
        deliverables = await self._define_deliverables(requirements, objectives)
        
        # Identify assumptions and risks
        assumptions = await self._identify_assumptions(requirements, constraints)
        risks = await self._assess_risks(requirements, constraints)
        
        # Create timeline
        timeline = await self._create_timeline(requirements, deliverables)
        
        self.project_scope = ProjectScope(
            objectives=objectives,
            deliverables=deliverables,
            constraints=constraints,
            assumptions=assumptions,
            risks=risks,
            timeline=timeline
        )
        
        return {
            'scope': self.project_scope.__dict__,
            'feasibility_score': await self._assess_feasibility(),
            'recommendations': await self._generate_recommendations()
        }
    
    async def create_user_stories(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Create user stories from requirements"""
        
        requirements = data.get('requirements', self.requirements)
        user_personas = data.get('user_personas', [])
        
        if not user_personas:
            # Generate default personas
            user_personas = await self._generate_user_personas(requirements)
        
        user_stories = []
        
        for req in requirements:
            if req.type == RequirementType.FUNCTIONAL:
                stories = await self._create_stories_for_requirement(
                    req, 
                    user_personas
                )
                user_stories.extend(stories)
        
        # Group by epic
        epics = await self._group_into_epics(user_stories)
        
        return {
            'user_stories': user_stories,
            'epics': epics,
            'personas': user_personas,
            'story_map': await self._create_story_map(epics)
        }
    
    def _get_lead_system_prompt(self) -> str:
        """System prompt for lead analyst agent"""
        return """
        You are a Senior Business Analyst with expertise in:
        - Requirements engineering and analysis
        - Business process modeling
        - Stakeholder management
        - Project scoping and planning
        - Risk assessment and mitigation
        
        Your role is to lead the business analysis team and ensure comprehensive
        understanding of project requirements and business objectives.
        """
    
    def _get_team_member_prompt(self, index: int) -> str:
        """System prompts for team member agents"""
        prompts = [
            """You are a Requirements Specialist focused on:
            - Functional requirements extraction
            - User story creation
            - Acceptance criteria definition""",
            
            """You are a Domain Expert focused on:
            - Industry best practices
            - Compliance requirements
            - Technical feasibility assessment""",
            
            """You are a UX Analyst focused on:
            - User experience requirements
            - Accessibility standards
            - User journey mapping"""
        ]
        
        return prompts[index % len(prompts)]
    
    async def _load_domain_knowledge(self):
        """Load domain-specific knowledge bases"""
        self.domain_knowledge_base = {
            'industries': await self._load_industry_templates(),
            'patterns': await self._load_requirement_patterns(),
            'best_practices': await self._load_best_practices()
        }
    
    def _create_requirement_analyzer_tool(self):
        """Create tool for requirement analysis"""
        return {
            'name': 'requirement_analyzer',
            'description': 'Analyze and categorize requirements',
            'parameters': {
                'type': 'object',
                'properties': {
                    'text': {'type': 'string'},
                    'category': {'type': 'string'}
                }
            }
        }
    
    # Additional helper methods would continue...
```

