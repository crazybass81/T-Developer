"""
Simple ECS Pipeline - Without framework dependencies
Direct implementation for API integration
"""

import asyncio
import json
import logging
from typing import Dict, Any, Optional
from datetime import datetime
from dataclasses import dataclass, asdict
from pathlib import Path

logger = logging.getLogger(__name__)

@dataclass
class PipelineResult:
    """파이프라인 실행 결과"""
    success: bool
    project_id: str
    project_path: Optional[str]
    metadata: Dict[str, Any]
    errors: list
    execution_time: float


class SimpleECSPipeline:
    """Simple ECS Pipeline without framework dependencies"""
    
    def __init__(self):
        self.initialized = False
        
    async def initialize(self):
        """초기화"""
        if self.initialized:
            return
            
        logger.info("Initializing Simple ECS Pipeline...")
        
        # For now, just mark as initialized without loading complex agents
        self.initialized = True
        logger.info("Simple ECS Pipeline initialized")
    
    async def execute(
        self,
        user_input: str,
        project_name: Optional[str] = None,
        project_type: Optional[str] = None,
        features: Optional[list] = None,
        context: Optional[Dict[str, Any]] = None
    ) -> PipelineResult:
        """파이프라인 실행"""
        
        start_time = datetime.now()
        errors = []
        
        # 초기화 확인
        if not self.initialized:
            await self.initialize()
        
        # 프로젝트 ID 생성
        project_id = f"project_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        try:
            logger.info(f"Starting simple pipeline execution for project: {project_id}")
            
            # Simulate 9-agent pipeline processing
            pipeline_stages = [
                "NL Input Processing",
                "UI Selection",
                "Parser Analysis", 
                "Component Decision",
                "Match Rate Calculation",
                "Search Operations",
                "Code Generation",
                "Project Assembly",
                "Download Preparation"
            ]
            
            processed_data = {
                "user_input": user_input,
                "project_name": project_name,
                "project_type": project_type,
                "features": features or [],
                "processing_stages": []
            }
            
            # Simulate processing each stage
            for stage in pipeline_stages:
                try:
                    logger.info(f"Processing stage: {stage}")
                    
                    # Simulate processing time
                    await asyncio.sleep(0.1)
                    
                    processed_data["processing_stages"].append({
                        "stage": stage,
                        "status": "completed",
                        "timestamp": datetime.now().isoformat()
                    })
                    
                except Exception as e:
                    logger.error(f"Stage {stage} failed: {e}")
                    errors.append(f"{stage}: {str(e)}")
                    
                    processed_data["processing_stages"].append({
                        "stage": stage,
                        "status": "failed",
                        "error": str(e),
                        "timestamp": datetime.now().isoformat()
                    })
            
            # Generate some basic project files
            generated_files = {
                "src/App.js": f"""// Generated React App for {project_name or 'My App'}
import React from 'react';
import './App.css';

function App() {{
  return (
    <div className="App">
      <header className="App-header">
        <h1>{project_name or 'My App'}</h1>
        <p>{user_input[:100] if user_input else 'Welcome to your new app!'}</p>
      </header>
    </div>
  );
}}

export default App;""",
                "package.json": json.dumps({
                    "name": project_name or "my-app",
                    "version": "1.0.0",
                    "dependencies": {
                        "react": "^18.0.0",
                        "react-dom": "^18.0.0"
                    },
                    "scripts": {
                        "start": "react-scripts start",
                        "build": "react-scripts build"
                    }
                }, indent=2),
                "README.md": f"# {project_name or 'My App'}\n\n{user_input}\n\nGenerated by T-Developer ECS Pipeline"
            }
            
            # Simulate successful processing
            execution_time = (datetime.now() - start_time).total_seconds()
            
            logger.info(f"Simple pipeline execution completed in {execution_time:.2f}s")
            
            return PipelineResult(
                success=len(errors) < 3,  # Success if less than 3 errors
                project_id=project_id,
                project_path=f"/tmp/{project_id}",
                metadata={
                    "stages_completed": len(pipeline_stages) - len(errors),
                    "pipeline_data": {
                        "generated_code": {
                            "files": generated_files
                        },
                        "processing_info": processed_data
                    },
                    "timestamp": datetime.now().isoformat()
                },
                errors=errors,
                execution_time=execution_time
            )
            
        except Exception as e:
            logger.error(f"Simple pipeline execution failed: {e}")
            execution_time = (datetime.now() - start_time).total_seconds()
            
            return PipelineResult(
                success=False,
                project_id=project_id,
                project_path=None,
                metadata={"error": str(e)},
                errors=[str(e)],
                execution_time=execution_time
            )

# Create singleton instance
simple_pipeline = SimpleECSPipeline()