"""
Metadata Generator Module for Assembly Agent
Generates comprehensive project metadata and documentation
"""

from typing import Dict, List, Any, Optional
import asyncio
import json
from dataclasses import dataclass
from datetime import datetime

@dataclass
class MetadataResult:
    success: bool
    deployment_configs: Dict[str, Any]
    readme_content: str
    license_content: str
    manifest_data: Dict[str, Any]
    processing_time: float
    error: str = ""

class MetadataGenerator:
    """Advanced metadata generation system"""
    
    def __init__(self):
        self.version = "1.0.0"
    
    async def generate_metadata(
        self,
        context: Dict[str, Any],
        analysis_results: Dict[str, Any]
    ) -> MetadataResult:
        """Generate comprehensive project metadata"""
        
        start_time = datetime.now()
        
        try:
            # Generate README
            readme_content = await self._generate_readme(context, analysis_results)
            
            # Generate LICENSE
            license_content = await self._generate_license(context)
            
            # Generate deployment configs
            deployment_configs = await self._generate_deployment_configs(context)
            
            # Generate manifest
            manifest_data = await self._generate_manifest(context, analysis_results)
            
            processing_time = (datetime.now() - start_time).total_seconds()
            
            return MetadataResult(
                success=True,
                deployment_configs=deployment_configs,
                readme_content=readme_content,
                license_content=license_content,
                manifest_data=manifest_data,
                processing_time=processing_time
            )
            
        except Exception as e:
            return MetadataResult(
                success=False,
                deployment_configs={},
                readme_content="",
                license_content="",
                manifest_data={},
                processing_time=(datetime.now() - start_time).total_seconds(),
                error=str(e)
            )
    
    async def _generate_readme(
        self,
        context: Dict[str, Any],
        analysis_results: Dict[str, Any]
    ) -> str:
        """Generate README.md content"""
        
        project_name = context.get('project_name', 'Generated Project')
        framework = context.get('framework', 'react')
        
        readme = f"""# {project_name}

A {framework} application generated by T-Developer.

## üöÄ Features

- Modern {framework} architecture
- Production-ready configuration
- Comprehensive testing setup
- Automated CI/CD pipeline
- Docker support

## üìã Prerequisites

- Node.js 18.x or higher (for JavaScript/TypeScript projects)
- Python 3.9+ (for Python projects)
- Docker (optional)

## üõ†Ô∏è Installation

```bash
# Clone the repository
git clone <repository-url>
cd {project_name.lower().replace(' ', '-')}

# Install dependencies
{"npm install" if framework in ['react', 'vue', 'angular', 'express'] else "pip install -r requirements.txt"}

# Start development server
{"npm run dev" if framework in ['react', 'vue', 'angular', 'express'] else "python main.py"}
```

## üìÅ Project Structure

```
{project_name.lower().replace(' ', '-')}/
‚îú‚îÄ‚îÄ src/                    # Source code
‚îú‚îÄ‚îÄ tests/                  # Test files
‚îú‚îÄ‚îÄ docs/                   # Documentation
‚îú‚îÄ‚îÄ {"public/" if framework in ['react', 'vue'] else "static/"}                 # Static assets
‚îî‚îÄ‚îÄ {"package.json" if framework in ['react', 'vue', 'angular', 'express'] else "requirements.txt"}            # Dependencies
```

## üß™ Testing

```bash
{"npm test" if framework in ['react', 'vue', 'angular', 'express'] else "pytest"}
```

## üöÄ Deployment

```bash
# Build for production
{"npm run build" if framework in ['react', 'vue', 'angular', 'express'] else "python -m build"}

# Deploy with Docker
docker build -t {project_name.lower().replace(' ', '-')} .
docker run -p {"3000:3000" if framework in ['react', 'vue', 'angular', 'express'] else "8000:8000"} {project_name.lower().replace(' ', '-')}
```

## üìÑ License

MIT License - see [LICENSE](LICENSE) file for details.

## ü§ù Contributing

1. Fork the project
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## üìû Support

For support and questions, please open an issue on GitHub.

---

*This project was generated by [T-Developer](https://github.com/t-developer-mvp) - AI-powered full-stack development platform.*
"""
        
        return readme
    
    async def _generate_license(self, context: Dict[str, Any]) -> str:
        """Generate LICENSE content"""
        
        current_year = datetime.now().year
        
        license_content = f"""MIT License

Copyright (c) {current_year} {context.get('project_name', 'Generated Project')}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
        
        return license_content
    
    async def _generate_deployment_configs(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Generate deployment configurations"""
        
        framework = context.get('framework', 'react')
        project_name = context.get('project_name', 'generated-project')
        
        configs = {
            'docker': {
                'enabled': True,
                'port': 3000 if framework in ['react', 'vue', 'angular', 'express'] else 8000,
                'environment': context.get('target_environments', ['development', 'production'])
            },
            'ci_cd': {
                'github_actions': True,
                'test_on_pr': True,
                'deploy_on_main': True
            },
            'cloud_deployment': {
                'netlify': framework in ['react', 'vue', 'angular'],
                'vercel': framework in ['react', 'vue', 'angular'],
                'heroku': True,
                'aws': True
            }
        }
        
        return configs
    
    async def _generate_manifest(
        self,
        context: Dict[str, Any],
        analysis_results: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate project manifest"""
        
        manifest = {
            'name': context.get('project_name', 'generated-project'),
            'version': context.get('version', '1.0.0'),
            'description': f"A {context.get('framework', 'react')} application",
            'framework': context.get('framework', 'react'),
            'language': context.get('language', 'typescript'),
            'created_at': datetime.now().isoformat(),
            'generated_by': 'T-Developer',
            'generator_version': self.version,
            'components': [
                c.get('name', '') for c in context.get('selected_components', [])
            ],
            'features': [
                'Modern architecture',
                'Production ready',
                'Testing included',
                'CI/CD configured',
                'Docker support'
            ],
            'quality_metrics': {
                'security_score': analysis_results.get('security', {}).get('security_score', 85),
                'performance_score': analysis_results.get('performance', {}).get('performance_score', 80),
                'validation_passed': analysis_results.get('validation', {}).get('passed_quality_gates', True)
            },
            'deployment_targets': context.get('target_environments', ['development', 'production'])
        }
        
        return manifest