"""
Vulnerability Scanner Module
Scans for security vulnerabilities in dependencies and code
"""

from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
from enum import Enum

class SeverityLevel(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class VulnerabilityScanner:
    """Scans for security vulnerabilities"""
    
    def __init__(self):
        self.vulnerability_databases = {
            "npm": "https://registry.npmjs.org/-/npm/v1/security/advisories",
            "pypi": "https://pypi.org/pypi",
            "maven": "https://repo.maven.apache.org",
            "cve": "https://cve.mitre.org"
        }
        
        # Known vulnerabilities (simplified for demo)
        self.known_vulnerabilities = {
            "lodash": {
                "<4.17.21": {
                    "severity": SeverityLevel.HIGH,
                    "cve": "CVE-2021-23337",
                    "description": "Prototype pollution vulnerability",
                    "fix": "Upgrade to version 4.17.21 or later"
                }
            },
            "axios": {
                "<0.21.1": {
                    "severity": SeverityLevel.MEDIUM,
                    "cve": "CVE-2020-28168",
                    "description": "Server-Side Request Forgery",
                    "fix": "Upgrade to version 0.21.1 or later"
                }
            },
            "django": {
                "<3.2.10": {
                    "severity": SeverityLevel.HIGH,
                    "cve": "CVE-2021-44420",
                    "description": "SQL injection vulnerability",
                    "fix": "Upgrade to version 3.2.10 or later"
                }
            }
        }
        
        self.security_patterns = {
            "sql_injection": [
                r"SELECT.*FROM.*WHERE.*=\s*['\"]?\$",
                r"execute\(['\"]SELECT",
                r"raw\(['\"]SELECT"
            ],
            "xss": [
                r"innerHTML\s*=",
                r"document\.write\(",
                r"eval\("
            ],
            "command_injection": [
                r"exec\(",
                r"system\(",
                r"shell_exec\("
            ],
            "path_traversal": [
                r"\.\./",
                r"\.\.\\",
                r"readFile.*\+"
            ]
        }
    
    async def scan_dependencies(
        self,
        dependencies: Dict[str, str],
        package_manager: str
    ) -> Dict[str, Any]:
        """
        Scan dependencies for known vulnerabilities
        
        Args:
            dependencies: Package dependencies with versions
            package_manager: Package manager type (npm, pip, etc.)
            
        Returns:
            Vulnerability scan results
        """
        
        vulnerabilities = []
        statistics = {
            "total_dependencies": len(dependencies),
            "vulnerable_dependencies": 0,
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0
        }
        
        for package, version in dependencies.items():
            vuln = await self._check_package_vulnerability(
                package,
                version,
                package_manager
            )
            
            if vuln:
                vulnerabilities.append(vuln)
                statistics["vulnerable_dependencies"] += 1
                statistics[vuln["severity"].value] += 1
        
        # Generate remediation plan
        remediation = self._generate_remediation_plan(vulnerabilities)
        
        # Calculate risk score
        risk_score = self._calculate_risk_score(statistics)
        
        return {
            "scan_timestamp": datetime.now().isoformat(),
            "package_manager": package_manager,
            "vulnerabilities": vulnerabilities,
            "statistics": statistics,
            "risk_score": risk_score,
            "risk_level": self._determine_risk_level(risk_score),
            "remediation": remediation,
            "compliance": self._check_compliance(vulnerabilities)
        }
    
    async def scan_code(
        self,
        code_files: List[Dict[str, str]],
        language: str
    ) -> Dict[str, Any]:
        """
        Scan code for security vulnerabilities
        
        Args:
            code_files: List of code files with content
            language: Programming language
            
        Returns:
            Code vulnerability scan results
        """
        
        issues = []
        
        for file_info in code_files:
            file_path = file_info.get("path", "unknown")
            content = file_info.get("content", "")
            
            file_issues = self._scan_file_content(
                content,
                file_path,
                language
            )
            
            issues.extend(file_issues)
        
        # Categorize issues
        categorized = self._categorize_issues(issues)
        
        # Generate fixes
        fixes = self._generate_code_fixes(issues, language)
        
        return {
            "scan_timestamp": datetime.now().isoformat(),
            "language": language,
            "files_scanned": len(code_files),
            "issues": issues,
            "categories": categorized,
            "fixes": fixes,
            "security_score": self._calculate_security_score(issues)
        }
    
    async def _check_package_vulnerability(
        self,
        package: str,
        version: str,
        package_manager: str
    ) -> Optional[Dict[str, Any]]:
        """Check if package has known vulnerabilities"""
        
        # Check against known vulnerabilities (simplified)
        if package in self.known_vulnerabilities:
            vulns = self.known_vulnerabilities[package]
            
            for vuln_version, vuln_info in vulns.items():
                if self._version_vulnerable(version, vuln_version):
                    return {
                        "package": package,
                        "version": version,
                        "severity": vuln_info["severity"],
                        "cve": vuln_info["cve"],
                        "description": vuln_info["description"],
                        "fix": vuln_info["fix"],
                        "references": [
                            f"https://nvd.nist.gov/vuln/detail/{vuln_info['cve']}"
                        ]
                    }
        
        # In real implementation, would query vulnerability databases
        return None
    
    def _version_vulnerable(self, current: str, vulnerable: str) -> bool:
        """Check if version is vulnerable"""
        
        # Simplified version comparison
        if vulnerable.startswith("<"):
            vulnerable_version = vulnerable[1:]
            return self._compare_versions(current, vulnerable_version) < 0
        elif vulnerable.startswith("<="):
            vulnerable_version = vulnerable[2:]
            return self._compare_versions(current, vulnerable_version) <= 0
        else:
            return current == vulnerable
    
    def _compare_versions(self, v1: str, v2: str) -> int:
        """Compare two version strings"""
        
        # Simple version comparison (real implementation would be more robust)
        v1_parts = v1.split(".")
        v2_parts = v2.split(".")
        
        for i in range(max(len(v1_parts), len(v2_parts))):
            p1 = int(v1_parts[i]) if i < len(v1_parts) else 0
            p2 = int(v2_parts[i]) if i < len(v2_parts) else 0
            
            if p1 < p2:
                return -1
            elif p1 > p2:
                return 1
        
        return 0
    
    def _scan_file_content(
        self,
        content: str,
        file_path: str,
        language: str
    ) -> List[Dict[str, Any]]:
        """Scan file content for security issues"""
        
        issues = []
        lines = content.split("\n")
        
        for pattern_type, patterns in self.security_patterns.items():
            for pattern in patterns:
                import re
                for i, line in enumerate(lines, 1):
                    if re.search(pattern, line):
                        issues.append({
                            "file": file_path,
                            "line": i,
                            "type": pattern_type,
                            "severity": self._determine_pattern_severity(pattern_type),
                            "message": f"Potential {pattern_type.replace('_', ' ')} vulnerability",
                            "code": line.strip()
                        })
        
        # Check for hardcoded secrets
        secret_patterns = [
            (r"api[_-]?key\s*=\s*['\"][^'\"]+['\"]", "Hardcoded API key"),
            (r"password\s*=\s*['\"][^'\"]+['\"]", "Hardcoded password"),
            (r"secret\s*=\s*['\"][^'\"]+['\"]", "Hardcoded secret"),
            (r"token\s*=\s*['\"][^'\"]+['\"]", "Hardcoded token")
        ]
        
        for pattern, message in secret_patterns:
            import re
            for i, line in enumerate(lines, 1):
                if re.search(pattern, line, re.IGNORECASE):
                    issues.append({
                        "file": file_path,
                        "line": i,
                        "type": "hardcoded_secret",
                        "severity": SeverityLevel.HIGH,
                        "message": message,
                        "code": line.strip()
                    })
        
        return issues
    
    def _determine_pattern_severity(self, pattern_type: str) -> SeverityLevel:
        """Determine severity for pattern type"""
        
        severities = {
            "sql_injection": SeverityLevel.CRITICAL,
            "xss": SeverityLevel.HIGH,
            "command_injection": SeverityLevel.CRITICAL,
            "path_traversal": SeverityLevel.HIGH,
            "hardcoded_secret": SeverityLevel.HIGH
        }
        
        return severities.get(pattern_type, SeverityLevel.MEDIUM)
    
    def _generate_remediation_plan(
        self,
        vulnerabilities: List[Dict]
    ) -> Dict[str, Any]:
        """Generate remediation plan for vulnerabilities"""
        
        plan = {
            "immediate_actions": [],
            "short_term": [],
            "long_term": [],
            "update_commands": []
        }
        
        for vuln in vulnerabilities:
            if vuln["severity"] == SeverityLevel.CRITICAL:
                plan["immediate_actions"].append({
                    "package": vuln["package"],
                    "action": vuln["fix"],
                    "priority": "urgent"
                })
                
                # Generate update command
                plan["update_commands"].append(
                    f"npm update {vuln['package']}"  # Adjust for package manager
                )
            elif vuln["severity"] == SeverityLevel.HIGH:
                plan["short_term"].append({
                    "package": vuln["package"],
                    "action": vuln["fix"],
                    "priority": "high"
                })
            else:
                plan["long_term"].append({
                    "package": vuln["package"],
                    "action": vuln["fix"],
                    "priority": "normal"
                })
        
        return plan
    
    def _calculate_risk_score(self, statistics: Dict) -> float:
        """Calculate overall risk score"""
        
        if statistics["total_dependencies"] == 0:
            return 0.0
        
        # Weighted scoring
        score = 0.0
        score += statistics["critical"] * 10
        score += statistics["high"] * 5
        score += statistics["medium"] * 2
        score += statistics["low"] * 0.5
        
        # Normalize to 0-100
        max_score = statistics["total_dependencies"] * 10
        normalized = (score / max_score) * 100 if max_score > 0 else 0
        
        return min(normalized, 100.0)
    
    def _determine_risk_level(self, risk_score: float) -> str:
        """Determine risk level from score"""
        
        if risk_score >= 80:
            return "critical"
        elif risk_score >= 60:
            return "high"
        elif risk_score >= 40:
            return "medium"
        elif risk_score >= 20:
            return "low"
        else:
            return "minimal"
    
    def _check_compliance(self, vulnerabilities: List[Dict]) -> Dict[str, bool]:
        """Check compliance with security standards"""
        
        compliance = {
            "owasp_top_10": True,
            "pci_dss": True,
            "hipaa": True,
            "gdpr": True
        }
        
        # Check for violations
        for vuln in vulnerabilities:
            if vuln["severity"] in [SeverityLevel.CRITICAL, SeverityLevel.HIGH]:
                # Critical vulnerabilities violate most standards
                compliance["pci_dss"] = False
                compliance["hipaa"] = False
                
            if "injection" in vuln.get("description", "").lower():
                compliance["owasp_top_10"] = False
        
        return compliance
    
    def _categorize_issues(self, issues: List[Dict]) -> Dict[str, List[Dict]]:
        """Categorize security issues"""
        
        categories = {}
        
        for issue in issues:
            issue_type = issue["type"]
            if issue_type not in categories:
                categories[issue_type] = []
            categories[issue_type].append(issue)
        
        return categories
    
    def _generate_code_fixes(
        self,
        issues: List[Dict],
        language: str
    ) -> List[Dict[str, str]]:
        """Generate code fixes for issues"""
        
        fixes = []
        
        for issue in issues:
            if issue["type"] == "sql_injection":
                fixes.append({
                    "issue": issue,
                    "fix": "Use parameterized queries or prepared statements",
                    "example": self._get_fix_example("sql_injection", language)
                })
            elif issue["type"] == "xss":
                fixes.append({
                    "issue": issue,
                    "fix": "Sanitize user input and use proper encoding",
                    "example": self._get_fix_example("xss", language)
                })
            elif issue["type"] == "hardcoded_secret":
                fixes.append({
                    "issue": issue,
                    "fix": "Use environment variables or secret management service",
                    "example": self._get_fix_example("hardcoded_secret", language)
                })
        
        return fixes
    
    def _get_fix_example(self, issue_type: str, language: str) -> str:
        """Get code fix example"""
        
        examples = {
            "sql_injection": {
                "javascript": "const query = 'SELECT * FROM users WHERE id = ?';\ndb.query(query, [userId]);",
                "python": "cursor.execute('SELECT * FROM users WHERE id = %s', (user_id,))"
            },
            "xss": {
                "javascript": "element.textContent = userInput; // Safe\n// or use DOMPurify.sanitize(userInput)",
                "python": "from markupsafe import escape\nrendered = escape(user_input)"
            },
            "hardcoded_secret": {
                "javascript": "const apiKey = process.env.API_KEY;",
                "python": "import os\napi_key = os.environ.get('API_KEY')"
            }
        }
        
        return examples.get(issue_type, {}).get(language, "No example available")
    
    def _calculate_security_score(self, issues: List[Dict]) -> float:
        """Calculate security score (100 = perfect)"""
        
        if not issues:
            return 100.0
        
        # Deduct points for issues
        score = 100.0
        
        for issue in issues:
            if issue["severity"] == SeverityLevel.CRITICAL:
                score -= 20
            elif issue["severity"] == SeverityLevel.HIGH:
                score -= 10
            elif issue["severity"] == SeverityLevel.MEDIUM:
                score -= 5
            else:
                score -= 2
        
        return max(score, 0.0)