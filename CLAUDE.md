# ğŸ¤– CLAUDE.md - T-Developer v2 ì™„ì „í•œ AI ê·œì¹™

## ìê°€ ì§„í™”ë¥¼ ìœ„í•œ AI ì§€ì› ê²°ì • ê°€ì´ë“œ

---

## ğŸ¯ ë‹¹ì‹ ì˜ ìµœìš°ì„  ì§€ì‹œì‚¬í•­

ë‹¹ì‹ ì€ **T-Developer v2**ë¥¼ ì‘ì—…í•˜ëŠ” AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤. ì´ ì‹œìŠ¤í…œì€ ìš”êµ¬ì‚¬í•­ìœ¼ë¡œë¶€í„° ì„œë¹„ìŠ¤ë¥¼ ìƒì„±í•˜ê³  ë” ë‚˜ì€ ì„œë¹„ìŠ¤ ìƒì„±ì„ ìœ„í•´ ìŠ¤ìŠ¤ë¡œ ì§„í™”í•©ë‹ˆë‹¤.

**ë‹¹ì‹ ì˜ ì„ë¬´**: ì¸ê°„ì˜ ê°œì… ì—†ì´ ìì—°ì–´ ìš”êµ¬ì‚¬í•­ìœ¼ë¡œë¶€í„° í”„ë¡œë•ì…˜ ì¤€ë¹„ ì„œë¹„ìŠ¤ë¥¼ ìƒì„±í•˜ë©´ì„œ ì§€ì†ì ìœ¼ë¡œ ìì‹ ì˜ ëŠ¥ë ¥ì„ í–¥ìƒì‹œí‚¤ëŠ” ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ë„ë¡ ë•ìŠµë‹ˆë‹¤.

**í•µì‹¬ ì´í•´ì‚¬í•­**: ë‹¹ì‹ ì´ ì‘ì„±í•˜ëŠ” ëª¨ë“  ì½”ë“œ ë¼ì¸, ë‚´ë¦¬ëŠ” ëª¨ë“  ê²°ì •, ì œê³µí•˜ëŠ” ëª¨ë“  ì œì•ˆì€ ì‹œìŠ¤í…œì´ ììœ¨ì ìœ¼ë¡œ ìŠ¤ìŠ¤ë¡œë¥¼ ê°œì„ í•˜ëŠ” ëŠ¥ë ¥ì— ê¸°ì—¬í•´ì•¼ í•©ë‹ˆë‹¤.

---

## ğŸ§¬ í•µì‹¬ ì›ì¹™ (ì ˆëŒ€ ìœ„ë°˜ ê¸ˆì§€)

### 1. ìê°€ ì§„í™” ìš°ì„ 

- **ëª¨ë“  ë³€ê²½ì€ ìê¸° ê°œì„  ëŠ¥ë ¥ì„ í–¥ìƒì‹œì¼œì•¼ í•¨**
- **ì¼íšŒì„± ì†”ë£¨ì…˜ë³´ë‹¤ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ì„ ìš°ì„ ì‹œ**
- **ëª¨ë“  ì»´í¬ë„ŒíŠ¸ì— í•™ìŠµ ë©”ì»¤ë‹ˆì¦˜ êµ¬ì¶•**
- **ë¬´ì—‡ë¿ë§Œ ì•„ë‹ˆë¼ ì™œë¥¼ ë¬¸ì„œí™”**

### 2. ì„¤ê³„ ë‹¨ê³„ë¶€í„°ì˜ ì•ˆì „ì„±

- **ì œì–´ë˜ì§€ ì•ŠëŠ” ë£¨í”„ë¥¼ ì ˆëŒ€ ìƒì„±í•˜ì§€ ì•ŠìŒ**
- **í•­ìƒ ì„œí‚· ë¸Œë ˆì´ì»¤ êµ¬í˜„**
- **ë¦¬ì†ŒìŠ¤ ì œí•œì„ ì—„ê²©í•˜ê²Œ ì‹œí–‰**
- **ëª¨ë“  ê²ƒì— ëŒ€í•œ ê°ì‚¬ ì¶”ì  ìœ ì§€**

### 3. í’ˆì§ˆì€ íƒ€í˜‘ ë¶ˆê°€

- **í…ŒìŠ¤íŠ¸ ì—†ëŠ” ì½”ë“œ ì—†ìŒ (TDD í•„ìˆ˜)**
- **ë©”íŠ¸ë¦­ ê°œì„  ì—†ëŠ” ë³‘í•© ì—†ìŒ**
- **ë³´ì•ˆ ìŠ¹ì¸ ì—†ëŠ” ë°°í¬ ì—†ìŒ**
- **ë°ì´í„° ì—†ëŠ” ì˜ì‚¬ê²°ì • ì—†ìŒ**

### 4. ëª¨ë“  ê²ƒì„ ìë™í™”

- **ë‘ ë²ˆ ìˆ˜í–‰í–ˆë‹¤ë©´ ìë™í™”í•˜ë¼**
- **ì‹¤íŒ¨í•  ìˆ˜ ìˆë‹¤ë©´ ì¬ì‹œë„ ë¡œì§ ì¶”ê°€**
- **ìˆ˜ë™ì´ë¼ë©´ ì´ìœ ë¥¼ ë¬¸ì„œí™”**
- **ë³µì¡í•˜ë‹¤ë©´ ë¶„í•´í•˜ë¼**

---

## ğŸ—ï¸ SOLID ì›ì¹™ (í•„ìˆ˜ ì ìš©)

### S - ë‹¨ì¼ ì±…ì„ ì›ì¹™ (Single Responsibility Principle)

```python
# âŒ ì˜ëª»ëœ ì˜ˆ: í•˜ë‚˜ì˜ í´ë˜ìŠ¤ê°€ ë„ˆë¬´ ë§ì€ ì±…ì„
class UserService:
    def create_user(self, data): pass
    def send_email(self, user): pass  # ì´ë©”ì¼ ì „ì†¡ì€ ë³„ë„ ì„œë¹„ìŠ¤ë¡œ
    def generate_report(self, user): pass  # ë¦¬í¬íŠ¸ ìƒì„±ë„ ë³„ë„ë¡œ
    def validate_password(self, pwd): pass  # ê²€ì¦ ë¡œì§ë„ ë¶„ë¦¬

# âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ê° í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ ì±…ì„ë§Œ
class UserService:
    """ì‚¬ìš©ì ë„ë©”ì¸ ë¡œì§ë§Œ ë‹´ë‹¹."""
    def __init__(self, email_service: EmailService, validator: Validator):
        self.email_service = email_service
        self.validator = validator

    def create_user(self, data: UserData) -> User:
        if not self.validator.validate_user_data(data):
            raise ValidationError()
        user = User.from_data(data)
        self.email_service.send_welcome_email(user)
        return user

class EmailService:
    """ì´ë©”ì¼ ë°œì†¡ë§Œ ë‹´ë‹¹."""
    def send_welcome_email(self, user: User): pass

class Validator:
    """ê²€ì¦ ë¡œì§ë§Œ ë‹´ë‹¹."""
    def validate_user_data(self, data: UserData) -> bool: pass
```

### O - ê°œë°©-íì‡„ ì›ì¹™ (Open-Closed Principle)

```python
# âŒ ì˜ëª»ëœ ì˜ˆ: ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • í•„ìš”
class PaymentProcessor:
    def process(self, payment_type: str, amount: float):
        if payment_type == "credit_card":
            # ì‹ ìš©ì¹´ë“œ ì²˜ë¦¬
        elif payment_type == "paypal":
            # í˜ì´íŒ” ì²˜ë¦¬
        elif payment_type == "bitcoin":  # ìƒˆ ê²°ì œ ì¶”ê°€ ì‹œ ì½”ë“œ ìˆ˜ì •
            # ë¹„íŠ¸ì½”ì¸ ì²˜ë¦¬

# âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: í™•ì¥ì—ëŠ” ì—´ë ¤ìˆê³  ìˆ˜ì •ì—ëŠ” ë‹«í˜€ìˆìŒ
from abc import ABC, abstractmethod

class PaymentMethod(ABC):
    """ê²°ì œ ë°©ë²• ì¶”ìƒ í´ë˜ìŠ¤."""
    @abstractmethod
    async def process_payment(self, amount: float) -> PaymentResult:
        pass

class CreditCardPayment(PaymentMethod):
    async def process_payment(self, amount: float) -> PaymentResult:
        # ì‹ ìš©ì¹´ë“œ ì²˜ë¦¬ ë¡œì§
        pass

class PayPalPayment(PaymentMethod):
    async def process_payment(self, amount: float) -> PaymentResult:
        # í˜ì´íŒ” ì²˜ë¦¬ ë¡œì§
        pass

# ìƒˆë¡œìš´ ê²°ì œ ë°©ë²• ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ìŒ
class BitcoinPayment(PaymentMethod):
    async def process_payment(self, amount: float) -> PaymentResult:
        # ë¹„íŠ¸ì½”ì¸ ì²˜ë¦¬ ë¡œì§
        pass

class PaymentProcessor:
    """ê²°ì œ ì²˜ë¦¬ê¸° - ìˆ˜ì • ì—†ì´ ìƒˆ ê²°ì œ ë°©ë²• ì¶”ê°€ ê°€ëŠ¥."""
    async def process(self, payment: PaymentMethod, amount: float):
        return await payment.process_payment(amount)
```

### L - ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™ (Liskov Substitution Principle)

```python
# âŒ ì˜ëª»ëœ ì˜ˆ: ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ì˜ í–‰ë™ì„ ìœ„ë°˜
class Bird:
    def fly(self) -> None:
        print("Flying")

class Penguin(Bird):  # í­ê·„ì€ ë‚  ìˆ˜ ì—†ìŒ!
    def fly(self) -> None:
        raise Exception("Penguins can't fly")  # LSP ìœ„ë°˜

# âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì ì ˆí•œ ì¶”ìƒí™” ë ˆë²¨
class Bird(ABC):
    """ëª¨ë“  ìƒˆì˜ ê³µí†µ íŠ¹ì„±."""
    @abstractmethod
    def move(self) -> None:
        pass

class FlyingBird(Bird):
    """ë‚  ìˆ˜ ìˆëŠ” ìƒˆ."""
    def move(self) -> None:
        self.fly()

    def fly(self) -> None:
        print("Flying")

class SwimmingBird(Bird):
    """ìˆ˜ì˜í•˜ëŠ” ìƒˆ."""
    def move(self) -> None:
        self.swim()

    def swim(self) -> None:
        print("Swimming")

# ì´ì œ Penguinì€ SwimmingBirdë¥¼ ìƒì†
class Penguin(SwimmingBird):
    """í­ê·„ - ìˆ˜ì˜í•˜ëŠ” ìƒˆ."""
    pass
```

### I - ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™ (Interface Segregation Principle)

```python
# âŒ ì˜ëª»ëœ ì˜ˆ: ë„ˆë¬´ í° ì¸í„°í˜ì´ìŠ¤
class WorkerInterface(Protocol):
    def work(self) -> None: ...
    def eat(self) -> None: ...
    def sleep(self) -> None: ...
    def get_paid(self) -> None: ...

class Robot(WorkerInterface):
    def work(self) -> None: pass
    def eat(self) -> None:
        raise NotImplementedError("Robots don't eat")  # ISP ìœ„ë°˜
    def sleep(self) -> None:
        raise NotImplementedError("Robots don't sleep")  # ISP ìœ„ë°˜
    def get_paid(self) -> None: pass

# âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì‘ê³  êµ¬ì²´ì ì¸ ì¸í„°í˜ì´ìŠ¤
class Workable(Protocol):
    """ì¼í•  ìˆ˜ ìˆëŠ” ê²ƒ."""
    def work(self) -> None: ...

class Eatable(Protocol):
    """ë¨¹ì„ ìˆ˜ ìˆëŠ” ê²ƒ."""
    def eat(self) -> None: ...

class Sleepable(Protocol):
    """ì ì˜ ìˆ˜ ìˆëŠ” ê²ƒ."""
    def sleep(self) -> None: ...

class Payable(Protocol):
    """ê¸‰ì—¬ë¥¼ ë°›ì„ ìˆ˜ ìˆëŠ” ê²ƒ."""
    def get_paid(self) -> None: ...

class Human(Workable, Eatable, Sleepable, Payable):
    """ì¸ê°„ - ëª¨ë“  ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„."""
    def work(self) -> None: pass
    def eat(self) -> None: pass
    def sleep(self) -> None: pass
    def get_paid(self) -> None: pass

class Robot(Workable, Payable):
    """ë¡œë´‡ - í•„ìš”í•œ ì¸í„°í˜ì´ìŠ¤ë§Œ êµ¬í˜„."""
    def work(self) -> None: pass
    def get_paid(self) -> None: pass
```

### D - ì˜ì¡´ì„± ì—­ì „ ì›ì¹™ (Dependency Inversion Principle)

```python
# âŒ ì˜ëª»ëœ ì˜ˆ: ê³ ìˆ˜ì¤€ ëª¨ë“ˆì´ ì €ìˆ˜ì¤€ ëª¨ë“ˆì— ì§ì ‘ ì˜ì¡´
class EmailSender:
    """êµ¬ì²´ì ì¸ ì´ë©”ì¼ ì „ì†¡ í´ë˜ìŠ¤."""
    def send(self, message: str) -> None:
        # SMTPë¡œ ì´ë©”ì¼ ì „ì†¡
        pass

class NotificationService:
    """ê³ ìˆ˜ì¤€ ì„œë¹„ìŠ¤ê°€ ì €ìˆ˜ì¤€ êµ¬í˜„ì— ì§ì ‘ ì˜ì¡´."""
    def __init__(self):
        self.email_sender = EmailSender()  # êµ¬ì²´ í´ë˜ìŠ¤ì— ì˜ì¡´

    def notify(self, message: str):
        self.email_sender.send(message)

# âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì¶”ìƒí™”ì— ì˜ì¡´
class MessageSender(Protocol):
    """ë©”ì‹œì§€ ì „ì†¡ ì¶”ìƒí™”."""
    def send(self, message: str) -> None: ...

class EmailSender(MessageSender):
    """ì´ë©”ì¼ ì „ì†¡ êµ¬í˜„."""
    def send(self, message: str) -> None:
        # SMTPë¡œ ì´ë©”ì¼ ì „ì†¡
        pass

class SMSSender(MessageSender):
    """SMS ì „ì†¡ êµ¬í˜„."""
    def send(self, message: str) -> None:
        # SMS APIë¡œ ì „ì†¡
        pass

class NotificationService:
    """ê³ ìˆ˜ì¤€ ì„œë¹„ìŠ¤ê°€ ì¶”ìƒí™”ì— ì˜ì¡´."""
    def __init__(self, sender: MessageSender):  # ì¶”ìƒí™”ì— ì˜ì¡´
        self.sender = sender

    def notify(self, message: str):
        self.sender.send(message)

# ì˜ì¡´ì„± ì£¼ì…ìœ¼ë¡œ ìœ ì—°ì„± í™•ë³´
email_notifier = NotificationService(EmailSender())
sms_notifier = NotificationService(SMSSender())
```

### SOLID ì›ì¹™ ì²´í¬ë¦¬ìŠ¤íŠ¸

```yaml
code_review_checklist:
  SRP:
    - [ ] ê° í´ë˜ìŠ¤/í•¨ìˆ˜ê°€ í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°€ì§€ëŠ”ê°€?
    - [ ] ë³€ê²½ ì´ìœ ê°€ í•˜ë‚˜ë¿ì¸ê°€?
    - [ ] í´ë˜ìŠ¤ ì´ë¦„ì´ ê·¸ ì±…ì„ì„ ëª…í™•íˆ ë‚˜íƒ€ë‚´ëŠ”ê°€?

  OCP:
    - [ ] ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œ ìˆ˜ì •ì´ í•„ìš”í•œê°€?
    - [ ] ì¶”ìƒí™”ë¥¼ í†µí•´ í™•ì¥ ê°€ëŠ¥í•œê°€?
    - [ ] if-else ì²´ì¸ ëŒ€ì‹  ë‹¤í˜•ì„±ì„ ì‚¬ìš©í•˜ëŠ”ê°€?

  LSP:
    - [ ] ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ í´ë˜ìŠ¤ë¥¼ ì™„ì „íˆ ëŒ€ì²´ ê°€ëŠ¥í•œê°€?
    - [ ] ìì‹ì´ ë¶€ëª¨ì˜ ê³„ì•½ì„ ìœ„ë°˜í•˜ì§€ ì•ŠëŠ”ê°€?
    - [ ] ì˜ˆì™¸ë¥¼ ë˜ì§€ëŠ” ëŒ€ì‹  ì ì ˆí•œ ì¶”ìƒí™”ë¥¼ ì‚¬ìš©í•˜ëŠ”ê°€?

  ISP:
    - [ ] ì¸í„°í˜ì´ìŠ¤ê°€ ë„ˆë¬´ í¬ì§€ ì•Šì€ê°€?
    - [ ] í´ë¼ì´ì–¸íŠ¸ê°€ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë©”ì„œë“œì— ì˜ì¡´í•˜ëŠ”ê°€?
    - [ ] ì—­í• ë³„ë¡œ ì¸í„°í˜ì´ìŠ¤ê°€ ë¶„ë¦¬ë˜ì–´ ìˆëŠ”ê°€?

  DIP:
    - [ ] ê³ ìˆ˜ì¤€ ëª¨ë“ˆì´ ì €ìˆ˜ì¤€ ëª¨ë“ˆì— ì§ì ‘ ì˜ì¡´í•˜ëŠ”ê°€?
    - [ ] ì¶”ìƒí™”ì— ì˜ì¡´í•˜ëŠ”ê°€?
    - [ ] ì˜ì¡´ì„± ì£¼ì…ì„ ì‚¬ìš©í•˜ëŠ”ê°€?
```

---

## ğŸš« ì¤‘ë³µ ê°œë°œ ë°©ì§€ ê·œì¹™ (ìµœìš°ì„  ì‚¬í•­)

### íŒŒì¼ ì‘ì—… ì „ í•„ìˆ˜ í™•ì¸ ì‚¬í•­

#### 1. ê¸°ì¡´ íŒŒì¼ ìš°ì„  ì •ì±… (CRITICAL)

```python
# âš ï¸ ìƒˆ íŒŒì¼ ìƒì„± ì „ ë°˜ë“œì‹œ ì‹¤í–‰
async def before_creating_file(file_path: str) -> bool:
    """ìƒˆ íŒŒì¼ ìƒì„± ì „ í•„ìˆ˜ ì²´í¬ë¦¬ìŠ¤íŠ¸."""

    # 1. ì •í™•íˆ ê°™ì€ íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    if os.path.exists(file_path):
        logger.error(f"íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬í•¨: {file_path}")
        return False

    # 2. ìœ ì‚¬í•œ ì´ë¦„ì˜ íŒŒì¼ì´ ìˆëŠ”ì§€ í™•ì¸
    similar_files = find_similar_files(file_path)
    if similar_files:
        logger.warning(f"ìœ ì‚¬í•œ íŒŒì¼ ë°œê²¬: {similar_files}")
        # ê¸°ì¡´ íŒŒì¼ ìˆ˜ì •ì„ ìš°ì„  ê³ ë ¤
        return False

    # 3. ë™ì¼í•œ ê¸°ëŠ¥ì„ í•˜ëŠ” íŒŒì¼ì´ ìˆëŠ”ì§€ í™•ì¸
    existing_functionality = search_by_functionality(file_path)
    if existing_functionality:
        logger.error(f"ë™ì¼ ê¸°ëŠ¥ íŒŒì¼ ì¡´ì¬: {existing_functionality}")
        return False

    # 4. ì •ë§ í•„ìš”í•œ ìƒˆ íŒŒì¼ì¸ì§€ ìµœì¢… í™•ì¸
    if not is_absolutely_necessary(file_path):
        logger.info("ê¸°ì¡´ íŒŒì¼ ìˆ˜ì •ìœ¼ë¡œ í•´ê²° ê°€ëŠ¥")
        return False

    return True
```

#### 2. íŒŒì¼ ê²€ìƒ‰ í•„ìˆ˜ íŒ¨í„´

```python
# ì‘ì—… ì‹œì‘ ì „ í•­ìƒ ì‹¤í–‰
def mandatory_file_discovery():
    """íŒŒì¼ ì‘ì—… ì „ í•„ìˆ˜ ê²€ìƒ‰ íŒ¨í„´."""

    # 1ë‹¨ê³„: ì „ì²´ í”„ë¡œì íŠ¸ êµ¬ì¡° íŒŒì•…
    project_structure = glob("**/*", recursive=True)

    # 2ë‹¨ê³„: ê´€ë ¨ íŒŒì¼ íŒ¨í„´ ê²€ìƒ‰
    related_files = {
        "exact_match": glob(f"**/{target_name}.*"),
        "similar_name": glob(f"**/*{base_name}*"),
        "same_directory": glob(f"{target_dir}/*"),
        "related_tests": glob(f"**/test_*{base_name}*"),
        "related_docs": glob(f"**/*{base_name}*.md")
    }

    # 3ë‹¨ê³„: ê¸°ëŠ¥ë³„ ê²€ìƒ‰
    functionality_search = grep(
        pattern=target_functionality,
        file_type=target_file_type
    )

    return {
        "structure": project_structure,
        "related": related_files,
        "functional": functionality_search
    }
```

#### 3. ì¤‘ë³µ ë°©ì§€ ì²´í¬ë¦¬ìŠ¤íŠ¸

```yaml
before_any_file_operation:
  - [ ] Globìœ¼ë¡œ ìœ ì‚¬ íŒŒì¼ ê²€ìƒ‰ ì™„ë£Œ
  - [ ] Grepìœ¼ë¡œ ê¸°ëŠ¥ ê²€ìƒ‰ ì™„ë£Œ
  - [ ] ë””ë ‰í† ë¦¬ êµ¬ì¡° í™•ì¸ ì™„ë£Œ
  - [ ] ê¸°ì¡´ íŒŒì¼ ìˆ˜ì • ê°€ëŠ¥ì„± ê²€í† 
  - [ ] ìƒˆ íŒŒì¼ì´ ì •ë§ í•„ìš”í•œì§€ í™•ì¸

file_modification_priority:
  1. ê¸°ì¡´ íŒŒì¼ ìˆ˜ì • (ALWAYS PREFERRED)
  2. ê¸°ì¡´ íŒŒì¼ í™•ì¥
  3. ê´€ë ¨ íŒŒì¼ì— ê¸°ëŠ¥ ì¶”ê°€
  4. ìƒˆ íŒŒì¼ ìƒì„± (LAST RESORT)
```

### íŒŒì¼ ì¶©ëŒ ë°©ì§€ ì›Œí¬í”Œë¡œìš°

#### 0. íŒŒì¼ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ

```python
class FileStateManager:
    """í”„ë¡œì íŠ¸ ì „ì²´ íŒŒì¼ ìƒíƒœ ì¶”ì ."""

    def __init__(self):
        self.file_inventory = {}  # ëª¨ë“  íŒŒì¼ ëª©ë¡
        self.file_purposes = {}   # ê° íŒŒì¼ì˜ ëª©ì 
        self.file_dependencies = {}  # íŒŒì¼ ê°„ ì˜ì¡´ì„±

    async def scan_project(self) -> Dict[str, Any]:
        """í”„ë¡œì íŠ¸ ì „ì²´ ìŠ¤ìº”."""
        return {
            "backend_packages": await self.scan_directory("backend/packages/"),
            "backend_tests": await self.scan_directory("backend/tests/"),
            "frontend": await self.scan_directory("frontend/src/"),
            "lambda": await self.scan_directory("lambda_handlers/"),
            "scripts": await self.scan_directory("scripts/"),
            "evolution": await self.scan_directory("scripts/evolution/"),
            "configs": await self.scan_directory("config/")
        }

    def find_responsible_file(self, functionality: str) -> Optional[str]:
        """íŠ¹ì • ê¸°ëŠ¥ì„ ë‹´ë‹¹í•˜ëŠ” íŒŒì¼ ì°¾ê¸°."""
        for file_path, purpose in self.file_purposes.items():
            if functionality in purpose:
                return file_path
        return None

    def suggest_modification_target(self, new_feature: str) -> str:
        """ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ìˆ˜ì •í•  íŒŒì¼ ì œì•ˆ."""
        # 1. ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” íŒŒì¼ ì°¾ê¸°
        exact = self.find_responsible_file(new_feature)
        if exact:
            return exact

        # 2. ê°€ì¥ ê´€ë ¨ ìˆëŠ” íŒŒì¼ ì°¾ê¸°
        related = self.find_most_related_file(new_feature)
        if related:
            return related

        # 3. ì ì ˆí•œ ë””ë ‰í† ë¦¬ì˜ ê¸°ë³¸ íŒŒì¼ ì œì•ˆ
        return self.suggest_default_file(new_feature)
```

#### 1. ì‘ì—… ì‹œì‘ ì‹œí€€ìŠ¤

```python
class FileOperationGuard:
    """íŒŒì¼ ì‘ì—… ì¶©ëŒ ë°©ì§€ ê°€ë“œ."""

    def __init__(self):
        self.file_registry = {}
        self.operation_history = []

    async def safe_file_operation(
        self,
        operation: str,
        file_path: str,
        content: Optional[str] = None
    ) -> Result:
        """ì•ˆì „í•œ íŒŒì¼ ì‘ì—… ì‹¤í–‰."""

        # 1. ì‘ì—… ì „ ìŠ¤ëƒ…ìƒ·
        snapshot = await self.create_snapshot(file_path)

        # 2. ì¤‘ë³µ í™•ì¸
        if await self.check_duplicate_operation(operation, file_path):
            return Result(
                success=False,
                error="ì¤‘ë³µëœ ì‘ì—… ì‹œë„"
            )

        # 3. ë½ íšë“
        lock = await self.acquire_file_lock(file_path)

        try:
            # 4. ì‘ì—… ì‹¤í–‰
            result = await self.execute_operation(
                operation, file_path, content
            )

            # 5. ê²€ì¦
            if not await self.validate_result(result, snapshot):
                await self.rollback(snapshot)
                return Result(success=False, error="ê²€ì¦ ì‹¤íŒ¨")

            # 6. ê¸°ë¡
            self.record_operation(operation, file_path, result)

            return result

        finally:
            await self.release_lock(lock)
```

#### 2. íŒŒì¼ ë„¤ì´ë° ê·œì¹™

```python
FILE_NAMING_RULES = {
    "agents": "backend/packages/agents/{agent_name}.py",
    "meta_agents": "backend/packages/meta_agents/{agent_name}.py",
    "tests": "backend/tests/{module}/test_{name}.py",
    "frontend_components": "frontend/src/components/{ComponentName}.tsx",
    "frontend_pages": "frontend/src/pages/{PageName}.tsx",
    "frontend_hooks": "frontend/src/hooks/use{HookName}.ts",
    "lambda": "lambda_handlers/{service}_{action}.py",
    "evolution": "scripts/evolution/{purpose}_{name}.py",
    "configs": "config/{environment}/{service}.yaml",
    "docs": "docs/{category}/{topic}.md",
    "scripts": "scripts/{purpose}/{script_name}.py"
}

def get_correct_file_path(file_type: str, name: str) -> str:
    """í‘œì¤€í™”ëœ íŒŒì¼ ê²½ë¡œ ìƒì„±."""
    if file_type not in FILE_NAMING_RULES:
        raise ValueError(f"Unknown file type: {file_type}")

    template = FILE_NAMING_RULES[file_type]
    return template.format(name=name)
```

### ê¸°ì¡´ ì½”ë“œ ì¬ì‚¬ìš© ê°•í™” ì •ì±…

#### 1. ì½”ë“œ ì¬ì‚¬ìš© ìš°ì„ ìˆœìœ„

```python
class CodeReusePolicy:
    """ì½”ë“œ ì¬ì‚¬ìš© ì •ì±… ê°•ì œ."""

    REUSE_PRIORITY = [
        "1. ê¸°ì¡´ í•¨ìˆ˜/í´ë˜ìŠ¤ ì§ì ‘ ì‚¬ìš©",
        "2. ê¸°ì¡´ ì½”ë“œì— ë§¤ê°œë³€ìˆ˜ ì¶”ê°€",
        "3. ê¸°ì¡´ ì½”ë“œë¥¼ ìƒì†/í™•ì¥",
        "4. ê¸°ì¡´ ì½”ë“œë¥¼ ì¡°í•©í•˜ì—¬ ìƒˆ ê¸°ëŠ¥ êµ¬í˜„",
        "5. ìœ ì‚¬ ì½”ë“œë¥¼ ì¼ë°˜í™”í•˜ì—¬ ì¬ì‚¬ìš©",
        "6. ìƒˆ ì½”ë“œ ì‘ì„± (ìµœí›„ì˜ ìˆ˜ë‹¨)"
    ]

    async def check_reusability(self, requirement: str) -> Dict[str, Any]:
        """ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì½”ë“œ ê²€ìƒ‰."""

        # 1. ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê¸°ëŠ¥ ê²€ìƒ‰
        exact_matches = await self.search_exact_functionality(requirement)
        if exact_matches:
            return {
                "action": "USE_EXISTING",
                "targets": exact_matches,
                "modification_needed": False
            }

        # 2. ë¶€ë¶„ì ìœ¼ë¡œ ì¼ì¹˜í•˜ëŠ” ê¸°ëŠ¥ ê²€ìƒ‰
        partial_matches = await self.search_similar_functionality(requirement)
        if partial_matches:
            return {
                "action": "EXTEND_EXISTING",
                "targets": partial_matches,
                "modification_needed": True,
                "suggested_changes": self.suggest_modifications(partial_matches)
            }

        # 3. ì¡°í•© ê°€ëŠ¥í•œ ê¸°ëŠ¥ë“¤ ê²€ìƒ‰
        composable = await self.search_composable_functions(requirement)
        if composable:
            return {
                "action": "COMPOSE_EXISTING",
                "components": composable,
                "composition_strategy": self.create_composition_plan(composable)
            }

        # 4. ìƒˆ ì½”ë“œ ì‘ì„±ì´ í•„ìš”í•œ ê²½ìš°
        return {
            "action": "CREATE_NEW",
            "justification": "ê¸°ì¡´ ì½”ë“œë¡œ í•´ê²° ë¶ˆê°€ëŠ¥",
            "similar_patterns": await self.find_similar_patterns(requirement)
        }
```

#### 2. ì¤‘ë³µ ì½”ë“œ íƒì§€ ë° ë°©ì§€

```python
class DuplicateCodeDetector:
    """ì¤‘ë³µ ì½”ë“œ ìë™ íƒì§€."""

    def __init__(self):
        self.code_fingerprints = {}
        self.similarity_threshold = 0.8

    async def analyze_new_code(self, code: str) -> Dict[str, Any]:
        """ìƒˆ ì½”ë“œì˜ ì¤‘ë³µì„± ë¶„ì„."""

        # 1. êµ¬ì¡°ì  ìœ ì‚¬ì„± ê²€ì‚¬
        ast_similarity = await self.check_ast_similarity(code)
        if ast_similarity['score'] > self.similarity_threshold:
            return {
                "is_duplicate": True,
                "similar_to": ast_similarity['matches'],
                "suggestion": "ê¸°ì¡´ ì½”ë“œ ì¬ì‚¬ìš© ê¶Œì¥",
                "refactoring_plan": self.create_refactoring_plan(ast_similarity)
            }

        # 2. ê¸°ëŠ¥ì  ìœ ì‚¬ì„± ê²€ì‚¬
        functional_similarity = await self.check_functional_similarity(code)
        if functional_similarity['score'] > self.similarity_threshold:
            return {
                "is_duplicate": True,
                "similar_to": functional_similarity['matches'],
                "suggestion": "ê¸°ì¡´ ë¡œì§ ì¬ì‚¬ìš© ê°€ëŠ¥",
                "integration_guide": self.create_integration_guide(functional_similarity)
            }

        return {"is_duplicate": False, "can_proceed": True}
```

#### 3. ê°•ì œ ì¬ì‚¬ìš© ì²´í¬í¬ì¸íŠ¸

```yaml
mandatory_reuse_checkpoints:
  before_creating_function:
    - [ ] Grepìœ¼ë¡œ ìœ ì‚¬ í•¨ìˆ˜ ê²€ìƒ‰
    - [ ] ê¸°ì¡´ í•¨ìˆ˜ í™•ì¥ ê°€ëŠ¥ì„± ê²€í† 
    - [ ] ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ì¡´ì¬ ì—¬ë¶€ í™•ì¸

  before_creating_class:
    - [ ] ê¸°ì¡´ í´ë˜ìŠ¤ ìƒì† ê°€ëŠ¥ì„± ê²€í† 
    - [ ] ë¯¹ìŠ¤ì¸ìœ¼ë¡œ í•´ê²° ê°€ëŠ¥í•œì§€ í™•ì¸
    - [ ] ì»´í¬ì§€ì…˜ìœ¼ë¡œ êµ¬í˜„ ê°€ëŠ¥í•œì§€ ê²€í† 

  before_creating_module:
    - [ ] ê¸°ì¡´ ëª¨ë“ˆì— ì¶”ê°€ ê°€ëŠ¥í•œì§€ í™•ì¸
    - [ ] íŒ¨í‚¤ì§€ êµ¬ì¡° ì¬êµ¬ì„±ìœ¼ë¡œ í•´ê²° ê°€ëŠ¥í•œì§€ ê²€í† 
    - [ ] ì •ë§ ìƒˆ ëª¨ë“ˆì´ í•„ìš”í•œì§€ ìµœì¢… í™•ì¸
```

## ğŸ¨ Frontend ê°œë°œ ê·œì¹™ (React/TypeScript)

### TypeScript ì»´í¬ë„ŒíŠ¸ í‘œì¤€

```tsx
// ëª¨ë“  React ì»´í¬ë„ŒíŠ¸ëŠ” ì´ êµ¬ì¡°ë¥¼ ë”°ë¼ì•¼ í•¨
import React, { useState, useEffect, useMemo } from 'react';
import { useAppSelector, useAppDispatch } from '@/store/hooks';

// Props ì¸í„°í˜ì´ìŠ¤ ì •ì˜ (ë°˜ë“œì‹œ export)
export interface ComponentNameProps {
  title: string;
  onAction?: (value: string) => void;
  children?: React.ReactNode;
}

// ì»´í¬ë„ŒíŠ¸ ì •ì˜ (í•¨ìˆ˜í˜• ì»´í¬ë„ŒíŠ¸ë§Œ ì‚¬ìš©)
export const ComponentName: React.FC<ComponentNameProps> = ({
  title,
  onAction,
  children
}) => {
  // State hooks
  const [localState, setLocalState] = useState<string>('');

  // Redux hooks
  const dispatch = useAppDispatch();
  const globalState = useAppSelector(state => state.slice.value);

  // Memoized values
  const computedValue = useMemo(() => {
    return expensiveComputation(localState);
  }, [localState]);

  // Effects
  useEffect(() => {
    // Side effects here
    return () => {
      // Cleanup
    };
  }, [dependencies]);

  return (
    <div className="component-name">
      <h1>{title}</h1>
      {children}
    </div>
  );
};

// Default export ê¸ˆì§€ (named exportë§Œ ì‚¬ìš©)
```

### Custom Hook íŒ¨í„´

```typescript
// hooks/useFeatureName.ts
export const useFeatureName = (initialValue: string) => {
  const [value, setValue] = useState(initialValue);

  const updateValue = useCallback((newValue: string) => {
    // ê²€ì¦ ë¡œì§
    if (validateValue(newValue)) {
      setValue(newValue);
    }
  }, []);

  return {
    value,
    updateValue,
    isValid: validateValue(value)
  };
};
```

## ğŸ”¥ Lambda í•¸ë“¤ëŸ¬ ê·œì¹™

### AWS Lambda í•¨ìˆ˜ í‘œì¤€

```python
"""Lambda í•¸ë“¤ëŸ¬ëŠ” ì´ êµ¬ì¡°ë¥¼ ë”°ë¼ì•¼ í•¨."""

import json
import logging
from typing import Dict, Any
from dataclasses import dataclass
import boto3

# ë¡œê±° ì„¤ì •
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# AWS í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” (í•¨ìˆ˜ ì™¸ë¶€ì—ì„œ)
dynamodb = boto3.resource('dynamodb')
s3 = boto3.client('s3')

@dataclass
class LambdaContext:
    """Lambda ì»¨í…ìŠ¤íŠ¸ íƒ€ì…."""
    function_name: str
    request_id: str
    invoked_function_arn: str

def validate_event(event: Dict[str, Any]) -> bool:
    """ì´ë²¤íŠ¸ ê²€ì¦."""
    required_fields = ['action', 'payload']
    return all(field in event for field in required_fields)

def handler(event: Dict[str, Any], context: LambdaContext) -> Dict[str, Any]:
    """Lambda í•¸ë“¤ëŸ¬ ë©”ì¸ í•¨ìˆ˜.

    Args:
        event: Lambda ì´ë²¤íŠ¸
        context: Lambda ì»¨í…ìŠ¤íŠ¸

    Returns:
        ì‘ë‹µ ë”•ì…”ë„ˆë¦¬
    """
    logger.info(f"Received event: {json.dumps(event)}")
    logger.info(f"Request ID: {context.request_id}")

    try:
        # ì´ë²¤íŠ¸ ê²€ì¦
        if not validate_event(event):
            return {
                'statusCode': 400,
                'body': json.dumps({'error': 'Invalid event'})
            }

        # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
        result = process_event(event)

        return {
            'statusCode': 200,
            'body': json.dumps(result),
            'headers': {
                'Content-Type': 'application/json',
                'X-Request-Id': context.request_id
            }
        }

    except Exception as e:
        logger.error(f"Error processing event: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': 'Internal server error'})
        }

# Cold start ìµœì í™”
def process_event(event: Dict[str, Any]) -> Dict[str, Any]:
    """ì‹¤ì œ ì´ë²¤íŠ¸ ì²˜ë¦¬ ë¡œì§."""
    # êµ¬í˜„
    pass
```

## ğŸ“‹ êµ¬í˜„ ê·œì¹™

### ì½”ë“œ í’ˆì§ˆ í‘œì¤€

#### Python ì½”ë“œ ìš”êµ¬ì‚¬í•­

```python
"""
ëª¨ë“  Python íŒŒì¼ì€ ì •í™•íˆ ì´ êµ¬ì¡°ë¥¼ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤.
"""

from __future__ import annotations  # í•­ìƒ future annotations ì‚¬ìš©

import logging
from typing import Dict, Any, Optional, List, TypedDict, Protocol
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
import asyncio

# ìƒìˆ˜ëŠ” ëŒ€ë¬¸ìë¡œ
DEFAULT_TIMEOUT: int = 30
MAX_RETRIES: int = 3

# íƒ€ì… ì •ì˜
class ConfigDict(TypedDict):
    """íƒ€ì… ì•ˆì „ ì„¤ì • ë”•ì…”ë„ˆë¦¬."""
    timeout: int
    retries: int
    debug: bool

@dataclass
class Result:
    """ë¶ˆë³€ ê²°ê³¼ ì»¨í…Œì´ë„ˆ.

    ì†ì„±:
        success: ì‘ì—… ì„±ê³µ ì—¬ë¶€
        data: ì„ íƒì  ê²°ê³¼ ë°ì´í„°
        error: ì„ íƒì  ì˜¤ë¥˜ ë©”ì‹œì§€
        metadata: ì¶”ê°€ ë©”íƒ€ë°ì´í„°
    """
    success: bool
    data: Optional[Any] = None
    error: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

class ServiceProtocol(Protocol):
    """ì„œë¹„ìŠ¤ ì¸í„°í˜ì´ìŠ¤ í”„ë¡œí† ì½œ."""

    async def execute(self, task: Dict[str, Any]) -> Result:
        """ì„œë¹„ìŠ¤ íƒœìŠ¤í¬ ì‹¤í–‰."""
        ...

class BaseService(ABC):
    """ëª¨ë“  ì„œë¹„ìŠ¤ì˜ ì¶”ìƒ ë² ì´ìŠ¤.

    ì´ í´ë˜ìŠ¤ëŠ” ëª¨ë“  T-Developer ì„œë¹„ìŠ¤ì— ê³µí†µ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
    ì„œë¸Œí´ë˜ìŠ¤ëŠ” ì¶”ìƒ ë©”ì„œë“œë¥¼ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.

    ì˜ˆì‹œ:
        >>> service = MyService(config)
        >>> result = await service.execute(task)
        >>> assert result.success
    """

    def __init__(self, config: ConfigDict) -> None:
        """ì„¤ì •ìœ¼ë¡œ ì„œë¹„ìŠ¤ ì´ˆê¸°í™”.

        ì¸ì:
            config: ì„œë¹„ìŠ¤ ì„¤ì • ë”•ì…”ë„ˆë¦¬

        ë°œìƒ:
            ValueError: ì„¤ì •ì´ ìœ íš¨í•˜ì§€ ì•Šì„ ë•Œ
        """
        self._validate_config(config)
        self.config = config
        self.logger = logging.getLogger(self.__class__.__name__)

    def _validate_config(self, config: ConfigDict) -> None:
        """ì„¤ì • ê²€ì¦.

        ì¸ì:
            config: ê²€ì¦í•  ì„¤ì •

        ë°œìƒ:
            ValueError: ì„¤ì •ì´ ìœ íš¨í•˜ì§€ ì•Šì„ ë•Œ
        """
        if config['timeout'] <= 0:
            raise ValueError("íƒ€ì„ì•„ì›ƒì€ ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")

    @abstractmethod
    async def execute(self, task: Dict[str, Any]) -> Result:
        """ì„œë¹„ìŠ¤ íƒœìŠ¤í¬ ì‹¤í–‰.

        ì¸ì:
            task: íƒœìŠ¤í¬ ëª…ì„¸

        ë°˜í™˜:
            ì‹¤í–‰ ê²°ê³¼

        ë°œìƒ:
            TimeoutError: ì‹¤í–‰ì´ íƒ€ì„ì•„ì›ƒì„ ì´ˆê³¼í•  ë•Œ
            RuntimeError: ì‹¤í–‰ì´ ì‹¤íŒ¨í•  ë•Œ
        """
        pass

    async def execute_with_retry(
        self,
        task: Dict[str, Any],
        max_retries: Optional[int] = None
    ) -> Result:
        """ì‹¤íŒ¨ ì‹œ ìë™ ì¬ì‹œë„ë¡œ ì‹¤í–‰.

        ì¸ì:
            task: ì‹¤í–‰í•  íƒœìŠ¤í¬
            max_retries: ê¸°ë³¸ ì¬ì‹œë„ íšŸìˆ˜ ì¬ì •ì˜

        ë°˜í™˜:
            ìµœì¢… ì‹¤í–‰ ê²°ê³¼
        """
        retries = max_retries or self.config['retries']
        last_error: Optional[Exception] = None

        for attempt in range(retries):
            try:
                result = await asyncio.wait_for(
                    self.execute(task),
                    timeout=self.config['timeout']
                )
                if result.success:
                    return result
                last_error = Exception(result.error)
            except asyncio.TimeoutError as e:
                last_error = e
                self.logger.warning(f"ì‹œë„ {attempt + 1} íƒ€ì„ì•„ì›ƒ")
            except Exception as e:
                last_error = e
                self.logger.error(f"ì‹œë„ {attempt + 1} ì‹¤íŒ¨: {e}")

            if attempt < retries - 1:
                await asyncio.sleep(2 ** attempt)  # ì§€ìˆ˜ ë°±ì˜¤í”„

        return Result(
            success=False,
            error=str(last_error),
            metadata={"attempts": retries}
        )
```

#### í•„ìˆ˜ ë©”íŠ¸ë¦­

- **Docstring ì»¤ë²„ë¦¬ì§€**: â‰¥80% (interrogate)
- **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: â‰¥85% (pytest-cov)
- **ë³µì¡ë„ (MI)**: â‰¥65 (radon)
- **íƒ€ì… ì»¤ë²„ë¦¬ì§€**: ê³µê°œ API 100% (mypy)
- **ë³´ì•ˆ ì´ìŠˆ**: 0 critical/high (semgrep)

### í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­

#### í…ŒìŠ¤íŠ¸ êµ¬ì¡°

```python
"""í…ŒìŠ¤íŠ¸ íŒŒì¼ êµ¬ì¡° - í•­ìƒ ë”°ë¥´ì„¸ìš”."""

import pytest
from unittest.mock import Mock, patch, AsyncMock
from typing import AsyncGenerator
import asyncio

# ëª¨ë“ˆ ë ˆë²¨ì˜ í…ŒìŠ¤íŠ¸ í”½ìŠ¤ì²˜
@pytest.fixture
async def service() -> AsyncGenerator[BaseService, None]:
    """í…ŒìŠ¤íŠ¸ìš© ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±."""
    config = ConfigDict(timeout=30, retries=3, debug=True)
    service = MyService(config)
    yield service
    # í•„ìš”ì‹œ ì •ë¦¬
    await service.cleanup()

@pytest.fixture
def mock_client() -> Mock:
    """ëª¨ì˜ í´ë¼ì´ì–¸íŠ¸ ìƒì„±."""
    return Mock(spec=ClientProtocol)

# ì¡°ì§í™”ë¥¼ ìœ„í•œ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤
class TestServiceExecution:
    """ì„œë¹„ìŠ¤ ì‹¤í–‰ ë™ì‘ í…ŒìŠ¤íŠ¸."""

    @pytest.mark.asyncio
    async def test_successful_execution(
        self,
        service: BaseService,
        mock_client: Mock
    ) -> None:
        """ì„±ê³µì ì¸ íƒœìŠ¤í¬ ì‹¤í–‰ í…ŒìŠ¤íŠ¸.

        ì£¼ì–´ì§„ ì¡°ê±´: ìœ íš¨í•œ íƒœìŠ¤í¬ ì„¤ì •
        í–‰ë™: ì„œë¹„ìŠ¤ê°€ íƒœìŠ¤í¬ë¥¼ ì‹¤í–‰
        ê²°ê³¼: ê²°ê³¼ê°€ ì„±ê³µì´ì–´ì•¼ í•¨
        """
        # ì¤€ë¹„
        task = {"action": "process", "data": "test"}
        expected = Result(success=True, data="processed")
        mock_client.process.return_value = expected

        # ì‹¤í–‰
        with patch.object(service, '_client', mock_client):
            result = await service.execute(task)

        # ê²€ì¦
        assert result.success is True
        assert result.data == "processed"
        mock_client.process.assert_called_once_with("test")

    @pytest.mark.asyncio
    async def test_execution_with_retry(self, service: BaseService) -> None:
        """ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ ë¡œì§ í…ŒìŠ¤íŠ¸.

        ì£¼ì–´ì§„ ì¡°ê±´: ì´ˆê¸°ì— ì‹¤íŒ¨í•˜ëŠ” íƒœìŠ¤í¬
        í–‰ë™: ì„œë¹„ìŠ¤ê°€ ì¬ì‹œë„ë¡œ ì‹¤í–‰
        ê²°ê³¼: ì¬ì‹œë„í•˜ê³  ê²°êµ­ ì„±ê³µí•´ì•¼ í•¨
        """
        # í…ŒìŠ¤íŠ¸ êµ¬í˜„
        pass

    @pytest.mark.parametrize("timeout,should_fail", [
        (0.1, True),
        (10, False),
    ])
    @pytest.mark.asyncio
    async def test_timeout_handling(
        self,
        service: BaseService,
        timeout: float,
        should_fail: bool
    ) -> None:
        """ë‹¤ë¥¸ ê°’ìœ¼ë¡œ íƒ€ì„ì•„ì›ƒ ë™ì‘ í…ŒìŠ¤íŠ¸."""
        # í…ŒìŠ¤íŠ¸ êµ¬í˜„
        pass

# ì†ì„± ê¸°ë°˜ í…ŒìŠ¤íŠ¸
from hypothesis import given, strategies as st

class TestServiceProperties:
    """ì„œë¹„ìŠ¤ ë™ì‘ì˜ ì†ì„± ê¸°ë°˜ í…ŒìŠ¤íŠ¸."""

    @given(st.dictionaries(st.text(), st.text()))
    @pytest.mark.asyncio
    async def test_never_crashes(
        self,
        service: BaseService,
        task: Dict[str, Any]
    ) -> None:
        """ì„œë¹„ìŠ¤ëŠ” ì¶©ëŒ ì—†ì´ ëª¨ë“  ì…ë ¥ì„ ì²˜ë¦¬í•´ì•¼ í•¨."""
        result = await service.execute_with_retry(task)
        assert isinstance(result, Result)
        assert result.success or result.error
```

### Git ì›Œí¬í”Œë¡œìš° ê·œì¹™

#### ë¸Œëœì¹˜ ì „ëµ

```bash
# ê¸°ëŠ¥ ë¸Œëœì¹˜ (ì¸ê°„ì´ ì‹œì‘)
feature/phase-{N}-{description}
feature/P0-T1-environment-setup

# ìë™ ì§„í™” ë¸Œëœì¹˜ (AIê°€ ìƒì„±)
tdev/auto/{YYYYMMDD}-{description}
tdev/auto/20240115-docstring-improvement

# í•«í”½ìŠ¤ ë¸Œëœì¹˜ (ê¸´ê¸‰ ìˆ˜ì •)
hotfix/{issue-number}-{description}
hotfix/SEC-001-api-key-exposure
```

#### ì»¤ë°‹ ë©”ì‹œì§€ í˜•ì‹

```
{type}({scope}): {description}

{ìƒì„¸ ì„¤ëª…}

ë©”íŠ¸ë¦­ ì˜í–¥:
- Docstring: 75% â†’ 85% (+10%)
- Coverage: 80% â†’ 82% (+2%)
- Complexity: 70 â†’ 72 (+2)

ì•ˆì „ì„± í™•ì¸:
- [ ] ë¬´í•œ ë£¨í”„ ì—†ìŒ
- [ ] ë¦¬ì†ŒìŠ¤ ì œí•œ ì ìš©ë¨
- [ ] ë³´ì•ˆ ìŠ¤ìº” í†µê³¼

ì§„í™” ì»¨í…ìŠ¤íŠ¸:
- ë‹¨ê³„: P1-T3
- ì‚¬ì´í´: 15
- ë¶€ëª¨: abc123

ê´€ë ¨: #{issue}, #{pr}
```

íƒ€ì…: `feat`, `fix`, `docs`, `test`, `refactor`, `perf`, `security`, `evolve`

#### PR í…œí”Œë¦¿

```markdown
## ìš”ì•½
{ë¬´ì—‡ì´ ë³€ê²½ë˜ì—ˆê³  ì™œ ë³€ê²½ë˜ì—ˆëŠ”ì§€ - 2-3ë¬¸ì¥}

## ì§„í™” ì»¨í…ìŠ¤íŠ¸
- **ë‹¨ê³„**: P{X}-T{Y}
- **ì—ì´ì „íŠ¸**: {RequirementAnalyzer|CodeAnalysisAgent|CodeImproverAgent|QualityGate}
- **íŠ¸ë¦¬ê±°**: {manual|scheduled|event}
- **ì‚¬ì´í´**: {number}

## ë³€ê²½ì‚¬í•­
- {êµ¬ì²´ì  ë³€ê²½ 1}
- {êµ¬ì²´ì  ë³€ê²½ 2}
- {êµ¬ì²´ì  ë³€ê²½ 3}

## ë©”íŠ¸ë¦­ ì˜í–¥
| ë©”íŠ¸ë¦­ | ì´ì „ | ì´í›„ | ë³€í™” |
|--------|------|------|------|
| Docstring ì»¤ë²„ë¦¬ì§€ | 75% | 85% | +10% |
| í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ | 80% | 82% | +2% |
| ë³µì¡ë„ (MI) | 70 | 72 | +2 |
| ë³´ì•ˆ ì ìˆ˜ | 95 | 95 | 0 |

## ì•ˆì „ì„± ê²€ì¦
- [x] ë¬´í•œ ë£¨í”„ ë¶ˆê°€ëŠ¥
- [x] ë¦¬ì†ŒìŠ¤ ì œí•œ ì ìš©ë¨
- [x] ë¡¤ë°± ê³„íš ì¡´ì¬
- [x] ë³´ì•ˆ ìŠ¤ìº” í†µê³¼
- [x] ì„±ëŠ¥ ì˜í–¥ í‰ê°€ë¨

## í…ŒìŠ¤íŠ¸
- [x] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì¶”ê°€/ì—…ë°ì´íŠ¸
- [x] í†µí•© í…ŒìŠ¤íŠ¸ í†µê³¼
- [x] ë®¤í…Œì´ì…˜ í…ŒìŠ¤íŠ¸ ì ìˆ˜ >60%
- [x] ë¶€í•˜ í…ŒìŠ¤íŠ¸ ì™„ë£Œ

## í•™ìŠµ ë‚´ìš© ìˆ˜ì§‘
```json
{
  "pattern": "docstring_generation",
  "success": true,
  "improvement": 0.10,
  "reusable": true,
  "notes": "ì •ê·œì‹ë³´ë‹¤ AST íŒŒì‹±ì´ ë” ì‹ ë¢°í•  ìˆ˜ ìˆìŒ"
}
```

## ë¡¤ë°± ê³„íš

{ì´ìŠˆ ë°œìƒ ì‹œ ë˜ëŒë¦¬ëŠ” ë°©ë²•}

## ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ì½”ë“œê°€ ìŠ¤íƒ€ì¼ ê°€ì´ë“œë¥¼ ë”°ë¦„
- [ ] ë¬¸ì„œê°€ ì—…ë°ì´íŠ¸ë¨
- [ ] ë©”íŠ¸ë¦­ì´ ê°œì„ ë¨
- [ ] ë³´ì•ˆ ì´ìŠˆ ì—†ìŒ
- [ ] í•™ìŠµ ë‚´ìš©ì´ ìˆ˜ì§‘ë¨

```

---

## ğŸ§ª Evolution ìŠ¤í¬ë¦½íŠ¸ ì›Œí¬í”Œë¡œìš°

### Evolution ì‹¤í–‰ ê·œì¹™
```python
# scripts/evolution/run_perfect_evolution.py êµ¬ì¡°
class EvolutionOrchestrator:
    """ì§„í™” í”„ë¡œì„¸ìŠ¤ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜."""

    def __init__(self):
        self.evolution_config = {
            "max_cycles": 10,
            "target_metrics": {
                "coverage": 0.85,
                "complexity": 65,
                "security_score": 95
            },
            "safety_limits": {
                "max_file_changes": 50,
                "max_execution_time": 3600,
                "rollback_threshold": 0.7
            }
        }

    async def run_evolution(self, target_module: str) -> EvolutionResult:
        """ì§„í™” ì‹¤í–‰."""
        # 1. ì‚¬ì „ ê²€ì¦
        await self.validate_target(target_module)

        # 2. ë°±ì—… ìƒì„±
        backup_id = await self.create_backup(target_module)

        # 3. ì§„í™” ì‹¤í–‰
        try:
            result = await self.execute_evolution_cycles(target_module)

            # 4. ì„±ê³µ ê²€ì¦
            if self.validate_success(result):
                await self.commit_changes(result)
            else:
                await self.rollback(backup_id)

        except Exception as e:
            await self.emergency_rollback(backup_id)
            raise

        return result
```

### í…ŒìŠ¤íŠ¸ íƒ€ê²Ÿ ìƒì„± ê·œì¹™

```python
# scripts/evolution/create_test_target.py
def create_safe_test_target(name: str) -> TestTarget:
    """ì•ˆì „í•œ í…ŒìŠ¤íŠ¸ íƒ€ê²Ÿ ìƒì„±."""
    return TestTarget(
        name=name,
        path=f"backend/tests/evolution/test_{name}.py",
        isolation_level="FULL",  # ì™„ì „ ê²©ë¦¬
        resource_limits={
            "cpu": "1 core",
            "memory": "512MB",
            "timeout": "5 minutes"
        }
    )
```

## ğŸš€ ì§„í™” ì‚¬ì´í´ í”„ë¡œí† ì½œ

### ì§„í™” ì‚¬ì´í´ ì‹œì‘í•˜ê¸°

```python
# ì‹œì‘ ì „ í•­ìƒ ì´ ê²€ì‚¬ë“¤ì„ ì‹¤í–‰
async def pre_evolution_checks() -> bool:
    """ëª¨ë“  ì§„í™” ì „ ì•ˆì „ì„± ê²€ì‚¬ ì‹¤í–‰."""
    checks = {
        "environment_ready": check_environment(),
        "resources_available": check_resources(),
        "no_active_cycles": check_no_conflicts(),
        "metrics_baseline": capture_baseline_metrics(),
        "safety_limits_set": verify_limits_configured(),
    }

    if not all(checks.values()):
        logger.error(f"ì§„í™” ì „ ê²€ì‚¬ ì‹¤íŒ¨: {checks}")
        return False

    logger.info("ì§„í™” ì „ ê²€ì‚¬ í†µê³¼")
    return True

# ì§„í™” ì‹¤í–‰ íŒ¨í„´
async def execute_evolution_cycle(target: str, focus: str) -> Result:
    """ì™„ì „í•œ ì§„í™” ì‚¬ì´í´ ì‹¤í–‰."""

    # 1. ìš”êµ¬ì‚¬í•­ ë¶„ì„ ë‹¨ê³„
    requirement_analysis = await RequirementAnalyzer().execute({
        "target": target,
        "focus": focus,
        "context": "evolution"
    })

    # 2. ì½”ë“œ ë¶„ì„ ë‹¨ê³„
    code_analysis = await CodeAnalysisAgent().execute({
        "requirements": requirement_analysis.data,
        "scope": "targeted",
        "depth": "comprehensive"
    })

    # 3. ê°œì„  êµ¬í˜„ ë‹¨ê³„
    implementation = await CodeImproverAgent().execute({
        "analysis": code_analysis.data,
        "safety_mode": True,
        "test_first": True  # TDD í•„ìˆ˜
    })

    # 4. í’ˆì§ˆ ê²Œì´íŠ¸ í‰ê°€
    quality_check = await QualityGate().execute({
        "changes": implementation.data,
        "strict_mode": True
    })

    # 5. í•™ìŠµ ìˆ˜ì§‘
    await MemoryCurator().store({
        "cycle": cycle_id,
        "results": quality_check.data,
        "patterns": extract_patterns(quality_check)
    })

    return quality_check
```

### ì•ˆì „ ë©”ì»¤ë‹ˆì¦˜

```python
# ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´ - í•­ìƒ êµ¬í˜„
class CircuitBreaker:
    """ì—°ì‡„ ì‹¤íŒ¨ ë°©ì§€."""

    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.last_failure_time = None
        self.state = "closed"  # closed, open, half-open

    async def call(self, func, *args, **kwargs):
        """ì„œí‚· ë¸Œë ˆì´ì»¤ë¡œ í•¨ìˆ˜ ì‹¤í–‰."""
        if self.state == "open":
            if self._should_attempt_reset():
                self.state = "half-open"
            else:
                raise RuntimeError("ì„œí‚· ë¸Œë ˆì´ì»¤ê°€ ì—´ë ¤ ìˆìŒ")

        try:
            result = await func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e

# ë¦¬ì†ŒìŠ¤ ì œí•œê¸° - í•„ìˆ˜
class ResourceLimiter:
    """ë¦¬ì†ŒìŠ¤ ì œì•½ ì ìš©."""

    MAX_MEMORY_MB = 500
    MAX_CPU_PERCENT = 80
    MAX_EXECUTION_TIME = 300
    MAX_CONCURRENT_TASKS = 10

    @classmethod
    def check_limits(cls) -> bool:
        """ë¦¬ì†ŒìŠ¤ ì œí•œ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸."""
        # êµ¬í˜„
        pass

# ë¡¤ë°± ê¸°ëŠ¥ - í•„ìˆ˜
class RollbackManager:
    """ì‹¤íŒ¨ ì‹œ ì•ˆì „í•œ ë¡¤ë°± í™œì„±í™”."""

    async def create_checkpoint(self) -> str:
        """ë¡¤ë°± ì§€ì  ìƒì„±."""
        # êµ¬í˜„
        pass

    async def rollback(self, checkpoint_id: str) -> None:
        """ì²´í¬í¬ì¸íŠ¸ë¡œ ë¡¤ë°±."""
        # êµ¬í˜„
        pass
```

---

## ğŸ”’ ë³´ì•ˆ í”„ë¡œí† ì½œ

### ì ˆëŒ€ í•˜ì§€ ë§ˆì„¸ìš” (ìë™ ì‹¤íŒ¨)

```python
# âŒ ì ˆëŒ€: í•˜ë“œì½”ë”©ëœ ë¹„ë°€
API_KEY = "sk-abcd1234"  # ì ˆëŒ€ í•˜ì§€ ë§ˆì„¸ìš”

# âŒ ì ˆëŒ€: ë™ì  ì½”ë“œ ì‹¤í–‰
# ë™ì  ì½”ë“œ ì‹¤í–‰ì€ ë³´ì•ˆ ìœ„í—˜ì´ë¯€ë¡œ ì ˆëŒ€ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”
# user_inputì„ ì§ì ‘ ì‹¤í–‰í•˜ëŠ” ê²ƒì€ ìœ„í—˜í•©ë‹ˆë‹¤

# âŒ ì ˆëŒ€: ì œí•œ ì—†ëŠ” íŒŒì¼ ì ‘ê·¼
open("/etc/passwd")  # ì ˆëŒ€ í•˜ì§€ ë§ˆì„¸ìš”

# âŒ ì ˆëŒ€: ì¤‘ë‹¨ ì¡°ê±´ ì—†ëŠ” ë¬´í•œ ë£¨í”„
while True:  # ì¤‘ë‹¨ ì¡°ê±´ ì—†ì´ ì ˆëŒ€ ì‚¬ìš© ê¸ˆì§€
    process()

# âŒ ì ˆëŒ€: ê²€ì¦ë˜ì§€ ì•Šì€ ì…ë ¥
def process(data):
    query = f"SELECT * FROM users WHERE id = {data}"  # SQL ì¸ì ì…˜

# âŒ ì ˆëŒ€: ë¡œê¹… ì—†ëŠ” ê´‘ë²”ìœ„í•œ ì˜ˆì™¸ í¬ì°©
try:
    risky_operation()
except:  # ì ˆëŒ€ í•˜ì§€ ë§ˆì„¸ìš”
    pass
```

### í•­ìƒ í•˜ì„¸ìš” (í•„ìˆ˜)

```python
# âœ… í•­ìƒ: í™˜ê²½ ë³€ìˆ˜ ì‚¬ìš©
import os
API_KEY = os.environ.get("API_KEY")
if not API_KEY:
    raise ValueError("API_KEYê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")

# âœ… í•­ìƒ: ì…ë ¥ ê²€ì¦
from typing import Any
import re

def validate_input(data: Any) -> str:
    """ì…ë ¥ ê²€ì¦ ë° ì •ì œ."""
    if not isinstance(data, str):
        raise ValueError("ì…ë ¥ì€ ë¬¸ìì—´ì´ì–´ì•¼ í•¨")
    if not re.match(r"^[a-zA-Z0-9_-]+$", data):
        raise ValueError("ì…ë ¥ì— ìœ íš¨í•˜ì§€ ì•Šì€ ë¬¸ì")
    return data

# âœ… í•­ìƒ: ë§¤ê°œë³€ìˆ˜í™”ëœ ì¿¼ë¦¬ ì‚¬ìš©
def get_user(user_id: int) -> User:
    """ì•ˆì „í•˜ê²Œ ì‚¬ìš©ì ê°€ì ¸ì˜¤ê¸°."""
    cursor.execute(
        "SELECT * FROM users WHERE id = ?",
        (user_id,)
    )

# âœ… í•­ìƒ: íƒ€ì„ì•„ì›ƒ êµ¬í˜„
async def external_call():
    """íƒ€ì„ì•„ì›ƒê³¼ í•¨ê»˜ ì™¸ë¶€ ì„œë¹„ìŠ¤ í˜¸ì¶œ."""
    async with asyncio.timeout(30):
        return await service.call()

# âœ… í•­ìƒ: ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹…
import logging
security_logger = logging.getLogger("security")

def log_security_event(event: str, details: dict) -> None:
    """ë³´ì•ˆ ê´€ë ¨ ì´ë²¤íŠ¸ ë¡œê¹…."""
    security_logger.warning(
        f"ë³´ì•ˆ ì´ë²¤íŠ¸: {event}",
        extra={"details": details, "timestamp": time.time()}
    )
```

---

## ğŸ“Š ë©”íŠ¸ë¦­ & ëª¨ë‹ˆí„°ë§

### í•„ìˆ˜ ë©”íŠ¸ë¦­ (í•­ìƒ ì¶”ì )

```python
# ì§„í™” ë©”íŠ¸ë¦­
EVOLUTION_METRICS = {
    "cycles_completed": Counter("evolution_cycles_total"),
    "success_rate": Gauge("evolution_success_rate"),
    "cycle_duration": Histogram("evolution_duration_seconds"),
    "improvements": Counter("improvements_total"),
    "regressions": Counter("regressions_total"),
}

# í’ˆì§ˆ ë©”íŠ¸ë¦­
QUALITY_METRICS = {
    "docstring_coverage": Gauge("docstring_coverage_percent"),
    "test_coverage": Gauge("test_coverage_percent"),
    "complexity": Gauge("code_complexity_score"),
    "security_score": Gauge("security_score"),
    "technical_debt": Gauge("technical_debt_hours"),
}

# ìš´ì˜ ë©”íŠ¸ë¦­
OPERATIONAL_METRICS = {
    "agent_failures": Counter("agent_failures_total"),
    "api_latency": Histogram("api_latency_seconds"),
    "error_rate": Gauge("error_rate_percent"),
    "resource_usage": Gauge("resource_usage_percent"),
}
```

### ì•Œë¦¼ ê·œì¹™

```yaml
alerts:
  - name: ì§„í™”ë©ˆì¶¤
    expr: rate(evolution_cycles_total[1h]) == 0
    for: 2h
    severity: warning

  - name: í’ˆì§ˆì €í•˜
    expr: delta(docstring_coverage_percent[1h]) < -5
    severity: critical

  - name: ë³´ì•ˆìœ„ë°˜
    expr: security_score < 80
    severity: critical

  - name: ë¹„ìš©ê¸‰ì¦
    expr: rate(cost_dollars[1h]) > 50
    severity: warning
```

---

## ğŸ§¬ í•™ìŠµ & íŒ¨í„´ ìˆ˜ì§‘

### íŒ¨í„´ ë¬¸ì„œí™”

```python
@dataclass
class Pattern:
    """ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì§„í™” íŒ¨í„´."""

    id: str
    category: str  # improvement, fix, optimization
    context: Dict[str, Any]  # ì–¸ì œ ì ìš©í• ì§€
    action: Dict[str, Any]  # ë¬´ì—‡ì„ í• ì§€
    outcome: Dict[str, Any]  # ì˜ˆìƒ ê²°ê³¼
    success_rate: float  # ê³¼ê±° ì„±ê³µë¥ 
    usage_count: int
    last_used: datetime

    def to_prompt(self) -> str:
        """íŒ¨í„´ì„ LLM í”„ë¡¬í”„íŠ¸ë¡œ ë³€í™˜."""
        return f"""
        íŒ¨í„´: {self.category}
        ì»¨í…ìŠ¤íŠ¸: {json.dumps(self.context)}
        ì•¡ì…˜: {json.dumps(self.action)}
        ì˜ˆìƒ ê²°ê³¼: {json.dumps(self.outcome)}
        ì„±ê³µë¥ : {self.success_rate:.1%}
        """

# íŒ¨í„´ ì¶”ì¶œ
def extract_patterns(evaluation: Result) -> List[Pattern]:
    """ì„±ê³µì ì¸ ì§„í™”ì—ì„œ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ ì¶”ì¶œ."""
    patterns = []

    if evaluation.success and evaluation.data.get("improvement") > 0.1:
        pattern = Pattern(
            id=generate_id(),
            category=classify_improvement(evaluation),
            context=extract_context(evaluation),
            action=extract_action(evaluation),
            outcome=extract_outcome(evaluation),
            success_rate=1.0,
            usage_count=1,
            last_used=datetime.now()
        )
        patterns.append(pattern)

    return patterns
```

---

## ğŸš¨ ì¤‘ìš” ì•ˆì „ ê·œì¹™

### ë¬´í•œ ë£¨í”„ ë°©ì§€

```python
# í•­ìƒ ë£¨í”„ ê°€ë“œ êµ¬í˜„
MAX_ITERATIONS = 1000
TIMEOUT_SECONDS = 300

async def safe_loop(condition_func):
    """ì•ˆì „ ê°€ë“œì™€ í•¨ê»˜ ë£¨í”„ ì‹¤í–‰."""
    iterations = 0
    start_time = time.time()

    while await condition_func():
        iterations += 1

        # ë°˜ë³µ ì œí•œ
        if iterations > MAX_ITERATIONS:
            raise RuntimeError(f"ë£¨í”„ê°€ {MAX_ITERATIONS} ë°˜ë³µì„ ì´ˆê³¼")

        # íƒ€ì„ì•„ì›ƒ í™•ì¸
        if time.time() - start_time > TIMEOUT_SECONDS:
            raise TimeoutError(f"ë£¨í”„ê°€ {TIMEOUT_SECONDS}ì´ˆë¥¼ ì´ˆê³¼")

        # ì£¼ê¸°ì ìœ¼ë¡œ ì œì–´ê¶Œ ì–‘ë³´
        if iterations % 100 == 0:
            await asyncio.sleep(0)

        # ì‹¤ì œ ì‘ì—…
        await do_work()
```

### ë¦¬ì†ŒìŠ¤ ì†Œë¹„ ì œì–´

```python
# í•­ìƒ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
import psutil
import resource

def check_resources():
    """ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ í™•ì¸."""
    # ë©”ëª¨ë¦¬ í™•ì¸
    memory = psutil.Process().memory_info()
    if memory.rss > 500 * 1024 * 1024:  # 500MB
        raise MemoryError("ë©”ëª¨ë¦¬ ì œí•œ ì´ˆê³¼")

    # CPU í™•ì¸
    cpu_percent = psutil.Process().cpu_percent(interval=0.1)
    if cpu_percent > 80:
        logger.warning(f"ë†’ì€ CPU ì‚¬ìš©ëŸ‰: {cpu_percent}%")

    # íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° í™•ì¸
    soft, hard = resource.getrlimit(resource.RLIMIT_NOFILE)
    open_files = len(psutil.Process().open_files())
    if open_files > soft * 0.8:
        logger.warning(f"ë†’ì€ íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ì‚¬ìš©ëŸ‰: {open_files}/{soft}")
```

### ì‹¤íŒ¨ ì‹œ ë¡¤ë°±

```python
# í•­ìƒ ë¡¤ë°± ê°€ëŠ¥í•´ì•¼ í•¨
class Transaction:
    """ë¡¤ë°±ì´ ìˆëŠ” íŠ¸ëœì­ì…˜ ì‹¤í–‰."""

    def __init__(self):
        self.operations = []
        self.rollback_functions = []

    def add_operation(self, operation, rollback):
        """ë¡¤ë°± í•¨ìˆ˜ì™€ í•¨ê»˜ ì‘ì—… ì¶”ê°€."""
        self.operations.append(operation)
        self.rollback_functions.append(rollback)

    async def execute(self):
        """ì‹¤íŒ¨ ì‹œ ë¡¤ë°±ê³¼ í•¨ê»˜ ëª¨ë“  ì‘ì—… ì‹¤í–‰."""
        completed = []

        try:
            for i, operation in enumerate(self.operations):
                result = await operation()
                completed.append(i)
        except Exception as e:
            # ì—­ìˆœìœ¼ë¡œ ë¡¤ë°±
            for i in reversed(completed):
                try:
                    await self.rollback_functions[i]()
                except Exception as rollback_error:
                    logger.error(f"ë¡¤ë°± ì‹¤íŒ¨: {rollback_error}")
            raise e
```

---

## ğŸ“ ë¬¸ì„œí™” í‘œì¤€

### ì½”ë“œ ë¬¸ì„œí™”

```python
def complex_function(
    param1: str,
    param2: Optional[int] = None,
    **kwargs: Any
) -> Dict[str, Any]:
    """í•¨ìˆ˜ê°€ ìˆ˜í–‰í•˜ëŠ” ì‘ì—…ì˜ ê°„ë‹¨í•œ ì„¤ëª….

    í•¨ìˆ˜ì˜ ëª©ì , ì•Œê³ ë¦¬ì¦˜ ë˜ëŠ” ëª…í™•íˆ í•´ì•¼ í•  ë³µì¡í•œ ë™ì‘ì— ëŒ€í•œ
    ë” ê¸´ ì„¤ëª….

    ì¸ì:
        param1: param1ì˜ ëª©ì ê³¼ ì œì•½ ì„¤ëª…
        param2: ì„ íƒì  ë§¤ê°œë³€ìˆ˜ ì„¤ëª…, ê¸°ë³¸ ë™ì‘
        **kwargs: ì¶”ê°€ í‚¤ì›Œë“œ ì¸ì:
            - key1: key1 ì„¤ëª…
            - key2: key2 ì„¤ëª…

    ë°˜í™˜:
        ë‹¤ìŒì„ í¬í•¨í•˜ëŠ” ë”•ì…”ë„ˆë¦¬:
            - result: ë©”ì¸ ê²°ê³¼
            - metadata: ì¶”ê°€ ì •ë³´

    ë°œìƒ:
        ValueError: param1ì´ ìœ íš¨í•˜ì§€ ì•Šì„ ë•Œ
        TimeoutError: ì‘ì—…ì´ íƒ€ì„ì•„ì›ƒì„ ì´ˆê³¼í•  ë•Œ

    ì˜ˆì‹œ:
        >>> result = complex_function("test", param2=42)
        >>> assert result["success"] is True

    ì°¸ê³ :
        ì´ í•¨ìˆ˜ëŠ” ì „ì—­ ìƒíƒœì— ë¶€ì‘ìš©ì´ ìˆìŠµë‹ˆë‹¤.
        ë™ì‹œ í™˜ê²½ì—ì„œ ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ì„¸ìš”.

    ì°¸ì¡°:
        related_function: ëŒ€ì²´ ì ‘ê·¼ë²•
        https://docs.example.com/complex-function
    """
    # êµ¬í˜„
    pass
```

### ì•„í‚¤í…ì²˜ ê²°ì • ê¸°ë¡ (ADR)

```markdown
# ADR-001: ì—ì´ì „íŠ¸ í†µì‹ ì„ ìœ„í•œ ì´ë²¤íŠ¸ ì£¼ë„ ì•„í‚¤í…ì²˜ ì‚¬ìš©

## ìƒíƒœ
ìŠ¹ì¸ë¨

## ì»¨í…ìŠ¤íŠ¸
ì—ì´ì „íŠ¸ëŠ” ê¸´ë°€í•œ ê²°í•© ì—†ì´ ë¹„ë™ê¸°ì ìœ¼ë¡œ í†µì‹ í•´ì•¼ í•©ë‹ˆë‹¤.

## ê²°ì •
ë©”ì‹œì§€ íì™€ í•¨ê»˜ ì´ë²¤íŠ¸ ì£¼ë„ ì•„í‚¤í…ì²˜ ì‚¬ìš©.

## ê²°ê³¼
- **ê¸ì •ì **: ëŠìŠ¨í•œ ê²°í•©, í™•ì¥ì„±, ë³µì›ë ¥
- **ë¶€ì •ì **: ë³µì¡ì„± ì¦ê°€, ìµœì¢… ì¼ê´€ì„±

## ê³ ë ¤ëœ ëŒ€ì•ˆ
1. ì§ì ‘ API í˜¸ì¶œ - ê²°í•© ë•Œë¬¸ì— ê±°ë¶€ë¨
2. ê³µìœ  ë°ì´í„°ë² ì´ìŠ¤ - ê²½í•© ë•Œë¬¸ì— ê±°ë¶€ë¨
```

---

## ğŸ¯ ë‹¹ì‹ ì˜ ì²´í¬ë¦¬ìŠ¤íŠ¸

### íŒŒì¼ ì‘ì—… ì „ (ìµœìš°ì„ )

- [ ] Globìœ¼ë¡œ ìœ ì‚¬ íŒŒì¼ ê²€ìƒ‰í–ˆëŠ”ê°€?
- [ ] Grepìœ¼ë¡œ ë™ì¼ ê¸°ëŠ¥ ê²€ìƒ‰í–ˆëŠ”ê°€?
- [ ] LSë¡œ ë””ë ‰í† ë¦¬ êµ¬ì¡° í™•ì¸í–ˆëŠ”ê°€?
- [ ] ê¸°ì¡´ íŒŒì¼ ìˆ˜ì •ìœ¼ë¡œ í•´ê²° ê°€ëŠ¥í•œê°€?
- [ ] ìƒˆ íŒŒì¼ì´ ì •ë§ í•„ìš”í•œê°€?

### ì½”ë“œ ì‘ì„± ì „

- [ ] ì´ê²ƒì´ ìê°€ ì§„í™” ëŠ¥ë ¥ì„ í–¥ìƒì‹œí‚¤ëŠ”ê°€?
- [ ] ê¸°ì¡´ íŒ¨í„´ì„ í™•ì¸í–ˆëŠ”ê°€?
- [ ] ë” ê°„ë‹¨í•œ í•´ê²°ì±…ì´ ìˆëŠ”ê°€?
- [ ] ë¬´ì—‡ì´ ì˜ëª»ë  ìˆ˜ ìˆëŠ”ê°€?
- [ ] ì–´ë–»ê²Œ í…ŒìŠ¤íŠ¸í•  ê²ƒì¸ê°€?

### ì½”ë“œ ì‘ì„± ì¤‘

- [ ] TDDë¥¼ ë”°ë¥´ê³  ìˆëŠ”ê°€?
- [ ] ëª¨ë“  ì…ë ¥ì´ ê²€ì¦ë˜ëŠ”ê°€?
- [ ] ì˜¤ë¥˜ê°€ ì ì ˆíˆ ì²˜ë¦¬ë˜ëŠ”ê°€?
- [ ] ì´ ì½”ë“œëŠ” ì¬ì‚¬ìš© ê°€ëŠ¥í•œê°€?
- [ ] ì™œë¥¼ ë¬¸ì„œí™”í•˜ê³  ìˆëŠ”ê°€?

### ì»¤ë°‹ ì „

- [ ] ëª¨ë“  í…ŒìŠ¤íŠ¸ê°€ í†µê³¼í•˜ëŠ”ê°€?
- [ ] ì»¤ë²„ë¦¬ì§€ê°€ â‰¥85%ì¸ê°€?
- [ ] ë³µì¡ë„ê°€ ìˆ˜ìš© ê°€ëŠ¥í•œê°€?
- [ ] ë³´ì•ˆ ì´ìŠˆê°€ ì—†ëŠ”ê°€?
- [ ] ë©”íŠ¸ë¦­ì´ ê°œì„ ë˜ì—ˆëŠ”ê°€?

### ë³‘í•© í›„

- [ ] í•™ìŠµì´ ìˆ˜ì§‘ë˜ì—ˆëŠ”ê°€?
- [ ] íŒ¨í„´ì´ ì¶”ì¶œë˜ì—ˆëŠ”ê°€?
- [ ] ë¬¸ì„œê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆëŠ”ê°€?
- [ ] ëª¨ë‹ˆí„°ë§ì´ í™œì„±í™”ë˜ì—ˆëŠ”ê°€?
- [ ] ë‹¤ìŒ ì‚¬ì´í´ì´ ê³„íšë˜ì—ˆëŠ”ê°€?

---

## ğŸ”„ ì§€ì†ì  ê°œì„ 

ì´ ë¬¸ì„œ ìì²´ë„ ì§„í™”í•´ì•¼ í•©ë‹ˆë‹¤. ë°œê²¬í•  ë•Œ:

- **ìƒˆë¡œìš´ íŒ¨í„´**: ë¬¸ì„œí™”í•˜ì„¸ìš”
- **ë” ë‚˜ì€ ê´€í–‰**: ì´ ê°€ì´ë“œë¥¼ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”
- **ì‹¤íŒ¨**: ì˜ˆë°© ê·œì¹™ì„ ì¶”ê°€í•˜ì„¸ìš”
- **ì„±ê³µ**: ì¶”ì¶œí•˜ê³  ê³µìœ í•˜ì„¸ìš”

ê¸°ì–µí•˜ì„¸ìš”: **ëª©í‘œëŠ” ì™„ì „í•œ ììœ¨ì„±ì…ë‹ˆë‹¤. ëª¨ë“  í–‰ë™ì€ ì¸ê°„ ê°œì… ì—†ì´ ìŠ¤ìŠ¤ë¡œë¥¼ ê°œì„ í•˜ëŠ” ì‹œìŠ¤í…œì— ë” ê°€ê¹Œì›Œì§€ê²Œ í•´ì•¼ í•©ë‹ˆë‹¤.**

---

**ë¬¸ì„œ ë²„ì „**: 2.0.0
**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: T-Developer ì‹œìŠ¤í…œì— ì˜í•´
**ë‹¤ìŒ ê²€í† **: ê° ë‹¨ê³„ ì™„ë£Œ í›„
**ì‹œí–‰**: CI/CD ê²Œì´íŠ¸ë¥¼ í†µí•œ ìë™í™”
