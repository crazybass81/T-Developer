import { Agent } from '@/core/agent';
import { logger } from '@/config/logger';
{{#if (includes capabilities 'database-access')}}
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';
{{/if}}
{{#if (includes capabilities 'llm-integration')}}
import { BedrockClient } from '@aws-sdk/client-bedrock';
{{/if}}

/**
 * {{description}}
 */
export class {{className}}Agent extends Agent {
  static readonly AGENT_NAME = '{{name}}';
  static readonly AGENT_TYPE = '{{type}}';
  
  {{#if (includes capabilities 'database-access')}}
  private docClient: DynamoDBDocumentClient;
  {{/if}}
  {{#if (includes capabilities 'llm-integration')}}
  private bedrockClient: BedrockClient;
  {{/if}}
  
  constructor() {
    super({
      name: {{className}}Agent.AGENT_NAME,
      type: {{className}}Agent.AGENT_TYPE,
      capabilities: [
        {{#each capabilities}}
        '{{this}}',
        {{/each}}
      ]
    });
    
    this.initialize();
  }
  
  private initialize(): void {
    {{#if (includes capabilities 'database-access')}}
    this.docClient = this.createDynamoDBClient();
    {{/if}}
    {{#if (includes capabilities 'llm-integration')}}
    this.bedrockClient = this.createBedrockClient();
    {{/if}}
  }
  
  async execute(input: any): Promise<any> {
    logger.info(`Executing ${this.name} agent`, { input });
    
    try {
      this.validateInput(input);
      const result = await this.process(input);
      
      return {
        success: true,
        data: result,
        metadata: {
          agentName: this.name,
          executionTime: Date.now(),
          version: '1.0.0'
        }
      };
      
    } catch (error) {
      logger.error(`Error in ${this.name} agent`, error);
      throw error;
    }
  }
  
  private validateInput(input: any): void {
    if (!input) {
      throw new Error('Input is required');
    }
  }
  
  private async process(input: any): Promise<any> {
    {{#if_eq type 'processing'}}
    return this.processData(input);
    {{/if_eq}}
    {{#if_eq type 'analysis'}}
    return this.analyzeData(input);
    {{/if_eq}}
    {{#if_eq type 'generation'}}
    return this.generateOutput(input);
    {{/if_eq}}
    {{#if_eq type 'integration'}}
    return this.integrateServices(input);
    {{/if_eq}}
  }
  
  {{#if_eq type 'processing'}}
  private async processData(data: any): Promise<any> {
    return data;
  }
  {{/if_eq}}
  
  {{#if_eq type 'analysis'}}
  private async analyzeData(data: any): Promise<any> {
    return { analyzed: true };
  }
  {{/if_eq}}
  
  {{#if_eq type 'generation'}}
  private async generateOutput(input: any): Promise<any> {
    return { generated: true };
  }
  {{/if_eq}}
  
  {{#if_eq type 'integration'}}
  private async integrateServices(input: any): Promise<any> {
    return { integrated: true };
  }
  {{/if_eq}}
}